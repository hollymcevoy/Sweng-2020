{"version":3,"sources":["../../../src/SpeechServices/SpeechToText/createSpeechRecognitionPonyfill.js"],"names":["AudioConfig","SpeechSDK","OutputFormat","ResultReason","SpeechConfig","SpeechRecognizer","serializeRecognitionResult","duration","errorDetails","json","offset","properties","reason","resultId","text","JSON","parse","averageAmplitude","arrayBuffer","array","Int16Array","reduce","call","amplitude","Math","abs","length","cognitiveServicesAsyncToPromise","fn","args","Promise","resolve","reject","SpeechRecognitionEvent","type","data","emma","interpretation","resultIndex","results","Event","prepareAudioConfig","audioConfig","originalAttach","attach","boundOriginalAttach","bind","firstChunk","muted","reader","read","chunk","buffer","events","onEvent","name","ArrayBuffer","isEnd","timeReceived","Date","now","pause","unprepare","createSpeechRecognitionPonyfillFromRecognizer","createRecognizer","enableTelemetry","looseEvents","referenceGrammars","textNormalization","SpeechRecognition","_continuous","_interimResults","_lang","window","document","documentElement","getAttribute","navigator","language","_grammars","SpeechGrammarList","_maxAlternatives","event","dispatchEvent","value","Error","_startOnce","catch","err","ErrorEvent","error","message","stack","lang","recognizer","queue","push","audioSourceReady","audioSourceOff","firstAudibleChunk","detachAudioConfigEvent","detach","canceled","_","sessionId","recognized","result","recognizing","sessionStarted","sessionStopped","speechStartDetected","speechEndDetected","phrases","grammars","dynamicGrammar","privReco","addReferenceGrammar","addPhrase","startContinuousRecognitionAsync","stopContinuousRecognitionAsync","abort","stop","undefined","finalizedResults","loop","shift","Object","keys","forEach","emitCognitiveServices","errorMessage","test","finalEvent","audioStarted","stopping","soundStarted","speechStarted","NoMatch","maxAlternatives","recognizable","transcript","continuous","interimResults","console","dispose","EventTarget","options","fromDefaultMicrophoneInput","fetchCredentials","speechRecognitionEndpointId","mediaDevices","getUserMedia","warn","authorizationToken","region","speechRecognitionHostname","subscriptionKey","host","hostname","port","protocol","speechConfig","fromHost","fromAuthorizationToken","fromSubscription","endpointId","outputFormat","Detailed","speechRecognitionLanguage"],"mappings":"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","sourcesContent":["/* eslint class-methods-use-this: \"off\" */\n/* eslint complexity: [\"error\", 70] */\n/* eslint no-await-in-loop: \"off\" */\n/* eslint no-empty-function: \"off\" */\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 100, 150] }] */\n\nimport { Event, EventTarget, getEventAttributeValue, setEventAttributeValue } from 'event-target-shim/es5';\n\nimport cognitiveServiceEventResultToWebSpeechRecognitionResultList from './cognitiveServiceEventResultToWebSpeechRecognitionResultList';\nimport createPromiseQueue from '../../Util/createPromiseQueue';\nimport patchOptions from '../patchOptions';\nimport SpeechGrammarList from './SpeechGrammarList';\nimport SpeechSDK from '../SpeechSDK';\n\n// https://docs.microsoft.com/en-us/javascript/api/microsoft-cognitiveservices-speech-sdk/speechconfig?view=azure-node-latest#outputformat\n// {\n//   \"RecognitionStatus\": \"Success\",\n//   \"Offset\": 900000,\n//   \"Duration\": 49000000,\n//   \"NBest\": [\n//     {\n//       \"Confidence\": 0.738919,\n//       \"Lexical\": \"second\",\n//       \"ITN\": \"second\",\n//       \"MaskedITN\": \"second\",\n//       \"Display\": \"Second.\"\n//     }\n//   ]\n// }\n\n// {\n//   \"RecognitionStatus\": \"InitialSilenceTimeout\",\n//   \"Offset\": 50000000,\n//   \"Duration\": 0\n// }\n\nconst { AudioConfig, OutputFormat, ResultReason, SpeechConfig, SpeechRecognizer } = SpeechSDK;\n\nfunction serializeRecognitionResult({ duration, errorDetails, json, offset, properties, reason, resultId, text }) {\n  return {\n    duration,\n    errorDetails,\n    json: JSON.parse(json),\n    offset,\n    properties,\n    reason,\n    resultId,\n    text\n  };\n}\n\nfunction averageAmplitude(arrayBuffer) {\n  const array = new Int16Array(arrayBuffer);\n\n  return (\n    [].reduce.call(array, (averageAmplitude, amplitude) => averageAmplitude + Math.abs(amplitude), 0) / array.length\n  );\n}\n\nfunction cognitiveServicesAsyncToPromise(fn) {\n  return (...args) => new Promise((resolve, reject) => fn(...args, resolve, reject));\n}\n\nclass SpeechRecognitionEvent extends Event {\n  constructor(type, { data, emma, interpretation, resultIndex, results } = {}) {\n    super(type);\n\n    this.data = data;\n    this.emma = emma;\n    this.interpretation = interpretation;\n    this.resultIndex = resultIndex;\n    this.results = results;\n  }\n}\n\nfunction prepareAudioConfig(audioConfig) {\n  const originalAttach = audioConfig.attach;\n  const boundOriginalAttach = audioConfig.attach.bind(audioConfig);\n  let firstChunk;\n  let muted;\n\n  // We modify \"attach\" function and detect when audible chunk is read.\n  // We will only modify \"attach\" function once.\n  audioConfig.attach = async () => {\n    const reader = await boundOriginalAttach();\n\n    return {\n      ...reader,\n      read: async () => {\n        const chunk = await reader.read();\n\n        // The magic number 150 is measured by:\n        // 1. Set microphone volume to 0\n        // 2. Observe the amplitude (100-110) for the first few chunks\n        //    (There is a short static caught when turning on the microphone)\n        // 3. Set the number a bit higher than the observation\n\n        if (!firstChunk && averageAmplitude(chunk.buffer) > 150) {\n          audioConfig.events.onEvent({ name: 'FirstAudibleChunk' });\n          firstChunk = true;\n        }\n\n        if (muted) {\n          return { buffer: new ArrayBuffer(0), isEnd: true, timeReceived: Date.now() };\n        }\n\n        return chunk;\n      }\n    };\n  };\n\n  return {\n    audioConfig,\n    pause: () => {\n      muted = true;\n    },\n    unprepare: () => {\n      audioConfig.attach = originalAttach;\n    }\n  };\n}\n\nexport function createSpeechRecognitionPonyfillFromRecognizer({\n  createRecognizer,\n  enableTelemetry,\n  looseEvents,\n  referenceGrammars,\n  textNormalization\n}) {\n  // If enableTelemetry is set to null or non-boolean, we will default to true.\n  SpeechRecognizer.enableTelemetry(enableTelemetry !== false);\n\n  class SpeechRecognition extends EventTarget {\n    constructor() {\n      super();\n\n      this._continuous = false;\n      this._interimResults = false;\n      this._lang =\n        typeof window !== 'undefined'\n          ? window.document.documentElement.getAttribute('lang') || window.navigator.language\n          : 'en-US';\n      this._grammars = new SpeechGrammarList();\n      this._maxAlternatives = 1;\n    }\n\n    emitCognitiveServices(type, event) {\n      this.dispatchEvent(\n        new SpeechRecognitionEvent('cognitiveservices', {\n          data: {\n            ...event,\n            type\n          }\n        })\n      );\n    }\n\n    get continuous() {\n      return this._continuous;\n    }\n\n    set continuous(value) {\n      this._continuous = value;\n    }\n\n    get grammars() {\n      return this._grammars;\n    }\n\n    set grammars(value) {\n      if (value instanceof SpeechGrammarList) {\n        this._grammars = value;\n      } else {\n        throw new Error(`The provided value is not of type 'SpeechGrammarList'`);\n      }\n    }\n\n    get interimResults() {\n      return this._interimResults;\n    }\n\n    set interimResults(value) {\n      this._interimResults = value;\n    }\n\n    get maxAlternatives() {\n      return this._maxAlternatives;\n    }\n\n    set maxAlternatives(value) {\n      this._maxAlternatives = value;\n    }\n\n    get lang() {\n      return this._lang;\n    }\n\n    set lang(value) {\n      this._lang = value;\n    }\n\n    get onaudioend() {\n      return getEventAttributeValue(this, 'audioend');\n    }\n\n    set onaudioend(value) {\n      setEventAttributeValue(this, 'audioend', value);\n    }\n\n    get onaudiostart() {\n      return getEventAttributeValue(this, 'audiostart');\n    }\n\n    set onaudiostart(value) {\n      setEventAttributeValue(this, 'audiostart', value);\n    }\n\n    get oncognitiveservices() {\n      return getEventAttributeValue(this, 'cognitiveservices');\n    }\n\n    set oncognitiveservices(value) {\n      setEventAttributeValue(this, 'cognitiveservices', value);\n    }\n\n    get onend() {\n      return getEventAttributeValue(this, 'end');\n    }\n\n    set onend(value) {\n      setEventAttributeValue(this, 'end', value);\n    }\n\n    get onerror() {\n      return getEventAttributeValue(this, 'error');\n    }\n\n    set onerror(value) {\n      setEventAttributeValue(this, 'error', value);\n    }\n\n    get onresult() {\n      return getEventAttributeValue(this, 'result');\n    }\n\n    set onresult(value) {\n      setEventAttributeValue(this, 'result', value);\n    }\n\n    get onsoundend() {\n      return getEventAttributeValue(this, 'soundend');\n    }\n\n    set onsoundend(value) {\n      setEventAttributeValue(this, 'soundend', value);\n    }\n\n    get onsoundstart() {\n      return getEventAttributeValue(this, 'soundstart');\n    }\n\n    set onsoundstart(value) {\n      setEventAttributeValue(this, 'soundstart', value);\n    }\n\n    get onspeechend() {\n      return getEventAttributeValue(this, 'speechend');\n    }\n\n    set onspeechend(value) {\n      setEventAttributeValue(this, 'speechend', value);\n    }\n\n    get onspeechstart() {\n      return getEventAttributeValue(this, 'speechstart');\n    }\n\n    set onspeechstart(value) {\n      setEventAttributeValue(this, 'speechstart', value);\n    }\n\n    get onstart() {\n      return getEventAttributeValue(this, 'start');\n    }\n\n    set onstart(value) {\n      setEventAttributeValue(this, 'start', value);\n    }\n\n    start() {\n      this._startOnce().catch(err => {\n        this.dispatchEvent(new ErrorEvent('error', { error: err, message: err && (err.stack || err.message) }));\n      });\n    }\n\n    async _startOnce() {\n      // TODO: [P2] Should check if recognition is active, we should not start recognition twice\n      const recognizer = await createRecognizer(this.lang);\n\n      const { pause, unprepare } = prepareAudioConfig(recognizer.audioConfig);\n\n      try {\n        const queue = createPromiseQueue();\n        let soundStarted;\n        let speechStarted;\n        let stopping;\n\n        const { detach: detachAudioConfigEvent } = recognizer.audioConfig.events.attach(event => {\n          const { name } = event;\n\n          if (name === 'AudioSourceReadyEvent') {\n            queue.push({ audioSourceReady: {} });\n          } else if (name === 'AudioSourceOffEvent') {\n            queue.push({ audioSourceOff: {} });\n          } else if (name === 'FirstAudibleChunk') {\n            queue.push({ firstAudibleChunk: {} });\n          }\n        });\n\n        recognizer.canceled = (_, { errorDetails, offset, reason, sessionId }) => {\n          queue.push({\n            canceled: {\n              errorDetails,\n              offset,\n              reason,\n              sessionId\n            }\n          });\n        };\n\n        recognizer.recognized = (_, { offset, result, sessionId }) => {\n          queue.push({\n            recognized: {\n              offset,\n              result: serializeRecognitionResult(result),\n              sessionId\n            }\n          });\n        };\n\n        recognizer.recognizing = (_, { offset, result, sessionId }) => {\n          queue.push({\n            recognizing: {\n              offset,\n              result: serializeRecognitionResult(result),\n              sessionId\n            }\n          });\n        };\n\n        recognizer.sessionStarted = (_, { sessionId }) => {\n          queue.push({ sessionStarted: { sessionId } });\n        };\n\n        recognizer.sessionStopped = (_, { sessionId }) => {\n          // \"sessionStopped\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\n          queue.push({ sessionStopped: { sessionId } });\n        };\n\n        recognizer.speechStartDetected = (_, { offset, sessionId }) => {\n          queue.push({ speechStartDetected: { offset, sessionId } });\n        };\n\n        recognizer.speechEndDetected = (_, { sessionId }) => {\n          // \"speechEndDetected\" is never fired, probably because we are using startContinuousRecognitionAsync instead of recognizeOnceAsync.\n          // Update: \"speechEndDetected\" is fired for DLSpeech.listenOnceAsync()\n          queue.push({ speechEndDetected: { sessionId } });\n        };\n\n        const { phrases } = this.grammars;\n\n        // HACK: We are using the internal of SpeechRecognizer because they did not expose it\n        const { dynamicGrammar } = recognizer.privReco;\n\n        referenceGrammars && referenceGrammars.length && dynamicGrammar.addReferenceGrammar(referenceGrammars);\n        phrases && phrases.length && dynamicGrammar.addPhrase(phrases);\n\n        await cognitiveServicesAsyncToPromise(recognizer.startContinuousRecognitionAsync.bind(recognizer))();\n\n        if (recognizer.stopContinuousRecognitionAsync) {\n          this.abort = () => queue.push({ abort: {} });\n          this.stop = () => queue.push({ stop: {} });\n        } else {\n          this.abort = this.stop = undefined;\n        }\n\n        let audioStarted;\n        let finalEvent;\n        let finalizedResults = [];\n\n        for (let loop = 0; !stopping || audioStarted; loop++) {\n          const event = await queue.shift();\n          const {\n            abort,\n            audioSourceOff,\n            audioSourceReady,\n            canceled,\n            firstAudibleChunk,\n            recognized,\n            recognizing,\n            stop\n          } = event;\n\n          // We are emitting event \"cognitiveservices\" for debugging purpose.\n          Object.keys(event).forEach(name => this.emitCognitiveServices(name, event[name]));\n\n          const errorMessage = canceled && canceled.errorDetails;\n\n          if (/Permission\\sdenied/u.test(errorMessage || '')) {\n            // If microphone is not allowed, we should not emit \"start\" event.\n\n            finalEvent = {\n              error: 'not-allowed',\n              type: 'error'\n            };\n\n            break;\n          }\n\n          if (!loop) {\n            this.dispatchEvent(new SpeechRecognitionEvent('start'));\n          }\n\n          if (errorMessage) {\n            if (/1006/u.test(errorMessage)) {\n              if (!audioStarted) {\n                this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n                this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n              }\n\n              finalEvent = {\n                error: 'network',\n                type: 'error'\n              };\n            } else {\n              finalEvent = {\n                error: 'unknown',\n                type: 'error'\n              };\n            }\n\n            break;\n          } else if (abort || stop) {\n            if (abort) {\n              finalEvent = {\n                error: 'aborted',\n                type: 'error'\n              };\n\n              // If we are aborting, we will ignore lingering recognizing/recognized events. But if we are stopping, we need them.\n              stopping = 'abort';\n            } else {\n              // When we pause, we will send { isEnd: true }, Speech Services will send us \"recognized\" event.\n              pause();\n              stopping = 'stop';\n            }\n\n            // Abort should not be dispatched without support of \"stopContinuousRecognitionAsync\".\n            // But for defensive purpose, we make sure \"stopContinuousRecognitionAsync\" is available before we can call.\n            if (abort && recognizer.stopContinuousRecognitionAsync) {\n              await cognitiveServicesAsyncToPromise(recognizer.stopContinuousRecognitionAsync.bind(recognizer))();\n            }\n          } else if (audioSourceReady) {\n            this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n\n            audioStarted = true;\n          } else if (firstAudibleChunk) {\n            this.dispatchEvent(new SpeechRecognitionEvent('soundstart'));\n\n            soundStarted = true;\n          } else if (audioSourceOff) {\n            // Looks like we don't need this line and all the tests are still working.\n            // Guessing probably stopping is already truthy.\n            // stopping = true;\n\n            speechStarted && this.dispatchEvent(new SpeechRecognitionEvent('speechend'));\n            soundStarted && this.dispatchEvent(new SpeechRecognitionEvent('soundend'));\n            audioStarted && this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n\n            audioStarted = soundStarted = speechStarted = false;\n\n            break;\n          } else if (stopping !== 'abort') {\n            if (recognized && recognized.result && recognized.result.reason === ResultReason.NoMatch) {\n              finalEvent = {\n                error: 'no-speech',\n                type: 'error'\n              };\n            } else if (recognized || recognizing) {\n              if (!audioStarted) {\n                // Unconfirmed prevention of quirks\n                this.dispatchEvent(new SpeechRecognitionEvent('audiostart'));\n\n                audioStarted = true;\n              }\n\n              if (!soundStarted) {\n                this.dispatchEvent(new SpeechRecognitionEvent('soundstart'));\n\n                soundStarted = true;\n              }\n\n              if (!speechStarted) {\n                this.dispatchEvent(new SpeechRecognitionEvent('speechstart'));\n\n                speechStarted = true;\n              }\n\n              if (recognized) {\n                const result = cognitiveServiceEventResultToWebSpeechRecognitionResultList(recognized.result, {\n                  maxAlternatives: this.maxAlternatives,\n                  textNormalization\n                });\n\n                const recognizable = !!result[0].transcript;\n\n                if (recognizable) {\n                  finalizedResults = [...finalizedResults, result];\n\n                  this.continuous &&\n                    this.dispatchEvent(\n                      new SpeechRecognitionEvent('result', {\n                        results: finalizedResults\n                      })\n                    );\n                }\n\n                // If it is continuous, we just sent the finalized results. So we don't need to send it again after \"audioend\" event.\n                if (this.continuous && recognizable) {\n                  finalEvent = null;\n                } else {\n                  finalEvent = {\n                    results: finalizedResults,\n                    type: 'result'\n                  };\n                }\n\n                if (!this.continuous && recognizer.stopContinuousRecognitionAsync) {\n                  await cognitiveServicesAsyncToPromise(recognizer.stopContinuousRecognitionAsync.bind(recognizer))();\n                }\n\n                // If event order can be loosened, we can send the recognized event as soon as we receive it.\n                // 1. If it is not recognizable (no-speech), we should send an \"error\" event just before \"end\" event. We will not loosen \"error\" events.\n                if (looseEvents && finalEvent && recognizable) {\n                  this.dispatchEvent(new SpeechRecognitionEvent(finalEvent.type, finalEvent));\n                  finalEvent = null;\n                }\n              } else if (recognizing) {\n                this.interimResults &&\n                  this.dispatchEvent(\n                    new SpeechRecognitionEvent('result', {\n                      results: [\n                        ...finalizedResults,\n                        cognitiveServiceEventResultToWebSpeechRecognitionResultList(recognizing.result, {\n                          maxAlternatives: this.maxAlternatives,\n                          textNormalization\n                        })\n                      ]\n                    })\n                  );\n              }\n            }\n          }\n        }\n\n        if (speechStarted) {\n          this.dispatchEvent(new SpeechRecognitionEvent('speechend'));\n        }\n\n        if (soundStarted) {\n          this.dispatchEvent(new SpeechRecognitionEvent('soundend'));\n        }\n\n        if (audioStarted) {\n          this.dispatchEvent(new SpeechRecognitionEvent('audioend'));\n        }\n\n        if (finalEvent) {\n          if (finalEvent.type === 'result' && !finalEvent.results.length) {\n            finalEvent = {\n              error: 'no-speech',\n              type: 'error'\n            };\n          }\n\n          if (finalEvent.type === 'error') {\n            this.dispatchEvent(new ErrorEvent('error', finalEvent));\n          } else {\n            this.dispatchEvent(new SpeechRecognitionEvent(finalEvent.type, finalEvent));\n          }\n        }\n\n        // Even though there is no \"start\" event emitted, we will still emit \"end\" event\n        // This is mainly for \"microphone blocked\" story.\n        this.dispatchEvent(new SpeechRecognitionEvent('end'));\n\n        detachAudioConfigEvent();\n      } catch (err) {\n        // Logging out the erorr because Speech SDK would fail silently.\n        console.error(err);\n\n        throw err;\n      } finally {\n        unprepare();\n        recognizer.dispose();\n      }\n    }\n  }\n\n  return {\n    SpeechGrammarList,\n    SpeechRecognition,\n    SpeechRecognitionEvent\n  };\n}\n\nexport default options => {\n  const {\n    audioConfig = AudioConfig.fromDefaultMicrophoneInput(),\n\n    // We set telemetry to true to honor the default telemetry settings of Speech SDK\n    // https://github.com/Microsoft/cognitive-services-speech-sdk-js#data--telemetry\n    enableTelemetry = true,\n\n    fetchCredentials,\n    looseEvents,\n    referenceGrammars,\n    speechRecognitionEndpointId,\n    textNormalization = 'display'\n  } = patchOptions(options);\n\n  if (!audioConfig && (!window.navigator.mediaDevices || !window.navigator.mediaDevices.getUserMedia)) {\n    console.warn(\n      'web-speech-cognitive-services: This browser does not support WebRTC and it will not work with Cognitive Services Speech Services.'\n    );\n\n    return {};\n  }\n\n  const createRecognizer = async lang => {\n    const { authorizationToken, region, speechRecognitionHostname, subscriptionKey } = await fetchCredentials();\n    let speechConfig;\n\n    if (speechRecognitionHostname) {\n      const host = { hostname: speechRecognitionHostname, port: 443, protocol: 'wss:' };\n\n      if (authorizationToken) {\n        speechConfig = SpeechConfig.fromHost(host);\n        speechConfig.authorizationToken = authorizationToken;\n      } else {\n        speechConfig = SpeechConfig.fromHost(host, subscriptionKey);\n      }\n    } else {\n      speechConfig = authorizationToken\n        ? SpeechConfig.fromAuthorizationToken(authorizationToken, region)\n        : SpeechConfig.fromSubscription(subscriptionKey, region);\n    }\n\n    if (speechRecognitionEndpointId) {\n      speechConfig.endpointId = speechRecognitionEndpointId;\n    }\n\n    speechConfig.outputFormat = OutputFormat.Detailed;\n    speechConfig.speechRecognitionLanguage = lang || 'en-US';\n\n    return new SpeechRecognizer(speechConfig, audioConfig);\n  };\n\n  return createSpeechRecognitionPonyfillFromRecognizer({\n    audioConfig,\n    createRecognizer,\n    enableTelemetry,\n    looseEvents,\n    referenceGrammars,\n    textNormalization\n  });\n};\n"],"file":"createSpeechRecognitionPonyfill.js"}