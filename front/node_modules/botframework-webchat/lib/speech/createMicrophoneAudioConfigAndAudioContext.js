"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createMicrophoneAudioConfigAndAudioContext;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _Exports = require("microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports");

var _Exports2 = require("microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports");

var _bytesPerSample = _interopRequireDefault(require("./bytesPerSample"));

var _createAudioConfig = _interopRequireDefault(require("./createAudioConfig"));

var _createAudioContext = _interopRequireDefault(require("./createAudioContext"));

var _getUserMedia = _interopRequireDefault(require("./getUserMedia"));

// This is how often we are flushing audio buffer to the network. Modify this value will affect latency.
var DEFAULT_BUFFER_DURATION_IN_MS = 100; // TODO: [P2] #3975 We should consider building our own PcmRecorder:
//       - Use Audio Worklet via blob URL
//       - Not hardcoding the sample rate or other values
// PcmRecorder always downscale to 16000 Hz. We cannot use the dynamic value from MediaConstraints or MediaTrackSettings.

var PCM_RECORDER_HARDCODED_SETTINGS = Object.freeze({
  channelCount: 1,
  sampleRate: 16000,
  sampleSize: 16
});
var PCM_RECORDER_HARDCODED_FORMAT = Object.freeze({
  bitsPerSample: PCM_RECORDER_HARDCODED_SETTINGS.sampleSize,
  channels: PCM_RECORDER_HARDCODED_SETTINGS.channelCount,
  samplesPerSec: PCM_RECORDER_HARDCODED_SETTINGS.sampleRate
});

function createMicrophoneAudioConfig(options) {
  var audioConstraints = options.audioConstraints,
      audioContext = options.audioContext,
      debug = options.debug,
      enableTelemetry = options.enableTelemetry,
      pcmRecorderWorkletUrl = options.pcmRecorderWorkletUrl;
  var bufferDurationInMS = options.bufferDurationInMS || DEFAULT_BUFFER_DURATION_IN_MS;
  var pcmRecorder = new _Exports2.PcmRecorder();
  pcmRecorderWorkletUrl && pcmRecorder.setWorkletUrl(pcmRecorderWorkletUrl);
  return (0, _createAudioConfig.default)({
    attach: function attach(audioNodeId) {
      return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var mediaStream, _mediaStream$getAudio, _mediaStream$getAudio2, firstAudioTrack, outputStream;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return (0, _getUserMedia.default)({
                  audio: audioConstraints,
                  video: false
                });

              case 2:
                mediaStream = _context.sent;
                _mediaStream$getAudio = mediaStream.getAudioTracks(), _mediaStream$getAudio2 = (0, _slicedToArray2.default)(_mediaStream$getAudio, 1), firstAudioTrack = _mediaStream$getAudio2[0];

                if (firstAudioTrack) {
                  _context.next = 6;
                  break;
                }

                throw new Error('No audio device is found.');

              case 6:
                outputStream = new _Exports.ChunkedArrayBufferStream( // Speech SDK quirks: PcmRecorder hardcoded sample rate of 16000 Hz.
                (0, _bytesPerSample.default)(PCM_RECORDER_HARDCODED_SETTINGS) * ( // eslint-disable-next-line no-magic-numbers
                (bufferDurationInMS || DEFAULT_BUFFER_DURATION_IN_MS) / 1000), audioNodeId);
                pcmRecorder.record(audioContext, mediaStream, outputStream);
                return _context.abrupt("return", {
                  audioStreamNode: {
                    // Speech SDK quirks: In SDK's original MicAudioSource implementation, it call turnOff() during detach().
                    //                    That means, it call turnOff(), then detach(), then turnOff() again. Seems redundant.
                    //                    When using with Direct Line Speech, turnOff() is never called.
                    detach: function detach() {
                      // Speech SDK quirks: In SDK, it call outputStream.close() in turnOff() before outputStream.readEnded() in detach().
                      //                    I think it make sense to call readEnded() before close().
                      outputStream.readEnded();
                      outputStream.close(); // PcmRecorder.releaseMediaResources() will disconnect/stop the MediaStream.
                      // We cannot use MediaStream again after turned off.

                      // PcmRecorder.releaseMediaResources() will disconnect/stop the MediaStream.
                      // We cannot use MediaStream again after turned off.
                      pcmRecorder.releaseMediaResources(audioContext); // MediaStream will become inactive after all tracks are removed.

                      // MediaStream will become inactive after all tracks are removed.
                      mediaStream.getTracks().forEach(function (track) {
                        return mediaStream.removeTrack(track);
                      }); // ESLint: "return" is required by TypeScript
                      // eslint-disable-next-line no-useless-return

                      // ESLint: "return" is required by TypeScript
                      // eslint-disable-next-line no-useless-return
                      return;
                    },
                    id: function id() {
                      return audioNodeId;
                    },
                    read: function read() {
                      return outputStream.read();
                    }
                  },
                  deviceInfo: {
                    manufacturer: 'Bot Framework Web Chat',
                    model: enableTelemetry ? firstAudioTrack.label : '',
                    type: enableTelemetry ? 'Microphones' : 'Unknown'
                  },
                  // Speech SDK quirks: PcmRecorder hardcoded sample rate of 16000 Hz.
                  //                    We cannot obtain this number other than looking at their source code.
                  //                    I.e. no getter property.
                  // PcmRecorder always downscale to 16000 Hz. We cannot use the dynamic value from MediaConstraints or MediaTrackSettings.
                  format: PCM_RECORDER_HARDCODED_FORMAT
                });

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    debug: debug
  });
}

function createMicrophoneAudioConfigAndAudioContext(_ref) {
  var audioContext = _ref.audioContext,
      audioInputDeviceId = _ref.audioInputDeviceId,
      enableTelemetry = _ref.enableTelemetry;
  // Web Chat has an implementation of AudioConfig for microphone that would enable better support on Safari:
  // - Maintain same instance of `AudioContext` across recognitions;
  // - Resume suspended `AudioContext` on user gestures.
  audioContext || (audioContext = (0, _createAudioContext.default)());
  return {
    audioConfig: createMicrophoneAudioConfig({
      audioConstraints: audioInputDeviceId ? {
        deviceId: audioInputDeviceId
      } : true,
      audioContext: audioContext,
      enableTelemetry: enableTelemetry ? true : undefined
    }),
    audioContext: audioContext
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zcGVlY2gvY3JlYXRlTWljcm9waG9uZUF1ZGlvQ29uZmlnQW5kQXVkaW9Db250ZXh0LnRzIl0sIm5hbWVzIjpbIkRFRkFVTFRfQlVGRkVSX0RVUkFUSU9OX0lOX01TIiwiUENNX1JFQ09SREVSX0hBUkRDT0RFRF9TRVRUSU5HUyIsIk9iamVjdCIsImZyZWV6ZSIsImNoYW5uZWxDb3VudCIsInNhbXBsZVJhdGUiLCJzYW1wbGVTaXplIiwiUENNX1JFQ09SREVSX0hBUkRDT0RFRF9GT1JNQVQiLCJiaXRzUGVyU2FtcGxlIiwiY2hhbm5lbHMiLCJzYW1wbGVzUGVyU2VjIiwiY3JlYXRlTWljcm9waG9uZUF1ZGlvQ29uZmlnIiwib3B0aW9ucyIsImF1ZGlvQ29uc3RyYWludHMiLCJhdWRpb0NvbnRleHQiLCJkZWJ1ZyIsImVuYWJsZVRlbGVtZXRyeSIsInBjbVJlY29yZGVyV29ya2xldFVybCIsImJ1ZmZlckR1cmF0aW9uSW5NUyIsInBjbVJlY29yZGVyIiwiUGNtUmVjb3JkZXIiLCJzZXRXb3JrbGV0VXJsIiwiYXR0YWNoIiwiYXVkaW9Ob2RlSWQiLCJhdWRpbyIsInZpZGVvIiwibWVkaWFTdHJlYW0iLCJnZXRBdWRpb1RyYWNrcyIsImZpcnN0QXVkaW9UcmFjayIsIkVycm9yIiwib3V0cHV0U3RyZWFtIiwiQ2h1bmtlZEFycmF5QnVmZmVyU3RyZWFtIiwicmVjb3JkIiwiYXVkaW9TdHJlYW1Ob2RlIiwiZGV0YWNoIiwicmVhZEVuZGVkIiwiY2xvc2UiLCJyZWxlYXNlTWVkaWFSZXNvdXJjZXMiLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJyZW1vdmVUcmFjayIsImlkIiwicmVhZCIsImRldmljZUluZm8iLCJtYW51ZmFjdHVyZXIiLCJtb2RlbCIsImxhYmVsIiwidHlwZSIsImZvcm1hdCIsImNyZWF0ZU1pY3JvcGhvbmVBdWRpb0NvbmZpZ0FuZEF1ZGlvQ29udGV4dCIsImF1ZGlvSW5wdXREZXZpY2VJZCIsImF1ZGlvQ29uZmln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LFlBQVksRUFBWkE7QUFOSyxHQUFQO0FBUUQiLCJzb3VyY2VSb290IjoiYnVuZGxlOi8vLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENodW5rZWRBcnJheUJ1ZmZlclN0cmVhbSB9IGZyb20gJ21pY3Jvc29mdC1jb2duaXRpdmVzZXJ2aWNlcy1zcGVlY2gtc2RrL2Rpc3RyaWIvbGliL3NyYy9jb21tb24vRXhwb3J0cyc7XG5pbXBvcnQgeyBQY21SZWNvcmRlciB9IGZyb20gJ21pY3Jvc29mdC1jb2duaXRpdmVzZXJ2aWNlcy1zcGVlY2gtc2RrL2Rpc3RyaWIvbGliL3NyYy9jb21tb24uYnJvd3Nlci9FeHBvcnRzJztcblxuaW1wb3J0IHsgQXVkaW9TdHJlYW1Ob2RlLCBEZXZpY2VJbmZvLCBGb3JtYXQgfSBmcm9tICcuL0N1c3RvbUF1ZGlvSW5wdXRTdHJlYW0nO1xuaW1wb3J0IGJ5dGVzUGVyU2FtcGxlIGZyb20gJy4vYnl0ZXNQZXJTYW1wbGUnO1xuaW1wb3J0IGNyZWF0ZUF1ZGlvQ29uZmlnIGZyb20gJy4vY3JlYXRlQXVkaW9Db25maWcnO1xuaW1wb3J0IGNyZWF0ZUF1ZGlvQ29udGV4dCBmcm9tICcuL2NyZWF0ZUF1ZGlvQ29udGV4dCc7XG5pbXBvcnQgZ2V0VXNlck1lZGlhIGZyb20gJy4vZ2V0VXNlck1lZGlhJztcblxuLy8gVGhpcyBpcyBob3cgb2Z0ZW4gd2UgYXJlIGZsdXNoaW5nIGF1ZGlvIGJ1ZmZlciB0byB0aGUgbmV0d29yay4gTW9kaWZ5IHRoaXMgdmFsdWUgd2lsbCBhZmZlY3QgbGF0ZW5jeS5cbmNvbnN0IERFRkFVTFRfQlVGRkVSX0RVUkFUSU9OX0lOX01TID0gMTAwO1xuXG4vLyBUT0RPOiBbUDJdICMzOTc1IFdlIHNob3VsZCBjb25zaWRlciBidWlsZGluZyBvdXIgb3duIFBjbVJlY29yZGVyOlxuLy8gICAgICAgLSBVc2UgQXVkaW8gV29ya2xldCB2aWEgYmxvYiBVUkxcbi8vICAgICAgIC0gTm90IGhhcmRjb2RpbmcgdGhlIHNhbXBsZSByYXRlIG9yIG90aGVyIHZhbHVlc1xuLy8gUGNtUmVjb3JkZXIgYWx3YXlzIGRvd25zY2FsZSB0byAxNjAwMCBIei4gV2UgY2Fubm90IHVzZSB0aGUgZHluYW1pYyB2YWx1ZSBmcm9tIE1lZGlhQ29uc3RyYWludHMgb3IgTWVkaWFUcmFja1NldHRpbmdzLlxuY29uc3QgUENNX1JFQ09SREVSX0hBUkRDT0RFRF9TRVRUSU5HUzogTWVkaWFUcmFja1NldHRpbmdzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNoYW5uZWxDb3VudDogMSxcbiAgc2FtcGxlUmF0ZTogMTYwMDAsXG4gIHNhbXBsZVNpemU6IDE2XG59KTtcblxuY29uc3QgUENNX1JFQ09SREVSX0hBUkRDT0RFRF9GT1JNQVQ6IEZvcm1hdCA9IE9iamVjdC5mcmVlemUoe1xuICBiaXRzUGVyU2FtcGxlOiBQQ01fUkVDT1JERVJfSEFSRENPREVEX1NFVFRJTkdTLnNhbXBsZVNpemUsXG4gIGNoYW5uZWxzOiBQQ01fUkVDT1JERVJfSEFSRENPREVEX1NFVFRJTkdTLmNoYW5uZWxDb3VudCxcbiAgc2FtcGxlc1BlclNlYzogUENNX1JFQ09SREVSX0hBUkRDT0RFRF9TRVRUSU5HUy5zYW1wbGVSYXRlXG59KTtcblxudHlwZSBNaWNyb3Bob25lQXVkaW9JbnB1dFN0cmVhbU9wdGlvbnMgPSB7XG4gIC8qKiBTcGVjaWZpZXMgdGhlIGNvbnN0cmFpbnRzIGZvciBzZWxlY3RpbmcgYW4gYXVkaW8gZGV2aWNlLiAqL1xuICBhdWRpb0NvbnN0cmFpbnRzPzogdHJ1ZSB8IE1lZGlhVHJhY2tDb25zdHJhaW50cztcblxuICAvKiogU3BlY2lmaWVzIHRoZSBgQXVkaW9Db250ZXh0YCB0byB1c2UuIFRoaXMgb2JqZWN0IG11c3QgYmUgcHJpbWVkIGFuZCByZWFkeSB0byB1c2UuICovXG4gIGF1ZGlvQ29udGV4dDogQXVkaW9Db250ZXh0O1xuXG4gIC8qKiBTcGVjaWZpZXMgdGhlIGJ1ZmZlcmluZyBkZWxheSBvbiBob3cgb2Z0ZW4gdG8gZmx1c2ggYXVkaW8gZGF0YSB0byBuZXR3b3JrLiBJbmNyZWFzaW5nIHRoZSB2YWx1ZSB3aWxsIGluY3JlYXNlIGF1ZGlvIGxhdGVuY3kuIERlZmF1bHQgaXMgMTAwIG1zLiAqL1xuICBidWZmZXJEdXJhdGlvbkluTVM/OiBudW1iZXI7XG5cbiAgLyoqIFNwZWNpZmllcyB3aGV0aGVyIHRvIGRpc3BsYXkgZGlhZ25vc3RpYyBpbmZvcm1hdGlvbi4gKi9cbiAgZGVidWc/OiB0cnVlO1xuXG4gIC8qKiBTcGVjaWZpZXMgaWYgdGVsZW1ldHJ5IGRhdGEgc2hvdWxkIGJlIHNlbnQuIElmIG5vdCBzcGVjaWZpZWQsIHRlbGVtZXRyeSBkYXRhIHdpbGwgTk9UIGJlIHNlbnQuICovXG4gIGVuYWJsZVRlbGVtZXRyeT86IHRydWU7XG5cbiAgLyoqIFNwZWNpZmllcyB0aGUgYEF1ZGlvV29ya2xldGAgVVJMIGZvciBgUGNtUmVjb3JkZXJgLiBJZiBub3Qgc3BlY2lmaWVkLCB3aWxsIHVzZSBzY3JpcHQgcHJvY2Vzc29yIG9uIFVJIHRocmVhZCBpbnN0ZWFkLiAqL1xuICBwY21SZWNvcmRlcldvcmtsZXRVcmw/OiBzdHJpbmc7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVNaWNyb3Bob25lQXVkaW9Db25maWcob3B0aW9uczogTWljcm9waG9uZUF1ZGlvSW5wdXRTdHJlYW1PcHRpb25zKSB7XG4gIGNvbnN0IHsgYXVkaW9Db25zdHJhaW50cywgYXVkaW9Db250ZXh0LCBkZWJ1ZywgZW5hYmxlVGVsZW1ldHJ5LCBwY21SZWNvcmRlcldvcmtsZXRVcmwgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJ1ZmZlckR1cmF0aW9uSW5NUyA9IG9wdGlvbnMuYnVmZmVyRHVyYXRpb25Jbk1TIHx8IERFRkFVTFRfQlVGRkVSX0RVUkFUSU9OX0lOX01TO1xuXG4gIGNvbnN0IHBjbVJlY29yZGVyID0gbmV3IFBjbVJlY29yZGVyKCk7XG5cbiAgcGNtUmVjb3JkZXJXb3JrbGV0VXJsICYmIHBjbVJlY29yZGVyLnNldFdvcmtsZXRVcmwocGNtUmVjb3JkZXJXb3JrbGV0VXJsKTtcblxuICByZXR1cm4gY3JlYXRlQXVkaW9Db25maWcoe1xuICAgIGFzeW5jIGF0dGFjaChhdWRpb05vZGVJZDogc3RyaW5nKTogUHJvbWlzZTx7XG4gICAgICBhdWRpb1N0cmVhbU5vZGU6IEF1ZGlvU3RyZWFtTm9kZTtcbiAgICAgIGRldmljZUluZm86IERldmljZUluZm87XG4gICAgICBmb3JtYXQ6IEZvcm1hdDtcbiAgICB9PiB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGdldCBuZXcgTWVkaWFTdHJlYW0gb24gZXZlcnkgYXR0YWNoKCkuXG4gICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgUGNtUmVjb3JkZXIucmVsZWFzZU1lZGlhUmVzb3VyY2VzKCkgZGlzY29ubmVjdGVkL3N0b3BwZWQgdGhlbS5cbiAgICAgIGNvbnN0IG1lZGlhU3RyZWFtID0gYXdhaXQgZ2V0VXNlck1lZGlhKHsgYXVkaW86IGF1ZGlvQ29uc3RyYWludHMsIHZpZGVvOiBmYWxzZSB9KTtcblxuICAgICAgY29uc3QgW2ZpcnN0QXVkaW9UcmFja10gPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuXG4gICAgICBpZiAoIWZpcnN0QXVkaW9UcmFjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGF1ZGlvIGRldmljZSBpcyBmb3VuZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0U3RyZWFtID0gbmV3IENodW5rZWRBcnJheUJ1ZmZlclN0cmVhbShcbiAgICAgICAgLy8gU3BlZWNoIFNESyBxdWlya3M6IFBjbVJlY29yZGVyIGhhcmRjb2RlZCBzYW1wbGUgcmF0ZSBvZiAxNjAwMCBIei5cbiAgICAgICAgYnl0ZXNQZXJTYW1wbGUoUENNX1JFQ09SREVSX0hBUkRDT0RFRF9TRVRUSU5HUykgKlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgICAgICAgKChidWZmZXJEdXJhdGlvbkluTVMgfHwgREVGQVVMVF9CVUZGRVJfRFVSQVRJT05fSU5fTVMpIC8gMTAwMCksXG4gICAgICAgIGF1ZGlvTm9kZUlkXG4gICAgICApO1xuXG4gICAgICBwY21SZWNvcmRlci5yZWNvcmQoYXVkaW9Db250ZXh0LCBtZWRpYVN0cmVhbSwgb3V0cHV0U3RyZWFtKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXVkaW9TdHJlYW1Ob2RlOiB7XG4gICAgICAgICAgLy8gU3BlZWNoIFNESyBxdWlya3M6IEluIFNESydzIG9yaWdpbmFsIE1pY0F1ZGlvU291cmNlIGltcGxlbWVudGF0aW9uLCBpdCBjYWxsIHR1cm5PZmYoKSBkdXJpbmcgZGV0YWNoKCkuXG4gICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIFRoYXQgbWVhbnMsIGl0IGNhbGwgdHVybk9mZigpLCB0aGVuIGRldGFjaCgpLCB0aGVuIHR1cm5PZmYoKSBhZ2Fpbi4gU2VlbXMgcmVkdW5kYW50LlxuICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBXaGVuIHVzaW5nIHdpdGggRGlyZWN0IExpbmUgU3BlZWNoLCB0dXJuT2ZmKCkgaXMgbmV2ZXIgY2FsbGVkLlxuICAgICAgICAgIGRldGFjaDogKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICAgICAgLy8gU3BlZWNoIFNESyBxdWlya3M6IEluIFNESywgaXQgY2FsbCBvdXRwdXRTdHJlYW0uY2xvc2UoKSBpbiB0dXJuT2ZmKCkgYmVmb3JlIG91dHB1dFN0cmVhbS5yZWFkRW5kZWQoKSBpbiBkZXRhY2goKS5cbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBJIHRoaW5rIGl0IG1ha2Ugc2Vuc2UgdG8gY2FsbCByZWFkRW5kZWQoKSBiZWZvcmUgY2xvc2UoKS5cbiAgICAgICAgICAgIG91dHB1dFN0cmVhbS5yZWFkRW5kZWQoKTtcbiAgICAgICAgICAgIG91dHB1dFN0cmVhbS5jbG9zZSgpO1xuXG4gICAgICAgICAgICAvLyBQY21SZWNvcmRlci5yZWxlYXNlTWVkaWFSZXNvdXJjZXMoKSB3aWxsIGRpc2Nvbm5lY3Qvc3RvcCB0aGUgTWVkaWFTdHJlYW0uXG4gICAgICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIE1lZGlhU3RyZWFtIGFnYWluIGFmdGVyIHR1cm5lZCBvZmYuXG4gICAgICAgICAgICBwY21SZWNvcmRlci5yZWxlYXNlTWVkaWFSZXNvdXJjZXMoYXVkaW9Db250ZXh0KTtcblxuICAgICAgICAgICAgLy8gTWVkaWFTdHJlYW0gd2lsbCBiZWNvbWUgaW5hY3RpdmUgYWZ0ZXIgYWxsIHRyYWNrcyBhcmUgcmVtb3ZlZC5cbiAgICAgICAgICAgIG1lZGlhU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spKTtcblxuICAgICAgICAgICAgLy8gRVNMaW50OiBcInJldHVyblwiIGlzIHJlcXVpcmVkIGJ5IFR5cGVTY3JpcHRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLXJldHVyblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6ICgpID0+IGF1ZGlvTm9kZUlkLFxuICAgICAgICAgIHJlYWQ6ICgpID0+IG91dHB1dFN0cmVhbS5yZWFkKClcbiAgICAgICAgfSxcbiAgICAgICAgZGV2aWNlSW5mbzoge1xuICAgICAgICAgIG1hbnVmYWN0dXJlcjogJ0JvdCBGcmFtZXdvcmsgV2ViIENoYXQnLFxuICAgICAgICAgIG1vZGVsOiBlbmFibGVUZWxlbWV0cnkgPyBmaXJzdEF1ZGlvVHJhY2subGFiZWwgOiAnJyxcbiAgICAgICAgICB0eXBlOiBlbmFibGVUZWxlbWV0cnkgPyAnTWljcm9waG9uZXMnIDogJ1Vua25vd24nXG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNwZWVjaCBTREsgcXVpcmtzOiBQY21SZWNvcmRlciBoYXJkY29kZWQgc2FtcGxlIHJhdGUgb2YgMTYwMDAgSHouXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBXZSBjYW5ub3Qgb2J0YWluIHRoaXMgbnVtYmVyIG90aGVyIHRoYW4gbG9va2luZyBhdCB0aGVpciBzb3VyY2UgY29kZS5cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIEkuZS4gbm8gZ2V0dGVyIHByb3BlcnR5LlxuICAgICAgICAvLyBQY21SZWNvcmRlciBhbHdheXMgZG93bnNjYWxlIHRvIDE2MDAwIEh6LiBXZSBjYW5ub3QgdXNlIHRoZSBkeW5hbWljIHZhbHVlIGZyb20gTWVkaWFDb25zdHJhaW50cyBvciBNZWRpYVRyYWNrU2V0dGluZ3MuXG4gICAgICAgIGZvcm1hdDogUENNX1JFQ09SREVSX0hBUkRDT0RFRF9GT1JNQVRcbiAgICAgIH07XG4gICAgfSxcbiAgICBkZWJ1Z1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlTWljcm9waG9uZUF1ZGlvQ29uZmlnQW5kQXVkaW9Db250ZXh0KHtcbiAgYXVkaW9Db250ZXh0LFxuICBhdWRpb0lucHV0RGV2aWNlSWQsXG4gIGVuYWJsZVRlbGVtZXRyeVxufToge1xuICBhdWRpb0NvbnRleHQ/OiBBdWRpb0NvbnRleHQ7XG4gIGF1ZGlvSW5wdXREZXZpY2VJZD86IHN0cmluZztcbiAgZW5hYmxlVGVsZW1ldHJ5PzogdHJ1ZTtcbn0pIHtcbiAgLy8gV2ViIENoYXQgaGFzIGFuIGltcGxlbWVudGF0aW9uIG9mIEF1ZGlvQ29uZmlnIGZvciBtaWNyb3Bob25lIHRoYXQgd291bGQgZW5hYmxlIGJldHRlciBzdXBwb3J0IG9uIFNhZmFyaTpcbiAgLy8gLSBNYWludGFpbiBzYW1lIGluc3RhbmNlIG9mIGBBdWRpb0NvbnRleHRgIGFjcm9zcyByZWNvZ25pdGlvbnM7XG4gIC8vIC0gUmVzdW1lIHN1c3BlbmRlZCBgQXVkaW9Db250ZXh0YCBvbiB1c2VyIGdlc3R1cmVzLlxuICBhdWRpb0NvbnRleHQgfHwgKGF1ZGlvQ29udGV4dCA9IGNyZWF0ZUF1ZGlvQ29udGV4dCgpKTtcblxuICByZXR1cm4ge1xuICAgIGF1ZGlvQ29uZmlnOiBjcmVhdGVNaWNyb3Bob25lQXVkaW9Db25maWcoe1xuICAgICAgYXVkaW9Db25zdHJhaW50czogYXVkaW9JbnB1dERldmljZUlkID8geyBkZXZpY2VJZDogYXVkaW9JbnB1dERldmljZUlkIH0gOiB0cnVlLFxuICAgICAgYXVkaW9Db250ZXh0LFxuICAgICAgZW5hYmxlVGVsZW1ldHJ5OiBlbmFibGVUZWxlbWV0cnkgPyB0cnVlIDogdW5kZWZpbmVkXG4gICAgfSksXG4gICAgYXVkaW9Db250ZXh0XG4gIH07XG59XG4iXX0=