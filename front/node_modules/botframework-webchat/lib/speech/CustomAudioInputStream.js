"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _microsoftCognitiveservicesSpeechSdk = require("microsoft-cognitiveservices-speech-sdk");

var _Exports = require("microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports");

var _AudioStreamFormat = require("microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat");

var _Exports2 = require("microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports");

var _botframeworkWebchatCore = require("botframework-webchat-core");

var _uuid = require("uuid");

var _pDeferEs = _interopRequireDefault(require("p-defer-es5"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var SYMBOL_DEVICE_INFO_DEFERRED = Symbol('deviceInfoDeferred');
var SYMBOL_EVENTS = Symbol('events');
var SYMBOL_FORMAT_DEFERRED = Symbol('formatDeferred');
var SYMBOL_OPTIONS = Symbol('options'); // Speech SDK quirks: Only 2 lifecycle functions are actually used.
//                    They are: attach() and turnOff().
//                    Others are not used, including: blob(), close(), detach(), turnOn().

var CustomAudioInputStream = /*#__PURE__*/function (_AudioInputStream) {
  (0, _inherits2.default)(CustomAudioInputStream, _AudioInputStream);

  var _super = _createSuper(CustomAudioInputStream);

  function CustomAudioInputStream() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck2.default)(this, CustomAudioInputStream);
    _this = _super.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), SYMBOL_DEVICE_INFO_DEFERRED, void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), SYMBOL_EVENTS, void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), SYMBOL_FORMAT_DEFERRED, void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), SYMBOL_OPTIONS, void 0);
    var normalizedOptions = {
      debug: options.debug || false,
      id: options.id || (0, _uuid.v4)().replace(/\x2D/g, '')
    }; // False alarm: indexer is a constant of type Symbol.
    // eslint-disable-next-line security/detect-object-injection

    _this[SYMBOL_DEVICE_INFO_DEFERRED] = (0, _pDeferEs.default)(); // False alarm: indexer is a constant of type Symbol.
    // eslint-disable-next-line security/detect-object-injection

    _this[SYMBOL_EVENTS] = new _Exports.EventSource(); // False alarm: indexer is a constant of type Symbol.
    // eslint-disable-next-line security/detect-object-injection

    _this[SYMBOL_FORMAT_DEFERRED] = (0, _pDeferEs.default)(); // False alarm: indexer is a constant of type Symbol.
    // eslint-disable-next-line security/detect-object-injection

    _this[SYMBOL_OPTIONS] = normalizedOptions;
    return _this;
  }

  (0, _createClass2.default)(CustomAudioInputStream, [{
    key: "events",
    get:
    /** Gets the event source for listening to events. */
    // ESLint: This code will only works in browsers other than IE11. Only works in ES5 is okay.
    // @ts-ignore Accessors are only available when targeting ECMAScript 5 and higher.ts(1056)
    function get() {
      // False alarm: indexer is a constant of type Symbol.
      // eslint-disable-next-line security/detect-object-injection
      return this[SYMBOL_EVENTS];
    }
    /** Gets the format of the audio stream. */
    // Speech SDK quirks: `AudioStreamFormatImpl` is internal implementation while `AudioStreamFormat` is public.
    //                    It is weird to expose `AudioStreamFormatImpl` instead of `AudioStreamFormat`.
    // Speech SDK quirks: It is weird to return a `Promise` in a property.
    // Speech SDK quirks: In normal speech recognition, getter of "format" is called only after "attach".
    //                    But in Direct Line Speech, it is called before "attach".
    // ESLint: This code will only works in browsers other than IE11. Only works in ES5 is okay.
    // @ts-ignore Accessors are only available when targeting ECMAScript 5 and higher.ts(1056)

  }, {
    key: "format",
    get: function get() {
      this.debug('Getting "format".'); // False alarm: indexer is a constant of type Symbol.
      // eslint-disable-next-line security/detect-object-injection

      return this[SYMBOL_FORMAT_DEFERRED].promise;
    }
    /** Gets the ID of this audio stream. */

  }, {
    key: "id",
    value: function id() {
      // False alarm: indexer is a constant of type Symbol.
      // eslint-disable-next-line security/detect-object-injection
      return this[SYMBOL_OPTIONS].id;
    }
    /** Emits an event. */
    // Speech SDK quirks: In JavaScript, onXxx means "listen to event XXX".
    //                    Instead, in Speech SDK, it means "emit event XXX".

  }, {
    key: "onEvent",
    value: function onEvent(event) {
      // False alarm: indexer is a constant of type Symbol.
      // eslint-disable-next-line security/detect-object-injection
      this[SYMBOL_EVENTS].onEvent(event);

      _Exports.Events.instance.onEvent(event);
    }
    /** Emits an `AudioSourceInitializingEvent`. */

  }, {
    key: "emitInitializing",
    value: function emitInitializing() {
      this.debug('Emitting "AudioSourceInitializingEvent".');
      this.onEvent(new _Exports.AudioSourceInitializingEvent(this.id()));
    }
    /** Emits an `AudioSourceReadyEvent`. */

  }, {
    key: "emitReady",
    value: function emitReady() {
      this.debug('Emitting "AudioSourceReadyEvent".');
      this.onEvent(new _Exports.AudioSourceReadyEvent(this.id()));
    }
    /** Emits an `AudioSourceErrorEvent`. */
    // Speech SDK quirks: Since "turnOn" is never called and "turnOff" does not work in Direct Line Speech, the "source error" event is not emitted at all.
    //                    Instead, we only emit "node error" event.

  }, {
    key: "emitError",
    value: function emitError(error) {
      this.debug('Emitting "AudioSourceErrorEvent".', {
        error: error
      }); // Speech SDK quirks: "error" is a string, instead of object of type "Error".

      this.onEvent(new _Exports.AudioSourceErrorEvent(this.id(), error.message));
    }
    /** Emits an `AudioStreamNodeAttachingEvent`. */

  }, {
    key: "emitNodeAttaching",
    value: function emitNodeAttaching(audioNodeId) {
      this.debug("Emitting \"AudioStreamNodeAttachingEvent\" for node \"".concat(audioNodeId, "\"."));
      this.onEvent(new _Exports.AudioStreamNodeAttachingEvent(this.id(), audioNodeId));
    }
    /** Emits an `AudioStreamNodeAttachedEvent`. */

  }, {
    key: "emitNodeAttached",
    value: function emitNodeAttached(audioNodeId) {
      this.debug("Emitting \"AudioStreamNodeAttachedEvent\" for node \"".concat(audioNodeId, "\"."));
      this.onEvent(new _Exports.AudioStreamNodeAttachedEvent(this.id(), audioNodeId));
    }
    /** Emits an `AudioStreamNodeErrorEvent`. */

  }, {
    key: "emitNodeError",
    value: function emitNodeError(audioNodeId, error) {
      this.debug("Emitting \"AudioStreamNodeErrorEvent\" for node \"".concat(audioNodeId, "\"."), {
        error: error
      }); // Speech SDK quirks: "error" is a string, instead of object of type "Error".

      this.onEvent(new _Exports.AudioStreamNodeErrorEvent(this.id(), audioNodeId, error.message));
    }
    /** Emits an `AudioStreamNodeDetachedEvent`. */

  }, {
    key: "emitNodeDetached",
    value: function emitNodeDetached(audioNodeId) {
      this.debug('Emitting "AudioStreamNodeDetachedEvent".');
      this.onEvent(new _Exports.AudioStreamNodeDetachedEvent(this.id(), audioNodeId));
    }
    /** Emits an `AudioSourceOffEvent`. */

  }, {
    key: "emitOff",
    value: function emitOff() {
      this.debug('Emitting "AudioSourceOffEvent".');
      this.onEvent(new _Exports.AudioSourceOffEvent(this.id()));
    } // Speech SDK quirks: Although "close" is marked as abstract, it is never called in our observations.
    // ESLint: Speech SDK requires this function, but we are not implementing it.

  }, {
    key: "close",
    value: function close() {
      this.debug('Callback for "close".');
      throw new Error('Not implemented');
    } // Speech SDK quirks: Although "turnOn" is implemented in Speech SDK Push/PullAudioInputStream, it is never called in our observations.

  }, {
    key: "turnOn",
    value: function turnOn() {
      this.debug('Callback for "turnOn".');
      throw new Error('Not implemented');
    } // Speech SDK quirks: Although "detach" is implemented in Speech SDK Push/PullAudioInputStream, it is never called in our observations.

  }, {
    key: "detach",
    value: function detach() {
      this.debug('Callback for "detach".');
      throw new Error('Not implemented');
    }
    /** Log the message to console if `debug` is set to `true`. */

  }, {
    key: "debug",
    value: function debug(message) {
      var _console;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // ESLint: For debugging, will only log when "debug" is set to "true".
      // False alarm: indexer is a constant of type Symbol.
      // eslint-disable-next-line no-console, security/detect-object-injection
      this[SYMBOL_OPTIONS].debug && (_console = console).info.apply(_console, ["CustomAudioInputStream: ".concat(message)].concat(args));
    }
    /** Implements this function. When called, it should start recording and return an `IAudioStreamNode`. */

  }, {
    key: "attach",
    value:
    /** Attaches the device by returning an audio node. */
    function attach(audioNodeId) {
      var _this2 = this;

      this.debug("Callback for \"attach\" with \"".concat(audioNodeId, "\"."));
      this.emitNodeAttaching(audioNodeId);
      return Promise.resolve().then( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var _yield$_this2$perform, audioStreamNode, deviceInfo, format;

        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _this2.emitInitializing();

                _context2.prev = 1;
                _context2.next = 4;
                return _this2.performAttach(audioNodeId);

              case 4:
                _yield$_this2$perform = _context2.sent;
                audioStreamNode = _yield$_this2$perform.audioStreamNode;
                deviceInfo = _yield$_this2$perform.deviceInfo;
                format = _yield$_this2$perform.format;

                // Although only getter of "format" is called before "attach" (in Direct Line Speech),
                // we are handling both "deviceInfo" and "format" in similar way for uniformity.
                // False alarm: indexer is a constant of type Symbol.
                // eslint-disable-next-line security/detect-object-injection
                _this2[SYMBOL_DEVICE_INFO_DEFERRED].resolve(deviceInfo); // False alarm: indexer is a constant of type Symbol.
                // eslint-disable-next-line security/detect-object-injection


                _this2[SYMBOL_FORMAT_DEFERRED].resolve(new _AudioStreamFormat.AudioStreamFormatImpl(format.samplesPerSec, format.bitsPerSample, format.channels));

                _this2.emitReady();

                _this2.emitNodeAttached(audioNodeId);

                return _context2.abrupt("return", {
                  detach: function () {
                    var _detach = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
                      return _regenerator.default.wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              _this2.debug("Detaching audio node \"".concat(audioNodeId, "\"."));

                              _context.next = 3;
                              return audioStreamNode.detach();

                            case 3:
                              // Speech SDK quirks: Since "turnOff" is not called in Direct Line Speech, we will emit event "source off" here instead.
                              _this2.emitOff();

                              _this2.emitNodeDetached(audioNodeId);

                            case 5:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee);
                    }));

                    function detach() {
                      return _detach.apply(this, arguments);
                    }

                    return detach;
                  }(),
                  id: function id() {
                    return audioStreamNode.id();
                  },
                  read: function read() {
                    _this2.debug('Reading');

                    return audioStreamNode.read();
                  }
                });

              case 15:
                _context2.prev = 15;
                _context2.t0 = _context2["catch"](1);

                _this2.emitNodeError(audioNodeId, _context2.t0);

                throw _context2.t0;

              case 19:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[1, 15]]);
      })));
    }
    /**
     * Implements this function. When called, it should stop recording. This is called before the `IAudioStreamNode.detach` function.
     *
     * Note: when using with Direct Line Speech, this function is never called.
     */
    // ESLint: We are not implementing this function because it is not called by Direct Line Speech.
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "performTurnOff",
    value: function performTurnOff() {
      // ESLint: "return" is required by TypeScript
      // eslint-disable-next-line no-useless-return
      return;
    }
    /** Turn off the audio device. This is called before detaching from the graph. */
    // Speech SDK quirks: It is confused to have both "turnOff" and "detach". "turnOff" is called before "detach".
    //                    Why don't we put all logics at "detach"?
    // Speech SDK quirks: Direct Line Speech never call "turnOff". "Source off" event need to be emitted during "detach" instead.
    //                    Also, custom implementation should be done at "detach" instead, such as ending and closing output streams.

  }, {
    key: "turnOff",
    value: function () {
      var _turnOff = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.debug("Callback for \"turnOff\".");
                _context3.next = 3;
                return this.performTurnOff();

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function turnOff() {
        return _turnOff.apply(this, arguments);
      }

      return turnOff;
    }()
    /** Gets the device information. */
    // ESLint: This code will only works in browsers other than IE11. Only works in ES5 is okay.
    // @ts-ignore Accessors are only available when targeting ECMAScript 5 and higher.ts(1056)

  }, {
    key: "deviceInfo",
    get: function get() {
      this.debug("Getting \"deviceInfo\"."); // False alarm: indexer is a constant of type Symbol.
      // eslint-disable-next-line security/detect-object-injection

      return Promise.all([this[SYMBOL_DEVICE_INFO_DEFERRED].promise, this[SYMBOL_FORMAT_DEFERRED].promise]).then(function (_ref2) {
        var _ref3 = (0, _slicedToArray2.default)(_ref2, 2),
            _ref3$ = _ref3[0],
            connectivity = _ref3$.connectivity,
            manufacturer = _ref3$.manufacturer,
            model = _ref3$.model,
            type = _ref3$.type,
            _ref3$2 = _ref3[1],
            bitsPerSample = _ref3$2.bitsPerSample,
            channels = _ref3$2.channels,
            samplesPerSec = _ref3$2.samplesPerSec;

        return {
          bitspersample: bitsPerSample,
          channelcount: channels,
          connectivity: typeof connectivity === 'string' && !(0, _botframeworkWebchatCore.isForbiddenPropertyName)(connectivity) ? // Mitigated through denylisting.
          // eslint-disable-next-line security/detect-object-injection
          _Exports2.connectivity[connectivity] : connectivity || _Exports2.connectivity.Unknown,
          manufacturer: manufacturer || '',
          model: model || '',
          samplerate: samplesPerSec,
          // Mitigated through denylisting.
          // eslint-disable-next-line security/detect-object-injection
          type: typeof type === 'string' && !(0, _botframeworkWebchatCore.isForbiddenPropertyName)(type) ? _Exports2.type[type] : type || _Exports2.type.Unknown
        };
      });
    }
  }]);
  return CustomAudioInputStream;
}(_microsoftCognitiveservicesSpeechSdk.AudioInputStream);

var _default = CustomAudioInputStream;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zcGVlY2gvQ3VzdG9tQXVkaW9JbnB1dFN0cmVhbS50cyJdLCJuYW1lcyI6WyJTWU1CT0xfREVWSUNFX0lORk9fREVGRVJSRUQiLCJTeW1ib2wiLCJTWU1CT0xfRVZFTlRTIiwiU1lNQk9MX0ZPUk1BVF9ERUZFUlJFRCIsIlNZTUJPTF9PUFRJT05TIiwiQ3VzdG9tQXVkaW9JbnB1dFN0cmVhbSIsIm9wdGlvbnMiLCJub3JtYWxpemVkT3B0aW9ucyIsImRlYnVnIiwiaWQiLCJyZXBsYWNlIiwiRXZlbnRTb3VyY2UiLCJwcm9taXNlIiwiZXZlbnQiLCJvbkV2ZW50IiwiRXZlbnRzIiwiaW5zdGFuY2UiLCJBdWRpb1NvdXJjZUluaXRpYWxpemluZ0V2ZW50IiwiQXVkaW9Tb3VyY2VSZWFkeUV2ZW50IiwiZXJyb3IiLCJBdWRpb1NvdXJjZUVycm9yRXZlbnQiLCJtZXNzYWdlIiwiYXVkaW9Ob2RlSWQiLCJBdWRpb1N0cmVhbU5vZGVBdHRhY2hpbmdFdmVudCIsIkF1ZGlvU3RyZWFtTm9kZUF0dGFjaGVkRXZlbnQiLCJBdWRpb1N0cmVhbU5vZGVFcnJvckV2ZW50IiwiQXVkaW9TdHJlYW1Ob2RlRGV0YWNoZWRFdmVudCIsIkF1ZGlvU291cmNlT2ZmRXZlbnQiLCJFcnJvciIsImFyZ3MiLCJjb25zb2xlIiwiaW5mbyIsImVtaXROb2RlQXR0YWNoaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiZW1pdEluaXRpYWxpemluZyIsInBlcmZvcm1BdHRhY2giLCJhdWRpb1N0cmVhbU5vZGUiLCJkZXZpY2VJbmZvIiwiZm9ybWF0IiwiQXVkaW9TdHJlYW1Gb3JtYXRJbXBsIiwic2FtcGxlc1BlclNlYyIsImJpdHNQZXJTYW1wbGUiLCJjaGFubmVscyIsImVtaXRSZWFkeSIsImVtaXROb2RlQXR0YWNoZWQiLCJkZXRhY2giLCJlbWl0T2ZmIiwiZW1pdE5vZGVEZXRhY2hlZCIsInJlYWQiLCJlbWl0Tm9kZUVycm9yIiwicGVyZm9ybVR1cm5PZmYiLCJhbGwiLCJjb25uZWN0aXZpdHkiLCJtYW51ZmFjdHVyZXIiLCJtb2RlbCIsInR5cGUiLCJiaXRzcGVyc2FtcGxlIiwiY2hhbm5lbGNvdW50IiwiQ29ubmVjdGl2aXR5IiwiVW5rbm93biIsInNhbXBsZXJhdGUiLCJUeXBlIiwiQXVkaW9JbnB1dFN0cmVhbSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFjQTs7QUFFQTs7QUFNQTs7QUFDQTs7QUFDQTs7Ozs7O0FBZ0RBLElBQU1BLDJCQUEyQixHQUFHQyxNQUFNLENBQUMsb0JBQUQsQ0FBMUM7QUFDQSxJQUFNQyxhQUFhLEdBQUdELE1BQU0sQ0FBQyxRQUFELENBQTVCO0FBQ0EsSUFBTUUsc0JBQXNCLEdBQUdGLE1BQU0sQ0FBQyxnQkFBRCxDQUFyQztBQUNBLElBQU1HLGNBQWMsR0FBR0gsTUFBTSxDQUFDLFNBQUQsQ0FBN0IsQyxDQUVBO0FBQ0E7QUFDQTs7SUFDZUksc0I7Ozs7O0FBQ2Isb0NBQW1DO0FBQUE7O0FBQUEsUUFBdkJDLE9BQXVCLHVFQUFKLEVBQUk7QUFBQTtBQUNqQztBQURpQywrRUF5QmxDTiwyQkF6QmtDO0FBQUEsK0VBMEJsQ0UsYUExQmtDO0FBQUEsK0VBMkJsQ0Msc0JBM0JrQztBQUFBLCtFQTRCbENDLGNBNUJrQztBQUdqQyxRQUFNRyxpQkFBb0MsR0FBRztBQUMzQ0MsTUFBQUEsS0FBSyxFQUFFRixPQUFPLENBQUNFLEtBQVIsSUFBaUIsS0FEbUI7QUFFM0NDLE1BQUFBLEVBQUUsRUFBRUgsT0FBTyxDQUFDRyxFQUFSLElBQWMsZ0JBQUtDLE9BQUwsQ0FBYSxPQUFiLEVBQW9CLEVBQXBCO0FBRnlCLEtBQTdDLENBSGlDLENBUWpDO0FBQ0E7O0FBQ0EsVUFBS1YsMkJBQUwsSUFBb0Msd0JBQXBDLENBVmlDLENBWWpDO0FBQ0E7O0FBQ0EsVUFBS0UsYUFBTCxJQUFzQixJQUFJUyxvQkFBSixFQUF0QixDQWRpQyxDQWdCakM7QUFDQTs7QUFDQSxVQUFLUixzQkFBTCxJ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S0FBZ0IsUUFBaEIsSUFBNEIsQ0FBQyxzREFBd0JBLElBQXhCLENBQTdCLEdBQTZETSxlQUFLTixJQUFMLENBQTdELEdBQTBFQSxJQUFJLElBQUlNLGVBQUtGO0FBZEMsU0FBaEc7QUFBQSxPQURLLENBQVA7QUFrQkQ7OztFQTVRMkNHLHFEOztlQStRL0IzRCxzQiIsInNvdXJjZVJvb3QiOiJidW5kbGU6Ly8vIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXVkaW9JbnB1dFN0cmVhbSB9IGZyb20gJ21pY3Jvc29mdC1jb2duaXRpdmVzZXJ2aWNlcy1zcGVlY2gtc2RrJztcblxuaW1wb3J0IHtcbiAgQXVkaW9Tb3VyY2VFcnJvckV2ZW50LFxuICBBdWRpb1NvdXJjZUV2ZW50LFxuICBBdWRpb1NvdXJjZUluaXRpYWxpemluZ0V2ZW50LFxuICBBdWRpb1NvdXJjZU9mZkV2ZW50LFxuICBBdWRpb1NvdXJjZVJlYWR5RXZlbnQsXG4gIEF1ZGlvU3RyZWFtTm9kZUF0dGFjaGVkRXZlbnQsXG4gIEF1ZGlvU3RyZWFtTm9kZUF0dGFjaGluZ0V2ZW50LFxuICBBdWRpb1N0cmVhbU5vZGVEZXRhY2hlZEV2ZW50LFxuICBBdWRpb1N0cmVhbU5vZGVFcnJvckV2ZW50LFxuICBFdmVudHMsXG4gIEV2ZW50U291cmNlXG59IGZyb20gJ21pY3Jvc29mdC1jb2duaXRpdmVzZXJ2aWNlcy1zcGVlY2gtc2RrL2Rpc3RyaWIvbGliL3NyYy9jb21tb24vRXhwb3J0cyc7XG5cbmltcG9ydCB7IEF1ZGlvU3RyZWFtRm9ybWF0SW1wbCB9IGZyb20gJ21pY3Jvc29mdC1jb2duaXRpdmVzZXJ2aWNlcy1zcGVlY2gtc2RrL2Rpc3RyaWIvbGliL3NyYy9zZGsvQXVkaW8vQXVkaW9TdHJlYW1Gb3JtYXQnO1xuXG5pbXBvcnQge1xuICBjb25uZWN0aXZpdHkgYXMgQ29ubmVjdGl2aXR5LFxuICBJU3BlZWNoQ29uZmlnQXVkaW9EZXZpY2UsXG4gIHR5cGUgYXMgVHlwZVxufSBmcm9tICdtaWNyb3NvZnQtY29nbml0aXZlc2VydmljZXMtc3BlZWNoLXNkay9kaXN0cmliL2xpYi9zcmMvY29tbW9uLnNwZWVjaC9FeHBvcnRzJztcblxuaW1wb3J0IHsgaXNGb3JiaWRkZW5Qcm9wZXJ0eU5hbWUgfSBmcm9tICdib3RmcmFtZXdvcmstd2ViY2hhdC1jb3JlJztcbmltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgY3JlYXRlRGVmZXJyZWQsIHsgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAncC1kZWZlci1lczUnO1xuXG50eXBlIEF1ZGlvU3RyZWFtTm9kZSA9IHtcbiAgZGV0YWNoOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBpZDogKCkgPT4gc3RyaW5nO1xuICByZWFkOiAoKSA9PiBQcm9taXNlPFN0cmVhbUNodW5rPEFycmF5QnVmZmVyPj47XG59O1xuXG50eXBlIERldmljZUluZm8gPSB7XG4gIGNvbm5lY3Rpdml0eT86IENvbm5lY3Rpdml0eSB8ICdCbHVldG9vdGgnIHwgJ1dpcmVkJyB8ICdXaUZpJyB8ICdDZWxsdWxhcicgfCAnSW5CdWlsdCcgfCAnVW5rbm93bic7XG4gIG1hbnVmYWN0dXJlcj86IHN0cmluZztcbiAgbW9kZWw/OiBzdHJpbmc7XG4gIHR5cGU/OlxuICAgIHwgVHlwZVxuICAgIHwgJ1Bob25lJ1xuICAgIHwgJ1NwZWFrZXInXG4gICAgfCAnQ2FyJ1xuICAgIHwgJ0hlYWRzZXQnXG4gICAgfCAnVGhlcm1vc3RhdCdcbiAgICB8ICdNaWNyb3Bob25lcydcbiAgICB8ICdEZXNrcGhvbmUnXG4gICAgfCAnUmVtb3RlQ29udHJvbCdcbiAgICB8ICdVbmtub3duJ1xuICAgIHwgJ0ZpbGUnXG4gICAgfCAnU3RyZWFtJztcbn07XG5cbnR5cGUgRm9ybWF0ID0ge1xuICBiaXRzUGVyU2FtcGxlOiBudW1iZXI7XG4gIGNoYW5uZWxzOiBudW1iZXI7XG4gIHNhbXBsZXNQZXJTZWM6IG51bWJlcjtcbn07XG5cbnR5cGUgTm9ybWFsaXplZE9wdGlvbnMgPSBSZXF1aXJlZDxPbWl0PE9wdGlvbnMsICdkZWJ1Zyc+PiAmIHtcbiAgZGVidWc6IGJvb2xlYW47XG59O1xuXG50eXBlIE9wdGlvbnMgPSB7XG4gIGRlYnVnPzogdHJ1ZTtcbiAgaWQ/OiBzdHJpbmc7XG59O1xuXG50eXBlIFN0cmVhbUNodW5rPFQ+ID0ge1xuICBpc0VuZDogYm9vbGVhbjtcbiAgYnVmZmVyOiBUO1xuICB0aW1lUmVjZWl2ZWQ6IG51bWJlcjtcbn07XG5cbmNvbnN0IFNZTUJPTF9ERVZJQ0VfSU5GT19ERUZFUlJFRCA9IFN5bWJvbCgnZGV2aWNlSW5mb0RlZmVycmVkJyk7XG5jb25zdCBTWU1CT0xfRVZFTlRTID0gU3ltYm9sKCdldmVudHMnKTtcbmNvbnN0IFNZTUJPTF9GT1JNQVRfREVGRVJSRUQgPSBTeW1ib2woJ2Zvcm1hdERlZmVycmVkJyk7XG5jb25zdCBTWU1CT0xfT1BUSU9OUyA9IFN5bWJvbCgnb3B0aW9ucycpO1xuXG4vLyBTcGVlY2ggU0RLIHF1aXJrczogT25seSAyIGxpZmVjeWNsZSBmdW5jdGlvbnMgYXJlIGFjdHVhbGx5IHVzZWQuXG4vLyAgICAgICAgICAgICAgICAgICAgVGhleSBhcmU6IGF0dGFjaCgpIGFuZCB0dXJuT2ZmKCkuXG4vLyAgICAgICAgICAgICAgICAgICAgT3RoZXJzIGFyZSBub3QgdXNlZCwgaW5jbHVkaW5nOiBibG9iKCksIGNsb3NlKCksIGRldGFjaCgpLCB0dXJuT24oKS5cbmFic3RyYWN0IGNsYXNzIEN1c3RvbUF1ZGlvSW5wdXRTdHJlYW0gZXh0ZW5kcyBBdWRpb0lucHV0U3RyZWFtIHtcbiAgY29uc3RydWN0b3Iob3B0aW9uczogT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRPcHRpb25zOiBOb3JtYWxpemVkT3B0aW9ucyA9IHtcbiAgICAgIGRlYnVnOiBvcHRpb25zLmRlYnVnIHx8IGZhbHNlLFxuICAgICAgaWQ6IG9wdGlvbnMuaWQgfHwgdjQoKS5yZXBsYWNlKC8tL2d1LCAnJylcbiAgICB9O1xuXG4gICAgLy8gRmFsc2UgYWxhcm06IGluZGV4ZXIgaXMgYSBjb25zdGFudCBvZiB0eXBlIFN5bWJvbC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW9iamVjdC1pbmplY3Rpb25cbiAgICB0aGlzW1NZTUJPTF9ERVZJQ0VfSU5GT19ERUZFUlJFRF0gPSBjcmVhdGVEZWZlcnJlZDxEZXZpY2VJbmZvPigpO1xuXG4gICAgLy8gRmFsc2UgYWxhcm06IGluZGV4ZXIgaXMgYSBjb25zdGFudCBvZiB0eXBlIFN5bWJvbC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW9iamVjdC1pbmplY3Rpb25cbiAgICB0aGlzW1NZTUJPTF9FVkVOVFNdID0gbmV3IEV2ZW50U291cmNlPEF1ZGlvU291cmNlRXZlbnQ+KCk7XG5cbiAgICAvLyBGYWxzZSBhbGFybTogaW5kZXhlciBpcyBhIGNvbnN0YW50IG9mIHR5cGUgU3ltYm9sLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzZWN1cml0eS9kZXRlY3Qtb2JqZWN0LWluamVjdGlvblxuICAgIHRoaXNbU1lNQk9MX0ZPUk1BVF9ERUZFUlJFRF0gPSBjcmVhdGVEZWZlcnJlZDxBdWRpb1N0cmVhbUZvcm1hdEltcGw+KCk7XG5cbiAgICAvLyBGYWxzZSBhbGFybTogaW5kZXhlciBpcyBhIGNvbnN0YW50IG9mIHR5cGUgU3ltYm9sLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzZWN1cml0eS9kZXRlY3Qtb2JqZWN0LWluamVjdGlvblxuICAgIHRoaXNbU1lNQk9MX09QVElPTlNdID0gbm9ybWFsaXplZE9wdGlvbnM7XG4gIH1cblxuICBbU1lNQk9MX0RFVklDRV9JTkZPX0RFRkVSUkVEXTogRGVmZXJyZWRQcm9taXNlPERldmljZUluZm8+O1xuICBbU1lNQk9MX0VWRU5UU106IEV2ZW50U291cmNlPEF1ZGlvU291cmNlRXZlbnQ+O1xuICBbU1lNQk9MX0ZPUk1BVF9ERUZFUlJFRF06IERlZmVycmVkUHJvbWlzZTxBdWRpb1N0cmVhbUZvcm1hdEltcGw+O1xuICBbU1lNQk9MX09QVElPTlNdOiBOb3JtYWxpemVkT3B0aW9ucztcblxuICAvKiogR2V0cyB0aGUgZXZlbnQgc291cmNlIGZvciBsaXN0ZW5pbmcgdG8gZXZlbnRzLiAqL1xuICAvLyBFU0xpbnQ6IFRoaXMgY29kZSB3aWxsIG9ubHkgd29ya3MgaW4gYnJvd3NlcnMgb3RoZXIgdGhhbiBJRTExLiBPbmx5IHdvcmtzIGluIEVTNSBpcyBva2F5LlxuICAvLyBAdHMtaWdub3JlIEFjY2Vzc29ycyBhcmUgb25seSBhdmFpbGFibGUgd2hlbiB0YXJnZXRpbmcgRUNNQVNjcmlwdCA1IGFuZCBoaWdoZXIudHMoMTA1NilcbiAgZ2V0IGV2ZW50cygpOiBFdmVudFNvdXJjZTxBdWRpb1NvdXJjZUV2ZW50PiB7XG4gICAgLy8gRmFsc2UgYWxhcm06IGluZGV4ZXIgaXMgYSBjb25zdGFudCBvZiB0eXBlIFN5bWJvbC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW9iamVjdC1pbmplY3Rpb25cbiAgICByZXR1cm4gdGhpc1tTWU1CT0xfRVZFTlRTXTtcbiAgfVxuXG4gIC8qKiBHZXRzIHRoZSBmb3JtYXQgb2YgdGhlIGF1ZGlvIHN0cmVhbS4gKi9cbiAgLy8gU3BlZWNoIFNESyBxdWlya3M6IGBBdWRpb1N0cmVhbUZvcm1hdEltcGxgIGlzIGludGVybmFsIGltcGxlbWVudGF0aW9uIHdoaWxlIGBBdWRpb1N0cmVhbUZvcm1hdGAgaXMgcHVibGljLlxuICAvLyAgICAgICAgICAgICAgICAgICAgSXQgaXMgd2VpcmQgdG8gZXhwb3NlIGBBdWRpb1N0cmVhbUZvcm1hdEltcGxgIGluc3RlYWQgb2YgYEF1ZGlvU3RyZWFtRm9ybWF0YC5cbiAgLy8gU3BlZWNoIFNESyBxdWlya3M6IEl0IGlzIHdlaXJkIHRvIHJldHVybiBhIGBQcm9taXNlYCBpbiBhIHByb3BlcnR5LlxuICAvLyBTcGVlY2ggU0RLIHF1aXJrczogSW4gbm9ybWFsIHNwZWVjaCByZWNvZ25pdGlvbiwgZ2V0dGVyIG9mIFwiZm9ybWF0XCIgaXMgY2FsbGVkIG9ubHkgYWZ0ZXIgXCJhdHRhY2hcIi5cbiAgLy8gICAgICAgICAgICAgICAgICAgIEJ1dCBpbiBEaXJlY3QgTGluZSBTcGVlY2gsIGl0IGlzIGNhbGxlZCBiZWZvcmUgXCJhdHRhY2hcIi5cbiAgLy8gRVNMaW50OiBUaGlzIGNvZGUgd2lsbCBvbmx5IHdvcmtzIGluIGJyb3dzZXJzIG90aGVyIHRoYW4gSUUxMS4gT25seSB3b3JrcyBpbiBFUzUgaXMgb2theS5cbiAgLy8gQHRzLWlnbm9yZSBBY2Nlc3NvcnMgYXJlIG9ubHkgYXZhaWxhYmxlIHdoZW4gdGFyZ2V0aW5nIEVDTUFTY3JpcHQgNSBhbmQgaGlnaGVyLnRzKDEwNTYpXG4gIGdldCBmb3JtYXQoKTogUHJvbWlzZTxBdWRpb1N0cmVhbUZvcm1hdEltcGw+IHtcbiAgICB0aGlzLmRlYnVnKCdHZXR0aW5nIFwiZm9ybWF0XCIuJyk7XG5cbiAgICAvLyBGYWxzZSBhbGFybTogaW5kZXhlciBpcyBhIGNvbnN0YW50IG9mIHR5cGUgU3ltYm9sLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzZWN1cml0eS9kZXRlY3Qtb2JqZWN0LWluamVjdGlvblxuICAgIHJldHVybiB0aGlzW1NZTUJPTF9GT1JNQVRfREVGRVJSRURdLnByb21pc2U7XG4gIH1cblxuICAvKiogR2V0cyB0aGUgSUQgb2YgdGhpcyBhdWRpbyBzdHJlYW0uICovXG4gIGlkKCk6IHN0cmluZyB7XG4gICAgLy8gRmFsc2UgYWxhcm06IGluZGV4ZXIgaXMgYSBjb25zdGFudCBvZiB0eXBlIFN5bWJvbC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW9iamVjdC1pbmplY3Rpb25cbiAgICByZXR1cm4gdGhpc1tTWU1CT0xfT1BUSU9OU10uaWQ7XG4gIH1cblxuICAvKiogRW1pdHMgYW4gZXZlbnQuICovXG4gIC8vIFNwZWVjaCBTREsgcXVpcmtzOiBJbiBKYXZhU2NyaXB0LCBvblh4eCBtZWFucyBcImxpc3RlbiB0byBldmVudCBYWFhcIi5cbiAgLy8gICAgICAgICAgICAgICAgICAgIEluc3RlYWQsIGluIFNwZWVjaCBTREssIGl0IG1lYW5zIFwiZW1pdCBldmVudCBYWFhcIi5cbiAgcHJvdGVjdGVkIG9uRXZlbnQoZXZlbnQ6IEF1ZGlvU291cmNlRXZlbnQpOiB2b2lkIHtcbiAgICAvLyBGYWxzZSBhbGFybTogaW5kZXhlciBpcyBhIGNvbnN0YW50IG9mIHR5cGUgU3ltYm9sLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzZWN1cml0eS9kZXRlY3Qtb2JqZWN0LWluamVjdGlvblxuICAgIHRoaXNbU1lNQk9MX0VWRU5UU10ub25FdmVudChldmVudCk7XG4gICAgRXZlbnRzLmluc3RhbmNlLm9uRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgLyoqIEVtaXRzIGFuIGBBdWRpb1NvdXJjZUluaXRpYWxpemluZ0V2ZW50YC4gKi9cbiAgcHJvdGVjdGVkIGVtaXRJbml0aWFsaXppbmcoKTogdm9pZCB7XG4gICAgdGhpcy5kZWJ1ZygnRW1pdHRpbmcgXCJBdWRpb1NvdXJjZUluaXRpYWxpemluZ0V2ZW50XCIuJyk7XG4gICAgdGhpcy5vbkV2ZW50KG5ldyBBdWRpb1NvdXJjZUluaXRpYWxpemluZ0V2ZW50KHRoaXMuaWQoKSkpO1xuICB9XG5cbiAgLyoqIEVtaXRzIGFuIGBBdWRpb1NvdXJjZVJlYWR5RXZlbnRgLiAqL1xuICBwcm90ZWN0ZWQgZW1pdFJlYWR5KCk6IHZvaWQge1xuICAgIHRoaXMuZGVidWcoJ0VtaXR0aW5nIFwiQXVkaW9Tb3VyY2VSZWFkeUV2ZW50XCIuJyk7XG4gICAgdGhpcy5vbkV2ZW50KG5ldyBBdWRpb1NvdXJjZVJlYWR5RXZlbnQodGhpcy5pZCgpKSk7XG4gIH1cblxuICAvKiogRW1pdHMgYW4gYEF1ZGlvU291cmNlRXJyb3JFdmVudGAuICovXG4gIC8vIFNwZWVjaCBTREsgcXVpcmtzOiBTaW5jZSBcInR1cm5PblwiIGlzIG5ldmVyIGNhbGxlZCBhbmQgXCJ0dXJuT2ZmXCIgZG9lcyBub3Qgd29yayBpbiBEaXJlY3QgTGluZSBTcGVlY2gsIHRoZSBcInNvdXJjZSBlcnJvclwiIGV2ZW50IGlzIG5vdCBlbWl0dGVkIGF0IGFsbC5cbiAgLy8gICAgICAgICAgICAgICAgICAgIEluc3RlYWQsIHdlIG9ubHkgZW1pdCBcIm5vZGUgZXJyb3JcIiBldmVudC5cbiAgcHJvdGVjdGVkIGVtaXRFcnJvcihlcnJvcjogRXJyb3IpOiB2b2lkIHtcbiAgICB0aGlzLmRlYnVnKCdFbWl0dGluZyBcIkF1ZGlvU291cmNlRXJyb3JFdmVudFwiLicsIHsgZXJyb3IgfSk7XG5cbiAgICAvLyBTcGVlY2ggU0RLIHF1aXJrczogXCJlcnJvclwiIGlzIGEgc3RyaW5nLCBpbnN0ZWFkIG9mIG9iamVjdCBvZiB0eXBlIFwiRXJyb3JcIi5cbiAgICB0aGlzLm9uRXZlbnQobmV3IEF1ZGlvU291cmNlRXJyb3JFdmVudCh0aGlzLmlkKCksIGVycm9yLm1lc3NhZ2UpKTtcbiAgfVxuXG4gIC8qKiBFbWl0cyBhbiBgQXVkaW9TdHJlYW1Ob2RlQXR0YWNoaW5nRXZlbnRgLiAqL1xuICBwcm90ZWN0ZWQgZW1pdE5vZGVBdHRhY2hpbmcoYXVkaW9Ob2RlSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZGVidWcoYEVtaXR0aW5nIFwiQXVkaW9TdHJlYW1Ob2RlQXR0YWNoaW5nRXZlbnRcIiBmb3Igbm9kZSBcIiR7YXVkaW9Ob2RlSWR9XCIuYCk7XG4gICAgdGhpcy5vbkV2ZW50KG5ldyBBdWRpb1N0cmVhbU5vZGVBdHRhY2hpbmdFdmVudCh0aGlzLmlkKCksIGF1ZGlvTm9kZUlkKSk7XG4gIH1cblxuICAvKiogRW1pdHMgYW4gYEF1ZGlvU3RyZWFtTm9kZUF0dGFjaGVkRXZlbnRgLiAqL1xuICBwcm90ZWN0ZWQgZW1pdE5vZGVBdHRhY2hlZChhdWRpb05vZGVJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5kZWJ1ZyhgRW1pdHRpbmcgXCJBdWRpb1N0cmVhbU5vZGVBdHRhY2hlZEV2ZW50XCIgZm9yIG5vZGUgXCIke2F1ZGlvTm9kZUlkfVwiLmApO1xuICAgIHRoaXMub25FdmVudChuZXcgQXVkaW9TdHJlYW1Ob2RlQXR0YWNoZWRFdmVudCh0aGlzLmlkKCksIGF1ZGlvTm9kZUlkKSk7XG4gIH1cblxuICAvKiogRW1pdHMgYW4gYEF1ZGlvU3RyZWFtTm9kZUVycm9yRXZlbnRgLiAqL1xuICBwcm90ZWN0ZWQgZW1pdE5vZGVFcnJvcihhdWRpb05vZGVJZDogc3RyaW5nLCBlcnJvcjogRXJyb3IpOiB2b2lkIHtcbiAgICB0aGlzLmRlYnVnKGBFbWl0dGluZyBcIkF1ZGlvU3RyZWFtTm9kZUVycm9yRXZlbnRcIiBmb3Igbm9kZSBcIiR7YXVkaW9Ob2RlSWR9XCIuYCwgeyBlcnJvciB9KTtcblxuICAgIC8vIFNwZWVjaCBTREsgcXVpcmtzOiBcImVycm9yXCIgaXMgYSBzdHJpbmcsIGluc3RlYWQgb2Ygb2JqZWN0IG9mIHR5cGUgXCJFcnJvclwiLlxuICAgIHRoaXMub25FdmVudChuZXcgQXVkaW9TdHJlYW1Ob2RlRXJyb3JFdmVudCh0aGlzLmlkKCksIGF1ZGlvTm9kZUlkLCBlcnJvci5tZXNzYWdlKSk7XG4gIH1cblxuICAvKiogRW1pdHMgYW4gYEF1ZGlvU3RyZWFtTm9kZURldGFjaGVkRXZlbnRgLiAqL1xuICBwcm90ZWN0ZWQgZW1pdE5vZGVEZXRhY2hlZChhdWRpb05vZGVJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5kZWJ1ZygnRW1pdHRpbmcgXCJBdWRpb1N0cmVhbU5vZGVEZXRhY2hlZEV2ZW50XCIuJyk7XG4gICAgdGhpcy5vbkV2ZW50KG5ldyBBdWRpb1N0cmVhbU5vZGVEZXRhY2hlZEV2ZW50KHRoaXMuaWQoKSwgYXVkaW9Ob2RlSWQpKTtcbiAgfVxuXG4gIC8qKiBFbWl0cyBhbiBgQXVkaW9Tb3VyY2VPZmZFdmVudGAuICovXG4gIHByb3RlY3RlZCBlbWl0T2ZmKCk6IHZvaWQge1xuICAgIHRoaXMuZGVidWcoJ0VtaXR0aW5nIFwiQXVkaW9Tb3VyY2VPZmZFdmVudFwiLicpO1xuICAgIHRoaXMub25FdmVudChuZXcgQXVkaW9Tb3VyY2VPZmZFdmVudCh0aGlzLmlkKCkpKTtcbiAgfVxuXG4gIC8vIFNwZWVjaCBTREsgcXVpcmtzOiBBbHRob3VnaCBcImNsb3NlXCIgaXMgbWFya2VkIGFzIGFic3RyYWN0LCBpdCBpcyBuZXZlciBjYWxsZWQgaW4gb3VyIG9ic2VydmF0aW9ucy5cbiAgLy8gRVNMaW50OiBTcGVlY2ggU0RLIHJlcXVpcmVzIHRoaXMgZnVuY3Rpb24sIGJ1dCB3ZSBhcmUgbm90IGltcGxlbWVudGluZyBpdC5cbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5kZWJ1ZygnQ2FsbGJhY2sgZm9yIFwiY2xvc2VcIi4nKTtcblxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvLyBTcGVlY2ggU0RLIHF1aXJrczogQWx0aG91Z2ggXCJ0dXJuT25cIiBpcyBpbXBsZW1lbnRlZCBpbiBTcGVlY2ggU0RLIFB1c2gvUHVsbEF1ZGlvSW5wdXRTdHJlYW0sIGl0IGlzIG5ldmVyIGNhbGxlZCBpbiBvdXIgb2JzZXJ2YXRpb25zLlxuICB0dXJuT24oKTogdm9pZCB7XG4gICAgdGhpcy5kZWJ1ZygnQ2FsbGJhY2sgZm9yIFwidHVybk9uXCIuJyk7XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLy8gU3BlZWNoIFNESyBxdWlya3M6IEFsdGhvdWdoIFwiZGV0YWNoXCIgaXMgaW1wbGVtZW50ZWQgaW4gU3BlZWNoIFNESyBQdXNoL1B1bGxBdWRpb0lucHV0U3RyZWFtLCBpdCBpcyBuZXZlciBjYWxsZWQgaW4gb3VyIG9ic2VydmF0aW9ucy5cbiAgZGV0YWNoKCk6IHZvaWQge1xuICAgIHRoaXMuZGVidWcoJ0NhbGxiYWNrIGZvciBcImRldGFjaFwiLicpO1xuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKiBMb2cgdGhlIG1lc3NhZ2UgdG8gY29uc29sZSBpZiBgZGVidWdgIGlzIHNldCB0byBgdHJ1ZWAuICovXG4gIHByaXZhdGUgZGVidWcobWVzc2FnZSwgLi4uYXJncykge1xuICAgIC8vIEVTTGludDogRm9yIGRlYnVnZ2luZywgd2lsbCBvbmx5IGxvZyB3aGVuIFwiZGVidWdcIiBpcyBzZXQgdG8gXCJ0cnVlXCIuXG4gICAgLy8gRmFsc2UgYWxhcm06IGluZGV4ZXIgaXMgYSBjb25zdGFudCBvZiB0eXBlIFN5bWJvbC5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZSwgc2VjdXJpdHkvZGV0ZWN0LW9iamVjdC1pbmplY3Rpb25cbiAgICB0aGlzW1NZTUJPTF9PUFRJT05TXS5kZWJ1ZyAmJiBjb25zb2xlLmluZm8oYEN1c3RvbUF1ZGlvSW5wdXRTdHJlYW06ICR7bWVzc2FnZX1gLCAuLi5hcmdzKTtcbiAgfVxuXG4gIC8qKiBJbXBsZW1lbnRzIHRoaXMgZnVuY3Rpb24uIFdoZW4gY2FsbGVkLCBpdCBzaG91bGQgc3RhcnQgcmVjb3JkaW5nIGFuZCByZXR1cm4gYW4gYElBdWRpb1N0cmVhbU5vZGVgLiAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcGVyZm9ybUF0dGFjaChhdWRpb05vZGVJZDogc3RyaW5nKTogUHJvbWlzZTx7XG4gICAgYXVkaW9TdHJlYW1Ob2RlOiBBdWRpb1N0cmVhbU5vZGU7XG4gICAgZGV2aWNlSW5mbzogRGV2aWNlSW5mbztcbiAgICBmb3JtYXQ6IEZvcm1hdDtcbiAgfT47XG5cbiAgLyoqIEF0dGFjaGVzIHRoZSBkZXZpY2UgYnkgcmV0dXJuaW5nIGFuIGF1ZGlvIG5vZGUuICovXG4gIGF0dGFjaChhdWRpb05vZGVJZDogc3RyaW5nKTogUHJvbWlzZTxBdWRpb1N0cmVhbU5vZGU+IHtcbiAgICB0aGlzLmRlYnVnKGBDYWxsYmFjayBmb3IgXCJhdHRhY2hcIiB3aXRoIFwiJHthdWRpb05vZGVJZH1cIi5gKTtcblxuICAgIHRoaXMuZW1pdE5vZGVBdHRhY2hpbmcoYXVkaW9Ob2RlSWQpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW48QXVkaW9TdHJlYW1Ob2RlPihhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXRJbml0aWFsaXppbmcoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBhdWRpb1N0cmVhbU5vZGUsIGRldmljZUluZm8sIGZvcm1hdCB9ID0gYXdhaXQgdGhpcy5wZXJmb3JtQXR0YWNoKGF1ZGlvTm9kZUlkKTtcblxuICAgICAgICAvLyBBbHRob3VnaCBvbmx5IGdldHRlciBvZiBcImZvcm1hdFwiIGlzIGNhbGxlZCBiZWZvcmUgXCJhdHRhY2hcIiAoaW4gRGlyZWN0IExpbmUgU3BlZWNoKSxcbiAgICAgICAgLy8gd2UgYXJlIGhhbmRsaW5nIGJvdGggXCJkZXZpY2VJbmZvXCIgYW5kIFwiZm9ybWF0XCIgaW4gc2ltaWxhciB3YXkgZm9yIHVuaWZvcm1pdHkuXG5cbiAgICAgICAgLy8gRmFsc2UgYWxhcm06IGluZGV4ZXIgaXMgYSBjb25zdGFudCBvZiB0eXBlIFN5bWJvbC5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1vYmplY3QtaW5qZWN0aW9uXG4gICAgICAgIHRoaXNbU1lNQk9MX0RFVklDRV9JTkZPX0RFRkVSUkVEXS5yZXNvbHZlKGRldmljZUluZm8pO1xuXG4gICAgICAgIC8vIEZhbHNlIGFsYXJtOiBpbmRleGVyIGlzIGEgY29uc3RhbnQgb2YgdHlwZSBTeW1ib2wuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzZWN1cml0eS9kZXRlY3Qtb2JqZWN0LWluamVjdGlvblxuICAgICAgICB0aGlzW1NZTUJPTF9GT1JNQVRfREVGRVJSRURdLnJlc29sdmUoXG4gICAgICAgICAgbmV3IEF1ZGlvU3RyZWFtRm9ybWF0SW1wbChmb3JtYXQuc2FtcGxlc1BlclNlYywgZm9ybWF0LmJpdHNQZXJTYW1wbGUsIGZvcm1hdC5jaGFubmVscylcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmVtaXRSZWFkeSgpO1xuICAgICAgICB0aGlzLmVtaXROb2RlQXR0YWNoZWQoYXVkaW9Ob2RlSWQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGV0YWNoOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKGBEZXRhY2hpbmcgYXVkaW8gbm9kZSBcIiR7YXVkaW9Ob2RlSWR9XCIuYCk7XG5cbiAgICAgICAgICAgIGF3YWl0IGF1ZGlvU3RyZWFtTm9kZS5kZXRhY2goKTtcblxuICAgICAgICAgICAgLy8gU3BlZWNoIFNESyBxdWlya3M6IFNpbmNlIFwidHVybk9mZlwiIGlzIG5vdCBjYWxsZWQgaW4gRGlyZWN0IExpbmUgU3BlZWNoLCB3ZSB3aWxsIGVtaXQgZXZlbnQgXCJzb3VyY2Ugb2ZmXCIgaGVyZSBpbnN0ZWFkLlxuICAgICAgICAgICAgdGhpcy5lbWl0T2ZmKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXROb2RlRGV0YWNoZWQoYXVkaW9Ob2RlSWQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQ6ICgpID0+IGF1ZGlvU3RyZWFtTm9kZS5pZCgpLFxuICAgICAgICAgIHJlYWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoJ1JlYWRpbmcnKTtcblxuICAgICAgICAgICAgcmV0dXJuIGF1ZGlvU3RyZWFtTm9kZS5yZWFkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lbWl0Tm9kZUVycm9yKGF1ZGlvTm9kZUlkLCBlcnJvcik7XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyB0aGlzIGZ1bmN0aW9uLiBXaGVuIGNhbGxlZCwgaXQgc2hvdWxkIHN0b3AgcmVjb3JkaW5nLiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGBJQXVkaW9TdHJlYW1Ob2RlLmRldGFjaGAgZnVuY3Rpb24uXG4gICAqXG4gICAqIE5vdGU6IHdoZW4gdXNpbmcgd2l0aCBEaXJlY3QgTGluZSBTcGVlY2gsIHRoaXMgZnVuY3Rpb24gaXMgbmV2ZXIgY2FsbGVkLlxuICAgKi9cblxuICAvLyBFU0xpbnQ6IFdlIGFyZSBub3QgaW1wbGVtZW50aW5nIHRoaXMgZnVuY3Rpb24gYmVjYXVzZSBpdCBpcyBub3QgY2FsbGVkIGJ5IERpcmVjdCBMaW5lIFNwZWVjaC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgcHJvdGVjdGVkIHBlcmZvcm1UdXJuT2ZmKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEVTTGludDogXCJyZXR1cm5cIiBpcyByZXF1aXJlZCBieSBUeXBlU2NyaXB0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtcmV0dXJuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqIFR1cm4gb2ZmIHRoZSBhdWRpbyBkZXZpY2UuIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSBkZXRhY2hpbmcgZnJvbSB0aGUgZ3JhcGguICovXG4gIC8vIFNwZWVjaCBTREsgcXVpcmtzOiBJdCBpcyBjb25mdXNlZCB0byBoYXZlIGJvdGggXCJ0dXJuT2ZmXCIgYW5kIFwiZGV0YWNoXCIuIFwidHVybk9mZlwiIGlzIGNhbGxlZCBiZWZvcmUgXCJkZXRhY2hcIi5cbiAgLy8gICAgICAgICAgICAgICAgICAgIFdoeSBkb24ndCB3ZSBwdXQgYWxsIGxvZ2ljcyBhdCBcImRldGFjaFwiP1xuICAvLyBTcGVlY2ggU0RLIHF1aXJrczogRGlyZWN0IExpbmUgU3BlZWNoIG5ldmVyIGNhbGwgXCJ0dXJuT2ZmXCIuIFwiU291cmNlIG9mZlwiIGV2ZW50IG5lZWQgdG8gYmUgZW1pdHRlZCBkdXJpbmcgXCJkZXRhY2hcIiBpbnN0ZWFkLlxuICAvLyAgICAgICAgICAgICAgICAgICAgQWxzbywgY3VzdG9tIGltcGxlbWVudGF0aW9uIHNob3VsZCBiZSBkb25lIGF0IFwiZGV0YWNoXCIgaW5zdGVhZCwgc3VjaCBhcyBlbmRpbmcgYW5kIGNsb3Npbmcgb3V0cHV0IHN0cmVhbXMuXG4gIGFzeW5jIHR1cm5PZmYoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5kZWJ1ZyhgQ2FsbGJhY2sgZm9yIFwidHVybk9mZlwiLmApO1xuXG4gICAgYXdhaXQgdGhpcy5wZXJmb3JtVHVybk9mZigpO1xuICB9XG5cbiAgLyoqIEdldHMgdGhlIGRldmljZSBpbmZvcm1hdGlvbi4gKi9cbiAgLy8gRVNMaW50OiBUaGlzIGNvZGUgd2lsbCBvbmx5IHdvcmtzIGluIGJyb3dzZXJzIG90aGVyIHRoYW4gSUUxMS4gT25seSB3b3JrcyBpbiBFUzUgaXMgb2theS5cbiAgLy8gQHRzLWlnbm9yZSBBY2Nlc3NvcnMgYXJlIG9ubHkgYXZhaWxhYmxlIHdoZW4gdGFyZ2V0aW5nIEVDTUFTY3JpcHQgNSBhbmQgaGlnaGVyLnRzKDEwNTYpXG4gIGdldCBkZXZpY2VJbmZvKCk6IFByb21pc2U8SVNwZWVjaENvbmZpZ0F1ZGlvRGV2aWNlPiB7XG4gICAgdGhpcy5kZWJ1ZyhgR2V0dGluZyBcImRldmljZUluZm9cIi5gKTtcblxuICAgIC8vIEZhbHNlIGFsYXJtOiBpbmRleGVyIGlzIGEgY29uc3RhbnQgb2YgdHlwZSBTeW1ib2wuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1vYmplY3QtaW5qZWN0aW9uXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt0aGlzW1NZTUJPTF9ERVZJQ0VfSU5GT19ERUZFUlJFRF0ucHJvbWlzZSwgdGhpc1tTWU1CT0xfRk9STUFUX0RFRkVSUkVEXS5wcm9taXNlXSkudGhlbihcbiAgICAgIChbeyBjb25uZWN0aXZpdHksIG1hbnVmYWN0dXJlciwgbW9kZWwsIHR5cGUgfSwgeyBiaXRzUGVyU2FtcGxlLCBjaGFubmVscywgc2FtcGxlc1BlclNlYyB9XSkgPT4gKHtcbiAgICAgICAgYml0c3BlcnNhbXBsZTogYml0c1BlclNhbXBsZSxcbiAgICAgICAgY2hhbm5lbGNvdW50OiBjaGFubmVscyxcbiAgICAgICAgY29ubmVjdGl2aXR5OlxuICAgICAgICAgIHR5cGVvZiBjb25uZWN0aXZpdHkgPT09ICdzdHJpbmcnICYmICFpc0ZvcmJpZGRlblByb3BlcnR5TmFtZShjb25uZWN0aXZpdHkpXG4gICAgICAgICAgICA/IC8vIE1pdGlnYXRlZCB0aHJvdWdoIGRlbnlsaXN0aW5nLlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW9iamVjdC1pbmplY3Rpb25cbiAgICAgICAgICAgICAgQ29ubmVjdGl2aXR5W2Nvbm5lY3Rpdml0eV1cbiAgICAgICAgICAgIDogY29ubmVjdGl2aXR5IHx8IENvbm5lY3Rpdml0eS5Vbmtub3duLFxuICAgICAgICBtYW51ZmFjdHVyZXI6IG1hbnVmYWN0dXJlciB8fCAnJyxcbiAgICAgICAgbW9kZWw6IG1vZGVsIHx8ICcnLFxuICAgICAgICBzYW1wbGVyYXRlOiBzYW1wbGVzUGVyU2VjLFxuICAgICAgICAvLyBNaXRpZ2F0ZWQgdGhyb3VnaCBkZW55bGlzdGluZy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNlY3VyaXR5L2RldGVjdC1vYmplY3QtaW5qZWN0aW9uXG4gICAgICAgIHR5cGU6IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyAmJiAhaXNGb3JiaWRkZW5Qcm9wZXJ0eU5hbWUodHlwZSkgPyBUeXBlW3R5cGVdIDogdHlwZSB8fCBUeXBlLlVua25vd25cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDdXN0b21BdWRpb0lucHV0U3RyZWFtO1xuXG5leHBvcnQgdHlwZSB7IEF1ZGlvU3RyZWFtTm9kZSwgRGV2aWNlSW5mbywgRm9ybWF0LCBPcHRpb25zIH07XG4iXX0=