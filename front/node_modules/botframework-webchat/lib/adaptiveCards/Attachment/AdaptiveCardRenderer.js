"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _botframeworkWebchatComponent = require("botframework-webchat-component");

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _useAdaptiveCardsHostConfig = _interopRequireDefault(require("../hooks/useAdaptiveCardsHostConfig"));

var _useAdaptiveCardsPackage = _interopRequireDefault(require("../hooks/useAdaptiveCardsPackage"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/* eslint no-magic-numbers: ["error", { "ignore": [-1, 0, 2] }] */
var ErrorBox = _botframeworkWebchatComponent.Components.ErrorBox;
var useDisabled = _botframeworkWebchatComponent.hooks.useDisabled,
    useLocalizer = _botframeworkWebchatComponent.hooks.useLocalizer,
    usePerformCardAction = _botframeworkWebchatComponent.hooks.usePerformCardAction,
    useRenderMarkdownAsHTML = _botframeworkWebchatComponent.hooks.useRenderMarkdownAsHTML,
    useScrollToEnd = _botframeworkWebchatComponent.hooks.useScrollToEnd,
    useStyleSet = _botframeworkWebchatComponent.hooks.useStyleSet;
var node_env = undefined || "production";

function bunchUndos() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    return fns.forEach(function (fn) {
      return fn === null || fn === void 0 ? void 0 : fn();
    });
  };
}
/**
 * Adds a class to the `HTMLElement`. Returns `true` if the class is added, otherwise, `undefined`.
 */


function addClass(element, className) {
  var classList = element.classList;

  if (!classList.contains(className)) {
    classList.add(className);
    return true;
  }
}
/**
 * Adds a class to the `HTMLElement` and re-add on mutations.
 *
 * @returns {function} A function, when called, will restore to previous state.
 */


function addPersistentClassWithUndo(element, className) {
  if (!element) {
    return;
  }

  if (addClass(element, className)) {
    // After we add the class, keep observing the element to make sure the class is not removed.
    var observer = new MutationObserver(function () {
      return addClass(element, className);
    });
    observer.observe(element, {
      attributes: true,
      attributeFilter: ['class']
    });
    return function () {
      var classNames = new Set(element.className.split(' '));
      classNames.delete(className);
      element.className = Array.from(classNames).join(' ');
      observer.disconnect();
    };
  }
}
/**
 * Returns `true`, if the object is a plain object and not a class, otherwise, `false`.
 */


function isPlainObject(obj) {
  return Object.getPrototypeOf(obj) === Object.prototype;
}
/**
 * Sets an attribute.
 *
 * @returns {function} A function, when called, will restore to previous state.
 */


function setAttributeWithUndo(element, qualifiedName, nextValue) {
  if (!element) {
    return;
  }

  var value = element.getAttribute(qualifiedName);

  if (value !== nextValue) {
    element.setAttribute(qualifiedName, nextValue);
    return function () {
      return value ? element.setAttribute(qualifiedName, value) : element.removeAttribute(qualifiedName);
    };
  }
}
/**
 * An event handler for disabling event bubbling and propagation.
 */


var disabledHandler = function disabledHandler(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
  event.stopPropagation();
};
/**
 * Listens to event once. Returns a function, when called, will stop listening.
 */


function addEventListenerOnceWithUndo(element, name, handler) {
  if (!element) {
    return;
  }
  /* eslint-disable-next-line prefer-const */


  var detach;

  var detachingHandler = function detachingHandler(event) {
    try {
      handler(event);
    } finally {
      // IE11 does not support { once: true }, so we need to detach manually.
      detach();
    }
  };

  detach = function detach() {
    return element.removeEventListener(name, detachingHandler);
  };

  element.addEventListener(name, detachingHandler, {
    once: true
  });
  return detach;
}
/**
 * Listens to event. Returns a function, when called, will stop listening.
 */


function addEventListenerWithUndo(element, name, handler) {
  if (!element) {
    return;
  }

  element.addEventListener(name, handler);
  return function () {
    return element.removeEventListener(name, handler);
  };
}
/**
 * Disables an element with undo function.
 *
 * @returns {function} A function, when called, will restore to previous state.
 */


function disableElementWithUndo(element) {
  if (!element) {
    return;
  }

  var undoStack = [];
  var isActive = element === document.activeElement;
  var tag = element.nodeName.toLowerCase();
  /* eslint-disable-next-line default-case */

  switch (tag) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      undoStack.push(setAttributeWithUndo(element, 'aria-disabled', 'true'));

      if (isActive) {
        undoStack.push(addEventListenerOnceWithUndo(element, 'blur', function () {
          return undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'));
        }));
      } else {
        undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'));
      }

      if (tag === 'input' || tag === 'textarea') {
        undoStack.push(addEventListenerWithUndo(element, 'click', disabledHandler));
        undoStack.push(setAttributeWithUndo(element, 'readonly', 'readonly'));
      } else if (tag === 'select') {
        undoStack.push.apply(undoStack, (0, _toConsumableArray2.default)([].map.call(element.querySelectorAll('option'), function (option) {
          return setAttributeWithUndo(option, 'disabled', 'disabled');
        })));
      }

      break;
  }

  return bunchUndos.apply(void 0, undoStack);
}
/**
 * Disables all inputtable descendants.
 *
 * @param {HTMLElement | undefined} element Container element to start looking for inputtable descendants.
 * @param {boolean} observeSubtree `true` to applies to all future inputtable descendants, otherwise, `false`.
 *
 * @returns {function} A function, when called, will restore to previous state.
 */


function disableInputElementsWithUndo(element) {
  var observeSubtree = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (!element) {
    return;
  }

  var undoStack = [].map.call(element.querySelectorAll('button, input, select, textarea'), function (element) {
    return disableElementWithUndo(element);
  });
  var tag = element.nodeName.toLowerCase(); // Only set tabindex="-1" on focusable element. Otherwise, we will make <div> focusable by mouse.

  (tag === 'a' || tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea') && undoStack.push(setAttributeWithUndo(element, 'tabindex', '-1'));

  if (observeSubtree) {
    var observer = new MutationObserver(function (mutations) {
      return mutations.forEach(function (_ref) {
        var addedNodes = _ref.addedNodes;
        return undoStack.push.apply(undoStack, (0, _toConsumableArray2.default)([].map.call(addedNodes, function (addedNode) {
          return disableInputElementsWithUndo(addedNode, false);
        })));
      });
    });
    observer.observe(element, {
      childList: true,
      subtree: true
    });
    undoStack.push(function () {
      return observer.disconnect();
    });
  }

  return bunchUndos.apply(void 0, (0, _toConsumableArray2.default)(undoStack));
}
/**
 * Gets the value of an attribute from an element.
 *
 * @returns {false | string} The value of the attribute. `false` if the attribute was not set.
 */


function getAttribute(element, qualifiedName) {
  return !!element && element.hasAttribute(qualifiedName) && (element.getAttribute(qualifiedName) || '');
}
/**
 * Sets or removes an attribute from an element.
 *
 * @param {HTMLElement} element - The element to set or remove attribute from.
 * @param {string} qualifiedName - The name of the attribute.
 * @param {false | string} value - The value of the attribute. When passing `false`, remove the attribute.
 */


function setOrRemoveAttribute(element, qualifiedName, value) {
  if (value === false) {
    element === null || element === void 0 ? void 0 : element.removeAttribute(qualifiedName);
  } else {
    element === null || element === void 0 ? void 0 : element.setAttribute(qualifiedName, value);
  }
}
/**
 * Sets or removes an attribute from an element with an undo function.
 *
 * @param {HTMLElement} element - The element to set or remove attribute from.
 * @param {string} qualifiedName - The name of the attribute.
 * @param {false | string} value - The value of the attribute. When passing `false`, remove the attribute.
 *
 * @returns {() => void} The undo function, when called, will undo all manipulations by restoring values recorded at the time of the function call.
 */


function setOrRemoveAttributeWithUndo(element, qualifiedName, value) {
  if (!element) {
    return;
  }

  var prevValue = getAttribute(element, qualifiedName);
  setOrRemoveAttribute(element, qualifiedName, value);
  return function () {
    return setOrRemoveAttribute(element, qualifiedName, prevValue);
  };
}
/**
 * Finds the first ancestor that fulfill the predicate.
 *
 * @param {HTMLElement} element - The starting element. This element will not be checked against the predicate.
 * @param {(ancestor: HTMLElement) => boolean} predicate - The predicate to fulfill.
 *
 * @returns {HTMLElement | undefined} The first ancestor that fulfill the predicate, otherwise, `undefined`.
 */


function findAncestor(element, predicate) {
  var current = element;

  while (current = current.parentElement) {
    if (predicate.call(element, current)) {
      return current;
    }
  }
}
/**
 * Indicates the action selected by performing a series of manipulations, with undo:
 *
 * - Accessibility: set `aria-pressed` to `true`
 * - Applies `styleOptions.actionPerformedClassName`
 *
 * @param {HTMLElement[]} selectedActionElements - An array of elements that are representing the action and is selected.
 * @param {string?} actionPerformedClassName - The name of the class to apply to all elements.
 *
 * @returns {() => void} The undo function, when called, will undo all manipulations by restoring values recorded at the time of the function call.
 */


function indicateActionSelectionWithUndo(selectedActionElements, actionPerformedClassName) {
  if (!(selectedActionElements !== null && selectedActionElements !== void 0 && selectedActionElements.length)) {
    return;
  } // Verify all input elements are "ac-pushButton", could belongs to ActionSet or "card actions".


  if (selectedActionElements.some(function (actionElement) {
    return !actionElement.classList.contains('ac-pushButton');
  })) {
    console.warn('botframework-webchat: Cannot mark selected action in the card, some elements are not an "ac-pushButton".');
    return;
  } // A distinct set of action set containers which has selections, excluding containers without actions.
  // Multiple submission in an Adaptive Card is still a vague area and TBD.
  // We might want to disable the whole card, just buttons in same container, or do nothing (today).


  var actionSetElements = new Set();
  selectedActionElements.forEach(function (selectedActionElement) {
    var actionSetElement = findAncestor(selectedActionElement, function (ancestor) {
      return ancestor.getAttribute('role') === 'menubar';
    });
    actionSetElement && actionSetElements.add(actionSetElement);
  });
  var undoStack = [];
  actionSetElements.forEach(function (actionSetElement) {
    // Remove "role" from every "ac-actionSet" container.
    undoStack.push(setOrRemoveAttributeWithUndo(actionSetElement, 'role', false)); // Modify "role" of every actions in the container.

    Array.from(actionSetElement.querySelectorAll('.ac-pushButton')).forEach(function (actionElement) {
      if (selectedActionElements.includes(actionElement)) {
        // Add "aria-pressed" and set "role" attribute to "button" (which is required by "aria-pressed").
        undoStack.push(setOrRemoveAttributeWithUndo(actionElement, 'aria-pressed', 'true'));
        undoStack.push(setOrRemoveAttributeWithUndo(actionElement, 'role', 'button')); // Highlight actions by applying `styleOptions.actionPerformedClassName`.

        actionPerformedClassName && undoStack.push(addPersistentClassWithUndo(actionElement, actionPerformedClassName));
      } else {
        // We removed "role=menubar" from the container, we must remove "role=menuitem" from unselected actions.
        undoStack.push(setOrRemoveAttributeWithUndo(actionElement, 'role', false));
      }
    });
  });
  return bunchUndos.apply(void 0, undoStack);
}
/**
 * Fixes accessibility issues from Adaptive Card, with undo.
 *
 * @returns {() => void} The undo function, when called, will undo all manipulations by restoring values recorded at the time of the function call.
 */


function fixAccessibilityIssuesWithUndo(element) {
  if (!element) {
    return;
  } // These hacks should be done in Adaptive Cards library instead.
  // Related to #3949: All action buttons inside role="menubar" should be role="menuitem".


  var undoStack = Array.from(element.querySelectorAll('.ac-actionSet[role="menubar"] [role="button"]')).map(function (actionButton) {
    return setAttributeWithUndo(actionButton, 'role', 'menuitem');
  });
  return function () {
    return undoStack.forEach(function (undo) {
      return undo === null || undo === void 0 ? void 0 : undo();
    });
  };
}

function getFocusableElements(element) {
  return [].filter.call(element.querySelectorAll(['a', 'body', 'button', 'frame', 'iframe', 'img', 'input', 'isindex', 'object', 'select', 'textarea', '[tabindex]'].join(', ')), function (element) {
    var tabIndex = (0, _botframeworkWebchatComponent.getTabIndex)(element);
    return typeof tabIndex === 'number' && tabIndex >= 0;
  });
}

function restoreActiveElementIndex(element, activeElementIndex) {
  var _getFocusableElements;

  (_getFocusableElements = getFocusableElements(element)[+activeElementIndex]) === null || _getFocusableElements === void 0 ? void 0 : _getFocusableElements.focus();
}

function saveActiveElementIndex(element) {
  return getFocusableElements(element).indexOf(document.activeElement);
}

function restoreInputValues(element, inputValues) {
  var inputs = element.querySelectorAll('input, select, textarea');
  [].forEach.call(inputs, function (input, index) {
    var value = inputValues[+index];

    if (typeof value !== 'undefined') {
      var tagName = input.tagName,
          type = input.type;

      if (tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {
        if (typeof value === 'boolean') {
          input.checked = value;
        }
      } else if (typeof value === 'string') {
        input.value = value;
      }
    }
  });
}

function saveInputValues(element) {
  var inputs = element.querySelectorAll('input, select, textarea');
  return [].map.call(inputs, function (input) {
    var type = input.type;

    if (input.tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {
      return input.checked;
    }

    return input.value;
  });
}

var AdaptiveCardRenderer = function AdaptiveCardRenderer(_ref2) {
  var actionPerformedClassName = _ref2.actionPerformedClassName,
      adaptiveCard = _ref2.adaptiveCard,
      disabledFromProps = _ref2.disabled,
      tapAction = _ref2.tapAction;

  var _useStyleSet = useStyleSet(),
      _useStyleSet2 = (0, _slicedToArray2.default)(_useStyleSet, 1),
      adaptiveCardRendererStyleSet = _useStyleSet2[0].adaptiveCardRenderer;

  var _useAdaptiveCardsPack = (0, _useAdaptiveCardsPackage.default)(),
      _useAdaptiveCardsPack2 = (0, _slicedToArray2.default)(_useAdaptiveCardsPack, 1),
      _useAdaptiveCardsPack3 = _useAdaptiveCardsPack2[0],
      GlobalSettings = _useAdaptiveCardsPack3.GlobalSettings,
      HostConfig = _useAdaptiveCardsPack3.HostConfig;

  var _useState = (0, _react.useState)([]),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      actionsPerformed = _useState2[0],
      setActionsPerformed = _useState2[1];

  var _useAdaptiveCardsHost = (0, _useAdaptiveCardsHostConfig.default)(),
      _useAdaptiveCardsHost2 = (0, _slicedToArray2.default)(_useAdaptiveCardsHost, 1),
      adaptiveCardsHostConfig = _useAdaptiveCardsHost2[0];

  var _useDisabled = useDisabled(),
      _useDisabled2 = (0, _slicedToArray2.default)(_useDisabled, 1),
      disabledFromComposer = _useDisabled2[0];

  var _useState3 = (0, _react.useState)([]),
      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),
      errors = _useState4[0],
      setErrors = _useState4[1];

  var _useState5 = (0, _react.useState)(0),
      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),
      lastRender = _useState6[0],
      setLastRender = _useState6[1];

  var activeElementIndexRef = (0, _react.useRef)(-1);
  var adaptiveCardElementRef = (0, _react.useRef)();
  var contentRef = (0, _react.useRef)();
  var inputValuesRef = (0, _react.useRef)([]);
  var localize = useLocalizer();
  var performCardAction = usePerformCardAction();
  var renderMarkdownAsHTML = useRenderMarkdownAsHTML();
  var scrollToEnd = useScrollToEnd();
  var disabled = disabledFromComposer || disabledFromProps; // TODO: [P2] #3199 We should consider using `adaptiveCard.selectAction` instead.
  // The null check for "tapAction" is in "handleClickAndKeyPressForTapAction".

  var handleClickAndKeyPress = (0, _react.useCallback)(function (event) {
    var _ref3 = event,
        key = _ref3.key,
        type = _ref3.type;
    var target = event.target; // Some items, e.g. tappable text, cannot be disabled thru DOM attributes

    var current = contentRef.current;
    var adaptiveCardRoot = current.querySelector('.ac-adaptiveCard[tabindex="0"]');

    if (!adaptiveCardRoot) {
      return console.warn('botframework-webchat: No Adaptive Card root container can be found; the card is probably on an unsupported Adaptive Card version.');
    } // For "keypress" event, we only listen to ENTER and SPACEBAR key.


    if (type === 'keypress') {
      if (key !== 'Enter' && key !== ' ') {
        return;
      }

      event.preventDefault();
    } // We will call performCardAction if either:
    // 1. We are on the target, or
    // 2. The event-dispatching element is not interactive


    if (target !== adaptiveCardRoot) {
      var tabIndex = (0, _botframeworkWebchatComponent.getTabIndex)(target); // If the user is clicking on something that is already clickable, do not allow them to click the card.
      // E.g. a hero card can be tappable, and image and buttons inside the hero card can also be tappable.

      if (typeof tabIndex === 'number' && tabIndex >= 0) {
        return;
      }
    }

    performCardAction(tapAction);
    scrollToEnd();
  }, [contentRef, performCardAction, scrollToEnd, tapAction]); // Only listen to event if it is not disabled and have "tapAction" prop.

  var handleClickAndKeyPressForTapAction = !disabled && tapAction ? handleClickAndKeyPress : undefined;
  var addActionsPerformed = (0, _react.useCallback)(function (action) {
    return !~actionsPerformed.indexOf(action) && setActionsPerformed([].concat((0, _toConsumableArray2.default)(actionsPerformed), [action]));
  }, [actionsPerformed, setActionsPerformed]);
  var handleExecuteAction = (0, _react.useCallback)(function (action) {
    // Some items, e.g. tappable image, cannot be disabled thru DOM attributes
    if (disabled) {
      return;
    }

    addActionsPerformed(action);
    var actionTypeName = action.getJsonTypeName();
    var image = action.iconUrl,
        title = action.title; // We cannot use "instanceof" check here, because web devs may bring their own version of Adaptive Cards package.
    // We need to check using "getJsonTypeName()" instead.

    if (actionTypeName === 'Action.OpenUrl') {
      var _ref4 = action,
          value = _ref4.url;
      performCardAction({
        image: image,
        title: title,
        type: 'openUrl',
        value: value
      });
    } else if (actionTypeName === 'Action.Submit') {
      var _ref5 = action,
          data = _ref5.data;

      if (typeof data !== 'undefined') {
        if (typeof data === 'string') {
          performCardAction({
            image: image,
            title: title,
            type: 'imBack',
            value: data
          });
        } else if (data.__isBotFrameworkCardAction) {
          performCardAction(data.cardAction);
        } else {
          performCardAction({
            image: image,
            title: title,
            type: 'postBack',
            value: data
          });
        }
      }

      scrollToEnd();
    } else {
      console.error("Web Chat: received unknown action from Adaptive Cards");
      console.error(action);
    }
  }, [addActionsPerformed, disabled, performCardAction, scrollToEnd]);
  (0, _react.useLayoutEffect)(function () {
    var current = contentRef.current;

    if (!current || !adaptiveCard) {
      activeElementIndexRef.current = -1;
      inputValuesRef.current = [];
    } // Currently, the only way to set the Markdown engine is to set it thru static member of AdaptiveCard class
    // TODO: [P3] Checks if we could make the "renderMarkdownAsHTML" per card
    //       This could be limitations from Adaptive Cards package (not supported as of 1.2.5)
    //       Because there could be timing difference between .parse and .render, we could be using wrong Markdown engine
    // "onProcessMarkdown" is a static function but we are trying to scope it to the current object instead.
    // eslint-disable-next-line dot-notation


    adaptiveCard.constructor['onProcessMarkdown'] = function (text, result) {
      if (renderMarkdownAsHTML) {
        result.outputHtml = renderMarkdownAsHTML(text);
        result.didProcess = true;
      }
    };

    if (adaptiveCardsHostConfig) {
      adaptiveCard.hostConfig = isPlainObject(adaptiveCardsHostConfig) ? new HostConfig(adaptiveCardsHostConfig) : adaptiveCardsHostConfig;
    } // For accessibility issue #1340, `tabindex="0"` must not be set for the root container if it is not interactive.


    GlobalSettings.setTabIndexAtCardRoot = !!tapAction;

    var _adaptiveCard$validat = adaptiveCard.validateProperties(),
        validationEvents = _adaptiveCard$validat.validationEvents;

    if (validationEvents.length) {
      return setErrors(validationEvents.reduce(function (items, _ref6) {
        var message = _ref6.message;
        return [].concat((0, _toConsumableArray2.default)(items), [new Error(message)]);
      }, []));
    }

    var element;

    try {
      element = adaptiveCard.render();
    } catch (error) {
      return setErrors([error]);
    }

    if (!element) {
      return setErrors([new Error('Adaptive Card rendered as empty element')]);
    } // Clear errors on next render


    setErrors([]);
    restoreInputValues(element, inputValuesRef.current);
    current.appendChild(element);
    adaptiveCardElementRef.current = element; // Focus can only be restored after the DOM is attached.

    restoreActiveElementIndex(element, activeElementIndexRef.current);
    setLastRender(Date.now());
    return function () {
      activeElementIndexRef.current = saveActiveElementIndex(element);
      inputValuesRef.current = saveInputValues(element);
      current.removeChild(adaptiveCardElementRef.current);
      adaptiveCardElementRef.current = undefined;
    };
  }, [adaptiveCard, adaptiveCardsHostConfig, contentRef, GlobalSettings, HostConfig, renderMarkdownAsHTML, setErrors, tapAction]);
  (0, _react.useEffect)(function () {
    // Set onExecuteAction without causing unnecessary re-render.
    adaptiveCard.onExecuteAction = disabled ? undefined : handleExecuteAction;
  }, [adaptiveCard, disabled, handleExecuteAction]);
  (0, _react.useEffect)(function () {
    return fixAccessibilityIssuesWithUndo(adaptiveCardElementRef.current);
  }, [adaptiveCardElementRef, lastRender]);
  (0, _react.useEffect)(function () {
    // If the Adaptive Card get re-rendered, re-disable elements as needed.
    if (disabled) {
      return disableInputElementsWithUndo(adaptiveCardElementRef.current);
    }
  }, [adaptiveCardElementRef, disabled, lastRender]);
  (0, _react.useEffect)(function () {
    // If the Adaptive Card changed, reset all actions performed.
    setActionsPerformed([]);
  }, [adaptiveCard]);
  (0, _react.useEffect)(function () {
    return indicateActionSelectionWithUndo( // Actions that do not have "renderedElement" means it is the Adaptive Card itself, such as "selectAction" (AC) or "tapAction" (rich cards).
    // We do not need to mark the whole card as performed.
    actionsPerformed.map(function (_ref7) {
      var renderedElement = _ref7.renderedElement;
      return renderedElement;
    }).filter(function (renderedElement) {
      return renderedElement;
    }), actionPerformedClassName);
  }, [actionsPerformed, actionPerformedClassName, lastRender]);
  return errors.length ? node_env === 'development' && /*#__PURE__*/_react.default.createElement(ErrorBox, {
    error: errors[0],
    type: localize('ADAPTIVE_CARD_ERROR_BOX_TITLE_RENDER')
  }) : /*#__PURE__*/_react.default.createElement("div", {
    className: (0, _classnames.default)(adaptiveCardRendererStyleSet + '', 'webchat__adaptive-card-renderer'),
    onClick: handleClickAndKeyPressForTapAction,
    onKeyPress: handleClickAndKeyPressForTapAction,
    ref: contentRef
  });
};

AdaptiveCardRenderer.defaultProps = {
  actionPerformedClassName: '',
  disabled: undefined,
  tapAction: undefined
};
AdaptiveCardRenderer.propTypes = {
  actionPerformedClassName: _propTypes.default.string,
  adaptiveCard: _propTypes.default.any.isRequired,
  disabled: _propTypes.default.bool,
  // TypeScript class is not mappable to PropTypes.func
  // @ts-ignore
  tapAction: _propTypes.default.shape({
    image: _propTypes.default.string,
    title: _propTypes.default.string,
    type: _propTypes.default.string.isRequired,
    value: _propTypes.default.string
  })
};
var _default = AdaptiveCardRenderer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hZGFwdGl2ZUNhcmRzL0F0dGFjaG1lbnQvQWRhcHRpdmVDYXJkUmVuZGVyZXIudHN4Il0sIm5hbWVzIjpbIkVycm9yQm94IiwiQ29tcG9uZW50cyIsInVzZURpc2FibGVkIiwiaG9va3MiLCJ1c2VMb2NhbGl6ZXIiLCJ1c2VQZXJmb3JtQ2FyZEFjdGlvbiIsInVzZVJlbmRlck1hcmtkb3duQXNIVE1MIiwidXNlU2Nyb2xsVG9FbmQiLCJ1c2VTdHlsZVNldCIsIm5vZGVfZW52IiwiYnVuY2hVbmRvcyIsImZucyIsImZvckVhY2giLCJmbiIsImFkZENsYXNzIiwiZWxlbWVudCIsImNsYXNzTmFtZSIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwiYWRkIiwiYWRkUGVyc2lzdGVudENsYXNzV2l0aFVuZG8iLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZUZpbHRlciIsImNsYXNzTmFtZXMiLCJTZXQiLCJzcGxpdCIsImRlbGV0ZSIsIkFycmF5IiwiZnJvbSIsImpvaW4iLCJkaXNjb25uZWN0IiwiaXNQbGFpbk9iamVjdCIsIm9iaiIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwic2V0QXR0cmlidXRlV2l0aFVuZG8iLCJxdWFsaWZpZWROYW1lIiwibmV4dFZhbHVlIiwidmFsdWUiLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJkaXNhYmxlZEhhbmRsZXIiLCJldmVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwic3RvcFByb3BhZ2F0aW9uIiwiYWRkRXZlbnRMaXN0ZW5lck9uY2VXaXRoVW5kbyIsIm5hbWUiLCJoYW5kbGVyIiwiZGV0YWNoIiwiZGV0YWNoaW5nSGFuZGxlciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsImFkZEV2ZW50TGlzdGVuZXJXaXRoVW5kbyIsImRpc2FibGVFbGVtZW50V2l0aFVuZG8iLCJ1bmRvU3RhY2siLCJpc0FjdGl2ZSIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsInRhZyIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJwdXNoIiwibWFwIiwiY2FsbCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvcHRpb24iLCJkaXNhYmxlSW5wdXRFbGVtZW50c1dpdGhVbmRvIiwib2JzZXJ2ZVN1YnRyZWUiLCJtdXRhdGlvbnMiLCJhZGRlZE5vZGVzIiwiYWRkZWROb2RlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImhhc0F0dHJpYnV0ZSIsInNldE9yUmVtb3ZlQXR0cmlidXRlIiwic2V0T3JSZW1vdmVBdHRyaWJ1dGVXaXRoVW5kbyIsInByZXZWYWx1ZSIsImZpbmRBbmNlc3RvciIsInByZWRpY2F0ZSIsImN1cnJlbnQiLCJwYXJlbnRFbGVtZW50IiwiaW5kaWNhdGVBY3Rpb25TZWxlY3Rpb25XaXRoVW5kbyIsInNlbGVjdGVkQWN0aW9uRWxlbWVudHMiLCJhY3Rpb25QZXJmb3JtZWRDbGFzc05hbWUiLCJsZW5ndGgiLCJzb21lIiwiYWN0aW9uRWxlbWVudCIsImNvbnNvbGUiLCJ3YXJuIiwiYWN0aW9uU2V0RWxlbWVudHMiLCJzZWxlY3RlZEFjdGlvbkVsZW1lbnQiLCJhY3Rpb25TZXRFbGVtZW50IiwiYW5jZXN0b3IiLCJpbmNsdWRlcyIsImZpeEFjY2Vzc2liaWxpdHlJc3N1ZXNXaXRoVW5kbyIsImFjdGlvbkJ1dHRvbiIsInVuZG8iLCJnZXRGb2N1c2FibGVFbGVtZW50cyIsImZpbHRlciIsInRhYkluZGV4IiwicmVzdG9yZUFjdGl2ZUVsZW1lbnRJbmRleCIsImFjdGl2ZUVsZW1lbnRJbmRleCIsImZvY3VzIiwic2F2ZUFjdGl2ZUVsZW1lbnRJbmRleCIsImluZGV4T2YiLCJyZXN0b3JlSW5wdXRWYWx1ZXMiLCJpbnB1dFZhbHVlcyIsImlucHV0cyIsImlucHV0IiwiaW5kZXgiLCJ0YWdOYW1lIiwidHlwZSIsImNoZWNrZWQiLCJzYXZlSW5wdXRWYWx1ZXMiLCJBZGFwdGl2ZUNhcmRSZW5kZXJlciIsImFkYXB0aXZlQ2FyZCIsImRpc2FibGVkRnJvbVByb3BzIiwiZGlzYWJsZWQiLCJ0YXBBY3Rpb24iLCJhZGFwdGl2ZUNhcmRSZW5kZXJlclN0eWxlU2V0IiwiYWRhcHRpdmVDYXJkUmVuZGVyZXIiLCJHbG9iYWxTZXR0aW5ncyIsIkhvc3RDb25maWciLCJhY3Rpb25zUGVyZm9ybWVkIiwic2V0QWN0aW9uc1BlcmZvcm1lZCIsImFkYXB0aXZlQ2FyZHNIb3N0Q29uZmlnIiwiZGlzYWJsZWRGcm9tQ29tcG9zZXIiLCJlcnJvcnMiLCJzZXRFcnJvcnMiLCJsYXN0UmVuZGVyIiwic2V0TGFzdFJlbmRlciIsImFjdGl2ZUVsZW1lbnRJbmRleFJlZiIsImFkYXB0aXZlQ2FyZEVsZW1lbnRSZWYiLCJjb250ZW50UmVmIiwiaW5wdXRWYWx1ZXNSZWYiLCJsb2NhbGl6ZSIsInBlcmZvcm1DYXJkQWN0aW9uIiwicmVuZGVyTWFya2Rvd25Bc0hUTUwiLCJzY3JvbGxUb0VuZCIsImhhbmRsZUNsaWNrQW5kS2V5UHJlc3MiLCJrZXkiLCJ0YXJnZXQiLCJhZGFwdGl2ZUNhcmRSb290IiwicXVlcnlTZWxlY3RvciIsImhhbmRsZUNsaWNrQW5kS2V5UHJlc3NGb3JUYXBBY3Rpb24iLCJ1bmRlZmluZWQiLCJhZGRBY3Rpb25zUGVyZm9ybWVkIiwiYWN0aW9uIiwiaGFuZGxlRXhlY3V0ZUFjdGlvbiIsImFjdGlvblR5cGVOYW1lIiwiZ2V0SnNvblR5cGVOYW1lIiwiaW1hZ2UiLCJpY29uVXJsIiwidGl0bGUiLCJ1cmwiLCJkYXRhIiwiX19pc0JvdEZyYW1ld29ya0NhcmRBY3Rpb24iLCJjYXJkQWN0aW9uIiwiZXJyb3IiLCJjb25zdHJ1Y3RvciIsInRleHQiLCJyZXN1bHQiLCJvdXRwdXRIdG1sIiwiZGlkUHJvY2VzcyIsImhvc3RDb25maWciLCJzZXRUYWJJbmRleEF0Q2FyZFJvb3QiLCJ2YWxpZGF0ZVByb3BlcnRpZXMiLCJ2YWxpZGF0aW9uRXZlbnRzIiwicmVkdWNlIiwiaXRlbXMiLCJtZXNzYWdlIiwiRXJyb3IiLCJyZW5kZXIiLCJhcHBlbmRDaGlsZCIsIkRhdGUiLCJub3ciLCJyZW1vdmVDaGlsZCIsIm9uRXhlY3V0ZUFjdGlvbiIsInJlbmRlcmVkRWxlbWVudCIsImRlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsInN0cmluZyIsImFueSIsImlzUmVxdWlyZWQiLCJib29sIiwic2hhcGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQVNBOztBQUVBOztBQUNBOztBQUNBOztBQVlBOztBQUNBOzs7Ozs7QUExQkE7QUE0QkEsSUFBUUEsUUFBUixHQUFxQkMsd0NBQXJCLENBQVFELFFBQVI7QUFDQSxJQUFRRSxXQUFSLEdBQWtIQyxtQ0FBbEgsQ0FBUUQsV0FBUjtBQUFBLElBQXFCRSxZQUFyQixHQUFrSEQsbUNBQWxILENBQXFCQyxZQUFyQjtBQUFBLElBQW1DQyxvQkFBbkMsR0FBa0hGLG1DQUFsSCxDQUFtQ0Usb0JBQW5DO0FBQUEsSUFBeURDLHVCQUF6RCxHQUFrSEgsbUNBQWxILENBQXlERyx1QkFBekQ7QUFBQSxJQUFrRkMsY0FBbEYsR0FBa0hKLG1DQUFsSCxDQUFrRkksY0FBbEY7QUFBQSxJQUFrR0MsV0FBbEcsR0FBa0hMLG1DQUFsSCxDQUFrR0ssV0FBbEc7QUFFQSxJQUFNQyxRQUFRLEdBQUcseUJBQWpCOztBQUlBLFNBQVNDLFVBQVQsR0FBMEQ7QUFBQSxvQ0FBbkNDLEdBQW1DO0FBQW5DQSxJQUFBQSxHQUFtQztBQUFBOztBQUN4RCxTQUFPO0FBQUEsV0FBTUEsR0FBRyxDQUFDQyxPQUFKLENBQVksVUFBQUMsRUFBRTtBQUFBLGFBQUlBLEVBQUosYUFBSUEsRUFBSix1QkFBSUEsRUFBRSxFQUFOO0FBQUEsS0FBZCxDQUFOO0FBQUEsR0FBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBOzs7QUFDQSxTQUFTQyxRQUFULENBQWtCQyxPQUFsQixFQUF3Q0MsU0FBeEMsRUFBNkU7QUFD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WUFBWSxFQUFFa0UsbUJBQVVFLEdBQVYsQ0FBY0MsVUFGRztBQUcvQm5FLEVBQUFBLFFBQVEsRUFBRWdFLG1CQUFVSSxJQUhXO0FBSy9CO0FBQ0E7QUFDQW5FLEVBQUFBLFNBQVMsRUFBRStELG1CQUFVSyxLQUFWLENBQWdCO0FBQ3pCbkMsSUFBQUEsS0FBSyxFQUFFOEIsbUJBQVVDLE1BRFE7QUFFekI3QixJQUFBQSxLQUFLLEVBQUU0QixtQkFBVUMsTUFGUTtBQUd6QnZFLElBQUFBLElBQUksRUFBRXNFLG1CQUFVQyxNQUFWLENBQWlCRSxVQUhFO0FBSXpCckosSUFBQUEsS0FBSyxFQUFFa0osbUJBQVVDO0FBSlEsR0FBaEI7QUFQb0IsQ0FBakM7ZUFlZXBFLG9CIiwic291cmNlUm9vdCI6ImJ1bmRsZTovLy8iLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogW1wiZXJyb3JcIiwgeyBcImlnbm9yZVwiOiBbLTEsIDAsIDJdIH1dICovXG5cbmltcG9ydCB7XG4gIEFjdGlvbiBhcyBBZGFwdGl2ZUNhcmRBY3Rpb24sXG4gIEFkYXB0aXZlQ2FyZCxcbiAgSU1hcmtkb3duUHJvY2Vzc2luZ1Jlc3VsdCxcbiAgT3BlblVybEFjdGlvbixcbiAgU3VibWl0QWN0aW9uXG59IGZyb20gJ2FkYXB0aXZlY2FyZHMnO1xuaW1wb3J0IHsgQ29tcG9uZW50cywgZ2V0VGFiSW5kZXgsIGhvb2tzIH0gZnJvbSAnYm90ZnJhbWV3b3JrLXdlYmNoYXQtY29tcG9uZW50JztcbmltcG9ydCB7IERpcmVjdExpbmVDYXJkQWN0aW9uIH0gZnJvbSAnYm90ZnJhbWV3b3JrLXdlYmNoYXQtY29yZSc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHtcbiAgS2V5Ym9hcmRFdmVudEhhbmRsZXIsXG4gIE1vdXNlRXZlbnRIYW5kbGVyLFxuICB1c2VDYWxsYmFjayxcbiAgdXNlRWZmZWN0LFxuICB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZVJlZixcbiAgdXNlU3RhdGUsXG4gIFZGQ1xufSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEJvdEZyYW1ld29ya0NhcmRBY3Rpb24gfSBmcm9tICcuL0FkYXB0aXZlQ2FyZEJ1aWxkZXInO1xuaW1wb3J0IHVzZUFkYXB0aXZlQ2FyZHNIb3N0Q29uZmlnIGZyb20gJy4uL2hvb2tzL3VzZUFkYXB0aXZlQ2FyZHNIb3N0Q29uZmlnJztcbmltcG9ydCB1c2VBZGFwdGl2ZUNhcmRzUGFja2FnZSBmcm9tICcuLi9ob29rcy91c2VBZGFwdGl2ZUNhcmRzUGFja2FnZSc7XG5cbmNvbnN0IHsgRXJyb3JCb3ggfSA9IENvbXBvbmVudHM7XG5jb25zdCB7IHVzZURpc2FibGVkLCB1c2VMb2NhbGl6ZXIsIHVzZVBlcmZvcm1DYXJkQWN0aW9uLCB1c2VSZW5kZXJNYXJrZG93bkFzSFRNTCwgdXNlU2Nyb2xsVG9FbmQsIHVzZVN0eWxlU2V0IH0gPSBob29rcztcblxuY29uc3Qgbm9kZV9lbnYgPSBwcm9jZXNzLmVudi5ub2RlX2VudiB8fCBwcm9jZXNzLmVudi5OT0RFX0VOVjtcblxudHlwZSBVbmRvRnVuY3Rpb24gPSAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGJ1bmNoVW5kb3MoLi4uZm5zOiBVbmRvRnVuY3Rpb25bXSk6IFVuZG9GdW5jdGlvbiB7XG4gIHJldHVybiAoKSA9PiBmbnMuZm9yRWFjaChmbiA9PiBmbj8uKCkpO1xufVxuXG4vKipcbiAqIEFkZHMgYSBjbGFzcyB0byB0aGUgYEhUTUxFbGVtZW50YC4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNsYXNzIGlzIGFkZGVkLCBvdGhlcndpc2UsIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgY2xhc3NOYW1lOiBzdHJpbmcpOiB0cnVlIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgeyBjbGFzc0xpc3QgfSA9IGVsZW1lbnQ7XG5cbiAgaWYgKCFjbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuICAgIGNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBhIGNsYXNzIHRvIHRoZSBgSFRNTEVsZW1lbnRgIGFuZCByZS1hZGQgb24gbXV0YXRpb25zLlxuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gQSBmdW5jdGlvbiwgd2hlbiBjYWxsZWQsIHdpbGwgcmVzdG9yZSB0byBwcmV2aW91cyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gYWRkUGVyc2lzdGVudENsYXNzV2l0aFVuZG8oZWxlbWVudDogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQsIGNsYXNzTmFtZTogc3RyaW5nKTogVW5kb0Z1bmN0aW9uIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAvLyBBZnRlciB3ZSBhZGQgdGhlIGNsYXNzLCBrZWVwIG9ic2VydmluZyB0aGUgZWxlbWVudCB0byBtYWtlIHN1cmUgdGhlIGNsYXNzIGlzIG5vdCByZW1vdmVkLlxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgYXR0cmlidXRlRmlsdGVyOiBbJ2NsYXNzJ10gfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IG5ldyBTZXQoZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoJyAnKSk7XG5cbiAgICAgIGNsYXNzTmFtZXMuZGVsZXRlKGNsYXNzTmFtZSk7XG5cbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gQXJyYXkuZnJvbShjbGFzc05hbWVzKS5qb2luKCcgJyk7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYHRydWVgLCBpZiB0aGUgb2JqZWN0IGlzIGEgcGxhaW4gb2JqZWN0IGFuZCBub3QgYSBjbGFzcywgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogU2V0cyBhbiBhdHRyaWJ1dGUuXG4gKlxuICogQHJldHVybnMge2Z1bmN0aW9ufSBBIGZ1bmN0aW9uLCB3aGVuIGNhbGxlZCwgd2lsbCByZXN0b3JlIHRvIHByZXZpb3VzIHN0YXRlLlxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVXaXRoVW5kbyhcbiAgZWxlbWVudDogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQsXG4gIHF1YWxpZmllZE5hbWU6IHN0cmluZyxcbiAgbmV4dFZhbHVlOiBzdHJpbmdcbik6IFVuZG9GdW5jdGlvbiB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUocXVhbGlmaWVkTmFtZSk7XG5cbiAgaWYgKHZhbHVlICE9PSBuZXh0VmFsdWUpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShxdWFsaWZpZWROYW1lLCBuZXh0VmFsdWUpO1xuXG4gICAgcmV0dXJuICgpID0+ICh2YWx1ZSA/IGVsZW1lbnQuc2V0QXR0cmlidXRlKHF1YWxpZmllZE5hbWUsIHZhbHVlKSA6IGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHF1YWxpZmllZE5hbWUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGV2ZW50IGhhbmRsZXIgZm9yIGRpc2FibGluZyBldmVudCBidWJibGluZyBhbmQgcHJvcGFnYXRpb24uXG4gKi9cbmNvbnN0IGRpc2FibGVkSGFuZGxlciA9IChldmVudDogRXZlbnQpID0+IHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuLyoqXG4gKiBMaXN0ZW5zIHRvIGV2ZW50IG9uY2UuIFJldHVybnMgYSBmdW5jdGlvbiwgd2hlbiBjYWxsZWQsIHdpbGwgc3RvcCBsaXN0ZW5pbmcuXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJPbmNlV2l0aFVuZG8oXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkLFxuICBuYW1lOiBzdHJpbmcsXG4gIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXJcbik6IFVuZG9GdW5jdGlvbiB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3QgKi9cbiAgbGV0IGRldGFjaDogKCkgPT4gdm9pZDtcbiAgY29uc3QgZGV0YWNoaW5nSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICB0cnkge1xuICAgICAgaGFuZGxlcihldmVudCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCB7IG9uY2U6IHRydWUgfSwgc28gd2UgbmVlZCB0byBkZXRhY2ggbWFudWFsbHkuXG4gICAgICBkZXRhY2goKTtcbiAgICB9XG4gIH07XG5cbiAgZGV0YWNoID0gKCkgPT4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGRldGFjaGluZ0hhbmRsZXIpO1xuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBkZXRhY2hpbmdIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGRldGFjaDtcbn1cblxuLyoqXG4gKiBMaXN0ZW5zIHRvIGV2ZW50LiBSZXR1cm5zIGEgZnVuY3Rpb24sIHdoZW4gY2FsbGVkLCB3aWxsIHN0b3AgbGlzdGVuaW5nLlxuICovXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyV2l0aFVuZG8oXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkLFxuICBuYW1lOiBzdHJpbmcsXG4gIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXJcbik6IFVuZG9GdW5jdGlvbiB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcblxuICByZXR1cm4gKCkgPT4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xufVxuXG4vKipcbiAqIERpc2FibGVzIGFuIGVsZW1lbnQgd2l0aCB1bmRvIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gQSBmdW5jdGlvbiwgd2hlbiBjYWxsZWQsIHdpbGwgcmVzdG9yZSB0byBwcmV2aW91cyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUVsZW1lbnRXaXRoVW5kbyhlbGVtZW50OiBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCk6IFVuZG9GdW5jdGlvbiB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHVuZG9TdGFjazogVW5kb0Z1bmN0aW9uW10gPSBbXTtcbiAgY29uc3QgaXNBY3RpdmUgPSBlbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICBjb25zdCB0YWcgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZSAqL1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgdW5kb1N0YWNrLnB1c2goc2V0QXR0cmlidXRlV2l0aFVuZG8oZWxlbWVudCwgJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpKTtcblxuICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgIHVuZG9TdGFjay5wdXNoKFxuICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXJPbmNlV2l0aFVuZG8oZWxlbWVudCwgJ2JsdXInLCAoKSA9PlxuICAgICAgICAgICAgdW5kb1N0YWNrLnB1c2goc2V0QXR0cmlidXRlV2l0aFVuZG8oZWxlbWVudCwgJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJykpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5kb1N0YWNrLnB1c2goc2V0QXR0cmlidXRlV2l0aFVuZG8oZWxlbWVudCwgJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgICAgICB1bmRvU3RhY2sucHVzaChhZGRFdmVudExpc3RlbmVyV2l0aFVuZG8oZWxlbWVudCwgJ2NsaWNrJywgZGlzYWJsZWRIYW5kbGVyKSk7XG4gICAgICAgIHVuZG9TdGFjay5wdXNoKHNldEF0dHJpYnV0ZVdpdGhVbmRvKGVsZW1lbnQsICdyZWFkb25seScsICdyZWFkb25seScpKTtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICB1bmRvU3RhY2sucHVzaChcbiAgICAgICAgICAuLi5bXS5tYXAuY2FsbChlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbicpLCBvcHRpb24gPT5cbiAgICAgICAgICAgIHNldEF0dHJpYnV0ZVdpdGhVbmRvKG9wdGlvbiwgJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJylcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGJ1bmNoVW5kb3MoLi4udW5kb1N0YWNrKTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlcyBhbGwgaW5wdXR0YWJsZSBkZXNjZW5kYW50cy5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgdW5kZWZpbmVkfSBlbGVtZW50IENvbnRhaW5lciBlbGVtZW50IHRvIHN0YXJ0IGxvb2tpbmcgZm9yIGlucHV0dGFibGUgZGVzY2VuZGFudHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9ic2VydmVTdWJ0cmVlIGB0cnVlYCB0byBhcHBsaWVzIHRvIGFsbCBmdXR1cmUgaW5wdXR0YWJsZSBkZXNjZW5kYW50cywgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICpcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gQSBmdW5jdGlvbiwgd2hlbiBjYWxsZWQsIHdpbGwgcmVzdG9yZSB0byBwcmV2aW91cyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUlucHV0RWxlbWVudHNXaXRoVW5kbyhlbGVtZW50OiBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCwgb2JzZXJ2ZVN1YnRyZWUgPSB0cnVlKTogVW5kb0Z1bmN0aW9uIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdW5kb1N0YWNrOiAoKCkgPT4gdm9pZClbXSA9IFtdLm1hcC5jYWxsKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScpLCBlbGVtZW50ID0+XG4gICAgZGlzYWJsZUVsZW1lbnRXaXRoVW5kbyhlbGVtZW50KVxuICApO1xuXG4gIGNvbnN0IHRhZyA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAvLyBPbmx5IHNldCB0YWJpbmRleD1cIi0xXCIgb24gZm9jdXNhYmxlIGVsZW1lbnQuIE90aGVyd2lzZSwgd2Ugd2lsbCBtYWtlIDxkaXY+IGZvY3VzYWJsZSBieSBtb3VzZS5cbiAgKHRhZyA9PT0gJ2EnIHx8IHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSAmJlxuICAgIHVuZG9TdGFjay5wdXNoKHNldEF0dHJpYnV0ZVdpdGhVbmRvKGVsZW1lbnQsICd0YWJpbmRleCcsICctMScpKTtcblxuICBpZiAob2JzZXJ2ZVN1YnRyZWUpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PlxuICAgICAgbXV0YXRpb25zLmZvckVhY2goKHsgYWRkZWROb2RlcyB9KSA9PlxuICAgICAgICB1bmRvU3RhY2sucHVzaCguLi5bXS5tYXAuY2FsbChhZGRlZE5vZGVzLCBhZGRlZE5vZGUgPT4gZGlzYWJsZUlucHV0RWxlbWVudHNXaXRoVW5kbyhhZGRlZE5vZGUsIGZhbHNlKSkpXG4gICAgICApXG4gICAgKTtcblxuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwgeyBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG5cbiAgICB1bmRvU3RhY2sucHVzaCgoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCkpO1xuICB9XG5cbiAgcmV0dXJuIGJ1bmNoVW5kb3MoLi4udW5kb1N0YWNrKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgZnJvbSBhbiBlbGVtZW50LlxuICpcbiAqIEByZXR1cm5zIHtmYWxzZSB8IHN0cmluZ30gVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuIGBmYWxzZWAgaWYgdGhlIGF0dHJpYnV0ZSB3YXMgbm90IHNldC5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBxdWFsaWZpZWROYW1lOiBzdHJpbmcpOiBmYWxzZSB8IHN0cmluZyB7XG4gIHJldHVybiAhIWVsZW1lbnQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUocXVhbGlmaWVkTmFtZSkgJiYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKHF1YWxpZmllZE5hbWUpIHx8ICcnKTtcbn1cblxuLyoqXG4gKiBTZXRzIG9yIHJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gYW4gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gc2V0IG9yIHJlbW92ZSBhdHRyaWJ1dGUgZnJvbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWFsaWZpZWROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7ZmFsc2UgfCBzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuIFdoZW4gcGFzc2luZyBgZmFsc2VgLCByZW1vdmUgdGhlIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gc2V0T3JSZW1vdmVBdHRyaWJ1dGUoZWxlbWVudDogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQsIHF1YWxpZmllZE5hbWU6IHN0cmluZywgdmFsdWU6IGZhbHNlIHwgc3RyaW5nKTogdm9pZCB7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICBlbGVtZW50Py5yZW1vdmVBdHRyaWJ1dGUocXVhbGlmaWVkTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudD8uc2V0QXR0cmlidXRlKHF1YWxpZmllZE5hbWUsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgb3IgcmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSBhbiBlbGVtZW50IHdpdGggYW4gdW5kbyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gc2V0IG9yIHJlbW92ZSBhdHRyaWJ1dGUgZnJvbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWFsaWZpZWROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7ZmFsc2UgfCBzdHJpbmd9IHZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuIFdoZW4gcGFzc2luZyBgZmFsc2VgLCByZW1vdmUgdGhlIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH0gVGhlIHVuZG8gZnVuY3Rpb24sIHdoZW4gY2FsbGVkLCB3aWxsIHVuZG8gYWxsIG1hbmlwdWxhdGlvbnMgYnkgcmVzdG9yaW5nIHZhbHVlcyByZWNvcmRlZCBhdCB0aGUgdGltZSBvZiB0aGUgZnVuY3Rpb24gY2FsbC5cbiAqL1xuZnVuY3Rpb24gc2V0T3JSZW1vdmVBdHRyaWJ1dGVXaXRoVW5kbyhcbiAgZWxlbWVudDogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQsXG4gIHF1YWxpZmllZE5hbWU6IHN0cmluZyxcbiAgdmFsdWU6IGZhbHNlIHwgc3RyaW5nXG4pOiBVbmRvRnVuY3Rpb24ge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwcmV2VmFsdWUgPSBnZXRBdHRyaWJ1dGUoZWxlbWVudCwgcXVhbGlmaWVkTmFtZSk7XG5cbiAgc2V0T3JSZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgcXVhbGlmaWVkTmFtZSwgdmFsdWUpO1xuXG4gIHJldHVybiAoKSA9PiBzZXRPclJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBxdWFsaWZpZWROYW1lLCBwcmV2VmFsdWUpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBhbmNlc3RvciB0aGF0IGZ1bGZpbGwgdGhlIHByZWRpY2F0ZS5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIHN0YXJ0aW5nIGVsZW1lbnQuIFRoaXMgZWxlbWVudCB3aWxsIG5vdCBiZSBjaGVja2VkIGFnYWluc3QgdGhlIHByZWRpY2F0ZS5cbiAqIEBwYXJhbSB7KGFuY2VzdG9yOiBIVE1MRWxlbWVudCkgPT4gYm9vbGVhbn0gcHJlZGljYXRlIC0gVGhlIHByZWRpY2F0ZSB0byBmdWxmaWxsLlxuICpcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IHVuZGVmaW5lZH0gVGhlIGZpcnN0IGFuY2VzdG9yIHRoYXQgZnVsZmlsbCB0aGUgcHJlZGljYXRlLCBvdGhlcndpc2UsIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBmaW5kQW5jZXN0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQsIHByZWRpY2F0ZTogKGFuY2VzdG9yOiBIVE1MRWxlbWVudCkgPT4gYm9vbGVhbik6IEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgbGV0IGN1cnJlbnQgPSBlbGVtZW50O1xuXG4gIHdoaWxlICgoY3VycmVudCA9IGN1cnJlbnQucGFyZW50RWxlbWVudCkpIHtcbiAgICBpZiAocHJlZGljYXRlLmNhbGwoZWxlbWVudCwgY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluZGljYXRlcyB0aGUgYWN0aW9uIHNlbGVjdGVkIGJ5IHBlcmZvcm1pbmcgYSBzZXJpZXMgb2YgbWFuaXB1bGF0aW9ucywgd2l0aCB1bmRvOlxuICpcbiAqIC0gQWNjZXNzaWJpbGl0eTogc2V0IGBhcmlhLXByZXNzZWRgIHRvIGB0cnVlYFxuICogLSBBcHBsaWVzIGBzdHlsZU9wdGlvbnMuYWN0aW9uUGVyZm9ybWVkQ2xhc3NOYW1lYFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnRbXX0gc2VsZWN0ZWRBY3Rpb25FbGVtZW50cyAtIEFuIGFycmF5IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHJlcHJlc2VudGluZyB0aGUgYWN0aW9uIGFuZCBpcyBzZWxlY3RlZC5cbiAqIEBwYXJhbSB7c3RyaW5nP30gYWN0aW9uUGVyZm9ybWVkQ2xhc3NOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNsYXNzIHRvIGFwcGx5IHRvIGFsbCBlbGVtZW50cy5cbiAqXG4gKiBAcmV0dXJucyB7KCkgPT4gdm9pZH0gVGhlIHVuZG8gZnVuY3Rpb24sIHdoZW4gY2FsbGVkLCB3aWxsIHVuZG8gYWxsIG1hbmlwdWxhdGlvbnMgYnkgcmVzdG9yaW5nIHZhbHVlcyByZWNvcmRlZCBhdCB0aGUgdGltZSBvZiB0aGUgZnVuY3Rpb24gY2FsbC5cbiAqL1xuZnVuY3Rpb24gaW5kaWNhdGVBY3Rpb25TZWxlY3Rpb25XaXRoVW5kbyhcbiAgc2VsZWN0ZWRBY3Rpb25FbGVtZW50czogSFRNTEVsZW1lbnRbXSB8IHVuZGVmaW5lZCxcbiAgYWN0aW9uUGVyZm9ybWVkQ2xhc3NOYW1lPzogc3RyaW5nXG4pOiBVbmRvRnVuY3Rpb24ge1xuICBpZiAoIXNlbGVjdGVkQWN0aW9uRWxlbWVudHM/Lmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFZlcmlmeSBhbGwgaW5wdXQgZWxlbWVudHMgYXJlIFwiYWMtcHVzaEJ1dHRvblwiLCBjb3VsZCBiZWxvbmdzIHRvIEFjdGlvblNldCBvciBcImNhcmQgYWN0aW9uc1wiLlxuICBpZiAoc2VsZWN0ZWRBY3Rpb25FbGVtZW50cy5zb21lKGFjdGlvbkVsZW1lbnQgPT4gIWFjdGlvbkVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhYy1wdXNoQnV0dG9uJykpKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ2JvdGZyYW1ld29yay13ZWJjaGF0OiBDYW5ub3QgbWFyayBzZWxlY3RlZCBhY3Rpb24gaW4gdGhlIGNhcmQsIHNvbWUgZWxlbWVudHMgYXJlIG5vdCBhbiBcImFjLXB1c2hCdXR0b25cIi4nXG4gICAgKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEEgZGlzdGluY3Qgc2V0IG9mIGFjdGlvbiBzZXQgY29udGFpbmVycyB3aGljaCBoYXMgc2VsZWN0aW9ucywgZXhjbHVkaW5nIGNvbnRhaW5lcnMgd2l0aG91dCBhY3Rpb25zLlxuICAvLyBNdWx0aXBsZSBzdWJtaXNzaW9uIGluIGFuIEFkYXB0aXZlIENhcmQgaXMgc3RpbGwgYSB2YWd1ZSBhcmVhIGFuZCBUQkQuXG4gIC8vIFdlIG1pZ2h0IHdhbnQgdG8gZGlzYWJsZSB0aGUgd2hvbGUgY2FyZCwganVzdCBidXR0b25zIGluIHNhbWUgY29udGFpbmVyLCBvciBkbyBub3RoaW5nICh0b2RheSkuXG4gIGNvbnN0IGFjdGlvblNldEVsZW1lbnRzID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcblxuICBzZWxlY3RlZEFjdGlvbkVsZW1lbnRzLmZvckVhY2goc2VsZWN0ZWRBY3Rpb25FbGVtZW50ID0+IHtcbiAgICBjb25zdCBhY3Rpb25TZXRFbGVtZW50ID0gZmluZEFuY2VzdG9yKFxuICAgICAgc2VsZWN0ZWRBY3Rpb25FbGVtZW50LFxuICAgICAgYW5jZXN0b3IgPT4gYW5jZXN0b3IuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdtZW51YmFyJ1xuICAgICk7XG5cbiAgICBhY3Rpb25TZXRFbGVtZW50ICYmIGFjdGlvblNldEVsZW1lbnRzLmFkZChhY3Rpb25TZXRFbGVtZW50KTtcbiAgfSk7XG5cbiAgY29uc3QgdW5kb1N0YWNrOiAoKCkgPT4gdm9pZClbXSA9IFtdO1xuXG4gIGFjdGlvblNldEVsZW1lbnRzLmZvckVhY2goYWN0aW9uU2V0RWxlbWVudCA9PiB7XG4gICAgLy8gUmVtb3ZlIFwicm9sZVwiIGZyb20gZXZlcnkgXCJhYy1hY3Rpb25TZXRcIiBjb250YWluZXIuXG4gICAgdW5kb1N0YWNrLnB1c2goc2V0T3JSZW1vdmVBdHRyaWJ1dGVXaXRoVW5kbyhhY3Rpb25TZXRFbGVtZW50LCAncm9sZScsIGZhbHNlKSk7XG5cbiAgICAvLyBNb2RpZnkgXCJyb2xlXCIgb2YgZXZlcnkgYWN0aW9ucyBpbiB0aGUgY29udGFpbmVyLlxuICAgIEFycmF5LmZyb20oYWN0aW9uU2V0RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYWMtcHVzaEJ1dHRvbicpIGFzIE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+KS5mb3JFYWNoKFxuICAgICAgYWN0aW9uRWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChzZWxlY3RlZEFjdGlvbkVsZW1lbnRzLmluY2x1ZGVzKGFjdGlvbkVsZW1lbnQpKSB7XG4gICAgICAgICAgLy8gQWRkIFwiYXJpYS1wcmVzc2VkXCIgYW5kIHNldCBcInJvbGVcIiBhdHRyaWJ1dGUgdG8gXCJidXR0b25cIiAod2hpY2ggaXMgcmVxdWlyZWQgYnkgXCJhcmlhLXByZXNzZWRcIikuXG4gICAgICAgICAgdW5kb1N0YWNrLnB1c2goc2V0T3JSZW1vdmVBdHRyaWJ1dGVXaXRoVW5kbyhhY3Rpb25FbGVtZW50LCAnYXJpYS1wcmVzc2VkJywgJ3RydWUnKSk7XG4gICAgICAgICAgdW5kb1N0YWNrLnB1c2goc2V0T3JSZW1vdmVBdHRyaWJ1dGVXaXRoVW5kbyhhY3Rpb25FbGVtZW50LCAncm9sZScsICdidXR0b24nKSk7XG5cbiAgICAgICAgICAvLyBIaWdobGlnaHQgYWN0aW9ucyBieSBhcHBseWluZyBgc3R5bGVPcHRpb25zLmFjdGlvblBlcmZvcm1lZENsYXNzTmFtZWAuXG4gICAgICAgICAgYWN0aW9uUGVyZm9ybWVkQ2xhc3NOYW1lICYmXG4gICAgICAgICAgICB1bmRvU3RhY2sucHVzaChhZGRQZXJzaXN0ZW50Q2xhc3NXaXRoVW5kbyhhY3Rpb25FbGVtZW50LCBhY3Rpb25QZXJmb3JtZWRDbGFzc05hbWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSByZW1vdmVkIFwicm9sZT1tZW51YmFyXCIgZnJvbSB0aGUgY29udGFpbmVyLCB3ZSBtdXN0IHJlbW92ZSBcInJvbGU9bWVudWl0ZW1cIiBmcm9tIHVuc2VsZWN0ZWQgYWN0aW9ucy5cbiAgICAgICAgICB1bmRvU3RhY2sucHVzaChzZXRPclJlbW92ZUF0dHJpYnV0ZVdpdGhVbmRvKGFjdGlvbkVsZW1lbnQsICdyb2xlJywgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH0pO1xuXG4gIHJldHVybiBidW5jaFVuZG9zKC4uLnVuZG9TdGFjayk7XG59XG5cbi8qKlxuICogRml4ZXMgYWNjZXNzaWJpbGl0eSBpc3N1ZXMgZnJvbSBBZGFwdGl2ZSBDYXJkLCB3aXRoIHVuZG8uXG4gKlxuICogQHJldHVybnMgeygpID0+IHZvaWR9IFRoZSB1bmRvIGZ1bmN0aW9uLCB3aGVuIGNhbGxlZCwgd2lsbCB1bmRvIGFsbCBtYW5pcHVsYXRpb25zIGJ5IHJlc3RvcmluZyB2YWx1ZXMgcmVjb3JkZWQgYXQgdGhlIHRpbWUgb2YgdGhlIGZ1bmN0aW9uIGNhbGwuXG4gKi9cbmZ1bmN0aW9uIGZpeEFjY2Vzc2liaWxpdHlJc3N1ZXNXaXRoVW5kbyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IFVuZG9GdW5jdGlvbiB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZXNlIGhhY2tzIHNob3VsZCBiZSBkb25lIGluIEFkYXB0aXZlIENhcmRzIGxpYnJhcnkgaW5zdGVhZC5cbiAgLy8gUmVsYXRlZCB0byAjMzk0OTogQWxsIGFjdGlvbiBidXR0b25zIGluc2lkZSByb2xlPVwibWVudWJhclwiIHNob3VsZCBiZSByb2xlPVwibWVudWl0ZW1cIi5cbiAgY29uc3QgdW5kb1N0YWNrOiBVbmRvRnVuY3Rpb25bXSA9IEFycmF5LmZyb20oXG4gICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYWMtYWN0aW9uU2V0W3JvbGU9XCJtZW51YmFyXCJdIFtyb2xlPVwiYnV0dG9uXCJdJykgYXMgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD5cbiAgKS5tYXAoYWN0aW9uQnV0dG9uID0+IHNldEF0dHJpYnV0ZVdpdGhVbmRvKGFjdGlvbkJ1dHRvbiwgJ3JvbGUnLCAnbWVudWl0ZW0nKSk7XG5cbiAgcmV0dXJuICgpID0+IHVuZG9TdGFjay5mb3JFYWNoKHVuZG8gPT4gdW5kbz8uKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRGb2N1c2FibGVFbGVtZW50cyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICByZXR1cm4gW10uZmlsdGVyLmNhbGwoXG4gICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgW1xuICAgICAgICAnYScsXG4gICAgICAgICdib2R5JyxcbiAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICdmcmFtZScsXG4gICAgICAgICdpZnJhbWUnLFxuICAgICAgICAnaW1nJyxcbiAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgJ2lzaW5kZXgnLFxuICAgICAgICAnb2JqZWN0JyxcbiAgICAgICAgJ3NlbGVjdCcsXG4gICAgICAgICd0ZXh0YXJlYScsXG4gICAgICAgICdbdGFiaW5kZXhdJ1xuICAgICAgXS5qb2luKCcsICcpXG4gICAgKSBhcyBOb2RlTGlzdE9mPEhUTUxFbGVtZW50PixcbiAgICBlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHRhYkluZGV4ID0gZ2V0VGFiSW5kZXgoZWxlbWVudCk7XG5cbiAgICAgIHJldHVybiB0eXBlb2YgdGFiSW5kZXggPT09ICdudW1iZXInICYmIHRhYkluZGV4ID49IDA7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiByZXN0b3JlQWN0aXZlRWxlbWVudEluZGV4KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBhY3RpdmVFbGVtZW50SW5kZXg6IG51bWJlcikge1xuICBnZXRGb2N1c2FibGVFbGVtZW50cyhlbGVtZW50KVsrYWN0aXZlRWxlbWVudEluZGV4XT8uZm9jdXMoKTtcbn1cblxuZnVuY3Rpb24gc2F2ZUFjdGl2ZUVsZW1lbnRJbmRleChlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICByZXR1cm4gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoZWxlbWVudCkuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gcmVzdG9yZUlucHV0VmFsdWVzKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBpbnB1dFZhbHVlczogKGJvb2xlYW4gfCBzdHJpbmcpW10pIHtcbiAgY29uc3QgaW5wdXRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYScpIGFzIE5vZGVMaXN0T2Y8XG4gICAgSFRNTElucHV0RWxlbWVudCB8IEhUTUxTZWxlY3RFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudFxuICA+O1xuXG4gIFtdLmZvckVhY2guY2FsbChpbnB1dHMsIChpbnB1dDogSFRNTElucHV0RWxlbWVudCB8IEhUTUxTZWxlY3RFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudCwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gaW5wdXRWYWx1ZXNbK2luZGV4XTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB7IHRhZ05hbWUsIHR5cGUgfSA9IGlucHV0O1xuXG4gICAgICBpZiAodGFnTmFtZSA9PT0gJ0lOUFVUJyAmJiAodHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0eXBlID09PSAncmFkaW8nKSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAoaW5wdXQgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzYXZlSW5wdXRWYWx1ZXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiAoYm9vbGVhbiB8IHN0cmluZylbXSB7XG4gIGNvbnN0IGlucHV0cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEnKSBhcyBOb2RlTGlzdE9mPFxuICAgIEhUTUxJbnB1dEVsZW1lbnQgfCBIVE1MU2VsZWN0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnRcbiAgPjtcblxuICByZXR1cm4gW10ubWFwLmNhbGwoaW5wdXRzLCAoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQgfCBIVE1MU2VsZWN0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQpID0+IHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IGlucHV0O1xuXG4gICAgaWYgKGlucHV0LnRhZ05hbWUgPT09ICdJTlBVVCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJykpIHtcbiAgICAgIHJldHVybiAoaW5wdXQgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5wdXQudmFsdWU7XG4gIH0pO1xufVxuXG50eXBlIEFkYXB0aXZlQ2FyZFJlbmRlcmVyUHJvcHMgPSB7XG4gIGFjdGlvblBlcmZvcm1lZENsYXNzTmFtZT86IHN0cmluZztcbiAgYWRhcHRpdmVDYXJkOiBBZGFwdGl2ZUNhcmQ7XG4gIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgdGFwQWN0aW9uPzogRGlyZWN0TGluZUNhcmRBY3Rpb247XG59O1xuXG5jb25zdCBBZGFwdGl2ZUNhcmRSZW5kZXJlcjogVkZDPEFkYXB0aXZlQ2FyZFJlbmRlcmVyUHJvcHM+ID0gKHtcbiAgYWN0aW9uUGVyZm9ybWVkQ2xhc3NOYW1lLFxuICBhZGFwdGl2ZUNhcmQsXG4gIGRpc2FibGVkOiBkaXNhYmxlZEZyb21Qcm9wcyxcbiAgdGFwQWN0aW9uXG59KSA9PiB7XG4gIGNvbnN0IFt7IGFkYXB0aXZlQ2FyZFJlbmRlcmVyOiBhZGFwdGl2ZUNhcmRSZW5kZXJlclN0eWxlU2V0IH1dID0gdXNlU3R5bGVTZXQoKTtcbiAgY29uc3QgW3sgR2xvYmFsU2V0dGluZ3MsIEhvc3RDb25maWcgfV0gPSB1c2VBZGFwdGl2ZUNhcmRzUGFja2FnZSgpO1xuICBjb25zdCBbYWN0aW9uc1BlcmZvcm1lZCwgc2V0QWN0aW9uc1BlcmZvcm1lZF0gPSB1c2VTdGF0ZTxBZGFwdGl2ZUNhcmRBY3Rpb25bXT4oW10pO1xuICBjb25zdCBbYWRhcHRpdmVDYXJkc0hvc3RDb25maWddID0gdXNlQWRhcHRpdmVDYXJkc0hvc3RDb25maWcoKTtcbiAgY29uc3QgW2Rpc2FibGVkRnJvbUNvbXBvc2VyXSA9IHVzZURpc2FibGVkKCk7XG4gIGNvbnN0IFtlcnJvcnMsIHNldEVycm9yc10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtsYXN0UmVuZGVyLCBzZXRMYXN0UmVuZGVyXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBhY3RpdmVFbGVtZW50SW5kZXhSZWYgPSB1c2VSZWYoLTEpO1xuICBjb25zdCBhZGFwdGl2ZUNhcmRFbGVtZW50UmVmID0gdXNlUmVmPEhUTUxFbGVtZW50PigpO1xuICBjb25zdCBjb250ZW50UmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PigpO1xuICBjb25zdCBpbnB1dFZhbHVlc1JlZiA9IHVzZVJlZjwoYm9vbGVhbiB8IHN0cmluZylbXT4oW10pO1xuICBjb25zdCBsb2NhbGl6ZSA9IHVzZUxvY2FsaXplcigpO1xuICBjb25zdCBwZXJmb3JtQ2FyZEFjdGlvbiA9IHVzZVBlcmZvcm1DYXJkQWN0aW9uKCk7XG4gIGNvbnN0IHJlbmRlck1hcmtkb3duQXNIVE1MID0gdXNlUmVuZGVyTWFya2Rvd25Bc0hUTUwoKTtcbiAgY29uc3Qgc2Nyb2xsVG9FbmQgPSB1c2VTY3JvbGxUb0VuZCgpO1xuXG4gIGNvbnN0IGRpc2FibGVkID0gZGlzYWJsZWRGcm9tQ29tcG9zZXIgfHwgZGlzYWJsZWRGcm9tUHJvcHM7XG5cbiAgLy8gVE9ETzogW1AyXSAjMzE5OSBXZSBzaG91bGQgY29uc2lkZXIgdXNpbmcgYGFkYXB0aXZlQ2FyZC5zZWxlY3RBY3Rpb25gIGluc3RlYWQuXG4gIC8vIFRoZSBudWxsIGNoZWNrIGZvciBcInRhcEFjdGlvblwiIGlzIGluIFwiaGFuZGxlQ2xpY2tBbmRLZXlQcmVzc0ZvclRhcEFjdGlvblwiLlxuICBjb25zdCBoYW5kbGVDbGlja0FuZEtleVByZXNzID0gdXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50OiBLZXlib2FyZEV2ZW50IHwgTW91c2VFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgY29uc3QgeyBrZXksIHR5cGUgfSA9IGV2ZW50IGFzIEtleWJvYXJkRXZlbnQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTERpdkVsZW1lbnQ7XG5cbiAgICAgIC8vIFNvbWUgaXRlbXMsIGUuZy4gdGFwcGFibGUgdGV4dCwgY2Fubm90IGJlIGRpc2FibGVkIHRocnUgRE9NIGF0dHJpYnV0ZXNcbiAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gY29udGVudFJlZjtcbiAgICAgIGNvbnN0IGFkYXB0aXZlQ2FyZFJvb3QgPSBjdXJyZW50LnF1ZXJ5U2VsZWN0b3IoJy5hYy1hZGFwdGl2ZUNhcmRbdGFiaW5kZXg9XCIwXCJdJyk7XG5cbiAgICAgIGlmICghYWRhcHRpdmVDYXJkUm9vdCkge1xuICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFxuICAgICAgICAgICdib3RmcmFtZXdvcmstd2ViY2hhdDogTm8gQWRhcHRpdmUgQ2FyZCByb290IGNvbnRhaW5lciBjYW4gYmUgZm91bmQ7IHRoZSBjYXJkIGlzIHByb2JhYmx5IG9uIGFuIHVuc3VwcG9ydGVkIEFkYXB0aXZlIENhcmQgdmVyc2lvbi4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBcImtleXByZXNzXCIgZXZlbnQsIHdlIG9ubHkgbGlzdGVuIHRvIEVOVEVSIGFuZCBTUEFDRUJBUiBrZXkuXG4gICAgICBpZiAodHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgICBpZiAoa2V5ICE9PSAnRW50ZXInICYmIGtleSAhPT0gJyAnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugd2lsbCBjYWxsIHBlcmZvcm1DYXJkQWN0aW9uIGlmIGVpdGhlcjpcbiAgICAgIC8vIDEuIFdlIGFyZSBvbiB0aGUgdGFyZ2V0LCBvclxuICAgICAgLy8gMi4gVGhlIGV2ZW50LWRpc3BhdGNoaW5nIGVsZW1lbnQgaXMgbm90IGludGVyYWN0aXZlXG4gICAgICBpZiAodGFyZ2V0ICE9PSBhZGFwdGl2ZUNhcmRSb290KSB7XG4gICAgICAgIGNvbnN0IHRhYkluZGV4ID0gZ2V0VGFiSW5kZXgodGFyZ2V0KTtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyBjbGlja2luZyBvbiBzb21ldGhpbmcgdGhhdCBpcyBhbHJlYWR5IGNsaWNrYWJsZSwgZG8gbm90IGFsbG93IHRoZW0gdG8gY2xpY2sgdGhlIGNhcmQuXG4gICAgICAgIC8vIEUuZy4gYSBoZXJvIGNhcmQgY2FuIGJlIHRhcHBhYmxlLCBhbmQgaW1hZ2UgYW5kIGJ1dHRvbnMgaW5zaWRlIHRoZSBoZXJvIGNhcmQgY2FuIGFsc28gYmUgdGFwcGFibGUuXG4gICAgICAgIGlmICh0eXBlb2YgdGFiSW5kZXggPT09ICdudW1iZXInICYmIHRhYkluZGV4ID49IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGVyZm9ybUNhcmRBY3Rpb24odGFwQWN0aW9uKTtcbiAgICAgIHNjcm9sbFRvRW5kKCk7XG4gICAgfSxcbiAgICBbY29udGVudFJlZiwgcGVyZm9ybUNhcmRBY3Rpb24sIHNjcm9sbFRvRW5kLCB0YXBBY3Rpb25dXG4gICk7XG5cbiAgLy8gT25seSBsaXN0ZW4gdG8gZXZlbnQgaWYgaXQgaXMgbm90IGRpc2FibGVkIGFuZCBoYXZlIFwidGFwQWN0aW9uXCIgcHJvcC5cbiAgY29uc3QgaGFuZGxlQ2xpY2tBbmRLZXlQcmVzc0ZvclRhcEFjdGlvbiA9ICFkaXNhYmxlZCAmJiB0YXBBY3Rpb24gPyBoYW5kbGVDbGlja0FuZEtleVByZXNzIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IGFkZEFjdGlvbnNQZXJmb3JtZWQgPSB1c2VDYWxsYmFjayhcbiAgICAoYWN0aW9uOiBBZGFwdGl2ZUNhcmRBY3Rpb24pOiB2b2lkID0+XG4gICAgICAhfmFjdGlvbnNQZXJmb3JtZWQuaW5kZXhPZihhY3Rpb24pICYmIHNldEFjdGlvbnNQZXJmb3JtZWQoWy4uLmFjdGlvbnNQZXJmb3JtZWQsIGFjdGlvbl0pLFxuICAgIFthY3Rpb25zUGVyZm9ybWVkLCBzZXRBY3Rpb25zUGVyZm9ybWVkXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUV4ZWN1dGVBY3Rpb24gPSB1c2VDYWxsYmFjayhcbiAgICAoYWN0aW9uOiBBZGFwdGl2ZUNhcmRBY3Rpb24pOiB2b2lkID0+IHtcbiAgICAgIC8vIFNvbWUgaXRlbXMsIGUuZy4gdGFwcGFibGUgaW1hZ2UsIGNhbm5vdCBiZSBkaXNhYmxlZCB0aHJ1IERPTSBhdHRyaWJ1dGVzXG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhZGRBY3Rpb25zUGVyZm9ybWVkKGFjdGlvbik7XG5cbiAgICAgIGNvbnN0IGFjdGlvblR5cGVOYW1lID0gYWN0aW9uLmdldEpzb25UeXBlTmFtZSgpO1xuICAgICAgY29uc3QgeyBpY29uVXJsOiBpbWFnZSwgdGl0bGUgfSA9IGFjdGlvbjtcblxuICAgICAgLy8gV2UgY2Fubm90IHVzZSBcImluc3RhbmNlb2ZcIiBjaGVjayBoZXJlLCBiZWNhdXNlIHdlYiBkZXZzIG1heSBicmluZyB0aGVpciBvd24gdmVyc2lvbiBvZiBBZGFwdGl2ZSBDYXJkcyBwYWNrYWdlLlxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayB1c2luZyBcImdldEpzb25UeXBlTmFtZSgpXCIgaW5zdGVhZC5cbiAgICAgIGlmIChhY3Rpb25UeXBlTmFtZSA9PT0gJ0FjdGlvbi5PcGVuVXJsJykge1xuICAgICAgICBjb25zdCB7IHVybDogdmFsdWUgfSA9IGFjdGlvbiBhcyBPcGVuVXJsQWN0aW9uO1xuXG4gICAgICAgIHBlcmZvcm1DYXJkQWN0aW9uKHtcbiAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICB0eXBlOiAnb3BlblVybCcsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGlvblR5cGVOYW1lID09PSAnQWN0aW9uLlN1Ym1pdCcpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhY3Rpb24gYXMgU3VibWl0QWN0aW9uIGFzIHtcbiAgICAgICAgICBkYXRhOiBzdHJpbmcgfCBCb3RGcmFtZXdvcmtDYXJkQWN0aW9uO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwZXJmb3JtQ2FyZEFjdGlvbih7XG4gICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgICB0aXRsZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2ltQmFjaycsXG4gICAgICAgICAgICAgIHZhbHVlOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuX19pc0JvdEZyYW1ld29ya0NhcmRBY3Rpb24pIHtcbiAgICAgICAgICAgIHBlcmZvcm1DYXJkQWN0aW9uKGRhdGEuY2FyZEFjdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlcmZvcm1DYXJkQWN0aW9uKHtcbiAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICB0eXBlOiAncG9zdEJhY2snLFxuICAgICAgICAgICAgICB2YWx1ZTogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2Nyb2xsVG9FbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdlYiBDaGF0OiByZWNlaXZlZCB1bmtub3duIGFjdGlvbiBmcm9tIEFkYXB0aXZlIENhcmRzYCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFthZGRBY3Rpb25zUGVyZm9ybWVkLCBkaXNhYmxlZCwgcGVyZm9ybUNhcmRBY3Rpb24sIHNjcm9sbFRvRW5kXVxuICApO1xuXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBjb250ZW50UmVmO1xuXG4gICAgaWYgKCFjdXJyZW50IHx8ICFhZGFwdGl2ZUNhcmQpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRJbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICBpbnB1dFZhbHVlc1JlZi5jdXJyZW50ID0gW107XG4gICAgfVxuXG4gICAgLy8gQ3VycmVudGx5LCB0aGUgb25seSB3YXkgdG8gc2V0IHRoZSBNYXJrZG93biBlbmdpbmUgaXMgdG8gc2V0IGl0IHRocnUgc3RhdGljIG1lbWJlciBvZiBBZGFwdGl2ZUNhcmQgY2xhc3NcblxuICAgIC8vIFRPRE86IFtQM10gQ2hlY2tzIGlmIHdlIGNvdWxkIG1ha2UgdGhlIFwicmVuZGVyTWFya2Rvd25Bc0hUTUxcIiBwZXIgY2FyZFxuICAgIC8vICAgICAgIFRoaXMgY291bGQgYmUgbGltaXRhdGlvbnMgZnJvbSBBZGFwdGl2ZSBDYXJkcyBwYWNrYWdlIChub3Qgc3VwcG9ydGVkIGFzIG9mIDEuMi41KVxuICAgIC8vICAgICAgIEJlY2F1c2UgdGhlcmUgY291bGQgYmUgdGltaW5nIGRpZmZlcmVuY2UgYmV0d2VlbiAucGFyc2UgYW5kIC5yZW5kZXIsIHdlIGNvdWxkIGJlIHVzaW5nIHdyb25nIE1hcmtkb3duIGVuZ2luZVxuXG4gICAgLy8gXCJvblByb2Nlc3NNYXJrZG93blwiIGlzIGEgc3RhdGljIGZ1bmN0aW9uIGJ1dCB3ZSBhcmUgdHJ5aW5nIHRvIHNjb3BlIGl0IHRvIHRoZSBjdXJyZW50IG9iamVjdCBpbnN0ZWFkLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkb3Qtbm90YXRpb25cbiAgICBhZGFwdGl2ZUNhcmQuY29uc3RydWN0b3JbJ29uUHJvY2Vzc01hcmtkb3duJ10gPSAodGV4dDogc3RyaW5nLCByZXN1bHQ6IElNYXJrZG93blByb2Nlc3NpbmdSZXN1bHQpID0+IHtcbiAgICAgIGlmIChyZW5kZXJNYXJrZG93bkFzSFRNTCkge1xuICAgICAgICByZXN1bHQub3V0cHV0SHRtbCA9IHJlbmRlck1hcmtkb3duQXNIVE1MKHRleHQpO1xuICAgICAgICByZXN1bHQuZGlkUHJvY2VzcyA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChhZGFwdGl2ZUNhcmRzSG9zdENvbmZpZykge1xuICAgICAgYWRhcHRpdmVDYXJkLmhvc3RDb25maWcgPSBpc1BsYWluT2JqZWN0KGFkYXB0aXZlQ2FyZHNIb3N0Q29uZmlnKVxuICAgICAgICA/IG5ldyBIb3N0Q29uZmlnKGFkYXB0aXZlQ2FyZHNIb3N0Q29uZmlnKVxuICAgICAgICA6IGFkYXB0aXZlQ2FyZHNIb3N0Q29uZmlnO1xuICAgIH1cblxuICAgIC8vIEZvciBhY2Nlc3NpYmlsaXR5IGlzc3VlICMxMzQwLCBgdGFiaW5kZXg9XCIwXCJgIG11c3Qgbm90IGJlIHNldCBmb3IgdGhlIHJvb3QgY29udGFpbmVyIGlmIGl0IGlzIG5vdCBpbnRlcmFjdGl2ZS5cbiAgICBHbG9iYWxTZXR0aW5ncy5zZXRUYWJJbmRleEF0Q2FyZFJvb3QgPSAhIXRhcEFjdGlvbjtcblxuICAgIGNvbnN0IHsgdmFsaWRhdGlvbkV2ZW50cyB9ID0gYWRhcHRpdmVDYXJkLnZhbGlkYXRlUHJvcGVydGllcygpO1xuXG4gICAgaWYgKHZhbGlkYXRpb25FdmVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2V0RXJyb3JzKHZhbGlkYXRpb25FdmVudHMucmVkdWNlKChpdGVtcywgeyBtZXNzYWdlIH0pID0+IFsuLi5pdGVtcywgbmV3IEVycm9yKG1lc3NhZ2UpXSwgW10pKTtcbiAgICB9XG5cbiAgICBsZXQgZWxlbWVudDogSFRNTEVsZW1lbnQ7XG5cbiAgICB0cnkge1xuICAgICAgZWxlbWVudCA9IGFkYXB0aXZlQ2FyZC5yZW5kZXIoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHNldEVycm9ycyhbZXJyb3JdKTtcbiAgICB9XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBzZXRFcnJvcnMoW25ldyBFcnJvcignQWRhcHRpdmUgQ2FyZCByZW5kZXJlZCBhcyBlbXB0eSBlbGVtZW50JyldKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBlcnJvcnMgb24gbmV4dCByZW5kZXJcbiAgICBzZXRFcnJvcnMoW10pO1xuXG4gICAgcmVzdG9yZUlucHV0VmFsdWVzKGVsZW1lbnQsIGlucHV0VmFsdWVzUmVmLmN1cnJlbnQpO1xuXG4gICAgY3VycmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICBhZGFwdGl2ZUNhcmRFbGVtZW50UmVmLmN1cnJlbnQgPSBlbGVtZW50O1xuXG4gICAgLy8gRm9jdXMgY2FuIG9ubHkgYmUgcmVzdG9yZWQgYWZ0ZXIgdGhlIERPTSBpcyBhdHRhY2hlZC5cbiAgICByZXN0b3JlQWN0aXZlRWxlbWVudEluZGV4KGVsZW1lbnQsIGFjdGl2ZUVsZW1lbnRJbmRleFJlZi5jdXJyZW50KTtcblxuICAgIHNldExhc3RSZW5kZXIoRGF0ZS5ub3coKSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYWN0aXZlRWxlbWVudEluZGV4UmVmLmN1cnJlbnQgPSBzYXZlQWN0aXZlRWxlbWVudEluZGV4KGVsZW1lbnQpO1xuICAgICAgaW5wdXRWYWx1ZXNSZWYuY3VycmVudCA9IHNhdmVJbnB1dFZhbHVlcyhlbGVtZW50KTtcblxuICAgICAgY3VycmVudC5yZW1vdmVDaGlsZChhZGFwdGl2ZUNhcmRFbGVtZW50UmVmLmN1cnJlbnQpO1xuXG4gICAgICBhZGFwdGl2ZUNhcmRFbGVtZW50UmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgfSwgW1xuICAgIGFkYXB0aXZlQ2FyZCxcbiAgICBhZGFwdGl2ZUNhcmRzSG9zdENvbmZpZyxcbiAgICBjb250ZW50UmVmLFxuICAgIEdsb2JhbFNldHRpbmdzLFxuICAgIEhvc3RDb25maWcsXG4gICAgcmVuZGVyTWFya2Rvd25Bc0hUTUwsXG4gICAgc2V0RXJyb3JzLFxuICAgIHRhcEFjdGlvblxuICBdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNldCBvbkV4ZWN1dGVBY3Rpb24gd2l0aG91dCBjYXVzaW5nIHVubmVjZXNzYXJ5IHJlLXJlbmRlci5cbiAgICBhZGFwdGl2ZUNhcmQub25FeGVjdXRlQWN0aW9uID0gZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVFeGVjdXRlQWN0aW9uO1xuICB9LCBbYWRhcHRpdmVDYXJkLCBkaXNhYmxlZCwgaGFuZGxlRXhlY3V0ZUFjdGlvbl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiBmaXhBY2Nlc3NpYmlsaXR5SXNzdWVzV2l0aFVuZG8oYWRhcHRpdmVDYXJkRWxlbWVudFJlZi5jdXJyZW50KSwgW2FkYXB0aXZlQ2FyZEVsZW1lbnRSZWYsIGxhc3RSZW5kZXJdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIHRoZSBBZGFwdGl2ZSBDYXJkIGdldCByZS1yZW5kZXJlZCwgcmUtZGlzYWJsZSBlbGVtZW50cyBhcyBuZWVkZWQuXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUlucHV0RWxlbWVudHNXaXRoVW5kbyhhZGFwdGl2ZUNhcmRFbGVtZW50UmVmLmN1cnJlbnQpO1xuICAgIH1cbiAgfSwgW2FkYXB0aXZlQ2FyZEVsZW1lbnRSZWYsIGRpc2FibGVkLCBsYXN0UmVuZGVyXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJZiB0aGUgQWRhcHRpdmUgQ2FyZCBjaGFuZ2VkLCByZXNldCBhbGwgYWN0aW9ucyBwZXJmb3JtZWQuXG4gICAgc2V0QWN0aW9uc1BlcmZvcm1lZChbXSk7XG4gIH0sIFthZGFwdGl2ZUNhcmRdKTtcblxuICB1c2VFZmZlY3QoXG4gICAgKCkgPT5cbiAgICAgIGluZGljYXRlQWN0aW9uU2VsZWN0aW9uV2l0aFVuZG8oXG4gICAgICAgIC8vIEFjdGlvbnMgdGhhdCBkbyBub3QgaGF2ZSBcInJlbmRlcmVkRWxlbWVudFwiIG1lYW5zIGl0IGlzIHRoZSBBZGFwdGl2ZSBDYXJkIGl0c2VsZiwgc3VjaCBhcyBcInNlbGVjdEFjdGlvblwiIChBQykgb3IgXCJ0YXBBY3Rpb25cIiAocmljaCBjYXJkcykuXG4gICAgICAgIC8vIFdlIGRvIG5vdCBuZWVkIHRvIG1hcmsgdGhlIHdob2xlIGNhcmQgYXMgcGVyZm9ybWVkLlxuICAgICAgICBhY3Rpb25zUGVyZm9ybWVkLm1hcCgoeyByZW5kZXJlZEVsZW1lbnQgfSkgPT4gcmVuZGVyZWRFbGVtZW50KS5maWx0ZXIocmVuZGVyZWRFbGVtZW50ID0+IHJlbmRlcmVkRWxlbWVudCksXG4gICAgICAgIGFjdGlvblBlcmZvcm1lZENsYXNzTmFtZVxuICAgICAgKSxcbiAgICBbYWN0aW9uc1BlcmZvcm1lZCwgYWN0aW9uUGVyZm9ybWVkQ2xhc3NOYW1lLCBsYXN0UmVuZGVyXVxuICApO1xuXG4gIHJldHVybiBlcnJvcnMubGVuZ3RoID8gKFxuICAgIG5vZGVfZW52ID09PSAnZGV2ZWxvcG1lbnQnICYmIDxFcnJvckJveCBlcnJvcj17ZXJyb3JzWzBdfSB0eXBlPXtsb2NhbGl6ZSgnQURBUFRJVkVfQ0FSRF9FUlJPUl9CT1hfVElUTEVfUkVOREVSJyl9IC8+XG4gICkgOiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzKGFkYXB0aXZlQ2FyZFJlbmRlcmVyU3R5bGVTZXQgKyAnJywgJ3dlYmNoYXRfX2FkYXB0aXZlLWNhcmQtcmVuZGVyZXInKX1cbiAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsaWNrQW5kS2V5UHJlc3NGb3JUYXBBY3Rpb24gYXMgdW5rbm93biBhcyBNb3VzZUV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD59XG4gICAgICBvbktleVByZXNzPXtoYW5kbGVDbGlja0FuZEtleVByZXNzRm9yVGFwQWN0aW9uIGFzIHVua25vd24gYXMgS2V5Ym9hcmRFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+fVxuICAgICAgcmVmPXtjb250ZW50UmVmfVxuICAgIC8+XG4gICk7XG59O1xuXG5BZGFwdGl2ZUNhcmRSZW5kZXJlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGFjdGlvblBlcmZvcm1lZENsYXNzTmFtZTogJycsXG4gIGRpc2FibGVkOiB1bmRlZmluZWQsXG4gIHRhcEFjdGlvbjogdW5kZWZpbmVkXG59O1xuXG5BZGFwdGl2ZUNhcmRSZW5kZXJlci5wcm9wVHlwZXMgPSB7XG4gIGFjdGlvblBlcmZvcm1lZENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYWRhcHRpdmVDYXJkOiBQcm9wVHlwZXMuYW55LmlzUmVxdWlyZWQsXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvLyBUeXBlU2NyaXB0IGNsYXNzIGlzIG5vdCBtYXBwYWJsZSB0byBQcm9wVHlwZXMuZnVuY1xuICAvLyBAdHMtaWdub3JlXG4gIHRhcEFjdGlvbjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBpbWFnZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0eXBlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmdcbiAgfSlcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFkYXB0aXZlQ2FyZFJlbmRlcmVyO1xuIl19