"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = playCognitiveServicesStream;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _createMultiBufferingPlayer = _interopRequireDefault(require("./createMultiBufferingPlayer"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Safari requires an audio buffer with a sample rate of 22050 Hz.
// Using a minimum sample rate of 44100 Hz as an example, the Speech SDK's default 16000 Hz will be upsampled to 48000 Hz.
var MIN_SAMPLE_RATE = 44100; // The Speech SDK is hardcoded to chop packets to 4096 bytes.
// Web Chat's multi-buffering player is set up with 3 buffers; each is 4096 bytes (2048 16-bit samples).
// For simplicity, the multi-buffer player currently does not support progressive buffering.
// Progressive buffering allows queuing at any sample size and will be concatenated.
// If 1000 samples are queued, then 1048 samples are queued, they will be concatenated into a single buffer of size 2048.
// For simplicity, data will be queued to two buffers.
// The first buffer is 1000 samples followed by 1048 zeroes, and the second buffer is 1048 samples followed by 1000 zeroes.
// There is no plan to support progressive buffering until the Speech SDK chops data at dynamic size.

var DEFAULT_BUFFER_SIZE = 4096;

function average(array) {
  return array.reduce(function (sum, value) {
    return sum + value;
  }, 0) / array.length;
}

function formatTypedBitArrayToFloatArray(audioData, maxValue) {
  var float32Data = new Float32Array(audioData.length);

  for (var i = 0; i < audioData.length; i++) {
    float32Data[+i] = audioData[+i] / maxValue;
  }

  return float32Data;
}

function formatAudioDataArrayBufferToFloatArray(_ref, arrayBuffer) {
  var bitsPerSample = _ref.bitsPerSample;

  switch (bitsPerSample) {
    case 8:
      return formatTypedBitArrayToFloatArray(new Int8Array(arrayBuffer), 128);

    case 16:
      return formatTypedBitArrayToFloatArray(new Int16Array(arrayBuffer), 32768);

    case 32:
      return formatTypedBitArrayToFloatArray(new Int32Array(arrayBuffer), 2147483648);

    default:
      throw new Error('Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time');
  }
}

function abortToReject(signal) {
  return new Promise(function (_, reject) {
    signal.onabort = function () {
      return reject(new Error('aborted'));
    };
  });
} // In a 2 channel audio (e.g. A/B), the data arrives as interleaved, like "ABABABABAB".
// This function will take "ABABABABAB" and return an array ["AAAAA", "BBBBB"].


function deinterleave(channelInterleavedAudioData, _ref2) {
  var channels = _ref2.channels;
  var multiChannelArrayBuffer = new Array(channels);
  var frameSize = channelInterleavedAudioData.length / channels;

  for (var channel = 0; channel < channels; channel++) {
    var audioData = new Float32Array(frameSize);
    multiChannelArrayBuffer[+channel] = audioData;

    for (var offset = 0; offset < frameSize; offset++) {
      audioData[+offset] = channelInterleavedAudioData[offset * channels + channel];
    }
  }

  return multiChannelArrayBuffer;
} // This function upsamples the audio data via an integer multiplier.
// Web Chat uses simple anti-aliasing. For simplicity, the anti-aliasing does not roll over to next buffer.


function multiplySampleRate(source, sampleRateMultiplier) {
  if (sampleRateMultiplier === 1) {
    return source;
  }

  var lastValues = new Array(sampleRateMultiplier).fill(source[0]);
  var target = new Float32Array(source.length * sampleRateMultiplier);

  for (var sourceOffset = 0; sourceOffset < source.length; sourceOffset++) {
    var value = source[+sourceOffset];
    var targetOffset = sourceOffset * sampleRateMultiplier;

    for (var multiplierIndex = 0; multiplierIndex < sampleRateMultiplier; multiplierIndex++) {
      lastValues.shift();
      lastValues.push(value);
      target[targetOffset + multiplierIndex] = average(lastValues);
    }
  }

  return target;
}

function playCognitiveServicesStream(_x, _x2) {
  return _playCognitiveServicesStream.apply(this, arguments);
}

function _playCognitiveServicesStream() {
  _playCognitiveServicesStream = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(audioContext, stream) {
    var _ref3,
        _ref3$signal,
        signal,
        queuedBufferSourceNodes,
        _args2 = arguments;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref3 = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {}, _ref3$signal = _ref3.signal, signal = _ref3$signal === void 0 ? {} : _ref3$signal;

            if (audioContext) {
              _context2.next = 5;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: audioContext must be specified.');

          case 5:
            if (stream) {
              _context2.next = 9;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream must be specified.');

          case 9:
            if (stream.format) {
              _context2.next = 13;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream is missing format.');

          case 13:
            if (!(typeof stream.read !== 'function')) {
              _context2.next = 15;
              break;
            }

            throw new Error('botframework-directlinespeech-sdk: stream is missing read().');

          case 15:
            queuedBufferSourceNodes = [];
            _context2.prev = 16;
            return _context2.delegateYield( /*#__PURE__*/_regenerator.default.mark(function _callee() {
              var format, abortPromise, array, read, samplesPerSec, newSamplesPerSec, sampleRateMultiplier, player, chunk, maxChunks, interleavedArray, multiChannelArray, upsampledMultiChannelArray;
              return _regenerator.default.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      format = stream.format;
                      abortPromise = abortToReject(signal);
                      array = new Uint8Array(DEFAULT_BUFFER_SIZE);

                      read = function read() {
                        return Promise.race([abortPromise.catch(function () {// Abort will gracefully end the queue. We will check signal.aborted later to throw abort exception.
                        }), stream.read(array.buffer).then(function (numBytes) {
                          return numBytes === array.byteLength ? array : numBytes ? array.slice(0, numBytes) : undefined;
                        })]);
                      };

                      if (!signal.aborted) {
                        _context.next = 6;
                        break;
                      }

                      throw new Error('aborted');

                    case 6:
                      samplesPerSec = format.samplesPerSec; // TODO: [P0] #3692 Remove the following if-condition block when the underlying bugs are resolved.
                      //       There is a bug in Speech SDK 1.15.0 that returns 24kHz instead of 16kHz.
                      //       Even if we explicitly specify the output audio format to 16kHz, there is another bug that ignored it.
                      //       In short, DLSpeech service currently always streams in RIFF WAV format, instead of MP3.
                      //       https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/313
                      //       https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/314

                      if (format.requestAudioFormatString === 'audio-24khz-48kbitrate-mono-mp3') {
                        samplesPerSec = 16000;
                      }

                      newSamplesPerSec = samplesPerSec;
                      sampleRateMultiplier = 1; // Safari requires a minimum sample rate of 22100 Hz.
                      // A multiplier is calculated the the data meets the minimum sample rate.
                      // An integer-based multiplier to simplify our upsampler.
                      // For security, data will only be upsampled up to 96000 Hz.

                      while (newSamplesPerSec < MIN_SAMPLE_RATE && newSamplesPerSec < 96000) {
                        sampleRateMultiplier++;
                        newSamplesPerSec = samplesPerSec * sampleRateMultiplier;
                      } // The third parameter is the sample size in bytes.
                      // For example, if the Speech SDK sends Web Chat 4096 bytes of 16-bit samples, there will be 2048 samples per channel.
                      // The multi-buffering player is set up to handle 2048 samples per buffer.
                      // If the multiplier 3x, it will handle 6144 samples per buffer.


                      player = (0, _createMultiBufferingPlayer.default)(audioContext, _objectSpread(_objectSpread({}, format), {}, {
                        samplesPerSec: newSamplesPerSec
                      }), DEFAULT_BUFFER_SIZE / (format.bitsPerSample / 8) * sampleRateMultiplier); // For security, the maximum number of chunks handled will be 1000.

                      _context.next = 14;
                      return read();

                    case 14:
                      chunk = _context.sent;
                      maxChunks = 0;

                    case 16:
                      if (!(chunk && maxChunks < 1000 && !signal.aborted)) {
                        _context.next = 29;
                        break;
                      }

                      if (!signal.aborted) {
                        _context.next = 19;
                        break;
                      }

                      return _context.abrupt("break", 29);

                    case 19:
                      // Data received from Speech SDK is interleaved; 2 channels (e.g. A and B) will be sent as "ABABABABAB"
                      // And each sample (A/B) will be an 8 to 32-bit number.
                      // Convert the 8 - 32-bit number into a floating-point number, as required by Web Audio API.
                      interleavedArray = formatAudioDataArrayBufferToFloatArray(format, chunk.buffer); // Deinterleave data back into two array buffer, e.g. "AAAAA" and "BBBBB".

                      multiChannelArray = deinterleave(interleavedArray, format); // Upsample data if necessary. If the multiplier is 2x, "AAAAA" will be upsampled to "AAAAAAAAAA" (with anti-alias).

                      upsampledMultiChannelArray = multiChannelArray.map(function (array) {
                        return multiplySampleRate(array, sampleRateMultiplier);
                      }); // Queue to the buffering player.

                      player.push(upsampledMultiChannelArray);

                    case 23:
                      _context.next = 25;
                      return read();

                    case 25:
                      chunk = _context.sent;
                      maxChunks++;
                      _context.next = 16;
                      break;

                    case 29:
                      abortPromise.catch(function () {
                        return player.cancelAll();
                      });

                      if (!signal.aborted) {
                        _context.next = 32;
                        break;
                      }

                      throw new Error('aborted');

                    case 32:
                      _context.next = 34;
                      return Promise.race([abortPromise, player.flush()]);

                    case 34:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            })(), "t0", 18);

          case 18:
            _context2.prev = 18;
            queuedBufferSourceNodes.forEach(function (node) {
              return node.stop();
            });
            return _context2.finish(18);

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[16,, 18, 21]]);
  }));
  return _playCognitiveServicesStream.apply(this, arguments);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9wbGF5Q29nbml0aXZlU2VydmljZXNTdHJlYW0uanMiXSwibmFtZXMiOlsiTUlOX1NBTVBMRV9SQVRFIiwiREVGQVVMVF9CVUZGRVJfU0laRSIsImF2ZXJhZ2UiLCJhcnJheSIsInJlZHVjZSIsInN1bSIsInZhbHVlIiwibGVuZ3RoIiwiZm9ybWF0VHlwZWRCaXRBcnJheVRvRmxvYXRBcnJheSIsImF1ZGlvRGF0YSIsIm1heFZhbHVlIiwiZmxvYXQzMkRhdGEiLCJGbG9hdDMyQXJyYXkiLCJpIiwiZm9ybWF0QXVkaW9EYXRhQXJyYXlCdWZmZXJUb0Zsb2F0QXJyYXkiLCJhcnJheUJ1ZmZlciIsImJpdHNQZXJTYW1wbGUiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkVycm9yIiwiYWJvcnRUb1JlamVjdCIsInNpZ25hbCIsIlByb21pc2UiLCJfIiwicmVqZWN0Iiwib25hYm9ydCIsImRlaW50ZXJsZWF2ZSIsImNoYW5uZWxJbnRlcmxlYXZlZEF1ZGlvRGF0YSIsImNoYW5uZWxzIiwibXVsdGlDaGFubmVsQXJyYXlCdWZmZXIiLCJBcnJheSIsImZyYW1lU2l6ZSIsImNoYW5uZWwiLCJvZmZzZXQiLCJtdWx0aXBseVNhbXBsZVJhdGUiLCJzb3VyY2UiLCJzYW1wbGVSYXRlTXVsdGlwbGllciIsImxhc3RWYWx1ZXMiLCJmaWxsIiwidGFyZ2V0Iiwic291cmNlT2Zmc2V0IiwidGFyZ2V0T2Zmc2V0IiwibXVsdGlwbGllckluZGV4Iiwic2hpZnQiLCJwdXNoIiwicGxheUNvZ25pdGl2ZVNlcnZpY2VzU3RyZWFtIiwiYXVkaW9Db250ZXh0Iiwic3RyZWFtIiwiZm9ybWF0IiwicmVhZCIsInF1ZXVlZEJ1ZmZlclNvdXJjZU5vZGVzIiwiYWJvcnRQcm9taXNlIiwiVWludDhBcnJheSIsInJhY2UiLCJjYXRjaCIsImJ1ZmZlciIsInRoZW4iLCJudW1CeXRlcyIsImJ5dGVMZW5ndGgiLCJzbGljZSIsInVuZGVmaW5lZCIsImFib3J0ZWQiLCJzYW1wbGVzUGVyU2VjIiwicmVxdWVzdEF1ZGlvRm9ybWF0U3RyaW5nIiwibmV3U2FtcGxlc1BlclNlYyIsInBsYXllciIsImNodW5rIiwibWF4Q2h1bmtzIiwiaW50ZXJsZWF2ZWRBcnJheSIsIm11bHRpQ2hhbm5lbEFycmF5IiwidXBzYW1wbGVkTXVsdGlDaGFubmVsQXJyYXkiLCJtYXAiLCJjYW5jZWxBbGwiLCJmbHVzaCIsImZvckVhY2giLCJub2RlIiwic3RvcCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBSUE7Ozs7OztBQUVBO0FBQ0E7QUFDQSxJQUFNQSxlQUFlLEdBQUcsS0FBeEIsQyxDQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBQ0EsSUFBTUMsbUJBQW1CLEdBQUcsSUFBNUI7O0FBRUEsU0FBU0MsT0FBVCxDQUFpQkMsS0FBakIsRUFBd0I7QUFDdEIsU0FBT0EsS0FBSyxDQUFDQyxNQUFOLENBQWEsVUFBQ0MsR0FBRCxFQUFNQyxLQUFOO0FBQUEsV0FBZ0JELEdBQUcsR0FBR0MsS0FBdEI7QUFBQSxHQUFiLEVBQTBDLENBQTFDLElBQStDSCxLQUFLLENBQUNJLE1BQTVEO0FBQ0Q7O0FBRUQsU0FBU0MsK0JBQVQsQ0FBeUNDLFNBQXpDLEVBQW9EQyxRQUFwRCxFQUE4RDtBQUM1RCxNQUFNQyxXQUFXLEdBQUcsSUFBSUMsWUFBSixDQUFpQkgsU0FBUyxDQUFDRixNQUEzQixDQUFwQjs7QUFFQSxPQUFLLElBQUlNLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdKLFNBQVMsQ0FBQ0YsTUFBOUIsRUFBc0NNLENBQUMsRUFBdkMsRUFBMkM7QUFDekNGLElBQUFBLFdBQVcsQ0FBQyxDQUFDRSxDQUFGLENBQVgsR0FBa0JKLFNBQVMsQ0FBQyxDQUFDSSxDQUFGLENBQVQsR0FBZ0JILFFBQWxDO0FBQ0Q7O0FBRUQsU0FBT0MsV0FBUDtBQUNEOztBQUVELFNBQVNHLHNDQUFULE9BQW1FQyxXQUFuRSxFQUFnRjtBQUFBLE1BQTlCQyxhQUE4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NEJBaUdILElBQUkxQyxLQUFKLENBQVUsU0FBVixDQWpHRzs7QUFBQTtBQUFBO0FBQUEsNkJBb0dMRyxPQUFPLENBQUMrQixJQUFSLENBQWEsQ0FBQ0YsWUFBRCxFQUFlYyxNQUFNLENBQUNRLEtBQVAsRUFBZixDQUFiLENBcEdLOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFzR1h2QixZQUFBQSx1QkFBdUIsQ0FBQ3dCLE9BQXhCLENBQWdDLFVBQUFDLElBQUk7QUFBQSxxQkFBSUEsSUFBSSxDQUFDQyxJQUFMLEVBQUo7QUFBQSxhQUFwQztBQXRHVzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHIiwic291cmNlUm9vdCI6ImRpcmVjdGxpbmVzcGVlY2g6Ly8vIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLW1hZ2ljLW51bWJlcnM6IFtcImVycm9yXCIsIHsgXCJpZ25vcmVcIjogWzAsIDEsIDgsIDE2LCAzMiwgMTI4LCAxMDAwLCAxNjAwMCwgMzI3NjgsIDk2MDAwLCAyMTQ3NDgzNjQ4XSB9XSAqL1xuLyogZXNsaW50IG5vLWF3YWl0LWluLWxvb3A6IFwib2ZmXCIgKi9cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogXCJvZmZcIiAqL1xuXG5pbXBvcnQgY3JlYXRlTXVsdGlCdWZmZXJpbmdQbGF5ZXIgZnJvbSAnLi9jcmVhdGVNdWx0aUJ1ZmZlcmluZ1BsYXllcic7XG5cbi8vIFNhZmFyaSByZXF1aXJlcyBhbiBhdWRpbyBidWZmZXIgd2l0aCBhIHNhbXBsZSByYXRlIG9mIDIyMDUwIEh6LlxuLy8gVXNpbmcgYSBtaW5pbXVtIHNhbXBsZSByYXRlIG9mIDQ0MTAwIEh6IGFzIGFuIGV4YW1wbGUsIHRoZSBTcGVlY2ggU0RLJ3MgZGVmYXVsdCAxNjAwMCBIeiB3aWxsIGJlIHVwc2FtcGxlZCB0byA0ODAwMCBIei5cbmNvbnN0IE1JTl9TQU1QTEVfUkFURSA9IDQ0MTAwO1xuXG4vLyBUaGUgU3BlZWNoIFNESyBpcyBoYXJkY29kZWQgdG8gY2hvcCBwYWNrZXRzIHRvIDQwOTYgYnl0ZXMuXG4vLyBXZWIgQ2hhdCdzIG11bHRpLWJ1ZmZlcmluZyBwbGF5ZXIgaXMgc2V0IHVwIHdpdGggMyBidWZmZXJzOyBlYWNoIGlzIDQwOTYgYnl0ZXMgKDIwNDggMTYtYml0IHNhbXBsZXMpLlxuLy8gRm9yIHNpbXBsaWNpdHksIHRoZSBtdWx0aS1idWZmZXIgcGxheWVyIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHByb2dyZXNzaXZlIGJ1ZmZlcmluZy5cblxuLy8gUHJvZ3Jlc3NpdmUgYnVmZmVyaW5nIGFsbG93cyBxdWV1aW5nIGF0IGFueSBzYW1wbGUgc2l6ZSBhbmQgd2lsbCBiZSBjb25jYXRlbmF0ZWQuXG4vLyBJZiAxMDAwIHNhbXBsZXMgYXJlIHF1ZXVlZCwgdGhlbiAxMDQ4IHNhbXBsZXMgYXJlIHF1ZXVlZCwgdGhleSB3aWxsIGJlIGNvbmNhdGVuYXRlZCBpbnRvIGEgc2luZ2xlIGJ1ZmZlciBvZiBzaXplIDIwNDguXG5cbi8vIEZvciBzaW1wbGljaXR5LCBkYXRhIHdpbGwgYmUgcXVldWVkIHRvIHR3byBidWZmZXJzLlxuLy8gVGhlIGZpcnN0IGJ1ZmZlciBpcyAxMDAwIHNhbXBsZXMgZm9sbG93ZWQgYnkgMTA0OCB6ZXJvZXMsIGFuZCB0aGUgc2Vjb25kIGJ1ZmZlciBpcyAxMDQ4IHNhbXBsZXMgZm9sbG93ZWQgYnkgMTAwMCB6ZXJvZXMuXG5cbi8vIFRoZXJlIGlzIG5vIHBsYW4gdG8gc3VwcG9ydCBwcm9ncmVzc2l2ZSBidWZmZXJpbmcgdW50aWwgdGhlIFNwZWVjaCBTREsgY2hvcHMgZGF0YSBhdCBkeW5hbWljIHNpemUuXG5jb25zdCBERUZBVUxUX0JVRkZFUl9TSVpFID0gNDA5NjtcblxuZnVuY3Rpb24gYXZlcmFnZShhcnJheSkge1xuICByZXR1cm4gYXJyYXkucmVkdWNlKChzdW0sIHZhbHVlKSA9PiBzdW0gKyB2YWx1ZSwgMCkgLyBhcnJheS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFR5cGVkQml0QXJyYXlUb0Zsb2F0QXJyYXkoYXVkaW9EYXRhLCBtYXhWYWx1ZSkge1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYXVkaW9EYXRhLmxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdWRpb0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBmbG9hdDMyRGF0YVsraV0gPSBhdWRpb0RhdGFbK2ldIC8gbWF4VmFsdWU7XG4gIH1cblxuICByZXR1cm4gZmxvYXQzMkRhdGE7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEF1ZGlvRGF0YUFycmF5QnVmZmVyVG9GbG9hdEFycmF5KHsgYml0c1BlclNhbXBsZSB9LCBhcnJheUJ1ZmZlcikge1xuICBzd2l0Y2ggKGJpdHNQZXJTYW1wbGUpIHtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gZm9ybWF0VHlwZWRCaXRBcnJheVRvRmxvYXRBcnJheShuZXcgSW50OEFycmF5KGFycmF5QnVmZmVyKSwgMTI4KTtcblxuICAgIGNhc2UgMTY6XG4gICAgICByZXR1cm4gZm9ybWF0VHlwZWRCaXRBcnJheVRvRmxvYXRBcnJheShuZXcgSW50MTZBcnJheShhcnJheUJ1ZmZlciksIDMyNzY4KTtcblxuICAgIGNhc2UgMzI6XG4gICAgICByZXR1cm4gZm9ybWF0VHlwZWRCaXRBcnJheVRvRmxvYXRBcnJheShuZXcgSW50MzJBcnJheShhcnJheUJ1ZmZlciksIDIxNDc0ODM2NDgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBXQVZFX0ZPUk1BVF9QQ00gKDgvMTYvMzIgYnBzKSBmb3JtYXQgc3VwcG9ydGVkIGF0IHRoaXMgdGltZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFib3J0VG9SZWplY3Qoc2lnbmFsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgc2lnbmFsLm9uYWJvcnQgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdhYm9ydGVkJykpO1xuICB9KTtcbn1cblxuLy8gSW4gYSAyIGNoYW5uZWwgYXVkaW8gKGUuZy4gQS9CKSwgdGhlIGRhdGEgYXJyaXZlcyBhcyBpbnRlcmxlYXZlZCwgbGlrZSBcIkFCQUJBQkFCQUJcIi5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCB0YWtlIFwiQUJBQkFCQUJBQlwiIGFuZCByZXR1cm4gYW4gYXJyYXkgW1wiQUFBQUFcIiwgXCJCQkJCQlwiXS5cbmZ1bmN0aW9uIGRlaW50ZXJsZWF2ZShjaGFubmVsSW50ZXJsZWF2ZWRBdWRpb0RhdGEsIHsgY2hhbm5lbHMgfSkge1xuICBjb25zdCBtdWx0aUNoYW5uZWxBcnJheUJ1ZmZlciA9IG5ldyBBcnJheShjaGFubmVscyk7XG4gIGNvbnN0IGZyYW1lU2l6ZSA9IGNoYW5uZWxJbnRlcmxlYXZlZEF1ZGlvRGF0YS5sZW5ndGggLyBjaGFubmVscztcblxuICBmb3IgKGxldCBjaGFubmVsID0gMDsgY2hhbm5lbCA8IGNoYW5uZWxzOyBjaGFubmVsKyspIHtcbiAgICBjb25zdCBhdWRpb0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGZyYW1lU2l6ZSk7XG5cbiAgICBtdWx0aUNoYW5uZWxBcnJheUJ1ZmZlclsrY2hhbm5lbF0gPSBhdWRpb0RhdGE7XG5cbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBmcmFtZVNpemU7IG9mZnNldCsrKSB7XG4gICAgICBhdWRpb0RhdGFbK29mZnNldF0gPSBjaGFubmVsSW50ZXJsZWF2ZWRBdWRpb0RhdGFbb2Zmc2V0ICogY2hhbm5lbHMgKyBjaGFubmVsXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbXVsdGlDaGFubmVsQXJyYXlCdWZmZXI7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gdXBzYW1wbGVzIHRoZSBhdWRpbyBkYXRhIHZpYSBhbiBpbnRlZ2VyIG11bHRpcGxpZXIuXG4vLyBXZWIgQ2hhdCB1c2VzIHNpbXBsZSBhbnRpLWFsaWFzaW5nLiBGb3Igc2ltcGxpY2l0eSwgdGhlIGFudGktYWxpYXNpbmcgZG9lcyBub3Qgcm9sbCBvdmVyIHRvIG5leHQgYnVmZmVyLlxuZnVuY3Rpb24gbXVsdGlwbHlTYW1wbGVSYXRlKHNvdXJjZSwgc2FtcGxlUmF0ZU11bHRpcGxpZXIpIHtcbiAgaWYgKHNhbXBsZVJhdGVNdWx0aXBsaWVyID09PSAxKSB7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGNvbnN0IGxhc3RWYWx1ZXMgPSBuZXcgQXJyYXkoc2FtcGxlUmF0ZU11bHRpcGxpZXIpLmZpbGwoc291cmNlWzBdKTtcbiAgY29uc3QgdGFyZ2V0ID0gbmV3IEZsb2F0MzJBcnJheShzb3VyY2UubGVuZ3RoICogc2FtcGxlUmF0ZU11bHRpcGxpZXIpO1xuXG4gIGZvciAobGV0IHNvdXJjZU9mZnNldCA9IDA7IHNvdXJjZU9mZnNldCA8IHNvdXJjZS5sZW5ndGg7IHNvdXJjZU9mZnNldCsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzb3VyY2VbK3NvdXJjZU9mZnNldF07XG4gICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gc291cmNlT2Zmc2V0ICogc2FtcGxlUmF0ZU11bHRpcGxpZXI7XG5cbiAgICBmb3IgKGxldCBtdWx0aXBsaWVySW5kZXggPSAwOyBtdWx0aXBsaWVySW5kZXggPCBzYW1wbGVSYXRlTXVsdGlwbGllcjsgbXVsdGlwbGllckluZGV4KyspIHtcbiAgICAgIGxhc3RWYWx1ZXMuc2hpZnQoKTtcbiAgICAgIGxhc3RWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB0YXJnZXRbdGFyZ2V0T2Zmc2V0ICsgbXVsdGlwbGllckluZGV4XSA9IGF2ZXJhZ2UobGFzdFZhbHVlcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcGxheUNvZ25pdGl2ZVNlcnZpY2VzU3RyZWFtKGF1ZGlvQ29udGV4dCwgc3RyZWFtLCB7IHNpZ25hbCA9IHt9IH0gPSB7fSkge1xuICBpZiAoIWF1ZGlvQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYm90ZnJhbWV3b3JrLWRpcmVjdGxpbmVzcGVlY2gtc2RrOiBhdWRpb0NvbnRleHQgbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG4gIH0gZWxzZSBpZiAoIXN0cmVhbSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYm90ZnJhbWV3b3JrLWRpcmVjdGxpbmVzcGVlY2gtc2RrOiBzdHJlYW0gbXVzdCBiZSBzcGVjaWZpZWQuJyk7XG4gIH0gZWxzZSBpZiAoIXN0cmVhbS5mb3JtYXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGZyYW1ld29yay1kaXJlY3RsaW5lc3BlZWNoLXNkazogc3RyZWFtIGlzIG1pc3NpbmcgZm9ybWF0LicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJlYW0ucmVhZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignYm90ZnJhbWV3b3JrLWRpcmVjdGxpbmVzcGVlY2gtc2RrOiBzdHJlYW0gaXMgbWlzc2luZyByZWFkKCkuJyk7XG4gIH1cblxuICBjb25zdCBxdWV1ZWRCdWZmZXJTb3VyY2VOb2RlcyA9IFtdO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBmb3JtYXQgfSA9IHN0cmVhbTtcbiAgICBjb25zdCBhYm9ydFByb21pc2UgPSBhYm9ydFRvUmVqZWN0KHNpZ25hbCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShERUZBVUxUX0JVRkZFUl9TSVpFKTtcblxuICAgIGNvbnN0IHJlYWQgPSAoKSA9PlxuICAgICAgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgYWJvcnRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvLyBBYm9ydCB3aWxsIGdyYWNlZnVsbHkgZW5kIHRoZSBxdWV1ZS4gV2Ugd2lsbCBjaGVjayBzaWduYWwuYWJvcnRlZCBsYXRlciB0byB0aHJvdyBhYm9ydCBleGNlcHRpb24uXG4gICAgICAgIH0pLFxuICAgICAgICBzdHJlYW1cbiAgICAgICAgICAucmVhZChhcnJheS5idWZmZXIpXG4gICAgICAgICAgLnRoZW4obnVtQnl0ZXMgPT4gKG51bUJ5dGVzID09PSBhcnJheS5ieXRlTGVuZ3RoID8gYXJyYXkgOiBudW1CeXRlcyA/IGFycmF5LnNsaWNlKDAsIG51bUJ5dGVzKSA6IHVuZGVmaW5lZCkpXG4gICAgICBdKTtcblxuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhYm9ydGVkJyk7XG4gICAgfVxuXG4gICAgbGV0IHsgc2FtcGxlc1BlclNlYyB9ID0gZm9ybWF0O1xuXG4gICAgLy8gVE9ETzogW1AwXSAjMzY5MiBSZW1vdmUgdGhlIGZvbGxvd2luZyBpZi1jb25kaXRpb24gYmxvY2sgd2hlbiB0aGUgdW5kZXJseWluZyBidWdzIGFyZSByZXNvbHZlZC5cbiAgICAvLyAgICAgICBUaGVyZSBpcyBhIGJ1ZyBpbiBTcGVlY2ggU0RLIDEuMTUuMCB0aGF0IHJldHVybnMgMjRrSHogaW5zdGVhZCBvZiAxNmtIei5cbiAgICAvLyAgICAgICBFdmVuIGlmIHdlIGV4cGxpY2l0bHkgc3BlY2lmeSB0aGUgb3V0cHV0IGF1ZGlvIGZvcm1hdCB0byAxNmtIeiwgdGhlcmUgaXMgYW5vdGhlciBidWcgdGhhdCBpZ25vcmVkIGl0LlxuICAgIC8vICAgICAgIEluIHNob3J0LCBETFNwZWVjaCBzZXJ2aWNlIGN1cnJlbnRseSBhbHdheXMgc3RyZWFtcyBpbiBSSUZGIFdBViBmb3JtYXQsIGluc3RlYWQgb2YgTVAzLlxuICAgIC8vICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvY29nbml0aXZlLXNlcnZpY2VzLXNwZWVjaC1zZGstanMvaXNzdWVzLzMxM1xuICAgIC8vICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvY29nbml0aXZlLXNlcnZpY2VzLXNwZWVjaC1zZGstanMvaXNzdWVzLzMxNFxuICAgIGlmIChmb3JtYXQucmVxdWVzdEF1ZGlvRm9ybWF0U3RyaW5nID09PSAnYXVkaW8tMjRraHotNDhrYml0cmF0ZS1tb25vLW1wMycpIHtcbiAgICAgIHNhbXBsZXNQZXJTZWMgPSAxNjAwMDtcbiAgICB9XG5cbiAgICBsZXQgbmV3U2FtcGxlc1BlclNlYyA9IHNhbXBsZXNQZXJTZWM7XG4gICAgbGV0IHNhbXBsZVJhdGVNdWx0aXBsaWVyID0gMTtcblxuICAgIC8vIFNhZmFyaSByZXF1aXJlcyBhIG1pbmltdW0gc2FtcGxlIHJhdGUgb2YgMjIxMDAgSHouXG4gICAgLy8gQSBtdWx0aXBsaWVyIGlzIGNhbGN1bGF0ZWQgdGhlIHRoZSBkYXRhIG1lZXRzIHRoZSBtaW5pbXVtIHNhbXBsZSByYXRlLlxuICAgIC8vIEFuIGludGVnZXItYmFzZWQgbXVsdGlwbGllciB0byBzaW1wbGlmeSBvdXIgdXBzYW1wbGVyLlxuICAgIC8vIEZvciBzZWN1cml0eSwgZGF0YSB3aWxsIG9ubHkgYmUgdXBzYW1wbGVkIHVwIHRvIDk2MDAwIEh6LlxuICAgIHdoaWxlIChuZXdTYW1wbGVzUGVyU2VjIDwgTUlOX1NBTVBMRV9SQVRFICYmIG5ld1NhbXBsZXNQZXJTZWMgPCA5NjAwMCkge1xuICAgICAgc2FtcGxlUmF0ZU11bHRpcGxpZXIrKztcbiAgICAgIG5ld1NhbXBsZXNQZXJTZWMgPSBzYW1wbGVzUGVyU2VjICogc2FtcGxlUmF0ZU11bHRpcGxpZXI7XG4gICAgfVxuXG4gICAgLy8gVGhlIHRoaXJkIHBhcmFtZXRlciBpcyB0aGUgc2FtcGxlIHNpemUgaW4gYnl0ZXMuXG4gICAgLy8gRm9yIGV4YW1wbGUsIGlmIHRoZSBTcGVlY2ggU0RLIHNlbmRzIFdlYiBDaGF0IDQwOTYgYnl0ZXMgb2YgMTYtYml0IHNhbXBsZXMsIHRoZXJlIHdpbGwgYmUgMjA0OCBzYW1wbGVzIHBlciBjaGFubmVsLlxuICAgIC8vIFRoZSBtdWx0aS1idWZmZXJpbmcgcGxheWVyIGlzIHNldCB1cCB0byBoYW5kbGUgMjA0OCBzYW1wbGVzIHBlciBidWZmZXIuXG4gICAgLy8gSWYgdGhlIG11bHRpcGxpZXIgM3gsIGl0IHdpbGwgaGFuZGxlIDYxNDQgc2FtcGxlcyBwZXIgYnVmZmVyLlxuICAgIGNvbnN0IHBsYXllciA9IGNyZWF0ZU11bHRpQnVmZmVyaW5nUGxheWVyKFxuICAgICAgYXVkaW9Db250ZXh0LFxuICAgICAgeyAuLi5mb3JtYXQsIHNhbXBsZXNQZXJTZWM6IG5ld1NhbXBsZXNQZXJTZWMgfSxcbiAgICAgIChERUZBVUxUX0JVRkZFUl9TSVpFIC8gKGZvcm1hdC5iaXRzUGVyU2FtcGxlIC8gOCkpICogc2FtcGxlUmF0ZU11bHRpcGxpZXJcbiAgICApO1xuXG4gICAgLy8gRm9yIHNlY3VyaXR5LCB0aGUgbWF4aW11bSBudW1iZXIgb2YgY2h1bmtzIGhhbmRsZWQgd2lsbCBiZSAxMDAwLlxuICAgIGZvciAoXG4gICAgICBsZXQgY2h1bmsgPSBhd2FpdCByZWFkKCksIG1heENodW5rcyA9IDA7XG4gICAgICBjaHVuayAmJiBtYXhDaHVua3MgPCAxMDAwICYmICFzaWduYWwuYWJvcnRlZDtcbiAgICAgIGNodW5rID0gYXdhaXQgcmVhZCgpLCBtYXhDaHVua3MrK1xuICAgICkge1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBEYXRhIHJlY2VpdmVkIGZyb20gU3BlZWNoIFNESyBpcyBpbnRlcmxlYXZlZDsgMiBjaGFubmVscyAoZS5nLiBBIGFuZCBCKSB3aWxsIGJlIHNlbnQgYXMgXCJBQkFCQUJBQkFCXCJcbiAgICAgIC8vIEFuZCBlYWNoIHNhbXBsZSAoQS9CKSB3aWxsIGJlIGFuIDggdG8gMzItYml0IG51bWJlci5cblxuICAgICAgLy8gQ29udmVydCB0aGUgOCAtIDMyLWJpdCBudW1iZXIgaW50byBhIGZsb2F0aW5nLXBvaW50IG51bWJlciwgYXMgcmVxdWlyZWQgYnkgV2ViIEF1ZGlvIEFQSS5cbiAgICAgIGNvbnN0IGludGVybGVhdmVkQXJyYXkgPSBmb3JtYXRBdWRpb0RhdGFBcnJheUJ1ZmZlclRvRmxvYXRBcnJheShmb3JtYXQsIGNodW5rLmJ1ZmZlcik7XG5cbiAgICAgIC8vIERlaW50ZXJsZWF2ZSBkYXRhIGJhY2sgaW50byB0d28gYXJyYXkgYnVmZmVyLCBlLmcuIFwiQUFBQUFcIiBhbmQgXCJCQkJCQlwiLlxuICAgICAgY29uc3QgbXVsdGlDaGFubmVsQXJyYXkgPSBkZWludGVybGVhdmUoaW50ZXJsZWF2ZWRBcnJheSwgZm9ybWF0KTtcblxuICAgICAgLy8gVXBzYW1wbGUgZGF0YSBpZiBuZWNlc3NhcnkuIElmIHRoZSBtdWx0aXBsaWVyIGlzIDJ4LCBcIkFBQUFBXCIgd2lsbCBiZSB1cHNhbXBsZWQgdG8gXCJBQUFBQUFBQUFBXCIgKHdpdGggYW50aS1hbGlhcykuXG4gICAgICBjb25zdCB1cHNhbXBsZWRNdWx0aUNoYW5uZWxBcnJheSA9IG11bHRpQ2hhbm5lbEFycmF5Lm1hcChhcnJheSA9PlxuICAgICAgICBtdWx0aXBseVNhbXBsZVJhdGUoYXJyYXksIHNhbXBsZVJhdGVNdWx0aXBsaWVyKVxuICAgICAgKTtcblxuICAgICAgLy8gUXVldWUgdG8gdGhlIGJ1ZmZlcmluZyBwbGF5ZXIuXG4gICAgICBwbGF5ZXIucHVzaCh1cHNhbXBsZWRNdWx0aUNoYW5uZWxBcnJheSk7XG4gICAgfVxuXG4gICAgYWJvcnRQcm9taXNlLmNhdGNoKCgpID0+IHBsYXllci5jYW5jZWxBbGwoKSk7XG5cbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWJvcnRlZCcpO1xuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRQcm9taXNlLCBwbGF5ZXIuZmx1c2goKV0pO1xuICB9IGZpbmFsbHkge1xuICAgIHF1ZXVlZEJ1ZmZlclNvdXJjZU5vZGVzLmZvckVhY2gobm9kZSA9PiBub2RlLnN0b3AoKSk7XG4gIH1cbn1cbiJdfQ==