"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _observable = _interopRequireDefault(require("core-js/features/observable"));

var _mathRandom = _interopRequireDefault(require("math-random"));

var _shareObservable = _interopRequireDefault(require("./shareObservable"));

var _SpeechSynthesisAudioStreamUtterance = _interopRequireDefault(require("./SpeechSynthesisAudioStreamUtterance"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function randomActivityId() {
  return (0, _mathRandom.default)().toString(36).substr(2);
}

var DirectLineSpeech = /*#__PURE__*/function () {
  function DirectLineSpeech(_ref) {
    var _this = this;

    var dialogServiceConnector = _ref.dialogServiceConnector;
    (0, _classCallCheck2.default)(this, DirectLineSpeech);
    var connectionStatusObserver;
    this.dialogServiceConnector = dialogServiceConnector;
    this.activity$ = (0, _shareObservable.default)(new _observable.default(function (observer) {
      _this._activityObserver = observer;
      connectionStatusObserver.next(0);
      connectionStatusObserver.next(1);
      dialogServiceConnector.connect(function () {
        connectionStatusObserver.next(2);
      }, function (error) {
        connectionStatusObserver.next(4);
        console.warn('botframework-directlinespeech-sdk: Failed to connect', {
          error: error
        });
      });
    }));
    this.connectionStatus$ = (0, _shareObservable.default)(new _observable.default(function (observer) {
      connectionStatusObserver = observer;
    }));

    dialogServiceConnector.activityReceived = function (_, _ref2) {
      var activity = _ref2.activity,
          audioStream = _ref2.audioStream;

      try {
        _this._activityObserver && _this._activityObserver.next(_objectSpread(_objectSpread({}, activity), {}, {
          channelData: _objectSpread(_objectSpread({}, activity.channelData), {}, {
            speechSynthesisUtterance: new _SpeechSynthesisAudioStreamUtterance.default(audioStream)
          }),
          from: _objectSpread(_objectSpread({}, activity.from), {}, {
            // Since DLSpeech service never ACK our outgoing activity, this activity must be from bot.
            role: 'bot'
          }),
          // Since DLSpeech never ACK our outgoing activity, the "replyToId" will rarely able to point to an existing activity.
          replyToId: undefined,
          // Direct Line Speech server currently do not timestamp outgoing activities.
          // Thus, it will be easier to just re-timestamp every incoming/outgoing activities using local time.
          timestamp: new Date().toISOString()
        }));
      } catch (error) {
        console.error(error);
      }
    };
  }

  (0, _createClass2.default)(DirectLineSpeech, [{
    key: "end",
    value: function end() {
      try {
        this.dialogServiceConnector.close();
      } catch (err) {
        if (!~err.message.indexOf('already disposed')) {
          throw err;
        }
      }
    }
  }, {
    key: "postActivity",
    value: function postActivity(activity) {
      // Currently, Web Chat set user ID on all outgoing activities.
      // As Direct Line Speech maintains its own user ID, Web Chat should not set the user ID.
      // TODO: [P2] We should move user ID into options of DirectLineJS, instead of Web Chat.
      activity = _objectSpread(_objectSpread({}, activity), {}, {
        from: {
          role: 'user'
        }
      });

      try {
        // TODO: [P1] Direct Line Speech server currently do not ack the outgoing activities with any activity ID or timestamp.
        var pseudoActivityId = randomActivityId();
        var isSpeech = !!(activity.channelData && activity.channelData.speech); // Do not send the activity if it was from speech.

        if (!isSpeech) {
          // Starting from Speech SDK 1.13.0, they accept JSON text instead of JavaScript object.
          // https://github.com/microsoft/cognitive-services-speech-sdk-js/commit/2f3a35446692b6d492a6c68e3237a48de67e293f
          this.dialogServiceConnector.sendActivityAsync(JSON.stringify(activity));
        }

        this._activityObserver && this._activityObserver.next(_objectSpread(_objectSpread({}, activity), {}, {
          id: pseudoActivityId,
          timestamp: new Date().toISOString()
        }));
        return _observable.default.of(pseudoActivityId);
      } catch (err) {
        return new _observable.default(function (observer) {
          return observer.error(err);
        });
      }
    }
  }]);
  return DirectLineSpeech;
}(); // Interfaces not yet implemented in Web Chat:
// referenceGrammarId?: string,
// getSessionId? : () => Observable<string>


exports.default = DirectLineSpeech;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9EaXJlY3RMaW5lU3BlZWNoLmpzIl0sIm5hbWVzIjpbInJhbmRvbUFjdGl2aXR5SWQiLCJ0b1N0cmluZyIsInN1YnN0ciIsIkRpcmVjdExpbmVTcGVlY2giLCJkaWFsb2dTZXJ2aWNlQ29ubmVjdG9yIiwiY29ubmVjdGlvblN0YXR1c09ic2VydmVyIiwiYWN0aXZpdHkkIiwiT2JzZXJ2YWJsZSIsIm9ic2VydmVyIiwiX2FjdGl2aXR5T2JzZXJ2ZXIiLCJuZXh0IiwiY29ubmVjdCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJjb25uZWN0aW9uU3RhdHVzJCIsImFjdGl2aXR5UmVjZWl2ZWQiLCJfIiwiYWN0aXZpdHkiLCJhdWRpb1N0cmVhbSIsImNoYW5uZWxEYXRhIiwic3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlIiwiU3BlZWNoU3ludGhlc2lzQXVkaW9TdHJlYW1VdHRlcmFuY2UiLCJmcm9tIiwicm9sZSIsInJlcGx5VG9JZCIsInVuZGVmaW5lZCIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImNsb3NlIiwiZXJyIiwibWVzc2FnZSIsImluZGV4T2YiLCJwc2V1ZG9BY3Rpdml0eUlkIiwiaXNTcGVlY2giLCJzcGVlY2giLCJzZW5kQWN0aXZpdHlBc3luYyIsIkpTT04iLCJzdHJpbmdpZnkiLCJpZCIsIm9mIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7O0FBRUEsU0FBU0EsZ0JBQVQsR0FBNEI7QUFDMUIsU0FBTywyQkFBU0MsUUFBVCxDQUFrQixFQUFsQixFQUFzQkMsTUFBdEIsQ0FBNkIsQ0FBN0IsQ0FBUDtBQUNEOztJQUVvQkMsZ0I7QUFDbkIsa0NBQXdDO0FBQUE7O0FBQUEsUUFBMUJDLHNCQUEwQixRQUExQkEsc0JBQTBCO0FBQUE7QUFDdEMsUUFBSUMsd0JBQUo7QUFFQSxTQUFLRCxzQkFBTCxHQUE4QkEsc0JBQTlCO0FBRUEsU0FBS0UsU0FBTCxHQUFpQiw4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TixnQkFGTjtBQUdFUCxVQUFBQSxTQUFTLEVBQUUsSUFBSUMsSUFBSixHQUFXQyxXQUFYO0FBSGIsV0FERjtBQU9BLGVBQU90QixvQkFBV2tDLEVBQVgsQ0FBY1AsZ0JBQWQsQ0FBUDtBQUNELE9BcEJELENBb0JFLE9BQU9ILEdBQVAsRUFBWTtBQUNaLGVBQU8sSUFBSXhCLG1CQUFKLENBQWUsVUFBQUMsUUFBUTtBQUFBLGlCQUFJQSxRQUFRLENBQUNJLEtBQVQsQ0FBZW1CLEdBQWYsQ0FBSjtBQUFBLFNBQXZCLENBQVA7QUFDRDtBQUNGOzs7S0FHSDtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiZGlyZWN0bGluZXNwZWVjaDovLy8iLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogW1wiZXJyb3JcIiwgeyBcImlnbm9yZVwiOiBbMCwgMSwgMiwgNCwgMzZdIH1dICovXG5cbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gJ2NvcmUtanMvZmVhdHVyZXMvb2JzZXJ2YWJsZSc7XG5pbXBvcnQgcmFuZG9tIGZyb20gJ21hdGgtcmFuZG9tJztcblxuaW1wb3J0IHNoYXJlT2JzZXJ2YWJsZSBmcm9tICcuL3NoYXJlT2JzZXJ2YWJsZSc7XG5pbXBvcnQgU3BlZWNoU3ludGhlc2lzQXVkaW9TdHJlYW1VdHRlcmFuY2UgZnJvbSAnLi9TcGVlY2hTeW50aGVzaXNBdWRpb1N0cmVhbVV0dGVyYW5jZSc7XG5cbmZ1bmN0aW9uIHJhbmRvbUFjdGl2aXR5SWQoKSB7XG4gIHJldHVybiByYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXJlY3RMaW5lU3BlZWNoIHtcbiAgY29uc3RydWN0b3IoeyBkaWFsb2dTZXJ2aWNlQ29ubmVjdG9yIH0pIHtcbiAgICBsZXQgY29ubmVjdGlvblN0YXR1c09ic2VydmVyO1xuXG4gICAgdGhpcy5kaWFsb2dTZXJ2aWNlQ29ubmVjdG9yID0gZGlhbG9nU2VydmljZUNvbm5lY3RvcjtcblxuICAgIHRoaXMuYWN0aXZpdHkkID0gc2hhcmVPYnNlcnZhYmxlKFxuICAgICAgbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgICAgICB0aGlzLl9hY3Rpdml0eU9ic2VydmVyID0gb2JzZXJ2ZXI7XG5cbiAgICAgICAgY29ubmVjdGlvblN0YXR1c09ic2VydmVyLm5leHQoMCk7XG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXNPYnNlcnZlci5uZXh0KDEpO1xuXG4gICAgICAgIGRpYWxvZ1NlcnZpY2VDb25uZWN0b3IuY29ubmVjdChcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uU3RhdHVzT2JzZXJ2ZXIubmV4dCgyKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25TdGF0dXNPYnNlcnZlci5uZXh0KDQpO1xuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2JvdGZyYW1ld29yay1kaXJlY3RsaW5lc3BlZWNoLXNkazogRmFpbGVkIHRvIGNvbm5lY3QnLCB7IGVycm9yIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuY29ubmVjdGlvblN0YXR1cyQgPSBzaGFyZU9ic2VydmFibGUoXG4gICAgICBuZXcgT2JzZXJ2YWJsZShvYnNlcnZlciA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXNPYnNlcnZlciA9IG9ic2VydmVyO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgZGlhbG9nU2VydmljZUNvbm5lY3Rvci5hY3Rpdml0eVJlY2VpdmVkID0gKF8sIHsgYWN0aXZpdHksIGF1ZGlvU3RyZWFtIH0pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2FjdGl2aXR5T2JzZXJ2ZXIgJiZcbiAgICAgICAgICB0aGlzLl9hY3Rpdml0eU9ic2VydmVyLm5leHQoe1xuICAgICAgICAgICAgLi4uYWN0aXZpdHksXG4gICAgICAgICAgICBjaGFubmVsRGF0YToge1xuICAgICAgICAgICAgICAuLi5hY3Rpdml0eS5jaGFubmVsRGF0YSxcbiAgICAgICAgICAgICAgc3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlOiBuZXcgU3BlZWNoU3ludGhlc2lzQXVkaW9TdHJlYW1VdHRlcmFuY2UoYXVkaW9TdHJlYW0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICAuLi5hY3Rpdml0eS5mcm9tLFxuICAgICAgICAgICAgICAvLyBTaW5jZSBETFNwZWVjaCBzZXJ2aWNlIG5ldmVyIEFDSyBvdXIgb3V0Z29pbmcgYWN0aXZpdHksIHRoaXMgYWN0aXZpdHkgbXVzdCBiZSBmcm9tIGJvdC5cbiAgICAgICAgICAgICAgcm9sZTogJ2JvdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBTaW5jZSBETFNwZWVjaCBuZXZlciBBQ0sgb3VyIG91dGdvaW5nIGFjdGl2aXR5LCB0aGUgXCJyZXBseVRvSWRcIiB3aWxsIHJhcmVseSBhYmxlIHRvIHBvaW50IHRvIGFuIGV4aXN0aW5nIGFjdGl2aXR5LlxuICAgICAgICAgICAgcmVwbHlUb0lkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAvLyBEaXJlY3QgTGluZSBTcGVlY2ggc2VydmVyIGN1cnJlbnRseSBkbyBub3QgdGltZXN0YW1wIG91dGdvaW5nIGFjdGl2aXRpZXMuXG4gICAgICAgICAgICAvLyBUaHVzLCBpdCB3aWxsIGJlIGVhc2llciB0byBqdXN0IHJlLXRpbWVzdGFtcCBldmVyeSBpbmNvbWluZy9vdXRnb2luZyBhY3Rpdml0aWVzIHVzaW5nIGxvY2FsIHRpbWUuXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGVuZCgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5kaWFsb2dTZXJ2aWNlQ29ubmVjdG9yLmNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIX5lcnIubWVzc2FnZS5pbmRleE9mKCdhbHJlYWR5IGRpc3Bvc2VkJykpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBvc3RBY3Rpdml0eShhY3Rpdml0eSkge1xuICAgIC8vIEN1cnJlbnRseSwgV2ViIENoYXQgc2V0IHVzZXIgSUQgb24gYWxsIG91dGdvaW5nIGFjdGl2aXRpZXMuXG4gICAgLy8gQXMgRGlyZWN0IExpbmUgU3BlZWNoIG1haW50YWlucyBpdHMgb3duIHVzZXIgSUQsIFdlYiBDaGF0IHNob3VsZCBub3Qgc2V0IHRoZSB1c2VyIElELlxuICAgIC8vIFRPRE86IFtQMl0gV2Ugc2hvdWxkIG1vdmUgdXNlciBJRCBpbnRvIG9wdGlvbnMgb2YgRGlyZWN0TGluZUpTLCBpbnN0ZWFkIG9mIFdlYiBDaGF0LlxuICAgIGFjdGl2aXR5ID0ge1xuICAgICAgLi4uYWN0aXZpdHksXG4gICAgICBmcm9tOiB7IHJvbGU6ICd1c2VyJyB9XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBUT0RPOiBbUDFdIERpcmVjdCBMaW5lIFNwZWVjaCBzZXJ2ZXIgY3VycmVudGx5IGRvIG5vdCBhY2sgdGhlIG91dGdvaW5nIGFjdGl2aXRpZXMgd2l0aCBhbnkgYWN0aXZpdHkgSUQgb3IgdGltZXN0YW1wLlxuICAgICAgY29uc3QgcHNldWRvQWN0aXZpdHlJZCA9IHJhbmRvbUFjdGl2aXR5SWQoKTtcbiAgICAgIGNvbnN0IGlzU3BlZWNoID0gISEoYWN0aXZpdHkuY2hhbm5lbERhdGEgJiYgYWN0aXZpdHkuY2hhbm5lbERhdGEuc3BlZWNoKTtcblxuICAgICAgLy8gRG8gbm90IHNlbmQgdGhlIGFjdGl2aXR5IGlmIGl0IHdhcyBmcm9tIHNwZWVjaC5cbiAgICAgIGlmICghaXNTcGVlY2gpIHtcbiAgICAgICAgLy8gU3RhcnRpbmcgZnJvbSBTcGVlY2ggU0RLIDEuMTMuMCwgdGhleSBhY2NlcHQgSlNPTiB0ZXh0IGluc3RlYWQgb2YgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvY29nbml0aXZlLXNlcnZpY2VzLXNwZWVjaC1zZGstanMvY29tbWl0LzJmM2EzNTQ0NjY5MmI2ZDQ5MmE2YzY4ZTMyMzdhNDhkZTY3ZTI5M2ZcbiAgICAgICAgdGhpcy5kaWFsb2dTZXJ2aWNlQ29ubmVjdG9yLnNlbmRBY3Rpdml0eUFzeW5jKEpTT04uc3RyaW5naWZ5KGFjdGl2aXR5KSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FjdGl2aXR5T2JzZXJ2ZXIgJiZcbiAgICAgICAgdGhpcy5fYWN0aXZpdHlPYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAuLi5hY3Rpdml0eSxcbiAgICAgICAgICBpZDogcHNldWRvQWN0aXZpdHlJZCxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgcmV0dXJuIE9ic2VydmFibGUub2YocHNldWRvQWN0aXZpdHlJZCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4gb2JzZXJ2ZXIuZXJyb3IoZXJyKSk7XG4gICAgfVxuICB9XG59XG5cbi8vIEludGVyZmFjZXMgbm90IHlldCBpbXBsZW1lbnRlZCBpbiBXZWIgQ2hhdDpcbi8vIHJlZmVyZW5jZUdyYW1tYXJJZD86IHN0cmluZyxcbi8vIGdldFNlc3Npb25JZD8gOiAoKSA9PiBPYnNlcnZhYmxlPHN0cmluZz5cbiJdfQ==