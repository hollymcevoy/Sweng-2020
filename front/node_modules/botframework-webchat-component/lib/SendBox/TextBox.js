"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.connectSendTextBox = void 0;
exports.useTextBoxSubmit = useTextBoxSubmit;
exports.useTextBoxValue = useTextBoxValue;

var _botframeworkWebchatApi = require("botframework-webchat-api");

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _detectBrowser = require("../Utils/detectBrowser");

var _AccessibleInputText = _interopRequireDefault(require("../Utils/AccessibleInputText"));

var _AutoResizeTextArea = _interopRequireDefault(require("./AutoResizeTextArea"));

var _connectToWebChat = _interopRequireDefault(require("../connectToWebChat"));

var _navigableEvent = _interopRequireDefault(require("../Utils/TypeFocusSink/navigableEvent"));

var _useFocus = _interopRequireDefault(require("../hooks/useFocus"));

var _useRegisterFocusSendBox = _interopRequireDefault(require("../hooks/internal/useRegisterFocusSendBox"));

var _useReplaceEmoticon = _interopRequireDefault(require("../hooks/internal/useReplaceEmoticon"));

var _useScrollDown = _interopRequireDefault(require("../hooks/useScrollDown"));

var _useScrollToEnd = _interopRequireDefault(require("../hooks/useScrollToEnd"));

var _useScrollUp = _interopRequireDefault(require("../hooks/useScrollUp"));

var _useStyleSet3 = _interopRequireDefault(require("../hooks/useStyleSet"));

var _useStyleToEmotionObject = _interopRequireDefault(require("../hooks/internal/useStyleToEmotionObject"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useDisabled = _botframeworkWebchatApi.hooks.useDisabled,
    useLocalizer = _botframeworkWebchatApi.hooks.useLocalizer,
    useSendBoxValue = _botframeworkWebchatApi.hooks.useSendBoxValue,
    useStopDictate = _botframeworkWebchatApi.hooks.useStopDictate,
    useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions,
    useSubmitSendBox = _botframeworkWebchatApi.hooks.useSubmitSendBox;
var ROOT_STYLE = {
  '&.webchat__send-box-text-box': {
    display: 'flex',
    '& .webchat__send-box-text-box__input, & .webchat__send-box-text-box__text-area': {
      flex: 1
    }
  }
};

var connectSendTextBox = function connectSendTextBox() {
  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {
    selectors[_key] = arguments[_key];
  }

  return _connectToWebChat.default.apply(void 0, [function (_ref) {
    var disabled = _ref.disabled,
        focusSendBox = _ref.focusSendBox,
        language = _ref.language,
        scrollToEnd = _ref.scrollToEnd,
        sendBoxValue = _ref.sendBoxValue,
        setSendBox = _ref.setSendBox,
        stopDictate = _ref.stopDictate,
        submitSendBox = _ref.submitSendBox;
    return {
      disabled: disabled,
      language: language,
      onChange: function onChange(_ref2) {
        var value = _ref2.target.value;
        setSendBox(value);
        stopDictate();
      },
      onKeyPress: function onKeyPress(event) {
        var key = event.key,
            shiftKey = event.shiftKey;

        if (key === 'Enter' && !shiftKey) {
          event.preventDefault();

          if (sendBoxValue) {
            scrollToEnd();
            submitSendBox();
            focusSendBox();
          }
        }
      },
      onSubmit: function onSubmit(event) {
        event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING
        // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box

        if (sendBoxValue) {
          scrollToEnd();
          submitSendBox();
        }
      },
      value: sendBoxValue
    };
  }].concat(selectors));
};

exports.connectSendTextBox = connectSendTextBox;

function useTextBoxSubmit() {
  var _useSendBoxValue = useSendBoxValue(),
      _useSendBoxValue2 = _slicedToArray(_useSendBoxValue, 1),
      sendBoxValue = _useSendBoxValue2[0];

  var focus = (0, _useFocus.default)();
  var scrollToEnd = (0, _useScrollToEnd.default)();
  var submitSendBox = useSubmitSendBox();
  return (0, _react.useCallback)(function (setFocus) {
    if (sendBoxValue) {
      scrollToEnd();
      submitSendBox();

      if (setFocus) {
        if (setFocus === true) {
          console.warn("\"botframework-webchat: Passing \"true\" to \"useTextBoxSubmit\" is deprecated and will be removed on or after 2022-04-23. Please pass \"sendBox\" instead.\"");
          focus('sendBox');
        } else {
          focus(setFocus);
        }
      }
    }

    return !!sendBoxValue;
  }, [focus, scrollToEnd, sendBoxValue, submitSendBox]);
}

function useTextBoxValue() {
  var _useSendBoxValue3 = useSendBoxValue(),
      _useSendBoxValue4 = _slicedToArray(_useSendBoxValue3, 2),
      value = _useSendBoxValue4[0],
      setValue = _useSendBoxValue4[1];

  var replaceEmoticon = (0, _useReplaceEmoticon.default)();
  var stopDictate = useStopDictate();
  var setter = (0, _react.useCallback)(function (nextValue) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        selectionEnd = _ref3.selectionEnd,
        selectionStart = _ref3.selectionStart;

    if (typeof nextValue !== 'string') {
      throw new Error('botframework-webchat: First argument passed to useTextBoxValue() must be a string.');
    } // Currently, we cannot detect whether the change is due to clipboard paste or pressing a key on the keyboard.
    // We should not change to emoji when the user is pasting text.
    // We would assume, for a single character addition, the user must be pressing a key.


    if (nextValue.length === value.length + 1) {
      var _replaceEmoticon = replaceEmoticon({
        selectionEnd: selectionEnd,
        selectionStart: selectionStart,
        value: nextValue
      }),
          nextSelectionEnd = _replaceEmoticon.selectionEnd,
          nextSelectionStart = _replaceEmoticon.selectionStart,
          nextValueWithEmoji = _replaceEmoticon.value;

      selectionEnd = nextSelectionEnd;
      selectionStart = nextSelectionStart;
      nextValue = nextValueWithEmoji;
    }

    setValue(nextValue);
    stopDictate();
    return {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: nextValue
    };
  }, [replaceEmoticon, setValue, stopDictate, value]);
  return [value, setter];
}

var PREVENT_DEFAULT_HANDLER = function PREVENT_DEFAULT_HANDLER(event) {
  return event.preventDefault();
};

var TextBox = function TextBox(_ref4) {
  var className = _ref4.className;

  var _useSendBoxValue5 = useSendBoxValue(),
      _useSendBoxValue6 = _slicedToArray(_useSendBoxValue5, 2),
      setSendBox = _useSendBoxValue6[1];

  var _useStyleSet = (0, _useStyleSet3.default)(),
      _useStyleSet2 = _slicedToArray(_useStyleSet, 1),
      sendBoxTextBoxStyleSet = _useStyleSet2[0].sendBoxTextBox;

  var _useStyleOptions = useStyleOptions(),
      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),
      sendBoxTextWrap = _useStyleOptions2[0].sendBoxTextWrap;

  var _useDisabled = useDisabled(),
      _useDisabled2 = _slicedToArray(_useDisabled, 1),
      disabled = _useDisabled2[0];

  var _useTextBoxValue = useTextBoxValue(),
      _useTextBoxValue2 = _slicedToArray(_useTextBoxValue, 2),
      textBoxValue = _useTextBoxValue2[0],
      setTextBoxValue = _useTextBoxValue2[1];

  var inputElementRef = (0, _react.useRef)();
  var localize = useLocalizer();
  var placeCheckpointOnChangeRef = (0, _react.useRef)(false);
  var prevInputStateRef = (0, _react.useRef)();
  var rootClassName = (0, _useStyleToEmotionObject.default)()(ROOT_STYLE) + '';
  var scrollDown = (0, _useScrollDown.default)();
  var scrollUp = (0, _useScrollUp.default)();
  var submitTextBox = useTextBoxSubmit();
  var undoStackRef = (0, _react.useRef)([]);
  var sendBoxString = localize('TEXT_INPUT_ALT');
  var typeYourMessageString = localize('TEXT_INPUT_PLACEHOLDER');
  var rememberInputState = (0, _react.useCallback)(function () {
    var _inputElementRef$curr = inputElementRef.current,
        selectionEnd = _inputElementRef$curr.selectionEnd,
        selectionStart = _inputElementRef$curr.selectionStart,
        value = _inputElementRef$curr.value;
    prevInputStateRef.current = {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: value
    };
  }, [inputElementRef, prevInputStateRef]); // This is for TypeFocusSink. When the focus in on the script, then starting press "a", without this line, it would cause errors.
  // We call rememberInputState() when "onFocus" event is fired, but since this is from TypeFocusSink, we are not able to receive "onFocus" event before it happen.

  (0, _react.useEffect)(rememberInputState, [rememberInputState]); // This is for moving the selection while setting the send box value.
  // If we only use setSendBox, we will need to wait for the next render cycle to get the value in, before we can set selectionEnd/Start.

  var setSelectionRangeAndValue = (0, _react.useCallback)(function (_ref5) {
    var selectionEnd = _ref5.selectionEnd,
        selectionStart = _ref5.selectionStart,
        value = _ref5.value;

    if (inputElementRef.current) {
      // We need to set the value, before selectionStart/selectionEnd.
      inputElementRef.current.value = value;
      inputElementRef.current.selectionStart = selectionStart;
      inputElementRef.current.selectionEnd = selectionEnd;
    }

    setSendBox(value);
  }, [inputElementRef, setSendBox]);
  var handleChange = (0, _react.useCallback)(function (event) {
    var _event$target = event.target,
        selectionEnd = _event$target.selectionEnd,
        selectionStart = _event$target.selectionStart,
        value = _event$target.value;

    if (placeCheckpointOnChangeRef.current) {
      undoStackRef.current.push(_objectSpread({}, prevInputStateRef.current));
      placeCheckpointOnChangeRef.current = false;
    }

    var nextInputState = setTextBoxValue(value, {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart
    }); // If an emoticon is converted to emoji, place another checkpoint.

    if (nextInputState.value !== value) {
      undoStackRef.current.push({
        selectionEnd: selectionEnd,
        selectionStart: selectionStart,
        value: value
      });
      placeCheckpointOnChangeRef.current = true;
      setSelectionRangeAndValue(nextInputState);
    }
  }, [placeCheckpointOnChangeRef, prevInputStateRef, setSelectionRangeAndValue, setTextBoxValue, undoStackRef]);
  var handleFocus = (0, _react.useCallback)(function () {
    rememberInputState();
    placeCheckpointOnChangeRef.current = true;
  }, [placeCheckpointOnChangeRef, rememberInputState]);
  var handleKeyDown = (0, _react.useCallback)(function (event) {
    var ctrlKey = event.ctrlKey,
        key = event.key,
        metaKey = event.metaKey;

    if ((ctrlKey || metaKey) && (key === 'Z' || key === 'z')) {
      event.preventDefault();
      var poppedInputState = undoStackRef.current.pop();

      if (poppedInputState) {
        prevInputStateRef.current = _objectSpread({}, poppedInputState);
      } else {
        prevInputStateRef.current = {
          selectionEnd: 0,
          selectionStart: 0,
          value: ''
        };
      }

      setSelectionRangeAndValue(prevInputStateRef.current);
    }
  }, [prevInputStateRef, setSelectionRangeAndValue, undoStackRef]);
  var handleKeyPress = (0, _react.useCallback)(function (event) {
    var key = event.key,
        shiftKey = event.shiftKey;

    if (key === 'Enter' && !shiftKey) {
      event.preventDefault(); // If text box is submitted, focus on the send box

      submitTextBox('sendBox'); // After submit, we will clear the undo stack.

      undoStackRef.current = [];
    }
  }, [submitTextBox, undoStackRef]);
  var handleSelect = (0, _react.useCallback)(function (_ref6) {
    var _ref6$target = _ref6.target,
        selectionEnd = _ref6$target.selectionEnd,
        selectionStart = _ref6$target.selectionStart,
        value = _ref6$target.value;

    if (value === prevInputStateRef.current.value) {
      // When caret move, we should push to undo stack on change.
      placeCheckpointOnChangeRef.current = true;
    }

    prevInputStateRef.current = {
      selectionEnd: selectionEnd,
      selectionStart: selectionStart,
      value: value
    };
  }, [placeCheckpointOnChangeRef, prevInputStateRef]);
  var handleSubmit = (0, _react.useCallback)(function (event) {
    event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING
    // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box

    submitTextBox(); // After submit, we will clear the undo stack.

    undoStackRef.current = [];
  }, [submitTextBox, undoStackRef]);
  var handleKeyDownCapture = (0, _react.useCallback)(function (event) {
    var ctrlKey = event.ctrlKey,
        metaKey = event.metaKey,
        shiftKey = event.shiftKey;

    if (ctrlKey || metaKey || shiftKey) {
      return;
    } // Navigable event means the end-user is focusing on an inputtable element, but it is okay to capture the arrow keys.


    if ((0, _navigableEvent.default)(event)) {
      var handled = true;

      switch (event.key) {
        case 'End':
          scrollDown({
            displacement: Infinity
          });
          break;

        case 'Home':
          scrollUp({
            displacement: Infinity
          });
          break;

        case 'PageDown':
          scrollDown();
          break;

        case 'PageUp':
          scrollUp();
          break;

        default:
          handled = false;
          break;
      }

      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }, [scrollDown, scrollUp]);
  var focusCallback = (0, _react.useCallback)(function () {
    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        noKeyboard = _ref7.noKeyboard;

    var current = inputElementRef.current;

    if (current) {
      // The "disable soft keyboard on mobile devices" logic will not work on IE11. It will cause the <input> to become read-only until next focus.
      // Thus, no mobile devices carry IE11 so we don't need to explicitly disable soft keyboard on IE11.
      // See #3757 for repro and details.
      if (noKeyboard && !_detectBrowser.ie11) {
        // To not activate the virtual keyboard while changing focus to an input, we will temporarily set it as read-only and flip it back.
        // https://stackoverflow.com/questions/7610758/prevent-iphone-default-keyboard-when-focusing-an-input/7610923
        var readOnly = current.getAttribute('readonly');
        current.setAttribute('readonly', 'readonly');
        setTimeout(function () {
          var current = inputElementRef.current;

          if (current) {
            current.focus();
            readOnly ? current.setAttribute('readonly', readOnly) : current.removeAttribute('readonly');
          }
        }, 0);
      } else {
        current.focus();
      }
    }
  }, [inputElementRef]);
  (0, _useRegisterFocusSendBox.default)(focusCallback);
  return /*#__PURE__*/_react.default.createElement("form", {
    "aria-disabled": disabled,
    className: (0, _classnames.default)('webchat__send-box-text-box', rootClassName, sendBoxTextBoxStyleSet + '', (className || '') + ''),
    onSubmit: disabled ? PREVENT_DEFAULT_HANDLER : handleSubmit
  }, !sendBoxTextWrap ? /*#__PURE__*/_react.default.createElement(_AccessibleInputText.default, {
    "aria-label": sendBoxString,
    className: "webchat__send-box-text-box__input",
    "data-id": "webchat-sendbox-input",
    disabled: disabled,
    enterKeyHint: "send",
    inputMode: "text",
    onChange: disabled ? undefined : handleChange,
    onFocus: disabled ? undefined : handleFocus,
    onKeyDown: disabled ? undefined : handleKeyDown,
    onKeyDownCapture: disabled ? undefined : handleKeyDownCapture,
    onKeyPress: disabled ? undefined : handleKeyPress,
    onSelect: disabled ? undefined : handleSelect,
    placeholder: typeYourMessageString,
    readOnly: disabled,
    ref: inputElementRef,
    type: "text",
    value: textBoxValue
  }) : /*#__PURE__*/_react.default.createElement(_AutoResizeTextArea.default, {
    "aria-label": sendBoxString,
    className: "webchat__send-box-text-box__text-area",
    "data-id": "webchat-sendbox-input",
    disabled: disabled,
    enterKeyHint: "send",
    inputMode: "text",
    onChange: disabled ? undefined : handleChange,
    onFocus: disabled ? undefined : handleFocus,
    onKeyDown: disabled ? undefined : handleKeyDown,
    onKeyDownCapture: disabled ? undefined : handleKeyDownCapture,
    onKeyPress: disabled ? undefined : handleKeyPress,
    onSelect: disabled ? undefined : handleSelect,
    placeholder: typeYourMessageString,
    readOnly: disabled,
    ref: inputElementRef,
    rows: 1,
    textAreaClassName: "webchat__send-box-text-box__html-text-area",
    value: textBoxValue
  }), disabled && /*#__PURE__*/_react.default.createElement("div", {
    className: "webchat__send-box-text-box__glass"
  }));
};

TextBox.defaultProps = {
  className: ''
};
TextBox.propTypes = {
  className: _propTypes.default.string
};
var _default = TextBox;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9TZW5kQm94L1RleHRCb3gudHN4Il0sIm5hbWVzIjpbInVzZURpc2FibGVkIiwiaG9va3MiLCJ1c2VMb2NhbGl6ZXIiLCJ1c2VTZW5kQm94VmFsdWUiLCJ1c2VTdG9wRGljdGF0ZSIsInVzZVN0eWxlT3B0aW9ucyIsInVzZVN1Ym1pdFNlbmRCb3giLCJST09UX1NUWUxFIiwiZGlzcGxheSIsImZsZXgiLCJjb25uZWN0U2VuZFRleHRCb3giLCJzZWxlY3RvcnMiLCJjb25uZWN0VG9XZWJDaGF0IiwiZGlzYWJsZWQiLCJmb2N1c1NlbmRCb3giLCJsYW5ndWFnZSIsInNjcm9sbFRvRW5kIiwic2VuZEJveFZhbHVlIiwic2V0U2VuZEJveCIsInN0b3BEaWN0YXRlIiwic3VibWl0U2VuZEJveCIsIm9uQ2hhbmdlIiwidmFsdWUiLCJ0YXJnZXQiLCJvbktleVByZXNzIiwiZXZlbnQiLCJrZXkiLCJzaGlmdEtleSIsInByZXZlbnREZWZhdWx0Iiwib25TdWJtaXQiLCJ1c2VUZXh0Qm94U3VibWl0IiwiZm9jdXMiLCJzZXRGb2N1cyIsImNvbnNvbGUiLCJ3YXJuIiwidXNlVGV4dEJveFZhbHVlIiwic2V0VmFsdWUiLCJyZXBsYWNlRW1vdGljb24iLCJzZXR0ZXIiLCJuZXh0VmFsdWUiLCJzZWxlY3Rpb25FbmQiLCJzZWxlY3Rpb25TdGFydCIsIkVycm9yIiwibGVuZ3RoIiwibmV4dFNlbGVjdGlvbkVuZCIsIm5leHRTZWxlY3Rpb25TdGFydCIsIm5leHRWYWx1ZVdpdGhFbW9qaSIsIlBSRVZFTlRfREVGQVVMVF9IQU5ETEVSIiwiVGV4dEJveCIsImNsYXNzTmFtZSIsInNlbmRCb3hUZXh0Qm94U3R5bGVTZXQiLCJzZW5kQm94VGV4dEJveCIsInNlbmRCb3hUZXh0V3JhcCIsInRleHRCb3hWYWx1ZSIsInNldFRleHRCb3hWYWx1ZSIsImlucHV0RWxlbWVudFJlZiIsImxvY2FsaXplIiwicGxhY2VDaGVja3BvaW50T25DaGFuZ2VSZWYiLCJwcmV2SW5wdXRTdGF0ZVJlZiIsInJvb3RDbGFzc05hbWUiLCJzY3JvbGxEb3duIiwic2Nyb2xsVXAiLCJzdWJtaXRUZXh0Qm94IiwidW5kb1N0YWNrUmVmIiwic2VuZEJveFN0cmluZyIsInR5cGVZb3VyTWVzc2FnZVN0cmluZyIsInJlbWVtYmVySW5wdXRTdGF0ZSIsImN1cnJlbnQiLCJzZXRTZWxlY3Rpb25SYW5nZUFuZFZhbHVlIiwiaGFuZGxlQ2hhbmdlIiwicHVzaCIsIm5leHRJbnB1dFN0YXRlIiwiaGFuZGxlRm9jdXMiLCJoYW5kbGVLZXlEb3duIiwiY3RybEtleSIsIm1ldGFLZXkiLCJwb3BwZWRJbnB1dFN0YXRlIiwicG9wIiwiaGFuZGxlS2V5UHJlc3MiLCJoYW5kbGVTZWxlY3QiLCJoYW5kbGVTdWJtaXQiLCJoYW5kbGVLZXlEb3duQ2FwdHVyZSIsImhhbmRsZWQiLCJkaXNwbGFjZW1lbnQiLCJJbmZpbml0eSIsInN0b3BQcm9wYWdhdGlvbiIsImZvY3VzQ2FsbGJhY2siLCJub0tleWJvYXJkIiwiaWUxMSIsInJlYWRPbmx5IiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwic2V0VGltZW91dCIsInJlbW92ZUF0dHJpYnV0ZSIsInVuZGVmaW5lZCIsImRlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsInN0cmluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFRQSxXQUFSLEdBQTBHQyw2QkFBMUcsQ0FBUUQsV0FBUjtBQUFBLElBQXFCRSxZQUFyQixHQUEwR0QsNkJBQTFHLENBQXFCQyxZQUFyQjtBQUFBLElBQW1DQyxlQUFuQyxHQUEwR0YsNkJBQTFHLENBQW1DRSxlQUFuQztBQUFBLElBQW9EQyxjQUFwRCxHQUEwR0gsNkJBQTFH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RTNELFFBQVEsR0FBR2lGLFNBQUgsR0FBZXJCLGFBVHBDO0FBVUUsSUFBQSxnQkFBZ0IsRUFBRTVELFFBQVEsR0FBR2lGLFNBQUgsR0FBZWIsb0JBVjNDO0FBV0UsSUFBQSxVQUFVLEVBQUVwRSxRQUFRLEdBQUdpRixTQUFILEdBQWVoQixjQVhyQztBQVlFLElBQUEsUUFBUSxFQUFFakUsUUFBUSxHQUFHaUYsU0FBSCxHQUFlZixZQVpuQztBQWFFLElBQUEsV0FBVyxFQUFFZCxxQkFiZjtBQWNFLElBQUEsUUFBUSxFQUFFcEQsUUFkWjtBQWVFLElBQUEsR0FBRyxFQUFFMEMsZUFmUDtBQWdCRSxJQUFBLElBQUksRUFBRSxDQWhCUjtBQWlCRSxJQUFBLGlCQUFpQixFQUFDLDRDQWpCcEI7QUFrQkUsSUFBQSxLQUFLLEVBQUVGO0FBbEJULElBL0JKLEVBb0RHeEMsUUFBUSxpQkFBSTtBQUFLLElBQUEsU0FBUyxFQUFDO0FBQWYsSUFwRGYsQ0FERjtBQXdERCxDQXhSRDs7QUEwUkFtQyxPQUFPLENBQUMrQyxZQUFSLEdBQXVCO0FBQ3JCOUMsRUFBQUEsU0FBUyxFQUFFO0FBRFUsQ0FBdkI7QUFJQUQsT0FBTyxDQUFDZ0QsU0FBUixHQUFvQjtBQUNsQi9DLEVBQUFBLFNBQVMsRUFBRWdELG1CQUFVQztBQURILENBQXBCO2VBSWVsRCxPIiwic291cmNlUm9vdCI6ImNvbXBvbmVudDovLy8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBob29rcyB9IGZyb20gJ2JvdGZyYW1ld29yay13ZWJjaGF0LWFwaSc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgTXV0YWJsZVJlZk9iamVjdCwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBpZTExIH0gZnJvbSAnLi4vVXRpbHMvZGV0ZWN0QnJvd3Nlcic7XG5pbXBvcnQgQWNjZXNzaWJsZUlucHV0VGV4dCBmcm9tICcuLi9VdGlscy9BY2Nlc3NpYmxlSW5wdXRUZXh0JztcbmltcG9ydCBBdXRvUmVzaXplVGV4dEFyZWEgZnJvbSAnLi9BdXRvUmVzaXplVGV4dEFyZWEnO1xuaW1wb3J0IGNvbm5lY3RUb1dlYkNoYXQgZnJvbSAnLi4vY29ubmVjdFRvV2ViQ2hhdCc7XG5pbXBvcnQgbmF2aWdhYmxlRXZlbnQgZnJvbSAnLi4vVXRpbHMvVHlwZUZvY3VzU2luay9uYXZpZ2FibGVFdmVudCc7XG5pbXBvcnQgdXNlRm9jdXMgZnJvbSAnLi4vaG9va3MvdXNlRm9jdXMnO1xuaW1wb3J0IHVzZVJlZ2lzdGVyRm9jdXNTZW5kQm94IGZyb20gJy4uL2hvb2tzL2ludGVybmFsL3VzZVJlZ2lzdGVyRm9jdXNTZW5kQm94JztcbmltcG9ydCB1c2VSZXBsYWNlRW1vdGljb24gZnJvbSAnLi4vaG9va3MvaW50ZXJuYWwvdXNlUmVwbGFjZUVtb3RpY29uJztcbmltcG9ydCB1c2VTY3JvbGxEb3duIGZyb20gJy4uL2hvb2tzL3VzZVNjcm9sbERvd24nO1xuaW1wb3J0IHVzZVNjcm9sbFRvRW5kIGZyb20gJy4uL2hvb2tzL3VzZVNjcm9sbFRvRW5kJztcbmltcG9ydCB1c2VTY3JvbGxVcCBmcm9tICcuLi9ob29rcy91c2VTY3JvbGxVcCc7XG5pbXBvcnQgdXNlU3R5bGVTZXQgZnJvbSAnLi4vaG9va3MvdXNlU3R5bGVTZXQnO1xuaW1wb3J0IHVzZVN0eWxlVG9FbW90aW9uT2JqZWN0IGZyb20gJy4uL2hvb2tzL2ludGVybmFsL3VzZVN0eWxlVG9FbW90aW9uT2JqZWN0JztcblxuY29uc3QgeyB1c2VEaXNhYmxlZCwgdXNlTG9jYWxpemVyLCB1c2VTZW5kQm94VmFsdWUsIHVzZVN0b3BEaWN0YXRlLCB1c2VTdHlsZU9wdGlvbnMsIHVzZVN1Ym1pdFNlbmRCb3ggfSA9IGhvb2tzO1xuXG5jb25zdCBST09UX1NUWUxFID0ge1xuICAnJi53ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveCc6IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG5cbiAgICAnJiAud2ViY2hhdF9fc2VuZC1ib3gtdGV4dC1ib3hfX2lucHV0LCAmIC53ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveF9fdGV4dC1hcmVhJzoge1xuICAgICAgZmxleDogMVxuICAgIH1cbiAgfVxufTtcblxuY29uc3QgY29ubmVjdFNlbmRUZXh0Qm94ID0gKC4uLnNlbGVjdG9ycykgPT5cbiAgY29ubmVjdFRvV2ViQ2hhdChcbiAgICAoeyBkaXNhYmxlZCwgZm9jdXNTZW5kQm94LCBsYW5ndWFnZSwgc2Nyb2xsVG9FbmQsIHNlbmRCb3hWYWx1ZSwgc2V0U2VuZEJveCwgc3RvcERpY3RhdGUsIHN1Ym1pdFNlbmRCb3ggfSkgPT4gKHtcbiAgICAgIGRpc2FibGVkLFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBvbkNoYW5nZTogKHsgdGFyZ2V0OiB7IHZhbHVlIH0gfSkgPT4ge1xuICAgICAgICBzZXRTZW5kQm94KHZhbHVlKTtcbiAgICAgICAgc3RvcERpY3RhdGUoKTtcbiAgICAgIH0sXG4gICAgICBvbktleVByZXNzOiBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBzaGlmdEtleSB9ID0gZXZlbnQ7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ0VudGVyJyAmJiAhc2hpZnRLZXkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgaWYgKHNlbmRCb3hWYWx1ZSkge1xuICAgICAgICAgICAgc2Nyb2xsVG9FbmQoKTtcbiAgICAgICAgICAgIHN1Ym1pdFNlbmRCb3goKTtcbiAgICAgICAgICAgIGZvY3VzU2VuZEJveCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uU3VibWl0OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gQ29uc2lkZXIgY2xlYXJpbmcgdGhlIHNlbmQgYm94IG9ubHkgYWZ0ZXIgd2UgcmVjZWl2ZWQgUE9TVF9BQ1RJVklUWV9QRU5ESU5HXG4gICAgICAgIC8vIEUuZy4gaWYgdGhlIGNvbm5lY3Rpb24gaXMgYmFkLCBzZW5kaW5nIHRoZSBtZXNzYWdlIGVzc2VudGlhbGx5IGRvIG5vdGhpbmcgYnV0IGp1c3QgY2xlYXJpbmcgdGhlIHNlbmQgYm94XG5cbiAgICAgICAgaWYgKHNlbmRCb3hWYWx1ZSkge1xuICAgICAgICAgIHNjcm9sbFRvRW5kKCk7XG4gICAgICAgICAgc3VibWl0U2VuZEJveCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmFsdWU6IHNlbmRCb3hWYWx1ZVxuICAgIH0pLFxuICAgIC4uLnNlbGVjdG9yc1xuICApO1xuXG5mdW5jdGlvbiB1c2VUZXh0Qm94U3VibWl0KCk6IChzZXRGb2N1cz86IGJvb2xlYW4gfCAnc2VuZEJveCcpID0+IHZvaWQge1xuICBjb25zdCBbc2VuZEJveFZhbHVlXSA9IHVzZVNlbmRCb3hWYWx1ZSgpO1xuICBjb25zdCBmb2N1cyA9IHVzZUZvY3VzKCk7XG4gIGNvbnN0IHNjcm9sbFRvRW5kID0gdXNlU2Nyb2xsVG9FbmQoKTtcbiAgY29uc3Qgc3VibWl0U2VuZEJveCA9IHVzZVN1Ym1pdFNlbmRCb3goKTtcblxuICByZXR1cm4gdXNlQ2FsbGJhY2soXG4gICAgc2V0Rm9jdXMgPT4ge1xuICAgICAgaWYgKHNlbmRCb3hWYWx1ZSkge1xuICAgICAgICBzY3JvbGxUb0VuZCgpO1xuICAgICAgICBzdWJtaXRTZW5kQm94KCk7XG5cbiAgICAgICAgaWYgKHNldEZvY3VzKSB7XG4gICAgICAgICAgaWYgKHNldEZvY3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGBcImJvdGZyYW1ld29yay13ZWJjaGF0OiBQYXNzaW5nIFwidHJ1ZVwiIHRvIFwidXNlVGV4dEJveFN1Ym1pdFwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBvbiBvciBhZnRlciAyMDIyLTA0LTIzLiBQbGVhc2UgcGFzcyBcInNlbmRCb3hcIiBpbnN0ZWFkLlwiYFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9jdXMoJ3NlbmRCb3gnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9jdXMoc2V0Rm9jdXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gISFzZW5kQm94VmFsdWU7XG4gICAgfSxcbiAgICBbZm9jdXMsIHNjcm9sbFRvRW5kLCBzZW5kQm94VmFsdWUsIHN1Ym1pdFNlbmRCb3hdXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVzZVRleHRCb3hWYWx1ZSgpOiBbXG4gIHN0cmluZyxcbiAgKFxuICAgIHRleHRCb3hWYWx1ZTogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHsgc2VsZWN0aW9uRW5kOiBudW1iZXI7IHNlbGVjdGlvblN0YXJ0OiBudW1iZXIgfVxuICApID0+IHsgc2VsZWN0aW9uRW5kOiBudW1iZXI7IHNlbGVjdGlvblN0YXJ0OiBudW1iZXI7IHZhbHVlOiBzdHJpbmcgfVxuXSB7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU2VuZEJveFZhbHVlKCk7XG4gIGNvbnN0IHJlcGxhY2VFbW90aWNvbiA9IHVzZVJlcGxhY2VFbW90aWNvbigpO1xuICBjb25zdCBzdG9wRGljdGF0ZSA9IHVzZVN0b3BEaWN0YXRlKCk7XG5cbiAgY29uc3Qgc2V0dGVyID0gdXNlQ2FsbGJhY2soXG4gICAgKG5leHRWYWx1ZSwgeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0IH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0VmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYm90ZnJhbWV3b3JrLXdlYmNoYXQ6IEZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byB1c2VUZXh0Qm94VmFsdWUoKSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgICAgfVxuXG4gICAgICAvLyBDdXJyZW50bHksIHdlIGNhbm5vdCBkZXRlY3Qgd2hldGhlciB0aGUgY2hhbmdlIGlzIGR1ZSB0byBjbGlwYm9hcmQgcGFzdGUgb3IgcHJlc3NpbmcgYSBrZXkgb24gdGhlIGtleWJvYXJkLlxuICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBjaGFuZ2UgdG8gZW1vamkgd2hlbiB0aGUgdXNlciBpcyBwYXN0aW5nIHRleHQuXG4gICAgICAvLyBXZSB3b3VsZCBhc3N1bWUsIGZvciBhIHNpbmdsZSBjaGFyYWN0ZXIgYWRkaXRpb24sIHRoZSB1c2VyIG11c3QgYmUgcHJlc3NpbmcgYSBrZXkuXG4gICAgICBpZiAobmV4dFZhbHVlLmxlbmd0aCA9PT0gdmFsdWUubGVuZ3RoICsgMSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2VsZWN0aW9uRW5kOiBuZXh0U2VsZWN0aW9uRW5kLFxuICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiBuZXh0U2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgdmFsdWU6IG5leHRWYWx1ZVdpdGhFbW9qaVxuICAgICAgICB9ID0gcmVwbGFjZUVtb3RpY29uKHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCwgdmFsdWU6IG5leHRWYWx1ZSB9KTtcblxuICAgICAgICBzZWxlY3Rpb25FbmQgPSBuZXh0U2VsZWN0aW9uRW5kO1xuICAgICAgICBzZWxlY3Rpb25TdGFydCA9IG5leHRTZWxlY3Rpb25TdGFydDtcbiAgICAgICAgbmV4dFZhbHVlID0gbmV4dFZhbHVlV2l0aEVtb2ppO1xuICAgICAgfVxuXG4gICAgICBzZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgICAgc3RvcERpY3RhdGUoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0aW9uRW5kLFxuICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgdmFsdWU6IG5leHRWYWx1ZVxuICAgICAgfTtcbiAgICB9LFxuICAgIFtyZXBsYWNlRW1vdGljb24sIHNldFZhbHVlLCBzdG9wRGljdGF0ZSwgdmFsdWVdXG4gICk7XG5cbiAgcmV0dXJuIFt2YWx1ZSwgc2V0dGVyXTtcbn1cblxuY29uc3QgUFJFVkVOVF9ERUZBVUxUX0hBTkRMRVIgPSBldmVudCA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5jb25zdCBUZXh0Qm94ID0gKHsgY2xhc3NOYW1lIH0pID0+IHtcbiAgY29uc3QgWywgc2V0U2VuZEJveF0gPSB1c2VTZW5kQm94VmFsdWUoKTtcbiAgY29uc3QgW3sgc2VuZEJveFRleHRCb3g6IHNlbmRCb3hUZXh0Qm94U3R5bGVTZXQgfV0gPSB1c2VTdHlsZVNldCgpO1xuICBjb25zdCBbeyBzZW5kQm94VGV4dFdyYXAgfV0gPSB1c2VTdHlsZU9wdGlvbnMoKTtcbiAgY29uc3QgW2Rpc2FibGVkXSA9IHVzZURpc2FibGVkKCk7XG4gIGNvbnN0IFt0ZXh0Qm94VmFsdWUsIHNldFRleHRCb3hWYWx1ZV0gPSB1c2VUZXh0Qm94VmFsdWUoKTtcbiAgY29uc3QgaW5wdXRFbGVtZW50UmVmOiBNdXRhYmxlUmVmT2JqZWN0PEhUTUxJbnB1dEVsZW1lbnQgJiBIVE1MVGV4dEFyZWFFbGVtZW50PiA9IHVzZVJlZigpO1xuICBjb25zdCBsb2NhbGl6ZSA9IHVzZUxvY2FsaXplcigpO1xuICBjb25zdCBwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHByZXZJbnB1dFN0YXRlUmVmOiBNdXRhYmxlUmVmT2JqZWN0PHtcbiAgICBzZWxlY3Rpb25FbmQ6IG51bWJlcjtcbiAgICBzZWxlY3Rpb25TdGFydDogbnVtYmVyO1xuICAgIHZhbHVlOiBzdHJpbmc7XG4gIH0+ID0gdXNlUmVmKCk7XG4gIGNvbnN0IHJvb3RDbGFzc05hbWUgPSB1c2VTdHlsZVRvRW1vdGlvbk9iamVjdCgpKFJPT1RfU1RZTEUpICsgJyc7XG4gIGNvbnN0IHNjcm9sbERvd24gPSB1c2VTY3JvbGxEb3duKCk7XG4gIGNvbnN0IHNjcm9sbFVwID0gdXNlU2Nyb2xsVXAoKTtcbiAgY29uc3Qgc3VibWl0VGV4dEJveCA9IHVzZVRleHRCb3hTdWJtaXQoKTtcbiAgY29uc3QgdW5kb1N0YWNrUmVmID0gdXNlUmVmKFtdKTtcblxuICBjb25zdCBzZW5kQm94U3RyaW5nID0gbG9jYWxpemUoJ1RFWFRfSU5QVVRfQUxUJyk7XG4gIGNvbnN0IHR5cGVZb3VyTWVzc2FnZVN0cmluZyA9IGxvY2FsaXplKCdURVhUX0lOUFVUX1BMQUNFSE9MREVSJyk7XG5cbiAgY29uc3QgcmVtZW1iZXJJbnB1dFN0YXRlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnQ6IHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCwgdmFsdWUgfVxuICAgIH0gPSBpbnB1dEVsZW1lbnRSZWY7XG5cbiAgICBwcmV2SW5wdXRTdGF0ZVJlZi5jdXJyZW50ID0geyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZSB9O1xuICB9LCBbaW5wdXRFbGVtZW50UmVmLCBwcmV2SW5wdXRTdGF0ZVJlZl0pO1xuXG4gIC8vIFRoaXMgaXMgZm9yIFR5cGVGb2N1c1NpbmsuIFdoZW4gdGhlIGZvY3VzIGluIG9uIHRoZSBzY3JpcHQsIHRoZW4gc3RhcnRpbmcgcHJlc3MgXCJhXCIsIHdpdGhvdXQgdGhpcyBsaW5lLCBpdCB3b3VsZCBjYXVzZSBlcnJvcnMuXG4gIC8vIFdlIGNhbGwgcmVtZW1iZXJJbnB1dFN0YXRlKCkgd2hlbiBcIm9uRm9jdXNcIiBldmVudCBpcyBmaXJlZCwgYnV0IHNpbmNlIHRoaXMgaXMgZnJvbSBUeXBlRm9jdXNTaW5rLCB3ZSBhcmUgbm90IGFibGUgdG8gcmVjZWl2ZSBcIm9uRm9jdXNcIiBldmVudCBiZWZvcmUgaXQgaGFwcGVuLlxuICB1c2VFZmZlY3QocmVtZW1iZXJJbnB1dFN0YXRlLCBbcmVtZW1iZXJJbnB1dFN0YXRlXSk7XG5cbiAgLy8gVGhpcyBpcyBmb3IgbW92aW5nIHRoZSBzZWxlY3Rpb24gd2hpbGUgc2V0dGluZyB0aGUgc2VuZCBib3ggdmFsdWUuXG4gIC8vIElmIHdlIG9ubHkgdXNlIHNldFNlbmRCb3gsIHdlIHdpbGwgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCByZW5kZXIgY3ljbGUgdG8gZ2V0IHRoZSB2YWx1ZSBpbiwgYmVmb3JlIHdlIGNhbiBzZXQgc2VsZWN0aW9uRW5kL1N0YXJ0LlxuICBjb25zdCBzZXRTZWxlY3Rpb25SYW5nZUFuZFZhbHVlID0gdXNlQ2FsbGJhY2soXG4gICAgKHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCwgdmFsdWUgfSkgPT4ge1xuICAgICAgaWYgKGlucHV0RWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc2V0IHRoZSB2YWx1ZSwgYmVmb3JlIHNlbGVjdGlvblN0YXJ0L3NlbGVjdGlvbkVuZC5cbiAgICAgICAgaW5wdXRFbGVtZW50UmVmLmN1cnJlbnQudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpbnB1dEVsZW1lbnRSZWYuY3VycmVudC5zZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBpbnB1dEVsZW1lbnRSZWYuY3VycmVudC5zZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICB9XG5cbiAgICAgIHNldFNlbmRCb3godmFsdWUpO1xuICAgIH0sXG4gICAgW2lucHV0RWxlbWVudFJlZiwgc2V0U2VuZEJveF1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldDogeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZSB9XG4gICAgICB9ID0gZXZlbnQ7XG5cbiAgICAgIGlmIChwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZi5jdXJyZW50KSB7XG4gICAgICAgIHVuZG9TdGFja1JlZi5jdXJyZW50LnB1c2goeyAuLi5wcmV2SW5wdXRTdGF0ZVJlZi5jdXJyZW50IH0pO1xuXG4gICAgICAgIHBsYWNlQ2hlY2twb2ludE9uQ2hhbmdlUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV4dElucHV0U3RhdGUgPSBzZXRUZXh0Qm94VmFsdWUodmFsdWUsIHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCB9KTtcblxuICAgICAgLy8gSWYgYW4gZW1vdGljb24gaXMgY29udmVydGVkIHRvIGVtb2ppLCBwbGFjZSBhbm90aGVyIGNoZWNrcG9pbnQuXG4gICAgICBpZiAobmV4dElucHV0U3RhdGUudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHVuZG9TdGFja1JlZi5jdXJyZW50LnB1c2goeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZSB9KTtcblxuICAgICAgICBwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZi5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgICBzZXRTZWxlY3Rpb25SYW5nZUFuZFZhbHVlKG5leHRJbnB1dFN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZiwgcHJldklucHV0U3RhdGVSZWYsIHNldFNlbGVjdGlvblJhbmdlQW5kVmFsdWUsIHNldFRleHRCb3hWYWx1ZSwgdW5kb1N0YWNrUmVmXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJlbWVtYmVySW5wdXRTdGF0ZSgpO1xuXG4gICAgcGxhY2VDaGVja3BvaW50T25DaGFuZ2VSZWYuY3VycmVudCA9IHRydWU7XG4gIH0sIFtwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZiwgcmVtZW1iZXJJbnB1dFN0YXRlXSk7XG5cbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKFxuICAgIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHsgY3RybEtleSwga2V5LCBtZXRhS2V5IH0gPSBldmVudDtcblxuICAgICAgaWYgKChjdHJsS2V5IHx8IG1ldGFLZXkpICYmIChrZXkgPT09ICdaJyB8fCBrZXkgPT09ICd6JykpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjb25zdCBwb3BwZWRJbnB1dFN0YXRlID0gdW5kb1N0YWNrUmVmLmN1cnJlbnQucG9wKCk7XG5cbiAgICAgICAgaWYgKHBvcHBlZElucHV0U3RhdGUpIHtcbiAgICAgICAgICBwcmV2SW5wdXRTdGF0ZVJlZi5jdXJyZW50ID0geyAuLi5wb3BwZWRJbnB1dFN0YXRlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldklucHV0U3RhdGVSZWYuY3VycmVudCA9IHsgc2VsZWN0aW9uRW5kOiAwLCBzZWxlY3Rpb25TdGFydDogMCwgdmFsdWU6ICcnIH07XG4gICAgICAgIH1cblxuICAgICAgICBzZXRTZWxlY3Rpb25SYW5nZUFuZFZhbHVlKHByZXZJbnB1dFN0YXRlUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3ByZXZJbnB1dFN0YXRlUmVmLCBzZXRTZWxlY3Rpb25SYW5nZUFuZFZhbHVlLCB1bmRvU3RhY2tSZWZdXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlS2V5UHJlc3MgPSB1c2VDYWxsYmFjayhcbiAgICBldmVudCA9PiB7XG4gICAgICBjb25zdCB7IGtleSwgc2hpZnRLZXkgfSA9IGV2ZW50O1xuXG4gICAgICBpZiAoa2V5ID09PSAnRW50ZXInICYmICFzaGlmdEtleSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIC8vIElmIHRleHQgYm94IGlzIHN1Ym1pdHRlZCwgZm9jdXMgb24gdGhlIHNlbmQgYm94XG4gICAgICAgIHN1Ym1pdFRleHRCb3goJ3NlbmRCb3gnKTtcblxuICAgICAgICAvLyBBZnRlciBzdWJtaXQsIHdlIHdpbGwgY2xlYXIgdGhlIHVuZG8gc3RhY2suXG4gICAgICAgIHVuZG9TdGFja1JlZi5jdXJyZW50ID0gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBbc3VibWl0VGV4dEJveCwgdW5kb1N0YWNrUmVmXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZVNlbGVjdCA9IHVzZUNhbGxiYWNrKFxuICAgICh7IHRhcmdldDogeyBzZWxlY3Rpb25FbmQsIHNlbGVjdGlvblN0YXJ0LCB2YWx1ZSB9IH0pID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gcHJldklucHV0U3RhdGVSZWYuY3VycmVudC52YWx1ZSkge1xuICAgICAgICAvLyBXaGVuIGNhcmV0IG1vdmUsIHdlIHNob3VsZCBwdXNoIHRvIHVuZG8gc3RhY2sgb24gY2hhbmdlLlxuICAgICAgICBwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcHJldklucHV0U3RhdGVSZWYuY3VycmVudCA9IHsgc2VsZWN0aW9uRW5kLCBzZWxlY3Rpb25TdGFydCwgdmFsdWUgfTtcbiAgICB9LFxuICAgIFtwbGFjZUNoZWNrcG9pbnRPbkNoYW5nZVJlZiwgcHJldklucHV0U3RhdGVSZWZdXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gQ29uc2lkZXIgY2xlYXJpbmcgdGhlIHNlbmQgYm94IG9ubHkgYWZ0ZXIgd2UgcmVjZWl2ZWQgUE9TVF9BQ1RJVklUWV9QRU5ESU5HXG4gICAgICAvLyBFLmcuIGlmIHRoZSBjb25uZWN0aW9uIGlzIGJhZCwgc2VuZGluZyB0aGUgbWVzc2FnZSBlc3NlbnRpYWxseSBkbyBub3RoaW5nIGJ1dCBqdXN0IGNsZWFyaW5nIHRoZSBzZW5kIGJveFxuICAgICAgc3VibWl0VGV4dEJveCgpO1xuXG4gICAgICAvLyBBZnRlciBzdWJtaXQsIHdlIHdpbGwgY2xlYXIgdGhlIHVuZG8gc3RhY2suXG4gICAgICB1bmRvU3RhY2tSZWYuY3VycmVudCA9IFtdO1xuICAgIH0sXG4gICAgW3N1Ym1pdFRleHRCb3gsIHVuZG9TdGFja1JlZl1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVLZXlEb3duQ2FwdHVyZSA9IHVzZUNhbGxiYWNrKFxuICAgIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHsgY3RybEtleSwgbWV0YUtleSwgc2hpZnRLZXkgfSA9IGV2ZW50O1xuXG4gICAgICBpZiAoY3RybEtleSB8fCBtZXRhS2V5IHx8IHNoaWZ0S2V5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTmF2aWdhYmxlIGV2ZW50IG1lYW5zIHRoZSBlbmQtdXNlciBpcyBmb2N1c2luZyBvbiBhbiBpbnB1dHRhYmxlIGVsZW1lbnQsIGJ1dCBpdCBpcyBva2F5IHRvIGNhcHR1cmUgdGhlIGFycm93IGtleXMuXG4gICAgICBpZiAobmF2aWdhYmxlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIGxldCBoYW5kbGVkID0gdHJ1ZTtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgIGNhc2UgJ0VuZCc6XG4gICAgICAgICAgICBzY3JvbGxEb3duKHsgZGlzcGxhY2VtZW50OiBJbmZpbml0eSB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSG9tZSc6XG4gICAgICAgICAgICBzY3JvbGxVcCh7IGRpc3BsYWNlbWVudDogSW5maW5pdHkgfSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1BhZ2VEb3duJzpcbiAgICAgICAgICAgIHNjcm9sbERvd24oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnUGFnZVVwJzpcbiAgICAgICAgICAgIHNjcm9sbFVwKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBoYW5kbGVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW3Njcm9sbERvd24sIHNjcm9sbFVwXVxuICApO1xuXG4gIGNvbnN0IGZvY3VzQ2FsbGJhY2sgPSB1c2VDYWxsYmFjayhcbiAgICAoeyBub0tleWJvYXJkIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSBpbnB1dEVsZW1lbnRSZWY7XG5cbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIC8vIFRoZSBcImRpc2FibGUgc29mdCBrZXlib2FyZCBvbiBtb2JpbGUgZGV2aWNlc1wiIGxvZ2ljIHdpbGwgbm90IHdvcmsgb24gSUUxMS4gSXQgd2lsbCBjYXVzZSB0aGUgPGlucHV0PiB0byBiZWNvbWUgcmVhZC1vbmx5IHVudGlsIG5leHQgZm9jdXMuXG4gICAgICAgIC8vIFRodXMsIG5vIG1vYmlsZSBkZXZpY2VzIGNhcnJ5IElFMTEgc28gd2UgZG9uJ3QgbmVlZCB0byBleHBsaWNpdGx5IGRpc2FibGUgc29mdCBrZXlib2FyZCBvbiBJRTExLlxuICAgICAgICAvLyBTZWUgIzM3NTcgZm9yIHJlcHJvIGFuZCBkZXRhaWxzLlxuICAgICAgICBpZiAobm9LZXlib2FyZCAmJiAhaWUxMSkge1xuICAgICAgICAgIC8vIFRvIG5vdCBhY3RpdmF0ZSB0aGUgdmlydHVhbCBrZXlib2FyZCB3aGlsZSBjaGFuZ2luZyBmb2N1cyB0byBhbiBpbnB1dCwgd2Ugd2lsbCB0ZW1wb3JhcmlseSBzZXQgaXQgYXMgcmVhZC1vbmx5IGFuZCBmbGlwIGl0IGJhY2suXG4gICAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzYxMDc1OC9wcmV2ZW50LWlwaG9uZS1kZWZhdWx0LWtleWJvYXJkLXdoZW4tZm9jdXNpbmctYW4taW5wdXQvNzYxMDkyM1xuICAgICAgICAgIGNvbnN0IHJlYWRPbmx5ID0gY3VycmVudC5nZXRBdHRyaWJ1dGUoJ3JlYWRvbmx5Jyk7XG5cbiAgICAgICAgICBjdXJyZW50LnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAncmVhZG9ubHknKTtcblxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSBpbnB1dEVsZW1lbnRSZWY7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgcmVhZE9ubHkgPyBjdXJyZW50LnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCByZWFkT25seSkgOiBjdXJyZW50LnJlbW92ZUF0dHJpYnV0ZSgncmVhZG9ubHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFtpbnB1dEVsZW1lbnRSZWZdXG4gICk7XG5cbiAgdXNlUmVnaXN0ZXJGb2N1c1NlbmRCb3goZm9jdXNDYWxsYmFjayk7XG5cbiAgcmV0dXJuIChcbiAgICA8Zm9ybVxuICAgICAgYXJpYS1kaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZXMoXG4gICAgICAgICd3ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveCcsXG4gICAgICAgIHJvb3RDbGFzc05hbWUsXG4gICAgICAgIHNlbmRCb3hUZXh0Qm94U3R5bGVTZXQgKyAnJyxcbiAgICAgICAgKGNsYXNzTmFtZSB8fCAnJykgKyAnJ1xuICAgICAgKX1cbiAgICAgIG9uU3VibWl0PXtkaXNhYmxlZCA/IFBSRVZFTlRfREVGQVVMVF9IQU5ETEVSIDogaGFuZGxlU3VibWl0fVxuICAgID5cbiAgICAgIHshc2VuZEJveFRleHRXcmFwID8gKFxuICAgICAgICA8QWNjZXNzaWJsZUlucHV0VGV4dFxuICAgICAgICAgIGFyaWEtbGFiZWw9e3NlbmRCb3hTdHJpbmd9XG4gICAgICAgICAgY2xhc3NOYW1lPVwid2ViY2hhdF9fc2VuZC1ib3gtdGV4dC1ib3hfX2lucHV0XCJcbiAgICAgICAgICBkYXRhLWlkPVwid2ViY2hhdC1zZW5kYm94LWlucHV0XCJcbiAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgZW50ZXJLZXlIaW50PVwic2VuZFwiXG4gICAgICAgICAgaW5wdXRNb2RlPVwidGV4dFwiXG4gICAgICAgICAgb25DaGFuZ2U9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIG9uRm9jdXM9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlRm9jdXN9XG4gICAgICAgICAgb25LZXlEb3duPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZUtleURvd259XG4gICAgICAgICAgb25LZXlEb3duQ2FwdHVyZT17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVLZXlEb3duQ2FwdHVyZX1cbiAgICAgICAgICBvbktleVByZXNzPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZUtleVByZXNzfVxuICAgICAgICAgIG9uU2VsZWN0PXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZVNlbGVjdH1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17dHlwZVlvdXJNZXNzYWdlU3RyaW5nfVxuICAgICAgICAgIHJlYWRPbmx5PXtkaXNhYmxlZH1cbiAgICAgICAgICByZWY9e2lucHV0RWxlbWVudFJlZn1cbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgdmFsdWU9e3RleHRCb3hWYWx1ZX1cbiAgICAgICAgLz5cbiAgICAgICkgOiAoXG4gICAgICAgIDxBdXRvUmVzaXplVGV4dEFyZWFcbiAgICAgICAgICBhcmlhLWxhYmVsPXtzZW5kQm94U3RyaW5nfVxuICAgICAgICAgIGNsYXNzTmFtZT1cIndlYmNoYXRfX3NlbmQtYm94LXRleHQtYm94X190ZXh0LWFyZWFcIlxuICAgICAgICAgIGRhdGEtaWQ9XCJ3ZWJjaGF0LXNlbmRib3gtaW5wdXRcIlxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBlbnRlcktleUhpbnQ9XCJzZW5kXCJcbiAgICAgICAgICBpbnB1dE1vZGU9XCJ0ZXh0XCJcbiAgICAgICAgICBvbkNoYW5nZT17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgb25Gb2N1cz17ZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBoYW5kbGVGb2N1c31cbiAgICAgICAgICBvbktleURvd249e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlS2V5RG93bn1cbiAgICAgICAgICBvbktleURvd25DYXB0dXJlPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZUtleURvd25DYXB0dXJlfVxuICAgICAgICAgIG9uS2V5UHJlc3M9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlS2V5UHJlc3N9XG4gICAgICAgICAgb25TZWxlY3Q9e2Rpc2FibGVkID8gdW5kZWZpbmVkIDogaGFuZGxlU2VsZWN0fVxuICAgICAgICAgIHBsYWNlaG9sZGVyPXt0eXBlWW91ck1lc3NhZ2VTdHJpbmd9XG4gICAgICAgICAgcmVhZE9ubHk9e2Rpc2FibGVkfVxuICAgICAgICAgIHJlZj17aW5wdXRFbGVtZW50UmVmfVxuICAgICAgICAgIHJvd3M9ezF9XG4gICAgICAgICAgdGV4dEFyZWFDbGFzc05hbWU9XCJ3ZWJjaGF0X19zZW5kLWJveC10ZXh0LWJveF9faHRtbC10ZXh0LWFyZWFcIlxuICAgICAgICAgIHZhbHVlPXt0ZXh0Qm94VmFsdWV9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgICAge2Rpc2FibGVkICYmIDxkaXYgY2xhc3NOYW1lPVwid2ViY2hhdF9fc2VuZC1ib3gtdGV4dC1ib3hfX2dsYXNzXCIgLz59XG4gICAgPC9mb3JtPlxuICApO1xufTtcblxuVGV4dEJveC5kZWZhdWx0UHJvcHMgPSB7XG4gIGNsYXNzTmFtZTogJydcbn07XG5cblRleHRCb3gucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRCb3g7XG5cbmV4cG9ydCB7IGNvbm5lY3RTZW5kVGV4dEJveCwgdXNlVGV4dEJveFN1Ym1pdCwgdXNlVGV4dEJveFZhbHVlIH07XG4iXX0=