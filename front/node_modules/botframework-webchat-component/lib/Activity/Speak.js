"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.connectSpeakActivity = void 0;

var _botframeworkWebchatApi = require("botframework-webchat-api");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _reactSay = _interopRequireWildcard(require("react-say"));

var _connectToWebChat = _interopRequireDefault(require("../connectToWebChat"));

var _SayAlt = _interopRequireDefault(require("./SayAlt"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useMarkActivityAsSpoken = _botframeworkWebchatApi.hooks.useMarkActivityAsSpoken,
    useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions,
    useVoiceSelector = _botframeworkWebchatApi.hooks.useVoiceSelector; // TODO: [P4] Consider moving this feature into BasicActivity
//       And it has better DOM position for showing visual spoken text
// TODO: [P3] We should add a "spoken" or "speakState" flag to indicate whether this activity is going to speak, or spoken

var connectSpeakActivity = function connectSpeakActivity() {
  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {
    selectors[_key] = arguments[_key];
  }

  return _connectToWebChat.default.apply(void 0, [function (_ref, _ref2) {
    var language = _ref.language,
        markActivity = _ref.markActivity,
        _selectVoice = _ref.selectVoice;
    var activity = _ref2.activity;
    return {
      language: language,
      markAsSpoken: function markAsSpoken() {
        return markActivity(activity, 'speak', false);
      },
      selectVoice: function selectVoice(voices) {
        return _selectVoice(voices, activity);
      }
    };
  }].concat(selectors));
};

exports.connectSpeakActivity = connectSpeakActivity;

var Speak = function Speak(_ref3) {
  var activity = _ref3.activity;

  var _useStyleOptions = useStyleOptions(),
      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),
      showSpokenText = _useStyleOptions2[0].showSpokenText;

  var markActivityAsSpoken = useMarkActivityAsSpoken();
  var selectVoice = useVoiceSelector(activity);
  var markAsSpoken = (0, _react.useCallback)(function () {
    markActivityAsSpoken(activity);
  }, [activity, markActivityAsSpoken]);
  var singleLine = (0, _react.useMemo)(function () {
    var _activity$attachments = activity.attachments,
        attachments = _activity$attachments === void 0 ? [] : _activity$attachments,
        speak = activity.speak,
        text = activity.text;
    return !!activity && [speak || text].concat(_toConsumableArray(attachments.filter(function (_ref4) {
      var contentType = _ref4.contentType;
      return contentType === 'application/vnd.microsoft.card.adaptive';
    }).map(function (attachment) {
      var _attachment$content;

      return attachment === null || attachment === void 0 ? void 0 : (_attachment$content = attachment.content) === null || _attachment$content === void 0 ? void 0 : _attachment$content.speak;
    }))).filter(function (line) {
      return line;
    }).join('\r\n');
  }, [activity]);
  var _activity$channelData = activity.channelData;
  _activity$channelData = _activity$channelData === void 0 ? {} : _activity$channelData;
  var speechSynthesisUtterance = _activity$channelData.speechSynthesisUtterance;
  return !!activity && /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, speechSynthesisUtterance ? /*#__PURE__*/_react.default.createElement(_reactSay.SayUtterance, {
    onEnd: markAsSpoken,
    onError: markAsSpoken,
    utterance: speechSynthesisUtterance
  }) : /*#__PURE__*/_react.default.createElement(_reactSay.default, {
    onEnd: markAsSpoken,
    onError: markAsSpoken,
    text: singleLine,
    voice: selectVoice
  }), !!showSpokenText && /*#__PURE__*/_react.default.createElement(_SayAlt.default, {
    speak: singleLine
  }));
};

Speak.propTypes = {
  activity: _propTypes.default.shape({
    attachments: _propTypes.default.arrayOf(_propTypes.default.shape({
      speak: _propTypes.default.string,
      subtitle: _propTypes.default.string,
      text: _propTypes.default.string,
      title: _propTypes.default.string
    })),
    channelData: _propTypes.default.shape({
      speechSynthesisUtterance: _propTypes.default.any
    }),
    speak: _propTypes.default.string,
    text: _propTypes.default.string
  }).isRequired
};
var _default = Speak;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9BY3Rpdml0eS9TcGVhay50c3giXSwibmFtZXMiOlsidXNlTWFya0FjdGl2aXR5QXNTcG9rZW4iLCJob29rcyIsInVzZVN0eWxlT3B0aW9ucyIsInVzZVZvaWNlU2VsZWN0b3IiLCJjb25uZWN0U3BlYWtBY3Rpdml0eSIsInNlbGVjdG9ycyIsImNvbm5lY3RUb1dlYkNoYXQiLCJsYW5ndWFnZSIsIm1hcmtBY3Rpdml0eSIsInNlbGVjdFZvaWNlIiwiYWN0aXZpdHkiLCJtYXJrQXNTcG9rZW4iLCJ2b2ljZXMiLCJTcGVhayIsInNob3dTcG9rZW5UZXh0IiwibWFya0FjdGl2aXR5QXNTcG9rZW4iLCJzaW5nbGVMaW5lIiwiYXR0YWNobWVudHMiLCJzcGVhayIsInRleHQiLCJmaWx0ZXIiLCJjb250ZW50VHlwZSIsIm1hcCIsImF0dGFjaG1lbnQiLCJjb250ZW50IiwibGluZSIsImpvaW4iLCJjaGFubmVsRGF0YSIsInNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsInNoYXBlIiwiYXJyYXlPZiIsInN0cmluZyIsInN1YnRpdGxlIiwidGl0bGUiLCJhbnkiLCJpc1JlcXVpcmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLElBQVFBLHVCQUFSLEdBQXVFQyw2QkFBdkUsQ0FBUUQsdUJBQVI7QUFBQSxJQUFpQ0UsZUFBakMsR0FBdUVELDZCQUF2RSxDQUFpQ0MsZUFBakM7QUFBQSxJQUFrREMsZ0JBQWxELEdBQXVFRiw2QkFBdkUsQ0FBa0RFLGdCQUFsRCxDLENBRUE7QUFDQTtBQUVBOztBQUNBLElBQU1DLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBdUI7QUFBQSxvQ0FBSUMsU0FBSjtBQUFJQSxJQUFBQSxTQUFKO0FBQUE7O0FBQUEsU0FDM0JDLHlDQUNFO0FBQUEsUUFBR0MsUUFBSCxR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RW9CLG1CQUFVQyxLQUFWLENBQWdCO0FBQ3hCZCxJQUFBQSxXQUFXLEVBQUVhLG1CQUFVRSxPQUFWLENBQ1hGLG1CQUFVQyxLQUFWLENBQWdCO0FBQ2RiLE1BQUFBLEtBQUssRUFBRVksbUJBQVVHLE1BREg7QUFFZEMsTUFBQUEsUUFBUSxFQUFFSixtQkFBVUcsTUFGTjtBQUdkZCxNQUFBQSxJQUFJLEVBQUVXLG1CQUFVRyxNQUhGO0FBSWRFLE1BQUFBLEtBQUssRUFBRUwsbUJBQVVHO0FBSkgsS0FBaEIsQ0FEVyxDQURXO0FBU3hCTixJQUFBQSxXQUFXLEVBQUVHLG1CQUFVQyxLQUFWLENBQWdCO0FBQzNCSCxNQUFBQSx3QkFBd0IsRUFBRUUsbUJBQVVNO0FBRFQsS0FBaEIsQ0FUVztBQVl4QmxCLElBQUFBLEtBQUssRUFBRVksbUJBQVVHLE1BWk87QUFheEJkLElBQUFBLElBQUksRUFBRVcsbUJBQVVHO0FBYlEsR0FBaEIsRUFjUEk7QUFmYSxDQUFsQjtlQWtCZXhCLEsiLCJzb3VyY2VSb290IjoiY29tcG9uZW50Oi8vLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdExpbmVBY3Rpdml0eSB9IGZyb20gJ2JvdGZyYW1ld29yay13ZWJjaGF0LWNvcmUnO1xuaW1wb3J0IHsgaG9va3MgfSBmcm9tICdib3RmcmFtZXdvcmstd2ViY2hhdC1hcGknO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyBGQywgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgU2F5LCB7IFNheVV0dGVyYW5jZSB9IGZyb20gJ3JlYWN0LXNheSc7XG5cbmltcG9ydCBjb25uZWN0VG9XZWJDaGF0IGZyb20gJy4uL2Nvbm5lY3RUb1dlYkNoYXQnO1xuaW1wb3J0IFNheUFsdCBmcm9tICcuL1NheUFsdCc7XG5cbmNvbnN0IHsgdXNlTWFya0FjdGl2aXR5QXNTcG9rZW4sIHVzZVN0eWxlT3B0aW9ucywgdXNlVm9pY2VTZWxlY3RvciB9ID0gaG9va3M7XG5cbi8vIFRPRE86IFtQNF0gQ29uc2lkZXIgbW92aW5nIHRoaXMgZmVhdHVyZSBpbnRvIEJhc2ljQWN0aXZpdHlcbi8vICAgICAgIEFuZCBpdCBoYXMgYmV0dGVyIERPTSBwb3NpdGlvbiBmb3Igc2hvd2luZyB2aXN1YWwgc3Bva2VuIHRleHRcblxuLy8gVE9ETzogW1AzXSBXZSBzaG91bGQgYWRkIGEgXCJzcG9rZW5cIiBvciBcInNwZWFrU3RhdGVcIiBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBhY3Rpdml0eSBpcyBnb2luZyB0byBzcGVhaywgb3Igc3Bva2VuXG5jb25zdCBjb25uZWN0U3BlYWtBY3Rpdml0eSA9ICguLi5zZWxlY3RvcnMpID0+XG4gIGNvbm5lY3RUb1dlYkNoYXQoXG4gICAgKHsgbGFuZ3VhZ2UsIG1hcmtBY3Rpdml0eSwgc2VsZWN0Vm9pY2UgfSwgeyBhY3Rpdml0eSB9KSA9PiAoe1xuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBtYXJrQXNTcG9rZW46ICgpID0+IG1hcmtBY3Rpdml0eShhY3Rpdml0eSwgJ3NwZWFrJywgZmFsc2UpLFxuICAgICAgc2VsZWN0Vm9pY2U6IHZvaWNlcyA9PiBzZWxlY3RWb2ljZSh2b2ljZXMsIGFjdGl2aXR5KVxuICAgIH0pLFxuICAgIC4uLnNlbGVjdG9yc1xuICApO1xuXG50eXBlIFNwZWFrUHJvcHMgPSB7XG4gIGFjdGl2aXR5OiBEaXJlY3RMaW5lQWN0aXZpdHk7XG59O1xuXG5jb25zdCBTcGVhazogRkM8U3BlYWtQcm9wcz4gPSAoeyBhY3Rpdml0eSB9KSA9PiB7XG4gIGNvbnN0IFt7IHNob3dTcG9rZW5UZXh0IH1dID0gdXNlU3R5bGVPcHRpb25zKCk7XG4gIGNvbnN0IG1hcmtBY3Rpdml0eUFzU3Bva2VuID0gdXNlTWFya0FjdGl2aXR5QXNTcG9rZW4oKTtcbiAgY29uc3Qgc2VsZWN0Vm9pY2UgPSB1c2VWb2ljZVNlbGVjdG9yKGFjdGl2aXR5KTtcblxuICBjb25zdCBtYXJrQXNTcG9rZW4gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgbWFya0FjdGl2aXR5QXNTcG9rZW4oYWN0aXZpdHkpO1xuICB9LCBbYWN0aXZpdHksIG1hcmtBY3Rpdml0eUFzU3Bva2VuXSk7XG5cbiAgY29uc3Qgc2luZ2xlTGluZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHsgYXR0YWNobWVudHMgPSBbXSwgc3BlYWssIHRleHQgfSA9IGFjdGl2aXR5O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICEhYWN0aXZpdHkgJiZcbiAgICAgIFtcbiAgICAgICAgc3BlYWsgfHwgdGV4dCxcbiAgICAgICAgLi4uYXR0YWNobWVudHNcbiAgICAgICAgICAuZmlsdGVyKCh7IGNvbnRlbnRUeXBlIH0pID0+IGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vdm5kLm1pY3Jvc29mdC5jYXJkLmFkYXB0aXZlJylcbiAgICAgICAgICAubWFwKGF0dGFjaG1lbnQgPT4gYXR0YWNobWVudD8uY29udGVudD8uc3BlYWspXG4gICAgICBdXG4gICAgICAgIC5maWx0ZXIobGluZSA9PiBsaW5lKVxuICAgICAgICAuam9pbignXFxyXFxuJylcbiAgICApO1xuICB9LCBbYWN0aXZpdHldKTtcblxuICBjb25zdCB7XG4gICAgY2hhbm5lbERhdGE6IHsgc3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlIH0gPSB7fVxuICB9OiB7IGNoYW5uZWxEYXRhOiB7IHNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZT86IFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSB9IH0gPSBhY3Rpdml0eTtcblxuICByZXR1cm4gKFxuICAgICEhYWN0aXZpdHkgJiYgKFxuICAgICAgPFJlYWN0LkZyYWdtZW50PlxuICAgICAgICB7c3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlID8gKFxuICAgICAgICAgIDxTYXlVdHRlcmFuY2Ugb25FbmQ9e21hcmtBc1Nwb2tlbn0gb25FcnJvcj17bWFya0FzU3Bva2VufSB1dHRlcmFuY2U9e3NwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZX0gLz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8U2F5IG9uRW5kPXttYXJrQXNTcG9rZW59IG9uRXJyb3I9e21hcmtBc1Nwb2tlbn0gdGV4dD17c2luZ2xlTGluZX0gdm9pY2U9e3NlbGVjdFZvaWNlfSAvPlxuICAgICAgICApfVxuICAgICAgICB7ISFzaG93U3Bva2VuVGV4dCAmJiA8U2F5QWx0IHNwZWFrPXtzaW5nbGVMaW5lfSAvPn1cbiAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgKVxuICApO1xufTtcblxuU3BlYWsucHJvcFR5cGVzID0ge1xuICBhY3Rpdml0eTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBhdHRhY2htZW50czogUHJvcFR5cGVzLmFycmF5T2YoXG4gICAgICBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICBzcGVhazogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgc3VidGl0bGU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHRleHQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICAgIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nXG4gICAgICB9KVxuICAgICksXG4gICAgY2hhbm5lbERhdGE6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBzcGVlY2hTeW50aGVzaXNVdHRlcmFuY2U6IFByb3BUeXBlcy5hbnlcbiAgICB9KSxcbiAgICBzcGVhazogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0ZXh0OiBQcm9wVHlwZXMuc3RyaW5nXG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNwZWFrO1xuXG5leHBvcnQgeyBjb25uZWN0U3BlYWtBY3Rpdml0eSB9O1xuIl19