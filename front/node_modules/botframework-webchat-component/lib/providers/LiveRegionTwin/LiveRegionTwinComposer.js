"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _LiveRegionTwinContainer = _interopRequireDefault(require("./private/LiveRegionTwinContainer"));

var _Context = _interopRequireDefault(require("./private/Context"));

var _useValueRef = _interopRequireDefault(require("../../hooks/internal/useValueRef"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var DEFAULT_ARIA_LIVE = 'polite';
var DEFAULT_FADE_AFTER = 1000;

/**
 * Live region twin is an UI component for queueing texts or elements to the screen reader using
 * a container element with `aria-live` attribute set.
 *
 * After the text is rendered and queued, it will be removed to reduce burden on the DOM tree.
 * Currently, we assume the assistive technologies should pick up the text within 1 second of rendering.
 * This value is configurable.
 *
 * By default, the live region is visible. If is is not desirable, the caller can use `className` prop to
 * hide its visuals.
 */
var LiveRegionTwinComposer = function LiveRegionTwinComposer(_ref) {
  var ariaLabel = _ref['aria-label'],
      _ref$ariaLive = _ref['aria-live'],
      ariaLive = _ref$ariaLive === void 0 ? DEFAULT_ARIA_LIVE : _ref$ariaLive,
      ariaRoleDescription = _ref['aria-roledescription'],
      children = _ref.children,
      className = _ref.className,
      _ref$fadeAfter = _ref.fadeAfter,
      fadeAfter = _ref$fadeAfter === void 0 ? DEFAULT_FADE_AFTER : _ref$fadeAfter,
      role = _ref.role;

  var _useState = (0, _react.useState)([]),
      _useState2 = _slicedToArray(_useState, 2),
      staticElementEntries = _useState2[0],
      setStaticElementEntries = _useState2[1];

  var fadeAfterRef = (0, _useValueRef.default)(fadeAfter);
  var markAllAsRenderedTimeoutIdRef = (0, _react.useRef)();
  var nextKeyRef = (0, _react.useRef)(1);
  var staticElementEntriesRef = (0, _useValueRef.default)(staticElementEntries); // This function is called by an effect hook `useMarkAllAsRenderedEffect`, it must be designed with converging in mind.
  // To prevent infinite render loop, after multiple calls to this function, it should eventually no-op.

  var markAllAsRendered = (0, _react.useCallback)(function () {
    if (!staticElementEntriesRef.current.length) {
      // Nothing to remove.
      return;
    } // When removing each element one-by-one based on an individual timeout, Narrator would narrate them twice occasionally.
    // Possibly it think some elements that is not removed during the current cycle, are new elements and queued them twice.
    // Thus, we are removing all at once to prevent bugs in Narrator.


    markAllAsRenderedTimeoutIdRef.current && clearTimeout(markAllAsRenderedTimeoutIdRef.current);
    markAllAsRenderedTimeoutIdRef.current = setTimeout(function () {
      // We are playing safe by using value ref to check its length here.
      // If we are certain that `setStaticElements(emptyArray => emptyArray)` is a no-op,
      // we could replace it with just the setter function.
      staticElementEntriesRef.current.length && setStaticElementEntries([]);
    }, fadeAfterRef.current);
  }, [fadeAfterRef, markAllAsRenderedTimeoutIdRef, setStaticElementEntries, staticElementEntriesRef]); // When this component is unmounting, make sure all future `setTimeout` are cleared and should not be fired.

  (0, _react.useEffect)(function () {
    return function () {
      return markAllAsRenderedTimeoutIdRef.current && clearTimeout(markAllAsRenderedTimeoutIdRef.current);
    };
  }, [markAllAsRenderedTimeoutIdRef]);
  var queueStaticElement = (0, _react.useCallback)(function (element) {
    var key = nextKeyRef.current;
    nextKeyRef.current = nextKeyRef.current + 1;
    setStaticElementEntries(function (entries) {
      return [].concat(_toConsumableArray(entries), [{
        element: element,
        key: key
      }]);
    });
  }, [nextKeyRef, setStaticElementEntries]);
  var staticElementEntriesState = (0, _react.useMemo)(function () {
    return Object.freeze([Object.freeze(staticElementEntries)]);
  }, [staticElementEntries]);
  var context = (0, _react.useMemo)(function () {
    return {
      markAllAsRendered: markAllAsRendered,
      queueStaticElement: queueStaticElement,
      staticElementEntriesState: staticElementEntriesState
    };
  }, [markAllAsRendered, queueStaticElement, staticElementEntriesState]);
  return /*#__PURE__*/_react.default.createElement(_Context.default.Provider, {
    value: context
  }, /*#__PURE__*/_react.default.createElement(_LiveRegionTwinContainer.default, {
    "aria-label": ariaLabel,
    "aria-live": ariaLive,
    "aria-roledescription": ariaRoleDescription,
    className: className,
    role: role
  }), children);
};

LiveRegionTwinComposer.defaultProps = {
  'aria-label': undefined,
  'aria-live': DEFAULT_ARIA_LIVE,
  'aria-roledescription': undefined,
  children: undefined,
  className: undefined,
  fadeAfter: DEFAULT_FADE_AFTER,
  role: undefined
};
LiveRegionTwinComposer.propTypes = {
  'aria-label': _propTypes.default.string,
  'aria-live': _propTypes.default.oneOf(['assertive', 'polite']),
  'aria-roledescription': _propTypes.default.string,
  children: _propTypes.default.any,
  className: _propTypes.default.string,
  fadeAfter: _propTypes.default.number,
  role: _propTypes.default.string
};
var _default = LiveRegionTwinComposer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcm92aWRlcnMvTGl2ZVJlZ2lvblR3aW4vTGl2ZVJlZ2lvblR3aW5Db21wb3Nlci50c3giXSwibmFtZXMiOlsiREVGQVVMVF9BUklBX0xJVkUiLCJERUZBVUxUX0ZBREVfQUZURVIiLCJMaXZlUmVnaW9uVHdpbkNvbXBvc2VyIiwiYXJpYUxhYmVsIiwiYXJpYUxpdmUiLCJhcmlhUm9sZURlc2NyaXB0aW9uIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJmYWRlQWZ0ZXIiLCJyb2xlIiwic3RhdGljRWxlbWVudEVudHJpZXMiLCJzZXRTdGF0aWNFbGVtZW50RW50cmllcyIsImZhZGVBZnRlclJlZiIsIm1hcmtBbGxBc1JlbmRlcmVkVGltZW91dElkUmVmIiwibmV4dEtleVJlZiIsInN0YXRpY0VsZW1lbnRFbnRyaWVzUmVmIiwibWFya0FsbEFzUmVuZGVyZWQiLCJjdXJyZW50IiwibGVuZ3RoIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInF1ZXVlU3RhdGljRWxlbWVudCIsImVsZW1lbnQiLCJrZXkiLCJlbnRyaWVzIiwic3RhdGljRWxlbWVudEVudHJpZXNTdGF0ZSIsIk9iamVjdCIsImZyZWV6ZSIsImNvbnRleHQiLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJvbmVPZiIsImFueSIsIm51bWJlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBSUE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQSxJQUFNQSxpQkFBaUIsR0FBRyxRQUExQjtBQUNBLElBQU1DLGtCQUFrQixHQUFHLElBQTNCOztBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUMsc0JBQXVELEdBQUcsU0FBMURBLHNCQUEwRCxPQVExRDtBQUFBLE1BUFVDLFNBT1YsUUFQSixZ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QyxJQUFBLEtBQUssRUFBRUc7QUFBdkMsa0JBQ0UsNkJBQUMsZ0NBQUQ7QUFDRSxrQkFBWXpCLFNBRGQ7QUFFRSxpQkFBV0MsUUFGYjtBQUdFLDRCQUFzQkMsbUJBSHhCO0FBSUUsSUFBQSxTQUFTLEVBQUVFLFNBSmI7QUFLRSxJQUFBLElBQUksRUFBRUU7QUFMUixJQURGLEVBUUdILFFBUkgsQ0FERjtBQVlELENBaEZEOztBQWtGQUosc0JBQXNCLENBQUMyQixZQUF2QixHQUFzQztBQUNwQyxnQkFBY0MsU0FEc0I7QUFFcEMsZUFBYTlCLGlCQUZ1QjtBQUdwQywwQkFBd0I4QixTQUhZO0FBSXBDeEIsRUFBQUEsUUFBUSxFQUFFd0IsU0FKMEI7QUFLcEN2QixFQUFBQSxTQUFTLEVBQUV1QixTQUx5QjtBQU1wQ3RCLEVBQUFBLFNBQVMsRUFBRVAsa0JBTnlCO0FBT3BDUSxFQUFBQSxJQUFJLEVBQUVxQjtBQVA4QixDQUF0QztBQVVBNUIsc0JBQXNCLENBQUM2QixTQUF2QixHQUFtQztBQUNqQyxnQkFBY0MsbUJBQVVDLE1BRFM7QUFFakMsZUFBYUQsbUJBQVVFLEtBQVYsQ0FBZ0IsQ0FBQyxXQUFELEVBQWMsUUFBZCxDQUFoQixDQUZvQjtBQUdqQywwQkFBd0JGLG1CQUFVQyxNQUhEO0FBSWpDM0IsRUFBQUEsUUFBUSxFQUFFMEIsbUJBQVVHLEdBSmE7QUFLakM1QixFQUFBQSxTQUFTLEVBQUV5QixtQkFBVUMsTUFMWTtBQU1qQ3pCLEVBQUFBLFNBQVMsRUFBRXdCLG1CQUFVSSxNQU5ZO0FBT2pDM0IsRUFBQUEsSUFBSSxFQUFFdUIsbUJBQVVDO0FBUGlCLENBQW5DO2VBVWUvQixzQiIsInNvdXJjZVJvb3QiOiJjb21wb25lbnQ6Ly8vIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgdHlwZSB7IEZDLCBQcm9wc1dpdGhDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IExpdmVSZWdpb25Ud2luQ29udGFpbmVyIGZyb20gJy4vcHJpdmF0ZS9MaXZlUmVnaW9uVHdpbkNvbnRhaW5lcic7XG5pbXBvcnQgTGl2ZVJlZ2lvblR3aW5Db250ZXh0IGZyb20gJy4vcHJpdmF0ZS9Db250ZXh0JztcbmltcG9ydCB1c2VWYWx1ZVJlZiBmcm9tICcuLi8uLi9ob29rcy9pbnRlcm5hbC91c2VWYWx1ZVJlZic7XG5cbmltcG9ydCB0eXBlIHsgU3RhdGljRWxlbWVudCwgU3RhdGljRWxlbWVudEVudHJ5IH0gZnJvbSAnLi9wcml2YXRlL3R5cGVzJztcblxuY29uc3QgREVGQVVMVF9BUklBX0xJVkUgPSAncG9saXRlJztcbmNvbnN0IERFRkFVTFRfRkFERV9BRlRFUiA9IDEwMDA7XG5cbnR5cGUgTGl2ZVJlZ2lvblR3aW5Db21wb3NlclByb3BzID0gUHJvcHNXaXRoQ2hpbGRyZW48e1xuICAvKiogT3B0aW9uYWwgXCJhcmlhLWxhYmVsXCIgYXR0cmlidXRlIGZvciB0aGUgbGl2ZSByZWdpb24gdHdpbiBjb250YWluZXIuICovXG4gICdhcmlhLWxhYmVsJz86IHN0cmluZztcblxuICAvKiogXCJhcmlhLWxpdmVcIiBhdHRyaWJ1dGUgZm9yIHRoZSBsaXZlIHJlZ2lvbiB0d2luIGNvbnRhaW5lciwgZGVmYXVsdHMgdG8gYCdwb2xpdGUnYC4gKi9cbiAgJ2FyaWEtbGl2ZSc/OiAnYXNzZXJ0aXZlJyB8ICdwb2xpdGUnO1xuXG4gIC8qKiBPcHRpb25hbCBcImFyaWEtcm9sZWRlc2NyaXB0aW9uXCIgYXR0cmlidXRlIGZvciB0aGUgbGl2ZSByZWdpb24gdHdpbiBjb250YWluZXIuICovXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic/OiBzdHJpbmc7XG5cbiAgLyoqIE9wdGlvbmFsIFwiY2xhc3NOYW1lXCIgYXR0cmlidXRlIGZvciB0aGUgbGl2ZSByZWdpb24gdHdpbiBjb250YWluZXIuICovXG4gIGNsYXNzTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3RhdGljIGVsZW1lbnRzIHdpbGwgZmFkZSBvdXQgYWZ0ZXIgdGhpcyB0aW1lb3V0IHZhbHVlIHNwZWNpZmllZCBpbiBtaWxsaXNlY29uZHMsIGRlZmF1bHRzIHRvIGAxMDAwYC5cbiAgICpcbiAgICogV2hlbiBsb3dlcmluZyB0aGlzIHZhbHVlLCBtYWtlIHN1cmUgc2NyZWVuIHJlYWRlciBjYW4gY29udGludWUgdG8gcGljayB1cCBuZXcgc3RhdGljIGVsZW1lbnRzIGJlZm9yZSBmYWRpbmcgb3V0LlxuICAgKlxuICAgKiBJZiB0aGlzIHByb3AgaXMgdXBkYXRlZCwgaXQgd2lsbCBiZSByZWZsZWN0ZWQgaW4gbmV4dCBxdWV1ZWluZyBlbGVtZW50cy5cbiAgICovXG4gIGZhZGVBZnRlcj86IG51bWJlcjtcblxuICAvKiogT3B0aW9uYWwgXCJyb2xlXCIgYXR0cmlidXRlIGZvciB0aGUgbGl2ZSByZWdpb24gdHdpbiBjb250YWluZXIuICovXG4gIHJvbGU/OiBzdHJpbmc7XG59PjtcblxuLyoqXG4gKiBMaXZlIHJlZ2lvbiB0d2luIGlzIGFuIFVJIGNvbXBvbmVudCBmb3IgcXVldWVpbmcgdGV4dHMgb3IgZWxlbWVudHMgdG8gdGhlIHNjcmVlbiByZWFkZXIgdXNpbmdcbiAqIGEgY29udGFpbmVyIGVsZW1lbnQgd2l0aCBgYXJpYS1saXZlYCBhdHRyaWJ1dGUgc2V0LlxuICpcbiAqIEFmdGVyIHRoZSB0ZXh0IGlzIHJlbmRlcmVkIGFuZCBxdWV1ZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZCB0byByZWR1Y2UgYnVyZGVuIG9uIHRoZSBET00gdHJlZS5cbiAqIEN1cnJlbnRseSwgd2UgYXNzdW1lIHRoZSBhc3Npc3RpdmUgdGVjaG5vbG9naWVzIHNob3VsZCBwaWNrIHVwIHRoZSB0ZXh0IHdpdGhpbiAxIHNlY29uZCBvZiByZW5kZXJpbmcuXG4gKiBUaGlzIHZhbHVlIGlzIGNvbmZpZ3VyYWJsZS5cbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgbGl2ZSByZWdpb24gaXMgdmlzaWJsZS4gSWYgaXMgaXMgbm90IGRlc2lyYWJsZSwgdGhlIGNhbGxlciBjYW4gdXNlIGBjbGFzc05hbWVgIHByb3AgdG9cbiAqIGhpZGUgaXRzIHZpc3VhbHMuXG4gKi9cbmNvbnN0IExpdmVSZWdpb25Ud2luQ29tcG9zZXI6IEZDPExpdmVSZWdpb25Ud2luQ29tcG9zZXJQcm9wcz4gPSAoe1xuICAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCxcbiAgJ2FyaWEtbGl2ZSc6IGFyaWFMaXZlID0gREVGQVVMVF9BUklBX0xJVkUsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IGFyaWFSb2xlRGVzY3JpcHRpb24sXG4gIGNoaWxkcmVuLFxuICBjbGFzc05hbWUsXG4gIGZhZGVBZnRlciA9IERFRkFVTFRfRkFERV9BRlRFUixcbiAgcm9sZVxufSkgPT4ge1xuICBjb25zdCBbc3RhdGljRWxlbWVudEVudHJpZXMsIHNldFN0YXRpY0VsZW1lbnRFbnRyaWVzXSA9IHVzZVN0YXRlPFN0YXRpY0VsZW1lbnRFbnRyeVtdPihbXSk7XG4gIGNvbnN0IGZhZGVBZnRlclJlZiA9IHVzZVZhbHVlUmVmKGZhZGVBZnRlcik7XG4gIGNvbnN0IG1hcmtBbGxBc1JlbmRlcmVkVGltZW91dElkUmVmID0gdXNlUmVmPGFueT4oKTtcbiAgY29uc3QgbmV4dEtleVJlZiA9IHVzZVJlZjxudW1iZXI+KDEpO1xuXG4gIGNvbnN0IHN0YXRpY0VsZW1lbnRFbnRyaWVzUmVmID0gdXNlVmFsdWVSZWYoc3RhdGljRWxlbWVudEVudHJpZXMpO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IGFuIGVmZmVjdCBob29rIGB1c2VNYXJrQWxsQXNSZW5kZXJlZEVmZmVjdGAsIGl0IG11c3QgYmUgZGVzaWduZWQgd2l0aCBjb252ZXJnaW5nIGluIG1pbmQuXG4gIC8vIFRvIHByZXZlbnQgaW5maW5pdGUgcmVuZGVyIGxvb3AsIGFmdGVyIG11bHRpcGxlIGNhbGxzIHRvIHRoaXMgZnVuY3Rpb24sIGl0IHNob3VsZCBldmVudHVhbGx5IG5vLW9wLlxuICBjb25zdCBtYXJrQWxsQXNSZW5kZXJlZCA9IHVzZUNhbGxiYWNrPCgpID0+IHZvaWQ+KCgpID0+IHtcbiAgICBpZiAoIXN0YXRpY0VsZW1lbnRFbnRyaWVzUmVmLmN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIHJlbW92ZS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHJlbW92aW5nIGVhY2ggZWxlbWVudCBvbmUtYnktb25lIGJhc2VkIG9uIGFuIGluZGl2aWR1YWwgdGltZW91dCwgTmFycmF0b3Igd291bGQgbmFycmF0ZSB0aGVtIHR3aWNlIG9jY2FzaW9uYWxseS5cbiAgICAvLyBQb3NzaWJseSBpdCB0aGluayBzb21lIGVsZW1lbnRzIHRoYXQgaXMgbm90IHJlbW92ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGN5Y2xlLCBhcmUgbmV3IGVsZW1lbnRzIGFuZCBxdWV1ZWQgdGhlbSB0d2ljZS5cbiAgICAvLyBUaHVzLCB3ZSBhcmUgcmVtb3ZpbmcgYWxsIGF0IG9uY2UgdG8gcHJldmVudCBidWdzIGluIE5hcnJhdG9yLlxuICAgIG1hcmtBbGxBc1JlbmRlcmVkVGltZW91dElkUmVmLmN1cnJlbnQgJiYgY2xlYXJUaW1lb3V0KG1hcmtBbGxBc1JlbmRlcmVkVGltZW91dElkUmVmLmN1cnJlbnQpO1xuXG4gICAgbWFya0FsbEFzUmVuZGVyZWRUaW1lb3V0SWRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gV2UgYXJlIHBsYXlpbmcgc2FmZSBieSB1c2luZyB2YWx1ZSByZWYgdG8gY2hlY2sgaXRzIGxlbmd0aCBoZXJlLlxuICAgICAgLy8gSWYgd2UgYXJlIGNlcnRhaW4gdGhhdCBgc2V0U3RhdGljRWxlbWVudHMoZW1wdHlBcnJheSA9PiBlbXB0eUFycmF5KWAgaXMgYSBuby1vcCxcbiAgICAgIC8vIHdlIGNvdWxkIHJlcGxhY2UgaXQgd2l0aCBqdXN0IHRoZSBzZXR0ZXIgZnVuY3Rpb24uXG4gICAgICBzdGF0aWNFbGVtZW50RW50cmllc1JlZi5jdXJyZW50Lmxlbmd0aCAmJiBzZXRTdGF0aWNFbGVtZW50RW50cmllcyhbXSk7XG4gICAgfSwgZmFkZUFmdGVyUmVmLmN1cnJlbnQpO1xuICB9LCBbZmFkZUFmdGVyUmVmLCBtYXJrQWxsQXNSZW5kZXJlZFRpbWVvdXRJZFJlZiwgc2V0U3RhdGljRWxlbWVudEVudHJpZXMsIHN0YXRpY0VsZW1lbnRFbnRyaWVzUmVmXSk7XG5cbiAgLy8gV2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50aW5nLCBtYWtlIHN1cmUgYWxsIGZ1dHVyZSBgc2V0VGltZW91dGAgYXJlIGNsZWFyZWQgYW5kIHNob3VsZCBub3QgYmUgZmlyZWQuXG4gIHVzZUVmZmVjdChcbiAgICAoKSA9PiAoKSA9PiBtYXJrQWxsQXNSZW5kZXJlZFRpbWVvdXRJZFJlZi5jdXJyZW50ICYmIGNsZWFyVGltZW91dChtYXJrQWxsQXNSZW5kZXJlZFRpbWVvdXRJZFJlZi5jdXJyZW50KSxcbiAgICBbbWFya0FsbEFzUmVuZGVyZWRUaW1lb3V0SWRSZWZdXG4gICk7XG5cbiAgY29uc3QgcXVldWVTdGF0aWNFbGVtZW50ID0gdXNlQ2FsbGJhY2s8KHN0YXRpY0VsZW1lbnQ6IFN0YXRpY0VsZW1lbnQpID0+IHZvaWQ+KFxuICAgIChlbGVtZW50OiBTdGF0aWNFbGVtZW50KTogdm9pZCA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBuZXh0S2V5UmVmLmN1cnJlbnQ7XG5cbiAgICAgIG5leHRLZXlSZWYuY3VycmVudCA9IG5leHRLZXlSZWYuY3VycmVudCArIDE7XG5cbiAgICAgIHNldFN0YXRpY0VsZW1lbnRFbnRyaWVzKGVudHJpZXMgPT4gWy4uLmVudHJpZXMsIHsgZWxlbWVudCwga2V5IH1dKTtcbiAgICB9LFxuICAgIFtuZXh0S2V5UmVmLCBzZXRTdGF0aWNFbGVtZW50RW50cmllc11cbiAgKTtcblxuICBjb25zdCBzdGF0aWNFbGVtZW50RW50cmllc1N0YXRlID0gdXNlTWVtbzxyZWFkb25seSBbcmVhZG9ubHkgU3RhdGljRWxlbWVudEVudHJ5W11dPihcbiAgICAoKSA9PiBPYmplY3QuZnJlZXplKFtPYmplY3QuZnJlZXplKHN0YXRpY0VsZW1lbnRFbnRyaWVzKV0pIGFzIHJlYWRvbmx5IFtyZWFkb25seSBTdGF0aWNFbGVtZW50RW50cnlbXV0sXG4gICAgW3N0YXRpY0VsZW1lbnRFbnRyaWVzXVxuICApO1xuXG4gIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBtYXJrQWxsQXNSZW5kZXJlZCxcbiAgICAgIHF1ZXVlU3RhdGljRWxlbWVudCxcbiAgICAgIHN0YXRpY0VsZW1lbnRFbnRyaWVzU3RhdGVcbiAgICB9KSxcbiAgICBbbWFya0FsbEFzUmVuZGVyZWQsIHF1ZXVlU3RhdGljRWxlbWVudCwgc3RhdGljRWxlbWVudEVudHJpZXNTdGF0ZV1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxMaXZlUmVnaW9uVHdpbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHR9PlxuICAgICAgPExpdmVSZWdpb25Ud2luQ29udGFpbmVyXG4gICAgICAgIGFyaWEtbGFiZWw9e2FyaWFMYWJlbH1cbiAgICAgICAgYXJpYS1saXZlPXthcmlhTGl2ZX1cbiAgICAgICAgYXJpYS1yb2xlZGVzY3JpcHRpb249e2FyaWFSb2xlRGVzY3JpcHRpb259XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICByb2xlPXtyb2xlfVxuICAgICAgLz5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0xpdmVSZWdpb25Ud2luQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbkxpdmVSZWdpb25Ud2luQ29tcG9zZXIuZGVmYXVsdFByb3BzID0ge1xuICAnYXJpYS1sYWJlbCc6IHVuZGVmaW5lZCxcbiAgJ2FyaWEtbGl2ZSc6IERFRkFVTFRfQVJJQV9MSVZFLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiB1bmRlZmluZWQsXG4gIGNoaWxkcmVuOiB1bmRlZmluZWQsXG4gIGNsYXNzTmFtZTogdW5kZWZpbmVkLFxuICBmYWRlQWZ0ZXI6IERFRkFVTFRfRkFERV9BRlRFUixcbiAgcm9sZTogdW5kZWZpbmVkXG59O1xuXG5MaXZlUmVnaW9uVHdpbkNvbXBvc2VyLnByb3BUeXBlcyA9IHtcbiAgJ2FyaWEtbGFiZWwnOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAnYXJpYS1saXZlJzogUHJvcFR5cGVzLm9uZU9mKFsnYXNzZXJ0aXZlJywgJ3BvbGl0ZSddKSxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogUHJvcFR5cGVzLnN0cmluZyxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZmFkZUFmdGVyOiBQcm9wVHlwZXMubnVtYmVyLFxuICByb2xlOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5leHBvcnQgZGVmYXVsdCBMaXZlUmVnaW9uVHdpbkNvbXBvc2VyO1xuIl19