"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _botframeworkWebchatApi = require("botframework-webchat-api");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _mathRandom = _interopRequireDefault(require("math-random"));

var _react = _interopRequireWildcard(require("react"));

var _scrollIntoViewWithBlockNearest = _interopRequireDefault(require("../../Utils/scrollIntoViewWithBlockNearest"));

var _Context = _interopRequireDefault(require("./private/Context"));

var _useActivityTreeWithRenderer = _interopRequireDefault(require("../ActivityTree/useActivityTreeWithRenderer"));

var _usePrevious = _interopRequireDefault(require("../../hooks/internal/usePrevious"));

var _useStateRef3 = _interopRequireDefault(require("../../hooks/internal/useStateRef"));

var _useValueRef = _interopRequireDefault(require("../../hooks/internal/useValueRef"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var useGetKeyByActivity = _botframeworkWebchatApi.hooks.useGetKeyByActivity;

function last(array) {
  return array[array.length - 1];
}

function uniqueId() {
  var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;
  return (0, _mathRandom.default)() // eslint-disable-next-line no-magic-numbers
  .toString(36) // eslint-disable-next-line no-magic-numbers
  .substring(2, 2 + count);
}

var TranscriptFocusComposer = function TranscriptFocusComposer(_ref) {
  var _containerRef$current;

  var children = _ref.children,
      containerRef = _ref.containerRef;

  var _useActivityTreeWithR = (0, _useActivityTreeWithRenderer.default)({
    flat: true
  }),
      _useActivityTreeWithR2 = _slicedToArray(_useActivityTreeWithR, 1),
      flattenedActivityTree = _useActivityTreeWithR2[0];

  var _useStateRef = (0, _useStateRef3.default)(),
      _useStateRef2 = _slicedToArray(_useStateRef, 3),
      _ = _useStateRef2[0],
      setRawFocusedActivityKey = _useStateRef2[1],
      rawFocusedActivityKeyRef = _useStateRef2[2];

  var getKeyByActivity = useGetKeyByActivity(); // As we need to use IDREF for `aria-activedescendant`,
  // this prefix will differentiate multiple instances of transcript on the same page.
  // eslint-disable-next-line no-magic-numbers

  var prefix = (0, _react.useMemo)(function () {
    return uniqueId(3);
  }, []);
  var getDescendantIdByActivityKey = (0, _react.useCallback)(function (activityKey) {
    return activityKey && "webchat__transcript-focus-".concat(prefix, "__activity-").concat(activityKey);
  }, [prefix]);
  var renderingActivityKeys = (0, _react.useMemo)(function () {
    return Object.freeze(flattenedActivityTree.map(function (_ref2) {
      var activity = _ref2.activity;
      return getKeyByActivity(activity);
    }));
  }, [flattenedActivityTree, getKeyByActivity]);
  var renderingActivityKeysRef = (0, _useValueRef.default)(renderingActivityKeys); // While the transcript or any descendants are not focused, if the transcript is updated, reset the user-selected active descendant.
  // This will assume the last activity, if any, will be the active descendant.

  var prevRenderingActivityKeys = (0, _usePrevious.default)(renderingActivityKeys);

  if (renderingActivityKeys !== prevRenderingActivityKeys && !((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(document.activeElement))) {
    rawFocusedActivityKeyRef.current = undefined;
  }

  var rawFocusedActivityKey = rawFocusedActivityKeyRef.current;
  var focusedActivityKey = (0, _react.useMemo)(function () {
    return renderingActivityKeys.includes(rawFocusedActivityKey) ? rawFocusedActivityKey : last(renderingActivityKeys);
  }, [renderingActivityKeys, rawFocusedActivityKey]);
  var focusedActivityKeyRef = (0, _useValueRef.default)(focusedActivityKey);
  var activeDescendantId = (0, _react.useMemo)(function () {
    return getDescendantIdByActivityKey(focusedActivityKey);
  }, [getDescendantIdByActivityKey, focusedActivityKey]);
  var focusByActivityKey = (0, _react.useCallback)(function (activityKey) {
    var withFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (activityKey === false) {
      // `false` means set it to nothing.
      setRawFocusedActivityKey(undefined);
    } else if (activityKey === true) {
      // `true` means set to something if it is not set.
      setRawFocusedActivityKey(function (key) {
        return key || focusedActivityKeyRef.current;
      });
    } else if (activityKey) {
      setRawFocusedActivityKey(activityKey);
    }

    if (withFocus) {
      var _containerRef$current2;

      (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.focus();

      var _activeDescendantId = getDescendantIdByActivityKey(activityKey === false ? // If "activityKey" is false, it means "focus nothing and reset it to the last activity".
      last(renderingActivityKeysRef.current) : activityKey && activityKey !== true ? // If "activity" is not "undefined" and not "true", it means "focus on this activity".
      activityKey : // If "activityKey" is "undefined", it means "don't modify the focus".
      // If "activityKey" is "true", it means "try to focus on anything".
      rawFocusedActivityKeyRef.current);

      var activeDescendantElement = _activeDescendantId && document.getElementById(_activeDescendantId); // Don't scroll active descendant into view if the focus is already inside it.
      // Otherwise, given the focus is on the send box, clicking on any <input> inside the Adaptive Cards may cause the view to move.
      // This UX is not desirable because click should not cause scroll.


      if (activeDescendantElement && !activeDescendantElement.contains(document.activeElement)) {
        (0, _scrollIntoViewWithBlockNearest.default)(activeDescendantElement);
      }
    }
  }, [getDescendantIdByActivityKey, containerRef, focusedActivityKeyRef, renderingActivityKeysRef, rawFocusedActivityKeyRef, setRawFocusedActivityKey]);
  var focusRelativeActivity = (0, _react.useCallback)(function (delta) {
    var orderedActivityKeys = renderingActivityKeysRef.current;

    if (isNaN(delta) || !orderedActivityKeys.length) {
      return focusByActivityKey(false, true);
    }

    var focusedActivityKey = focusedActivityKeyRef.current;
    var index = orderedActivityKeys.indexOf(focusedActivityKey);
    var nextIndex = ~index ? Math.max(0, Math.min(orderedActivityKeys.length - 1, index + delta)) : orderedActivityKeys.length - 1;
    focusByActivityKey(orderedActivityKeys[+nextIndex], true);
  }, [focusedActivityKeyRef, renderingActivityKeysRef, focusByActivityKey]);
  var contextValue = (0, _react.useMemo)(function () {
    return {
      activeDescendantIdState: Object.freeze([activeDescendantId]),
      getDescendantIdByActivityKey: getDescendantIdByActivityKey,
      focusByActivityKey: focusByActivityKey,
      focusedActivityKeyState: Object.freeze([focusedActivityKey]),
      focusedExplicitlyState: Object.freeze([!!rawFocusedActivityKey]),
      focusRelativeActivity: focusRelativeActivity
    };
  }, [activeDescendantId, getDescendantIdByActivityKey, focusByActivityKey, focusedActivityKey, focusRelativeActivity, rawFocusedActivityKey]);
  return /*#__PURE__*/_react.default.createElement(_Context.default.Provider, {
    value: contextValue
  }, children);
};

TranscriptFocusComposer.propTypes = {
  // PropTypes is not fully compatible with TypeScript.
  // @ts-ignore
  containerRef: _propTypes.default.shape({
    current: _propTypes.default.instanceOf(HTMLElement)
  }).isRequired
};
var _default = TranscriptFocusComposer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcm92aWRlcnMvVHJhbnNjcmlwdEZvY3VzL1RyYW5zY3JpcHRGb2N1c0NvbXBvc2VyLnRzeCJdLCJuYW1lcyI6WyJ1c2VHZXRLZXlCeUFjdGl2aXR5IiwiaG9va3MiLCJsYXN0IiwiYXJyYXkiLCJsZW5ndGgiLCJ1bmlxdWVJZCIsImNvdW50IiwiSW5maW5pdHkiLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsIlRyYW5zY3JpcHRGb2N1c0NvbXBvc2VyIiwiY2hpbGRyZW4iLCJjb250YWluZXJSZWYiLCJmbGF0IiwiZmxhdHRlbmVkQWN0aXZpdHlUcmVlIiwiXyIsInNldFJhd0ZvY3VzZWRBY3Rpdml0eUtleSIsInJhd0ZvY3VzZWRBY3Rpdml0eUtleVJlZiIsImdldEtleUJ5QWN0aXZpdHkiLCJwcmVmaXgiLCJnZXREZXNjZW5kYW50SWRCeUFjdGl2aXR5S2V5IiwiYWN0aXZpdHlLZXkiLCJyZW5kZXJpbmdBY3Rpdml0eUtleXMiLCJPYmplY3QiLCJmcmVlemUiLCJtYXAiLCJhY3Rpdml0eSIsInJlbmRlcmluZ0FjdGl2aXR5S2V5c1JlZiIsInByZXZSZW5kZXJpbmdBY3Rpdml0eUtleXMiLCJjdXJyZW50IiwiY29udGFpbnMiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJ1bmRlZmluZWQiLCJyYXdGb2N1c2VkQWN0aXZpdHlLZXkiLCJmb2N1c2VkQWN0aXZpdHlLZXkiLCJpbmNsdWRlcyIsImZvY3VzZWRBY3Rpdml0eUtleVJlZiIsImFjdGl2ZURlc2NlbmRhbnRJZCIsImZvY3VzQnlBY3Rpdml0eUtleSIsIndpdGhGb2N1cyIsImtleSIsImZvY3VzIiwiYWN0aXZlRGVzY2VuZGFudEVsZW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImZvY3VzUmVsYXRpdmVBY3Rpdml0eSIsImRlbHRhIiwib3JkZXJlZEFjdGl2aXR5S2V5cyIsImlzTmFOIiwiaW5kZXgiLCJpbmRleE9mIiwibmV4dEluZGV4IiwiTWF0aCIsIm1heCIsIm1pbiIsImNvbnRleHRWYWx1ZSIsImFjdGl2ZURlc2NlbmRhbnRJZFN0YXRlIiwiZm9jdXNlZEFjdGl2aXR5S2V5U3RhdGUiLCJmb2N1c2VkRXhwbGljaXRseVN0YXRlIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwic2hhcGUiLCJpbnN0YW5jZU9mIiwiSFRNTEVsZW1lbnQiLCJpc1JlcXVpcmVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFJQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJQSxJQUFRQSxtQkFBUixHQUFnQ0MsNkJBQWhDLENBQVFELG1CQUFSOztBQU1BLFNBQVNFLElBQVQsQ0FBaUJDLEtBQWpCLEVBQXNDO0FBQ3BDLFNBQU9BLEtBQUssQ0FBQ0EsS0FBSyxDQUFDQyxNQUFOLEdBQWUsQ0FBaEIsQ0FBWjtBQUNEOztBQUVELFNBQVNDLFFBQVQsR0FBb0M7QUFBQSxNQUFsQkMsS0FBa0IsdUVBQVZDLFFBQVU7QUFDbEMsU0FDRSwyQkFDRTtBQURGLEdBRUdDLFFBRkgsQ0FFWSxFQUZaLEVBR0U7QUFIRixHQUlHQyxTQUpILENBSWEsQ0FKYixFQUlnQixJQUFJSCxLQUpwQixDQURGO0FBT0Q7O0FBRUQsSUFBTUksdUJBQXlELEdBQUcsU0FBNURBLHVCQUE0RCxPQUFnQztBQUFBOztBQUFBLE1BQTdCQyxRQUE2QixRQUE3QkEsUUFBNkI7QUFBQSxNQUFuQkMsWUFBbUIsUUFBbkJBLFlBQW1COztBQUNoRyw4QkFBZ0MsMENBQTRCO0FBQUVDLElBQUFBLElBQUksRUFBRTtBQUFSLEdBQTVCLENBQWhDO0FBQUE7QUFBQSxNQUFPQyxxQkFBUDs7QUFDQSxxQkFBZ0UsNEJBQWhFO0FBQUE7QUFBQSxNQUFPQyxDQUFQO0FBQUEsTUFBVUMsd0JBQVY7QUFBQSxNQUFvQ0Msd0JBQXBDOztBQUNBLE1BQU1DLGdCQUFnQixHQUFHbEIsbUJBQW1CLEVBQTVDLENBSGdHLENBS2hHO0FBQ0E7QUFDQTs7QUFDQSxNQUFN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QUFELEVBQXdCVix3QkFBeEIsRUFBa0RZLGtCQUFsRCxDQWpCNEIsQ0FBOUI7QUFvQkEsTUFBTWdCLFlBQVksR0FBRyxvQkFDbkI7QUFBQSxXQUFPO0FBQ0xDLE1BQUFBLHVCQUF1QixFQUFFakMsTUFBTSxDQUFDQyxNQUFQLENBQWMsQ0FBQ2Msa0JBQUQsQ0FBZCxDQURwQjtBQUVMbEIsTUFBQUEsNEJBQTRCLEVBQTVCQSw0QkFGSztBQUdMbUIsTUFBQUEsa0JBQWtCLEVBQWxCQSxrQkFISztBQUlMa0IsTUFBQUEsdUJBQXVCLEVBQUVsQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxDQUFDVyxrQkFBRCxDQUFkLENBSnBCO0FBS0x1QixNQUFBQSxzQkFBc0IsRUFBRW5DLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLENBQUMsQ0FBQyxDQUFDVSxxQkFBSCxDQUFkLENBTG5CO0FBTUxXLE1BQUFBLHFCQUFxQixFQUFyQkE7QUFOSyxLQUFQO0FBQUEsR0FEbUIsRUFTbkIsQ0FDRVAsa0JBREYsRUFFRWxCLDRCQUZGLEVBR0VtQixrQkFIRixFQUlFSixrQkFKRixFQUtFVSxxQkFMRixFQU1FWCxxQkFORixDQVRtQixDQUFyQjtBQW1CQSxzQkFBTyw2QkFBQyxnQkFBRCxDQUF3QixRQUF4QjtBQUFpQyxJQUFBLEtBQUssRUFBRXFCO0FBQXhDLEtBQXVENUMsUUFBdkQsQ0FBUDtBQUNELENBcklEOztBQXVJQUQsdUJBQXVCLENBQUNpRCxTQUF4QixHQUFvQztBQUNsQztBQUNBO0FBQ0EvQyxFQUFBQSxZQUFZLEVBQUVnRCxtQkFBVUMsS0FBVixDQUFnQjtBQUM1QmhDLElBQUFBLE9BQU8sRUFBRStCLG1CQUFVRSxVQUFWLENBQXFCQyxXQUFyQjtBQURtQixHQUFoQixFQUVYQztBQUwrQixDQUFwQztlQVFldEQsdUIiLCJzb3VyY2VSb290IjoiY29tcG9uZW50Oi8vLyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhvb2tzIH0gZnJvbSAnYm90ZnJhbWV3b3JrLXdlYmNoYXQtYXBpJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgcmFuZG9tIGZyb20gJ21hdGgtcmFuZG9tJztcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHR5cGUgeyBGQywgTXV0YWJsZVJlZk9iamVjdCB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHNjcm9sbEludG9WaWV3V2l0aEJsb2NrTmVhcmVzdCBmcm9tICcuLi8uLi9VdGlscy9zY3JvbGxJbnRvVmlld1dpdGhCbG9ja05lYXJlc3QnO1xuaW1wb3J0IFRyYW5zY3JpcHRGb2N1c0NvbnRleHQgZnJvbSAnLi9wcml2YXRlL0NvbnRleHQnO1xuaW1wb3J0IHVzZUFjdGl2aXR5VHJlZVdpdGhSZW5kZXJlciBmcm9tICcuLi9BY3Rpdml0eVRyZWUvdXNlQWN0aXZpdHlUcmVlV2l0aFJlbmRlcmVyJztcbmltcG9ydCB1c2VQcmV2aW91cyBmcm9tICcuLi8uLi9ob29rcy9pbnRlcm5hbC91c2VQcmV2aW91cyc7XG5pbXBvcnQgdXNlU3RhdGVSZWYgZnJvbSAnLi4vLi4vaG9va3MvaW50ZXJuYWwvdXNlU3RhdGVSZWYnO1xuaW1wb3J0IHVzZVZhbHVlUmVmIGZyb20gJy4uLy4uL2hvb2tzL2ludGVybmFsL3VzZVZhbHVlUmVmJztcblxuaW1wb3J0IHR5cGUgeyBUcmFuc2NyaXB0Rm9jdXNDb250ZXh0VHlwZSB9IGZyb20gJy4vcHJpdmF0ZS9Db250ZXh0JztcblxuY29uc3QgeyB1c2VHZXRLZXlCeUFjdGl2aXR5IH0gPSBob29rcztcblxudHlwZSBUcmFuc2NyaXB0Rm9jdXNDb21wb3NlclByb3BzID0ge1xuICBjb250YWluZXJSZWY6IE11dGFibGVSZWZPYmplY3Q8SFRNTEVsZW1lbnQ+O1xufTtcblxuZnVuY3Rpb24gbGFzdDxUPihhcnJheTogQXJyYXlMaWtlPFQ+KSB7XG4gIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbn1cblxuZnVuY3Rpb24gdW5pcXVlSWQoY291bnQgPSBJbmZpbml0eSkge1xuICByZXR1cm4gKFxuICAgIHJhbmRvbSgpXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgLnRvU3RyaW5nKDM2KVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgICAgIC5zdWJzdHJpbmcoMiwgMiArIGNvdW50KVxuICApO1xufVxuXG5jb25zdCBUcmFuc2NyaXB0Rm9jdXNDb21wb3NlcjogRkM8VHJhbnNjcmlwdEZvY3VzQ29tcG9zZXJQcm9wcz4gPSAoeyBjaGlsZHJlbiwgY29udGFpbmVyUmVmIH0pID0+IHtcbiAgY29uc3QgW2ZsYXR0ZW5lZEFjdGl2aXR5VHJlZV0gPSB1c2VBY3Rpdml0eVRyZWVXaXRoUmVuZGVyZXIoeyBmbGF0OiB0cnVlIH0pO1xuICBjb25zdCBbXywgc2V0UmF3Rm9jdXNlZEFjdGl2aXR5S2V5LCByYXdGb2N1c2VkQWN0aXZpdHlLZXlSZWZdID0gdXNlU3RhdGVSZWY8c3RyaW5nIHwgdW5kZWZpbmVkPigpO1xuICBjb25zdCBnZXRLZXlCeUFjdGl2aXR5ID0gdXNlR2V0S2V5QnlBY3Rpdml0eSgpO1xuXG4gIC8vIEFzIHdlIG5lZWQgdG8gdXNlIElEUkVGIGZvciBgYXJpYS1hY3RpdmVkZXNjZW5kYW50YCxcbiAgLy8gdGhpcyBwcmVmaXggd2lsbCBkaWZmZXJlbnRpYXRlIG11bHRpcGxlIGluc3RhbmNlcyBvZiB0cmFuc2NyaXB0IG9uIHRoZSBzYW1lIHBhZ2UuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gIGNvbnN0IHByZWZpeCA9IHVzZU1lbW88c3RyaW5nPigoKSA9PiB1bmlxdWVJZCgzKSwgW10pO1xuXG4gIGNvbnN0IGdldERlc2NlbmRhbnRJZEJ5QWN0aXZpdHlLZXk6IChhY3Rpdml0eUtleT86IHN0cmluZykgPT4gc3RyaW5nIHwgdW5kZWZpbmVkID0gdXNlQ2FsbGJhY2soXG4gICAgKGFjdGl2aXR5S2V5Pzogc3RyaW5nKSA9PiBhY3Rpdml0eUtleSAmJiBgd2ViY2hhdF9fdHJhbnNjcmlwdC1mb2N1cy0ke3ByZWZpeH1fX2FjdGl2aXR5LSR7YWN0aXZpdHlLZXl9YCxcbiAgICBbcHJlZml4XVxuICApO1xuXG4gIGNvbnN0IHJlbmRlcmluZ0FjdGl2aXR5S2V5cyA9IHVzZU1lbW88cmVhZG9ubHkgc3RyaW5nW10+KFxuICAgICgpID0+IE9iamVjdC5mcmVlemUoZmxhdHRlbmVkQWN0aXZpdHlUcmVlLm1hcCgoeyBhY3Rpdml0eSB9KSA9PiBnZXRLZXlCeUFjdGl2aXR5KGFjdGl2aXR5KSkpLFxuICAgIFtmbGF0dGVuZWRBY3Rpdml0eVRyZWUsIGdldEtleUJ5QWN0aXZpdHldXG4gICk7XG5cbiAgY29uc3QgcmVuZGVyaW5nQWN0aXZpdHlLZXlzUmVmID0gdXNlVmFsdWVSZWY8cmVhZG9ubHkgc3RyaW5nW10+KHJlbmRlcmluZ0FjdGl2aXR5S2V5cyk7XG5cbiAgLy8gV2hpbGUgdGhlIHRyYW5zY3JpcHQgb3IgYW55IGRlc2NlbmRhbnRzIGFyZSBub3QgZm9jdXNlZCwgaWYgdGhlIHRyYW5zY3JpcHQgaXMgdXBkYXRlZCwgcmVzZXQgdGhlIHVzZXItc2VsZWN0ZWQgYWN0aXZlIGRlc2NlbmRhbnQuXG4gIC8vIFRoaXMgd2lsbCBhc3N1bWUgdGhlIGxhc3QgYWN0aXZpdHksIGlmIGFueSwgd2lsbCBiZSB0aGUgYWN0aXZlIGRlc2NlbmRhbnQuXG4gIGNvbnN0IHByZXZSZW5kZXJpbmdBY3Rpdml0eUtleXMgPSB1c2VQcmV2aW91cyhyZW5kZXJpbmdBY3Rpdml0eUtleXMpO1xuXG4gIGlmIChyZW5kZXJpbmdBY3Rpdml0eUtleXMgIT09IHByZXZSZW5kZXJpbmdBY3Rpdml0eUtleXMgJiYgIWNvbnRhaW5lclJlZi5jdXJyZW50Py5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgIHJhd0ZvY3VzZWRBY3Rpdml0eUtleVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgeyBjdXJyZW50OiByYXdGb2N1c2VkQWN0aXZpdHlLZXkgfSA9IHJhd0ZvY3VzZWRBY3Rpdml0eUtleVJlZjtcblxuICBjb25zdCBmb2N1c2VkQWN0aXZpdHlLZXkgPSB1c2VNZW1vPHN0cmluZz4oXG4gICAgKCkgPT4gKHJlbmRlcmluZ0FjdGl2aXR5S2V5cy5pbmNsdWRlcyhyYXdGb2N1c2VkQWN0aXZpdHlLZXkpID8gcmF3Rm9jdXNlZEFjdGl2aXR5S2V5IDogbGFzdChyZW5kZXJpbmdBY3Rpdml0eUtleXMpKSxcbiAgICBbcmVuZGVyaW5nQWN0aXZpdHlLZXlzLCByYXdGb2N1c2VkQWN0aXZpdHlLZXldXG4gICk7XG5cbiAgY29uc3QgZm9jdXNlZEFjdGl2aXR5S2V5UmVmID0gdXNlVmFsdWVSZWYoZm9jdXNlZEFjdGl2aXR5S2V5KTtcblxuICBjb25zdCBhY3RpdmVEZXNjZW5kYW50SWQgPSB1c2VNZW1vPHN0cmluZz4oXG4gICAgKCkgPT4gZ2V0RGVzY2VuZGFudElkQnlBY3Rpdml0eUtleShmb2N1c2VkQWN0aXZpdHlLZXkpLFxuICAgIFtnZXREZXNjZW5kYW50SWRCeUFjdGl2aXR5S2V5LCBmb2N1c2VkQWN0aXZpdHlLZXldXG4gICk7XG5cbiAgY29uc3QgZm9jdXNCeUFjdGl2aXR5S2V5ID0gdXNlQ2FsbGJhY2s8XG4gICAgKGFjdGl2aXR5S2V5OiBib29sZWFuIHwgc3RyaW5nIHwgdW5kZWZpbmVkLCB3aXRoRm9jdXM6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHZvaWRcbiAgPihcbiAgICAoYWN0aXZpdHlLZXk6IGJvb2xlYW4gfCBzdHJpbmcgfCB1bmRlZmluZWQsIHdpdGhGb2N1czogYm9vbGVhbiB8IHVuZGVmaW5lZCA9IHRydWUpID0+IHtcbiAgICAgIGlmIChhY3Rpdml0eUtleSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gYGZhbHNlYCBtZWFucyBzZXQgaXQgdG8gbm90aGluZy5cbiAgICAgICAgc2V0UmF3Rm9jdXNlZEFjdGl2aXR5S2V5KHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2aXR5S2V5ID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGB0cnVlYCBtZWFucyBzZXQgdG8gc29tZXRoaW5nIGlmIGl0IGlzIG5vdCBzZXQuXG4gICAgICAgIHNldFJhd0ZvY3VzZWRBY3Rpdml0eUtleShrZXkgPT4ga2V5IHx8IGZvY3VzZWRBY3Rpdml0eUtleVJlZi5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoYWN0aXZpdHlLZXkpIHtcbiAgICAgICAgc2V0UmF3Rm9jdXNlZEFjdGl2aXR5S2V5KGFjdGl2aXR5S2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpdGhGb2N1cykge1xuICAgICAgICBjb250YWluZXJSZWYuY3VycmVudD8uZm9jdXMoKTtcblxuICAgICAgICBjb25zdCBhY3RpdmVEZXNjZW5kYW50SWQgPSBnZXREZXNjZW5kYW50SWRCeUFjdGl2aXR5S2V5KFxuICAgICAgICAgIGFjdGl2aXR5S2V5ID09PSBmYWxzZVxuICAgICAgICAgICAgPyAvLyBJZiBcImFjdGl2aXR5S2V5XCIgaXMgZmFsc2UsIGl0IG1lYW5zIFwiZm9jdXMgbm90aGluZyBhbmQgcmVzZXQgaXQgdG8gdGhlIGxhc3QgYWN0aXZpdHlcIi5cbiAgICAgICAgICAgICAgbGFzdChyZW5kZXJpbmdBY3Rpdml0eUtleXNSZWYuY3VycmVudClcbiAgICAgICAgICAgIDogYWN0aXZpdHlLZXkgJiYgYWN0aXZpdHlLZXkgIT09IHRydWVcbiAgICAgICAgICAgID8gLy8gSWYgXCJhY3Rpdml0eVwiIGlzIG5vdCBcInVuZGVmaW5lZFwiIGFuZCBub3QgXCJ0cnVlXCIsIGl0IG1lYW5zIFwiZm9jdXMgb24gdGhpcyBhY3Rpdml0eVwiLlxuICAgICAgICAgICAgICBhY3Rpdml0eUtleVxuICAgICAgICAgICAgOiAvLyBJZiBcImFjdGl2aXR5S2V5XCIgaXMgXCJ1bmRlZmluZWRcIiwgaXQgbWVhbnMgXCJkb24ndCBtb2RpZnkgdGhlIGZvY3VzXCIuXG4gICAgICAgICAgICAgIC8vIElmIFwiYWN0aXZpdHlLZXlcIiBpcyBcInRydWVcIiwgaXQgbWVhbnMgXCJ0cnkgdG8gZm9jdXMgb24gYW55dGhpbmdcIi5cbiAgICAgICAgICAgICAgcmF3Rm9jdXNlZEFjdGl2aXR5S2V5UmVmLmN1cnJlbnRcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBhY3RpdmVEZXNjZW5kYW50RWxlbWVudCA9IGFjdGl2ZURlc2NlbmRhbnRJZCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhY3RpdmVEZXNjZW5kYW50SWQpO1xuXG4gICAgICAgIC8vIERvbid0IHNjcm9sbCBhY3RpdmUgZGVzY2VuZGFudCBpbnRvIHZpZXcgaWYgdGhlIGZvY3VzIGlzIGFscmVhZHkgaW5zaWRlIGl0LlxuICAgICAgICAvLyBPdGhlcndpc2UsIGdpdmVuIHRoZSBmb2N1cyBpcyBvbiB0aGUgc2VuZCBib3gsIGNsaWNraW5nIG9uIGFueSA8aW5wdXQ+IGluc2lkZSB0aGUgQWRhcHRpdmUgQ2FyZHMgbWF5IGNhdXNlIHRoZSB2aWV3IHRvIG1vdmUuXG4gICAgICAgIC8vIFRoaXMgVVggaXMgbm90IGRlc2lyYWJsZSBiZWNhdXNlIGNsaWNrIHNob3VsZCBub3QgY2F1c2Ugc2Nyb2xsLlxuICAgICAgICBpZiAoYWN0aXZlRGVzY2VuZGFudEVsZW1lbnQgJiYgIWFjdGl2ZURlc2NlbmRhbnRFbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgc2Nyb2xsSW50b1ZpZXdXaXRoQmxvY2tOZWFyZXN0KGFjdGl2ZURlc2NlbmRhbnRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW1xuICAgICAgZ2V0RGVzY2VuZGFudElkQnlBY3Rpdml0eUtleSxcbiAgICAgIGNvbnRhaW5lclJlZixcbiAgICAgIGZvY3VzZWRBY3Rpdml0eUtleVJlZixcbiAgICAgIHJlbmRlcmluZ0FjdGl2aXR5S2V5c1JlZixcbiAgICAgIHJhd0ZvY3VzZWRBY3Rpdml0eUtleVJlZixcbiAgICAgIHNldFJhd0ZvY3VzZWRBY3Rpdml0eUtleVxuICAgIF1cbiAgKTtcblxuICBjb25zdCBmb2N1c1JlbGF0aXZlQWN0aXZpdHkgPSB1c2VDYWxsYmFjayhcbiAgICAoZGVsdGE6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3QgeyBjdXJyZW50OiBvcmRlcmVkQWN0aXZpdHlLZXlzIH0gPSByZW5kZXJpbmdBY3Rpdml0eUtleXNSZWY7XG5cbiAgICAgIGlmIChpc05hTihkZWx0YSkgfHwgIW9yZGVyZWRBY3Rpdml0eUtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmb2N1c0J5QWN0aXZpdHlLZXkoZmFsc2UsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGN1cnJlbnQ6IGZvY3VzZWRBY3Rpdml0eUtleSB9ID0gZm9jdXNlZEFjdGl2aXR5S2V5UmVmO1xuXG4gICAgICBjb25zdCBpbmRleCA9IG9yZGVyZWRBY3Rpdml0eUtleXMuaW5kZXhPZihmb2N1c2VkQWN0aXZpdHlLZXkpO1xuICAgICAgY29uc3QgbmV4dEluZGV4ID0gfmluZGV4XG4gICAgICAgID8gTWF0aC5tYXgoMCwgTWF0aC5taW4ob3JkZXJlZEFjdGl2aXR5S2V5cy5sZW5ndGggLSAxLCBpbmRleCArIGRlbHRhKSlcbiAgICAgICAgOiBvcmRlcmVkQWN0aXZpdHlLZXlzLmxlbmd0aCAtIDE7XG5cbiAgICAgIGZvY3VzQnlBY3Rpdml0eUtleShvcmRlcmVkQWN0aXZpdHlLZXlzWytuZXh0SW5kZXhdLCB0cnVlKTtcbiAgICB9LFxuICAgIFtmb2N1c2VkQWN0aXZpdHlLZXlSZWYsIHJlbmRlcmluZ0FjdGl2aXR5S2V5c1JlZiwgZm9jdXNCeUFjdGl2aXR5S2V5XVxuICApO1xuXG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW88VHJhbnNjcmlwdEZvY3VzQ29udGV4dFR5cGU+KFxuICAgICgpID0+ICh7XG4gICAgICBhY3RpdmVEZXNjZW5kYW50SWRTdGF0ZTogT2JqZWN0LmZyZWV6ZShbYWN0aXZlRGVzY2VuZGFudElkXSkgYXMgcmVhZG9ubHkgW3N0cmluZ10sXG4gICAgICBnZXREZXNjZW5kYW50SWRCeUFjdGl2aXR5S2V5LFxuICAgICAgZm9jdXNCeUFjdGl2aXR5S2V5LFxuICAgICAgZm9jdXNlZEFjdGl2aXR5S2V5U3RhdGU6IE9iamVjdC5mcmVlemUoW2ZvY3VzZWRBY3Rpdml0eUtleV0pIGFzIHJlYWRvbmx5IFtzdHJpbmddLFxuICAgICAgZm9jdXNlZEV4cGxpY2l0bHlTdGF0ZTogT2JqZWN0LmZyZWV6ZShbISFyYXdGb2N1c2VkQWN0aXZpdHlLZXldKSBhcyByZWFkb25seSBbYm9vbGVhbl0sXG4gICAgICBmb2N1c1JlbGF0aXZlQWN0aXZpdHlcbiAgICB9KSxcbiAgICBbXG4gICAgICBhY3RpdmVEZXNjZW5kYW50SWQsXG4gICAgICBnZXREZXNjZW5kYW50SWRCeUFjdGl2aXR5S2V5LFxuICAgICAgZm9jdXNCeUFjdGl2aXR5S2V5LFxuICAgICAgZm9jdXNlZEFjdGl2aXR5S2V5LFxuICAgICAgZm9jdXNSZWxhdGl2ZUFjdGl2aXR5LFxuICAgICAgcmF3Rm9jdXNlZEFjdGl2aXR5S2V5XG4gICAgXVxuICApO1xuXG4gIHJldHVybiA8VHJhbnNjcmlwdEZvY3VzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT57Y2hpbGRyZW59PC9UcmFuc2NyaXB0Rm9jdXNDb250ZXh0LlByb3ZpZGVyPjtcbn07XG5cblRyYW5zY3JpcHRGb2N1c0NvbXBvc2VyLnByb3BUeXBlcyA9IHtcbiAgLy8gUHJvcFR5cGVzIGlzIG5vdCBmdWxseSBjb21wYXRpYmxlIHdpdGggVHlwZVNjcmlwdC5cbiAgLy8gQHRzLWlnbm9yZVxuICBjb250YWluZXJSZWY6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgY3VycmVudDogUHJvcFR5cGVzLmluc3RhbmNlT2YoSFRNTEVsZW1lbnQpXG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zY3JpcHRGb2N1c0NvbXBvc2VyO1xuIl19