"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _Context = _interopRequireDefault(require("./Context"));

var _getTabIndex = _interopRequireDefault(require("./getTabIndex"));

var _inputtableKey = _interopRequireDefault(require("./inputtableKey"));

var _excluded = ["children", "disabled", "onKeyDownCapture", "sendFocusRef"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var DEFAULT_STYLE = {
  outline: 0
};

var BaseFocusBox = function BaseFocusBox(_ref, ref) {
  var children = _ref.children,
      disabled = _ref.disabled,
      onKeyDownCapture = _ref.onKeyDownCapture,
      sendFocusRefProp = _ref.sendFocusRef,
      otherProps = _objectWithoutProperties(_ref, _excluded);

  var sendFocusRefPersist = (0, _react.useRef)(null);
  var patchedSendFocusRef = (0, _react.useMemo)(function () {
    return sendFocusRefProp || sendFocusRefPersist;
  }, [sendFocusRefPersist, sendFocusRefProp]);
  var context = (0, _react.useMemo)(function () {
    return {
      sendFocusRef: patchedSendFocusRef
    };
  }, [patchedSendFocusRef]);
  var focus = (0, _react.useCallback)(function () {
    var current = patchedSendFocusRef.current;
    current && current.focus();
  }, [patchedSendFocusRef]);
  var handleKeyDownCapture = (0, _react.useCallback)(function (event) {
    onKeyDownCapture && onKeyDownCapture(event);
    var altKey = event.altKey,
        ctrlKey = event.ctrlKey,
        key = event.key,
        metaKey = event.metaKey,
        target = event.target;
    var tabIndex = (0, _getTabIndex.default)(target);

    if (altKey || ctrlKey && key !== 'v' || metaKey || !(0, _inputtableKey.default)(key) && key !== 'Backspace') {
      // Ignore if one of the utility key (except SHIFT) is pressed
      // E.g. CTRL-C on a link in one of the message should not jump to chat box
      // E.g. "A" or "Backspace" should jump to chat box
      return;
    }

    if (typeof tabIndex !== 'number' || tabIndex < 0 || target.getAttribute('aria-disabled') === 'true') {
      event.stopPropagation();
      focus();
    }
  }, [focus, onKeyDownCapture]);
  return /*#__PURE__*/_react.default.createElement(_Context.default.Provider, {
    value: context
  }, /*#__PURE__*/_react.default.createElement("div", _extends({}, otherProps, {
    onKeyDownCapture: disabled ? undefined : handleKeyDownCapture,
    ref: ref,
    style: DEFAULT_STYLE,
    tabIndex: -1
  }), typeof children === 'function' ? children({
    focus: focus
  }) : children));
};

var FocusBox = /*#__PURE__*/(0, _react.forwardRef)(BaseFocusBox);
FocusBox.defaultProps = BaseFocusBox.defaultProps = {
  children: undefined,
  disabled: false,
  onKeyDownCapture: undefined
};
FocusBox.propTypes = BaseFocusBox.propTypes = {
  children: _propTypes.default.any,
  disabled: _propTypes.default.bool,
  onKeyDownCapture: _propTypes.default.func,
  sendFocusRef: _propTypes.default.shape({
    current: _propTypes.default.shape({
      focus: _propTypes.default.func
    })
  }).isRequired
};
var _default = FocusBox;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9VdGlscy9UeXBlRm9jdXNTaW5rL0ZvY3VzQm94LmpzIl0sIm5hbWVzIjpbIkRFRkFVTFRfU1RZTEUiLCJvdXRsaW5lIiwiQmFzZUZvY3VzQm94IiwicmVmIiwiY2hpbGRyZW4iLCJkaXNhYmxlZCIsIm9uS2V5RG93bkNhcHR1cmUiLCJzZW5kRm9jdXNSZWZQcm9wIiwic2VuZEZvY3VzUmVmIiwib3RoZXJQcm9wcyIsInNlbmRGb2N1c1JlZlBlcnNpc3QiLCJwYXRjaGVkU2VuZEZvY3VzUmVmIiwiY29udGV4dCIsImZvY3VzIiwiY3VycmVudCIsImhhbmRsZUtleURvd25DYXB0dXJlIiwiZXZlbnQiLCJhbHRLZXkiLCJjdHJsS2V5Iiwia2V5IiwibWV0YUtleSIsInRhcmdldCIsInRhYkluZGV4IiwiZ2V0QXR0cmlidXRlIiwic3RvcFByb3BhZ2F0aW9uIiwidW5kZWZpbmVkIiwiRm9jdXNCb3giLCJkZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJhbnkiLCJib29sIiwiZnVuYyIsInNoYXBlIiwiaXNSZXF1aXJlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBR0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxhQUFhLEdBQUc7QUFBRUMsRUFBQUEsT0FBTyxFQUFFO0FBQVgsQ0FBdEI7O0FBRUEsSUFBTUMsWUFBWSxHQUFHLFNBQWZBLFlBQWUsT0FBMEZDLEdBQTFGLEVBQWtHO0FBQUEsTUFBL0ZDLFFBQStGLFFBQS9GQSxRQUErRjtBQUFBLE1BQXJGQyxRQUFxRixRQUFyRkEsUUFBcUY7QUFBQSxNQUEzRUMsZ0JBQTJFLFFBQTNFQSxnQkFBMkU7QUFBQSxNQUEzQ0MsZ0JBQTJDLFFBQXpEQyxZQUF5RDtBQUFBLE1BQXRCQyxVQUFzQjs7QUFDckgsTUFBTUMsbUJBQW1CLEdBQUcsbUJBQU8sSUFBUCxDQUE1QjtBQUNBLE1BQU1DLG1CQUFtQixHQUFHLG9CQUMxQjtBQUFBLFdBQU1KLGdCQUFnQixJQUFJRyxtQkFBMUI7QUFBQSxHQUQwQixFQUUxQixDQUFDQSxtQkFBRCxFQUFzQkgsZ0JBQXRCLENBRjBCLENBQTVCO0FBS0EsTUFBTUssT0FBTyxHQUFHLG9CQUNkO0FBQUEsV0FBTztBQUNMSixNQUFBQSxZQUFZLEVBQUVHO0FBRFQsS0FBUDtBQUFBLEdBRGMsRUFJZCxDQUFDQSxtQkFBRCxDQUpjLENBQWhCO0FBT0EsTUFBTUUsS0FBSyxHQUFHLHdCQUFZLFlBQU07QUFDOUIsUUFBUUMsT0FBUixHQUFvQkgsbUJBQXBCLENBQVFHLE9BQVI7QUFFQUEsSUFBQUEsT0FBTyxJQUFJQSxPQUFPLENBQUNELEtBQVIsRUFBWDtBQUNELEdBSmEsRUFJWCxDQUFDRixtQkFBRCxDQUpXLENBQWQ7QUFNQSxNQUFNSSxvQkFBb0IsR0FBRyx3QkFDM0IsVUFBQUMsS0FBSyxFQUFJO0FBQ1BWLElBQUFBLGdCQUFnQixJQUFJQSxnQkFBZ0IsQ0FBQ1UsS0FBRCxDQUFwQztBQUVBLFFBQVFDLE1BQVIsR0FBa0RELEtBQWxELENBQVFDLE1BQVI7QUFBQSxRQUFnQkMsT0FBaEIsR0FBa0RGLEtBQWxELENBQWdCRSxPQUFoQjtBQUFBLFFBQXlCQyxHQUF6QixHQUFrREgsS0FBbEQsQ0FBeUJHLEdBQXpCO0FBQUEsUUFBOEJDLE9BQTlCLEdBQWtESixLQUFsRCxDQUE4QkksT0FBOUI7QUFBQSxRQUF1Q0MsTUFBdkMsR0FBa0RMLEtBQWxELENBQXVDSyxNQUF2QztBQUNBLFFBQU1DLFFBQVEsR0FBRywwQkFBWUQsTUFBWixDQUFqQjs7QUFFQSxRQUFJSixNQUFNLElBQUtDLE9BQU8sSUFBSUMsR0FBRyxLQUFLLEdBQTlCLElBQXNDQyxPQUF0QyxJQUFrRCxDQUFDLDRCQUFjRCxHQUFkLENBQUQsSUFBdUJBLEdBQUcsS0FBSyxXQUFyRixFQUFtRztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVELFFBQUksT0FBT0csUUFBUCxLQUFvQixRQUFwQixJQUFnQ0EsUUFBUSxHQUFHLENBQTNDLElBQWdERCxNQUFNLENBQUNFLFlBQVAsQ0FBb0IsZUFBcEIsTUFBeUMsTUFBN0YsRUFBcUc7QUFDbkdQLE1BQUFBLEtBQUssQ0FBQ1EsZUFBTjtBQUVBWCxNQUFBQSxLQUFLO0FBQ047QUFDRixHQW5CMEIsRUFvQjNCLENBQUNBLEtBQUQsRUFBUVAsZ0JBQVIsQ0FwQjJCLENBQTdCO0FBdUJBLHNCQUNFLDZCQUFDLGdCQUFELENBQVMsUUFBVDtBQUFrQixJQUFBLEtBQUssRUFBRU07QUFBekIsa0JBQ0UsaURBQ01ILFVBRE47QUFFRSxJQUFBLGdCQUFnQixFQUFFSixRQUFRLEdBQUdvQixTQUFILEdBQWVWLG9CQUYzQztBQUdFLElBQUEsR0FBRyxFQUFFWixHQUhQO0FBSUUsSUFBQSxLQUFLLEVBQUVILGFBSlQ7QUFLRSxJQUFBLFFBQVEsRUFBRSxDQUFDO0FBTGIsTUFPRyxPQUFPSSxRQUFQLEtBQW9CLFVBQXBCLEdBQWlDQSxRQUFRLENBQUM7QUFBRVMsSUFBQUEsS0FBSyxFQUFMQTtBQUFGLEdBQUQsQ0FBekMsR0FBdURULFFBUDFELENBREYsQ0FERjtBQWFELENBeEREOztBQTBEQSxJQUFNc0IsUUFBUSxnQkFBRyx1QkFBV3hCLFlBQVgsQ0FBakI7QUFFQXdCLFFBQVEsQ0FBQ0MsWUFBVCxHQUF3QnpCLFlBQVksQ0FBQ3lCLFlBQWIsR0FBNEI7QUFDbER2QixFQUFBQSxRQUFRLEVBQUVxQixTQUR3QztBQUVsRHBCLEVBQUFBLFFBQVEsRUFBRSxLQUZ3QztBQUdsREMsRUFBQUEsZ0JBQWdCLEVBQUVtQjtBQUhnQyxDQUFwRDtBQU1BQyxRQUFRLENBQUNFLFNBQVQsR0FBcUIxQixZQUFZLENBQUMwQixTQUFiLEdBQXlCO0FBQzVDeEIsRUFBQUEsUUFBUSxFQUFFeUIsbUJBQVVDLEdBRHdCO0FBRTVDekIsRUFBQUEsUUFBUSxFQUFFd0IsbUJBQVVFLElBRndCO0FBRzVDekIsRUFBQUEsZ0JBQWdCLEVBQUV1QixtQkFBVUcsSUFIZ0I7QUFJNUN4QixFQUFBQSxZQUFZLEVBQUVxQixtQkFBVUksS0FBVixDQUFnQjtBQUM1Qm5CLElBQUFBLE9BQU8sRUFBRWUsbUJBQVVJLEtBQVYsQ0FBZ0I7QUFDdkJwQixNQUFBQSxLQUFLLEVBQUVnQixtQkFBVUc7QUFETSxLQUFoQjtBQURtQixHQUFoQixFQUlYRTtBQVJ5QyxDQUE5QztlQVdlUixRIiwic291cmNlUm9vdCI6ImNvbXBvbmVudDovLy8iLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGlzIGZvciBkZWZhdWx0UHJvcHM6IHsgY2hpbGRyZW46IHVuZGVmaW5lZCB9XG4vKiBlc2xpbnQgbm8tdW5kZWZpbmVkOiBcIm9mZlwiICovXG5cbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IENvbnRleHQgZnJvbSAnLi9Db250ZXh0JztcbmltcG9ydCBnZXRUYWJJbmRleCBmcm9tICcuL2dldFRhYkluZGV4JztcbmltcG9ydCBpbnB1dHRhYmxlS2V5IGZyb20gJy4vaW5wdXR0YWJsZUtleSc7XG5cbmNvbnN0IERFRkFVTFRfU1RZTEUgPSB7IG91dGxpbmU6IDAgfTtcblxuY29uc3QgQmFzZUZvY3VzQm94ID0gKHsgY2hpbGRyZW4sIGRpc2FibGVkLCBvbktleURvd25DYXB0dXJlLCBzZW5kRm9jdXNSZWY6IHNlbmRGb2N1c1JlZlByb3AsIC4uLm90aGVyUHJvcHMgfSwgcmVmKSA9PiB7XG4gIGNvbnN0IHNlbmRGb2N1c1JlZlBlcnNpc3QgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHBhdGNoZWRTZW5kRm9jdXNSZWYgPSB1c2VNZW1vKFxuICAgICgpID0+IHNlbmRGb2N1c1JlZlByb3AgfHwgc2VuZEZvY3VzUmVmUGVyc2lzdCxcbiAgICBbc2VuZEZvY3VzUmVmUGVyc2lzdCwgc2VuZEZvY3VzUmVmUHJvcF1cbiAgKTtcblxuICBjb25zdCBjb250ZXh0ID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgc2VuZEZvY3VzUmVmOiBwYXRjaGVkU2VuZEZvY3VzUmVmXG4gICAgfSksXG4gICAgW3BhdGNoZWRTZW5kRm9jdXNSZWZdXG4gICk7XG5cbiAgY29uc3QgZm9jdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBwYXRjaGVkU2VuZEZvY3VzUmVmO1xuXG4gICAgY3VycmVudCAmJiBjdXJyZW50LmZvY3VzKCk7XG4gIH0sIFtwYXRjaGVkU2VuZEZvY3VzUmVmXSk7XG5cbiAgY29uc3QgaGFuZGxlS2V5RG93bkNhcHR1cmUgPSB1c2VDYWxsYmFjayhcbiAgICBldmVudCA9PiB7XG4gICAgICBvbktleURvd25DYXB0dXJlICYmIG9uS2V5RG93bkNhcHR1cmUoZXZlbnQpO1xuXG4gICAgICBjb25zdCB7IGFsdEtleSwgY3RybEtleSwga2V5LCBtZXRhS2V5LCB0YXJnZXQgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgdGFiSW5kZXggPSBnZXRUYWJJbmRleCh0YXJnZXQpO1xuXG4gICAgICBpZiAoYWx0S2V5IHx8IChjdHJsS2V5ICYmIGtleSAhPT0gJ3YnKSB8fCBtZXRhS2V5IHx8ICghaW5wdXR0YWJsZUtleShrZXkpICYmIGtleSAhPT0gJ0JhY2tzcGFjZScpKSB7XG4gICAgICAgIC8vIElnbm9yZSBpZiBvbmUgb2YgdGhlIHV0aWxpdHkga2V5IChleGNlcHQgU0hJRlQpIGlzIHByZXNzZWRcbiAgICAgICAgLy8gRS5nLiBDVFJMLUMgb24gYSBsaW5rIGluIG9uZSBvZiB0aGUgbWVzc2FnZSBzaG91bGQgbm90IGp1bXAgdG8gY2hhdCBib3hcbiAgICAgICAgLy8gRS5nLiBcIkFcIiBvciBcIkJhY2tzcGFjZVwiIHNob3VsZCBqdW1wIHRvIGNoYXQgYm94XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0YWJJbmRleCAhPT0gJ251bWJlcicgfHwgdGFiSW5kZXggPCAwIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGZvY3VzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbZm9jdXMsIG9uS2V5RG93bkNhcHR1cmVdXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dH0+XG4gICAgICA8ZGl2XG4gICAgICAgIHsuLi5vdGhlclByb3BzfVxuICAgICAgICBvbktleURvd25DYXB0dXJlPXtkaXNhYmxlZCA/IHVuZGVmaW5lZCA6IGhhbmRsZUtleURvd25DYXB0dXJlfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgc3R5bGU9e0RFRkFVTFRfU1RZTEV9XG4gICAgICAgIHRhYkluZGV4PXstMX1cbiAgICAgID5cbiAgICAgICAge3R5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHsgZm9jdXMgfSkgOiBjaGlsZHJlbn1cbiAgICAgIDwvZGl2PlxuICAgIDwvQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbmNvbnN0IEZvY3VzQm94ID0gZm9yd2FyZFJlZihCYXNlRm9jdXNCb3gpO1xuXG5Gb2N1c0JveC5kZWZhdWx0UHJvcHMgPSBCYXNlRm9jdXNCb3guZGVmYXVsdFByb3BzID0ge1xuICBjaGlsZHJlbjogdW5kZWZpbmVkLFxuICBkaXNhYmxlZDogZmFsc2UsXG4gIG9uS2V5RG93bkNhcHR1cmU6IHVuZGVmaW5lZFxufTtcblxuRm9jdXNCb3gucHJvcFR5cGVzID0gQmFzZUZvY3VzQm94LnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgb25LZXlEb3duQ2FwdHVyZTogUHJvcFR5cGVzLmZ1bmMsXG4gIHNlbmRGb2N1c1JlZjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjdXJyZW50OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgZm9jdXM6IFByb3BUeXBlcy5mdW5jXG4gICAgfSlcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuZXhwb3J0IGRlZmF1bHQgRm9jdXNCb3g7XG4iXX0=