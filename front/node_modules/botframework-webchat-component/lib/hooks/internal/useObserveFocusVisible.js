"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useObserveFocusVisible;

var _react = require("react");

var _supportPseudoClass = _interopRequireDefault(require("../../Utils/supportPseudoClass"));

var _useNonce3 = _interopRequireDefault(require("./useNonce"));

var _useValueRef = _interopRequireDefault(require("./useValueRef"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var INPUT_TYPES_ALLOW_LIST = ['date', 'datetime-local', 'datetime', 'email', 'month', 'number', 'password', 'search', 'tel', 'text', 'time', 'url', 'week'];
/**
 * Computes whether the given element should automatically trigger the
 * `focus-visible` class being added, i.e. whether it should always match
 * `:focus-visible` when focused.
 * @param {Element} el
 * @return {boolean}
 */

function focusTriggersKeyboardModality(el) {
  var isContentEditable = el.isContentEditable,
      readOnly = el.readOnly,
      tagName = el.tagName,
      type = el.type;
  return tagName === 'INPUT' && INPUT_TYPES_ALLOW_LIST.includes(type) && !readOnly || tagName === 'TEXTAREA' && !readOnly || isContentEditable;
}

function createEventSubscription(target, types, handler) {
  var subscribed;

  var subscribe = function subscribe() {
    if (!subscribed) {
      types.forEach(function (type) {
        return target.addEventListener(type, handler);
      });
      subscribed = true;
    }
  };

  var unsubscribe = function unsubscribe() {
    if (subscribed) {
      types.forEach(function (type) {
        return target.removeEventListener(type, handler);
      });
      subscribed = undefined;
    }
  };

  return {
    pause: unsubscribe,
    resume: subscribe
  };
} // TODO: Add tests
//       1. Focus via keyboard vs. mouse
//       2. Focus via keyboard, switch app, switch back (expect to get another focusVisible after switch back)
//       3. Focus via mouse, switch app, switch back (do NOT expect to get another focusVisible after switch back)


function useObserveFocusVisibleForLegacyBrowsers(targetRef, onFocusVisibleRef) {
  // This polyfill algorithm is adopted from https://github.com/WICG/focus-visible.
  var blurSinceRef = (0, _react.useRef)(0);
  var hadKeyboardEventRef = (0, _react.useRef)(true);
  var hasFocusVisibleRef = (0, _react.useRef)(false);
  var eventSubscription = (0, _react.useMemo)(function () {
    return createEventSubscription(document, ['mousemove', 'mousedown', 'mouseup', 'pointermove', 'pointerdown', 'pointerup', 'touchmove', 'touchstart', 'touchend'], function (event) {
      var _nodeName;

      if (((_nodeName = event.target.nodeName) === null || _nodeName === void 0 ? void 0 : _nodeName.toLowerCase()) !== 'html') {
        hadKeyboardEventRef.current = false;
        eventSubscription.pause();
      }
    });
  }, [hadKeyboardEventRef]);
  var setHasFocusVisible = (0, _react.useCallback)(function (nextHasFocusVisible) {
    if (hasFocusVisibleRef.current !== nextHasFocusVisible) {
      hasFocusVisibleRef.current = nextHasFocusVisible;
      nextHasFocusVisible && (onFocusVisibleRef === null || onFocusVisibleRef === void 0 ? void 0 : onFocusVisibleRef.current());
    }
  }, [hasFocusVisibleRef, onFocusVisibleRef]);
  var handleKeyDown = (0, _react.useCallback)(function (event) {
    if (event.altKey || event.ctrlKey || event.metaKey) {
      return;
    }

    if (event.target === targetRef.current) {
      setHasFocusVisible(true);
    }

    hadKeyboardEventRef.current = true;
  }, [hadKeyboardEventRef, setHasFocusVisible, targetRef]);
  var handlePointerDown = (0, _react.useCallback)(function () {
    hadKeyboardEventRef.current = false;
  }, [hadKeyboardEventRef]);
  var handleFocus = (0, _react.useCallback)(function (_ref) {
    var target = _ref.target;
    target === targetRef.current && (hadKeyboardEventRef.current || focusTriggersKeyboardModality(target)) && setHasFocusVisible(true);
  }, [hadKeyboardEventRef, setHasFocusVisible, targetRef]);
  var handleBlur = (0, _react.useCallback)(function (event) {
    if (event.target === targetRef.current && hasFocusVisibleRef.current) {
      blurSinceRef.current = Date.now();
      setHasFocusVisible(false);
    }
  }, [blurSinceRef, hasFocusVisibleRef, setHasFocusVisible, targetRef]);
  var handleVisibilityChange = (0, _react.useCallback)(function () {
    if (document.visibilityState === 'hidden') {
      // The element is blurred due to "visibilityState" set to "hidden".
      // 100ms is referenced from the WICG polyfill.
      // eslint-disable-next-line no-magic-numbers
      if (Date.now() - blurSinceRef.current < 100) {
        hadKeyboardEventRef.current = true;
      }

      eventSubscription.resume();
    }
  }, [blurSinceRef, eventSubscription, hadKeyboardEventRef]);
  (0, _react.useEffect)(function () {
    document.addEventListener('keydown', handleKeyDown, true);
    document.addEventListener('mousedown', handlePointerDown, true);
    document.addEventListener('pointerdown', handlePointerDown, true);
    document.addEventListener('touchstart', handlePointerDown, true);
    document.addEventListener('visibilitychange', handleVisibilityChange, true);
    return function () {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handlePointerDown);
      document.removeEventListener('pointerdown', handlePointerDown);
      document.removeEventListener('touchstart', handlePointerDown);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, [handleKeyDown, handlePointerDown, handleVisibilityChange]);
  (0, _react.useEffect)(function () {
    var target = targetRef.current;
    target.addEventListener('blur', handleBlur, true);
    target.addEventListener('focus', handleFocus, true);
    return function () {
      target.removeEventListener('blur', handleBlur);
      target.removeEventListener('focus', handleFocus);
    }; // We specifically add "targetRef.current" here.
    // If the target element changed, we should reattach our event listeners.
  }, [handleBlur, handleFocus, targetRef]);
  (0, _react.useEffect)(function () {
    eventSubscription.resume();
    return function () {
      return eventSubscription.pause();
    };
  }, [eventSubscription]);
}

function useObserveFocusVisibleForModernBrowsers(targetRef, onFocusVisibleRef) {
  var handleFocus = (0, _react.useCallback)(function () {
    if (targetRef.current.matches(':focus-visible')) {
      onFocusVisibleRef === null || onFocusVisibleRef === void 0 ? void 0 : onFocusVisibleRef.current();
    }
  }, [onFocusVisibleRef, targetRef]);
  (0, _react.useEffect)(function () {
    var target = targetRef.current;
    target.addEventListener('focus', handleFocus);
    return function () {
      return target.removeEventListener('focus', handleFocus);
    }; // We specifically add "targetRef.current" here.
    // If the target element changed, we should reattach our event listeners.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [handleFocus, targetRef, targetRef.current]);
}

function useObserveFocusVisible(targetRef, onFocusVisible) {
  var _useNonce = (0, _useNonce3.default)(),
      _useNonce2 = _slicedToArray(_useNonce, 1),
      nonce = _useNonce2[0];

  var onFocusVisibleRef = (0, _useValueRef.default)(onFocusVisible); // The nonce is use for browser capabilities. Just in case the "nonce" had changed unexpectedly, the capabilities of the browser should never change.
  // Thus, we are using an initial version of "nonce". In case web devs changed the "nonce" to an invalid value, we won't break rules of hooks (as stated below).

  var nonceRef = (0, _react.useRef)(nonce); // ":focus-visible" selector is supported from Chrome/Edge 86+ and not supported in IE11 or Safari.
  // Doing a capability check on pseudo classes requires injecting a stylesheet, thus nonce is needed.

  var supportFocusVisible = (0, _react.useMemo)(function () {
    return (0, _supportPseudoClass.default)(':focus-visible', nonceRef.current);
  }, [nonceRef]); // Since "supportPseudoClass" is a browser capability, the result should be constant during the page lifetime.
  // Thus, running hooks conditionally is okay here.

  if (supportFocusVisible) {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useObserveFocusVisibleForModernBrowsers(targetRef, onFocusVisibleRef);
  } else {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useObserveFocusVisibleForLegacyBrowsers(targetRef, onFocusVisibleRef);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ob29rcy9pbnRlcm5hbC91c2VPYnNlcnZlRm9jdXNWaXNpYmxlLnRzIl0sIm5hbWVzIjpbIklOUFVUX1RZUEVTX0FMTE9XX0xJU1QiLCJmb2N1c1RyaWdnZXJzS2V5Ym9hcmRNb2RhbGl0eSIsImVsIiwiaXNDb250ZW50RWRpdGFibGUiLCJyZWFkT25seSIsInRhZ05hbWUiLCJ0eXBlIiwiaW5jbHVkZXMiLCJjcmVhdGVFdmVudFN1YnNjcmlwdGlvbiIsInRhcmdldCIsInR5cGVzIiwiaGFuZGxlciIsInN1YnNjcmliZWQiLCJzdWJzY3JpYmUiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsInVuc3Vic2NyaWJlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVuZGVmaW5lZCIsInBhdXNlIiwicmVzdW1lIiwidXNlT2JzZXJ2ZUZvY3VzVmlzaWJsZUZvckxlZ2FjeUJyb3dzZXJzIiwidGFyZ2V0UmVmIiwib25Gb2N1c1Zpc2libGVSZWYiLCJibHVyU2luY2VSZWYiLCJoYWRLZXlib2FyZEV2ZW50UmVmIiwiaGFzRm9jdXNWaXNpYmxlUmVmIiwiZXZlbnRTdWJzY3JpcHRpb24iLCJkb2N1bWVudCIsImV2ZW50Iiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImN1cnJlbnQiLCJzZXRIYXNGb2N1c1Zpc2libGUiLCJuZXh0SGFzRm9jdXNWaXNpYmxlIiwiaGFuZGxlS2V5RG93biIsImFsdEtleSIsImN0cmxLZXkiLCJtZXRhS2V5IiwiaGFuZGxlUG9pbnRlckRvd24iLCJoYW5kbGVGb2N1cyIsImhhbmRsZUJsdXIiLCJEYXRlIiwibm93IiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsInZpc2liaWxpdHlTdGF0ZSIsInVzZU9ic2VydmVGb2N1c1Zpc2libGVGb3JNb2Rlcm5Ccm93c2VycyIsIm1hdGNoZXMiLCJ1c2VPYnNlcnZlRm9jdXNWaXNpYmxlIiwib25Gb2N1c1Zpc2libGUiLCJub25jZSIsIm5vbmNlUmVmIiwic3VwcG9y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QUEsTUFBT0MsS0FBUDs7QUFDQSxNQUFNM0IsaUJBQWlCLEdBQUcsMEJBQVkwQixjQUFaLENBQTFCLENBRjRHLENBSTVHO0FBQ0E7O0FBQ0EsTUFBTUUsUUFBUSxHQUFHLG1CQUFPRCxLQUFQLENBQWpCLENBTjRHLENBUTVHO0FBQ0E7O0FBQ0EsTUFBTUUsbUJBQW1CLEdBQUcsb0JBQVE7QUFBQSxXQUFNLGlDQUFtQixnQkFBbkIsRUFBcUNELFFBQVEsQ0FBQ25CLE9BQTlDLENBQU47QUFBQSxHQUFSLEVBQXNFLENBQUNtQixRQUFELENBQXRFLENBQTVCLENBVjRHLENBWTVHO0FBQ0E7O0FBQ0EsTUFBSUMsbUJBQUosRUFBeUI7QUFDdkI7QUFDQU4sSUFBQUEsdUNBQXVDLENBQUN4QixTQUFELEVBQVlDLGlCQUFaLENBQXZDO0FBQ0QsR0FIRCxNQUdPO0FBQ0w7QUFDQUYsSUFBQUEsdUNBQXVDLENBQUNDLFNBQUQsRUFBWUMsaUJBQVosQ0FBdkM7QUFDRDtBQUNGIiwic291cmNlUm9vdCI6ImNvbXBvbmVudDovLy8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNdXRhYmxlUmVmT2JqZWN0LCBSZWZPYmplY3QsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHN1cHBvcnRQc2V1ZG9DbGFzcyBmcm9tICcuLi8uLi9VdGlscy9zdXBwb3J0UHNldWRvQ2xhc3MnO1xuaW1wb3J0IHVzZU5vbmNlIGZyb20gJy4vdXNlTm9uY2UnO1xuaW1wb3J0IHVzZVZhbHVlUmVmIGZyb20gJy4vdXNlVmFsdWVSZWYnO1xuXG5jb25zdCBJTlBVVF9UWVBFU19BTExPV19MSVNUID0gW1xuICAnZGF0ZScsXG4gICdkYXRldGltZS1sb2NhbCcsXG4gICdkYXRldGltZScsXG4gICdlbWFpbCcsXG4gICdtb250aCcsXG4gICdudW1iZXInLFxuICAncGFzc3dvcmQnLFxuICAnc2VhcmNoJyxcbiAgJ3RlbCcsXG4gICd0ZXh0JyxcbiAgJ3RpbWUnLFxuICAndXJsJyxcbiAgJ3dlZWsnXG5dO1xuXG4vKipcbiAqIENvbXB1dGVzIHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgdHJpZ2dlciB0aGVcbiAqIGBmb2N1cy12aXNpYmxlYCBjbGFzcyBiZWluZyBhZGRlZCwgaS5lLiB3aGV0aGVyIGl0IHNob3VsZCBhbHdheXMgbWF0Y2hcbiAqIGA6Zm9jdXMtdmlzaWJsZWAgd2hlbiBmb2N1c2VkLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZm9jdXNUcmlnZ2Vyc0tleWJvYXJkTW9kYWxpdHkoZWw6IEhUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgaXNDb250ZW50RWRpdGFibGUsIHJlYWRPbmx5LCB0YWdOYW1lLCB0eXBlIH0gPSBlbDtcblxuICByZXR1cm4gKFxuICAgICh0YWdOYW1lID09PSAnSU5QVVQnICYmIElOUFVUX1RZUEVTX0FMTE9XX0xJU1QuaW5jbHVkZXModHlwZSkgJiYgIXJlYWRPbmx5KSB8fFxuICAgICh0YWdOYW1lID09PSAnVEVYVEFSRUEnICYmICFyZWFkT25seSkgfHxcbiAgICBpc0NvbnRlbnRFZGl0YWJsZVxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudFN1YnNjcmlwdGlvbihcbiAgdGFyZ2V0OiBFbGVtZW50IHwgTm9kZSxcbiAgdHlwZXM6IHN0cmluZ1tdLFxuICBoYW5kbGVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG4pOiB7XG4gIHBhdXNlOiAoKSA9PiB2b2lkO1xuICByZXN1bWU6ICgpID0+IHZvaWQ7XG59IHtcbiAgbGV0IHN1YnNjcmliZWQ6IHRydWU7XG5cbiAgY29uc3Qgc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgIGlmICghc3Vic2NyaWJlZCkge1xuICAgICAgdHlwZXMuZm9yRWFjaCh0eXBlID0+IHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpKTtcbiAgICAgIHN1YnNjcmliZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICBpZiAoc3Vic2NyaWJlZCkge1xuICAgICAgdHlwZXMuZm9yRWFjaCh0eXBlID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpKTtcbiAgICAgIHN1YnNjcmliZWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgcGF1c2U6IHVuc3Vic2NyaWJlLFxuICAgIHJlc3VtZTogc3Vic2NyaWJlXG4gIH07XG59XG5cbi8vIFRPRE86IEFkZCB0ZXN0c1xuLy8gICAgICAgMS4gRm9jdXMgdmlhIGtleWJvYXJkIHZzLiBtb3VzZVxuLy8gICAgICAgMi4gRm9jdXMgdmlhIGtleWJvYXJkLCBzd2l0Y2ggYXBwLCBzd2l0Y2ggYmFjayAoZXhwZWN0IHRvIGdldCBhbm90aGVyIGZvY3VzVmlzaWJsZSBhZnRlciBzd2l0Y2ggYmFjaylcbi8vICAgICAgIDMuIEZvY3VzIHZpYSBtb3VzZSwgc3dpdGNoIGFwcCwgc3dpdGNoIGJhY2sgKGRvIE5PVCBleHBlY3QgdG8gZ2V0IGFub3RoZXIgZm9jdXNWaXNpYmxlIGFmdGVyIHN3aXRjaCBiYWNrKVxuZnVuY3Rpb24gdXNlT2JzZXJ2ZUZvY3VzVmlzaWJsZUZvckxlZ2FjeUJyb3dzZXJzKFxuICB0YXJnZXRSZWY6IFJlZk9iamVjdDxIVE1MRWxlbWVudD4sXG4gIG9uRm9jdXNWaXNpYmxlUmVmOiBNdXRhYmxlUmVmT2JqZWN0PCgpID0+IHZvaWQ+XG4pIHtcbiAgLy8gVGhpcyBwb2x5ZmlsbCBhbGdvcml0aG0gaXMgYWRvcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL2ZvY3VzLXZpc2libGUuXG4gIGNvbnN0IGJsdXJTaW5jZVJlZiA9IHVzZVJlZigwKTtcbiAgY29uc3QgaGFkS2V5Ym9hcmRFdmVudFJlZiA9IHVzZVJlZih0cnVlKTtcbiAgY29uc3QgaGFzRm9jdXNWaXNpYmxlUmVmID0gdXNlUmVmKGZhbHNlKTtcblxuICBjb25zdCBldmVudFN1YnNjcmlwdGlvbiA9IHVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIGNyZWF0ZUV2ZW50U3Vic2NyaXB0aW9uKFxuICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgW1xuICAgICAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgICAgICdtb3VzZWRvd24nLFxuICAgICAgICAgICdtb3VzZXVwJyxcbiAgICAgICAgICAncG9pbnRlcm1vdmUnLFxuICAgICAgICAgICdwb2ludGVyZG93bicsXG4gICAgICAgICAgJ3BvaW50ZXJ1cCcsXG4gICAgICAgICAgJ3RvdWNobW92ZScsXG4gICAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICd0b3VjaGVuZCdcbiAgICAgICAgXSxcbiAgICAgICAgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmICgoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5ub2RlTmFtZT8udG9Mb3dlckNhc2UoKSAhPT0gJ2h0bWwnKSB7XG4gICAgICAgICAgICBoYWRLZXlib2FyZEV2ZW50UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGV2ZW50U3Vic2NyaXB0aW9uLnBhdXNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgIFtoYWRLZXlib2FyZEV2ZW50UmVmXVxuICApO1xuXG4gIGNvbnN0IHNldEhhc0ZvY3VzVmlzaWJsZSA9IHVzZUNhbGxiYWNrKFxuICAgIG5leHRIYXNGb2N1c1Zpc2libGUgPT4ge1xuICAgICAgaWYgKGhhc0ZvY3VzVmlzaWJsZVJlZi5jdXJyZW50ICE9PSBuZXh0SGFzRm9jdXNWaXNpYmxlKSB7XG4gICAgICAgIGhhc0ZvY3VzVmlzaWJsZVJlZi5jdXJyZW50ID0gbmV4dEhhc0ZvY3VzVmlzaWJsZTtcbiAgICAgICAgbmV4dEhhc0ZvY3VzVmlzaWJsZSAmJiBvbkZvY3VzVmlzaWJsZVJlZj8uY3VycmVudCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2hhc0ZvY3VzVmlzaWJsZVJlZiwgb25Gb2N1c1Zpc2libGVSZWZdXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IHVzZUNhbGxiYWNrKFxuICAgIChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0YXJnZXRSZWYuY3VycmVudCkge1xuICAgICAgICBzZXRIYXNGb2N1c1Zpc2libGUodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGhhZEtleWJvYXJkRXZlbnRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBbaGFkS2V5Ym9hcmRFdmVudFJlZiwgc2V0SGFzRm9jdXNWaXNpYmxlLCB0YXJnZXRSZWZdXG4gICk7XG5cbiAgY29uc3QgaGFuZGxlUG9pbnRlckRvd24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaGFkS2V5Ym9hcmRFdmVudFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gIH0sIFtoYWRLZXlib2FyZEV2ZW50UmVmXSk7XG5cbiAgY29uc3QgaGFuZGxlRm9jdXMgPSB1c2VDYWxsYmFjayhcbiAgICAoeyB0YXJnZXQgfTogRXZlbnQpID0+IHtcbiAgICAgIHRhcmdldCA9PT0gdGFyZ2V0UmVmLmN1cnJlbnQgJiZcbiAgICAgICAgKGhhZEtleWJvYXJkRXZlbnRSZWYuY3VycmVudCB8fCBmb2N1c1RyaWdnZXJzS2V5Ym9hcmRNb2RhbGl0eSh0YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkpICYmXG4gICAgICAgIHNldEhhc0ZvY3VzVmlzaWJsZSh0cnVlKTtcbiAgICB9LFxuICAgIFtoYWRLZXlib2FyZEV2ZW50UmVmLCBzZXRIYXNGb2N1c1Zpc2libGUsIHRhcmdldFJlZl1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVCbHVyID0gdXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGFyZ2V0UmVmLmN1cnJlbnQgJiYgaGFzRm9jdXNWaXNpYmxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgYmx1clNpbmNlUmVmLmN1cnJlbnQgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHNldEhhc0ZvY3VzVmlzaWJsZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbYmx1clNpbmNlUmVmLCBoYXNGb2N1c1Zpc2libGVSZWYsIHNldEhhc0ZvY3VzVmlzaWJsZSwgdGFyZ2V0UmVmXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGJsdXJyZWQgZHVlIHRvIFwidmlzaWJpbGl0eVN0YXRlXCIgc2V0IHRvIFwiaGlkZGVuXCIuXG4gICAgICAvLyAxMDBtcyBpcyByZWZlcmVuY2VkIGZyb20gdGhlIFdJQ0cgcG9seWZpbGwuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgaWYgKERhdGUubm93KCkgLSBibHVyU2luY2VSZWYuY3VycmVudCA8IDEwMCkge1xuICAgICAgICBoYWRLZXlib2FyZEV2ZW50UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBldmVudFN1YnNjcmlwdGlvbi5yZXN1bWUoKTtcbiAgICB9XG4gIH0sIFtibHVyU2luY2VSZWYsIGV2ZW50U3Vic2NyaXB0aW9uLCBoYWRLZXlib2FyZEV2ZW50UmVmXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBoYW5kbGVQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UsIHRydWUpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKTtcbiAgICB9O1xuICB9LCBbaGFuZGxlS2V5RG93biwgaGFuZGxlUG9pbnRlckRvd24sIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2VdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudDogdGFyZ2V0IH0gPSB0YXJnZXRSZWY7XG5cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIsIHRydWUpO1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZUZvY3VzLCB0cnVlKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpO1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlRm9jdXMpO1xuICAgIH07XG5cbiAgICAvLyBXZSBzcGVjaWZpY2FsbHkgYWRkIFwidGFyZ2V0UmVmLmN1cnJlbnRcIiBoZXJlLlxuICAgIC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBjaGFuZ2VkLCB3ZSBzaG91bGQgcmVhdHRhY2ggb3VyIGV2ZW50IGxpc3RlbmVycy5cbiAgfSwgW2hhbmRsZUJsdXIsIGhhbmRsZUZvY3VzLCB0YXJnZXRSZWZdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGV2ZW50U3Vic2NyaXB0aW9uLnJlc3VtZSgpO1xuXG4gICAgcmV0dXJuICgpID0+IGV2ZW50U3Vic2NyaXB0aW9uLnBhdXNlKCk7XG4gIH0sIFtldmVudFN1YnNjcmlwdGlvbl0pO1xufVxuXG5mdW5jdGlvbiB1c2VPYnNlcnZlRm9jdXNWaXNpYmxlRm9yTW9kZXJuQnJvd3NlcnMoXG4gIHRhcmdldFJlZjogUmVmT2JqZWN0PEhUTUxFbGVtZW50PixcbiAgb25Gb2N1c1Zpc2libGVSZWY6IE11dGFibGVSZWZPYmplY3Q8KCkgPT4gdm9pZD5cbikge1xuICBjb25zdCBoYW5kbGVGb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAodGFyZ2V0UmVmLmN1cnJlbnQubWF0Y2hlcygnOmZvY3VzLXZpc2libGUnKSkge1xuICAgICAgb25Gb2N1c1Zpc2libGVSZWY/LmN1cnJlbnQoKTtcbiAgICB9XG4gIH0sIFtvbkZvY3VzVmlzaWJsZVJlZiwgdGFyZ2V0UmVmXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7IGN1cnJlbnQ6IHRhcmdldCB9ID0gdGFyZ2V0UmVmO1xuXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlRm9jdXMpO1xuXG4gICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIGhhbmRsZUZvY3VzKTtcblxuICAgIC8vIFdlIHNwZWNpZmljYWxseSBhZGQgXCJ0YXJnZXRSZWYuY3VycmVudFwiIGhlcmUuXG4gICAgLy8gSWYgdGhlIHRhcmdldCBlbGVtZW50IGNoYW5nZWQsIHdlIHNob3VsZCByZWF0dGFjaCBvdXIgZXZlbnQgbGlzdGVuZXJzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2hhbmRsZUZvY3VzLCB0YXJnZXRSZWYsIHRhcmdldFJlZi5jdXJyZW50XSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZU9ic2VydmVGb2N1c1Zpc2libGUodGFyZ2V0UmVmOiBSZWZPYmplY3Q8SFRNTEVsZW1lbnQ+LCBvbkZvY3VzVmlzaWJsZTogKCkgPT4gdm9pZCkge1xuICBjb25zdCBbbm9uY2VdID0gdXNlTm9uY2UoKTtcbiAgY29uc3Qgb25Gb2N1c1Zpc2libGVSZWYgPSB1c2VWYWx1ZVJlZihvbkZvY3VzVmlzaWJsZSk7XG5cbiAgLy8gVGhlIG5vbmNlIGlzIHVzZSBmb3IgYnJvd3NlciBjYXBhYmlsaXRpZXMuIEp1c3QgaW4gY2FzZSB0aGUgXCJub25jZVwiIGhhZCBjaGFuZ2VkIHVuZXhwZWN0ZWRseSwgdGhlIGNhcGFiaWxpdGllcyBvZiB0aGUgYnJvd3NlciBzaG91bGQgbmV2ZXIgY2hhbmdlLlxuICAvLyBUaHVzLCB3ZSBhcmUgdXNpbmcgYW4gaW5pdGlhbCB2ZXJzaW9uIG9mIFwibm9uY2VcIi4gSW4gY2FzZSB3ZWIgZGV2cyBjaGFuZ2VkIHRoZSBcIm5vbmNlXCIgdG8gYW4gaW52YWxpZCB2YWx1ZSwgd2Ugd29uJ3QgYnJlYWsgcnVsZXMgb2YgaG9va3MgKGFzIHN0YXRlZCBiZWxvdykuXG4gIGNvbnN0IG5vbmNlUmVmID0gdXNlUmVmKG5vbmNlKTtcblxuICAvLyBcIjpmb2N1cy12aXNpYmxlXCIgc2VsZWN0b3IgaXMgc3VwcG9ydGVkIGZyb20gQ2hyb21lL0VkZ2UgODYrIGFuZCBub3Qgc3VwcG9ydGVkIGluIElFMTEgb3IgU2FmYXJpLlxuICAvLyBEb2luZyBhIGNhcGFiaWxpdHkgY2hlY2sgb24gcHNldWRvIGNsYXNzZXMgcmVxdWlyZXMgaW5qZWN0aW5nIGEgc3R5bGVzaGVldCwgdGh1cyBub25jZSBpcyBuZWVkZWQuXG4gIGNvbnN0IHN1cHBvcnRGb2N1c1Zpc2libGUgPSB1c2VNZW1vKCgpID0+IHN1cHBvcnRQc2V1ZG9DbGFzcygnOmZvY3VzLXZpc2libGUnLCBub25jZVJlZi5jdXJyZW50KSwgW25vbmNlUmVmXSk7XG5cbiAgLy8gU2luY2UgXCJzdXBwb3J0UHNldWRvQ2xhc3NcIiBpcyBhIGJyb3dzZXIgY2FwYWJpbGl0eSwgdGhlIHJlc3VsdCBzaG91bGQgYmUgY29uc3RhbnQgZHVyaW5nIHRoZSBwYWdlIGxpZmV0aW1lLlxuICAvLyBUaHVzLCBydW5uaW5nIGhvb2tzIGNvbmRpdGlvbmFsbHkgaXMgb2theSBoZXJlLlxuICBpZiAoc3VwcG9ydEZvY3VzVmlzaWJsZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHVzZU9ic2VydmVGb2N1c1Zpc2libGVGb3JNb2Rlcm5Ccm93c2Vycyh0YXJnZXRSZWYsIG9uRm9jdXNWaXNpYmxlUmVmKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICB1c2VPYnNlcnZlRm9jdXNWaXNpYmxlRm9yTGVnYWN5QnJvd3NlcnModGFyZ2V0UmVmLCBvbkZvY3VzVmlzaWJsZVJlZik7XG4gIH1cbn1cbiJdfQ==