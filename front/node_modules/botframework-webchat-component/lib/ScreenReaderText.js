"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _useStyleToEmotionObject = _interopRequireDefault(require("./hooks/internal/useStyleToEmotionObject"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint react/forbid-dom-props: ["off"] */
var ROOT_STYLE = {
  // .sr-only - This component is intended to be invisible to the visual Web Chat user, but read by the AT when using a screen reader
  color: 'transparent',
  height: 1,
  overflow: 'hidden',
  position: 'absolute',
  // We need to set top: 0, otherwise, it will repro:
  // - Run NVDA
  // - Make the transcript long enough to show the scrollbar
  // - Press SHIFT-TAB, focus on upload button
  // - Press up arrow multiple times
  top: 0,
  whiteSpace: 'nowrap',
  width: 1
};
var ScreenReaderText = /*#__PURE__*/(0, _react.forwardRef)(function (_ref, ref) {
  var ariaHidden = _ref['aria-hidden'],
      id = _ref.id,
      text = _ref.text;
  var rootClassName = (0, _useStyleToEmotionObject.default)()(ROOT_STYLE) + '';

  if (ariaHidden && !id) {
    console.warn('botframework-webchat assertion: when "aria-hidden" is set, the screen reader text should be read by "aria-labelledby". Thus, "id" must be set.');
  }

  return /*#__PURE__*/_react.default.createElement("div", {
    "aria-hidden": ariaHidden,
    className: rootClassName,
    id: id,
    ref: ref
  }, text);
});
ScreenReaderText.defaultProps = {
  'aria-hidden': undefined,
  id: undefined
};
ScreenReaderText.propTypes = {
  'aria-hidden': _propTypes.default.bool,
  id: _propTypes.default.string,
  text: _propTypes.default.string.isRequired
};
var _default = ScreenReaderText;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9TY3JlZW5SZWFkZXJUZXh0LnRzeCJdLCJuYW1lcyI6WyJST09UX1NUWUxFIiwiY29sb3IiLCJoZWlnaHQiLCJvdmVyZmxvdyIsInBvc2l0aW9uIiwidG9wIiwid2hpdGVTcGFjZSIsIndpZHRoIiwiU2NyZWVuUmVhZGVyVGV4dCIsInJlZiIsImFyaWFIaWRkZW4iLCJpZCIsInRleHQiLCJyb290Q2xhc3NOYW1lIiwiY29uc29sZSIsIndhcm4iLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJib29sIiwic3RyaW5nIiwiaXNSZXF1aXJlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRUE7O0FBQ0E7O0FBSUE7Ozs7Ozs7O0FBUEE7QUFTQSxJQUFNQSxVQUFVLEdBQUc7QUFDakI7QUFDQUMsRUFBQUEsS0FBSyxFQUFFLGFBRlU7QUFHakJDLEVBQUFBLE1BQU0sRUFBRSxDQUhTO0FBSWpCQyxFQUFBQSxRQUFRLEVBQUUsUUFKTztBQUtqQkMsRUFBQUEsUUFBUSxFQUFFLFVBTE87QUFNakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxFQUFBQSxHQUFHLEVBQUUsQ0FYWTtBQVlqQkMsRUFBQUEsVUFBVSxFQUFFLFFBWks7QUFhakJDLEVBQUFBLEtBQUssRUFBRTtBQWJVLENBQW5CO0FBc0JBLElBQU1DLGdCQUE0QyxnQkFBRyx1QkFDbkQsZ0JBQTBDQyxHQUExQyxFQUFrRDtBQUFBLE1BQWhDQyxVQUFnQyxRQUEvQyxhQUErQztBQUFBLE1BQXBCQyxFQUFvQixRQUFwQkEsRUFBb0I7QUFBQSxNQUFoQkMsSUFBZ0IsUUFBaEJBLElBQWdCO0FBQ2hELE1BQU1DLGFBQWEsR0FBRyx3Q0FBMEJiLFVBQTFCLElBQXdDLEVBQTlEOztBQUVBLE1BQUlVLFVBQVUsSUFBSSxDQUFDQyxFQUFuQixFQUF1QjtBQUNyQkcsSUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQ0UsZ0pBREY7QUFHRDs7QUFFRCxzQkFDRTtBQUFLLG1CQUFhTCxVQUFsQjtBQUE4QixJQUFBLFNBQVMsRUFBRUcsYUFBekM7QUFBd0QsSUFBQSxFQUFFLEVBQUVGLEVBQTVEO0FBQWdFLElBQUEsR0FBRyxFQUFFRjtBQUFyRSxLQUNHRyxJQURILENBREY7QUFLRCxDQWZrRCxDQUFyRDtBQWtCQUosZ0JBQWdCLENBQUNRLFlBQWpCLEdBQWdDO0FBQzlCLGlCQUFlQyxTQURlO0FBRTlCTixFQUFBQSxFQUFFLEVBQUVNO0FBRjBCLENBQWhDO0FBS0FULGdCQUFnQixDQUFDVSxTQUFqQixHQUE2QjtBQUMzQixpQkFBZUMsbUJBQVVDLElBREU7QUFFM0JULEVBQUFBLEVBQUUsRUFBRVEsbUJBQVVFLE1BRmE7QUFHM0JULEVBQUFBLElBQUksRUFBRU8sbUJBQVVFLE1BQVYsQ0FBaUJDO0FBSEksQ0FBN0I7ZUFNZWQsZ0IiLCJzb3VyY2VSb290IjoiY29tcG9uZW50Oi8vLyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCByZWFjdC9mb3JiaWQtZG9tLXByb3BzOiBbXCJvZmZcIl0gKi9cblxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgdHlwZSB7IFZGQyB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHVzZVN0eWxlVG9FbW90aW9uT2JqZWN0IGZyb20gJy4vaG9va3MvaW50ZXJuYWwvdXNlU3R5bGVUb0Vtb3Rpb25PYmplY3QnO1xuXG5jb25zdCBST09UX1NUWUxFID0ge1xuICAvLyAuc3Itb25seSAtIFRoaXMgY29tcG9uZW50IGlzIGludGVuZGVkIHRvIGJlIGludmlzaWJsZSB0byB0aGUgdmlzdWFsIFdlYiBDaGF0IHVzZXIsIGJ1dCByZWFkIGJ5IHRoZSBBVCB3aGVuIHVzaW5nIGEgc2NyZWVuIHJlYWRlclxuICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgaGVpZ2h0OiAxLFxuICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAvLyBXZSBuZWVkIHRvIHNldCB0b3A6IDAsIG90aGVyd2lzZSwgaXQgd2lsbCByZXBybzpcbiAgLy8gLSBSdW4gTlZEQVxuICAvLyAtIE1ha2UgdGhlIHRyYW5zY3JpcHQgbG9uZyBlbm91Z2ggdG8gc2hvdyB0aGUgc2Nyb2xsYmFyXG4gIC8vIC0gUHJlc3MgU0hJRlQtVEFCLCBmb2N1cyBvbiB1cGxvYWQgYnV0dG9uXG4gIC8vIC0gUHJlc3MgdXAgYXJyb3cgbXVsdGlwbGUgdGltZXNcbiAgdG9wOiAwLFxuICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgd2lkdGg6IDFcbn07XG5cbnR5cGUgU2NyZWVuUmVhZGVyVGV4dFByb3BzID0ge1xuICAnYXJpYS1oaWRkZW4nPzogYm9vbGVhbjtcbiAgaWQ/OiBzdHJpbmc7XG4gIHRleHQ6IHN0cmluZztcbn07XG5cbmNvbnN0IFNjcmVlblJlYWRlclRleHQ6IFZGQzxTY3JlZW5SZWFkZXJUZXh0UHJvcHM+ID0gZm9yd2FyZFJlZjxIVE1MRGl2RWxlbWVudCwgU2NyZWVuUmVhZGVyVGV4dFByb3BzPihcbiAgKHsgJ2FyaWEtaGlkZGVuJzogYXJpYUhpZGRlbiwgaWQsIHRleHQgfSwgcmVmKSA9PiB7XG4gICAgY29uc3Qgcm9vdENsYXNzTmFtZSA9IHVzZVN0eWxlVG9FbW90aW9uT2JqZWN0KCkoUk9PVF9TVFlMRSkgKyAnJztcblxuICAgIGlmIChhcmlhSGlkZGVuICYmICFpZCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnYm90ZnJhbWV3b3JrLXdlYmNoYXQgYXNzZXJ0aW9uOiB3aGVuIFwiYXJpYS1oaWRkZW5cIiBpcyBzZXQsIHRoZSBzY3JlZW4gcmVhZGVyIHRleHQgc2hvdWxkIGJlIHJlYWQgYnkgXCJhcmlhLWxhYmVsbGVkYnlcIi4gVGh1cywgXCJpZFwiIG11c3QgYmUgc2V0LidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgYXJpYS1oaWRkZW49e2FyaWFIaWRkZW59IGNsYXNzTmFtZT17cm9vdENsYXNzTmFtZX0gaWQ9e2lkfSByZWY9e3JlZn0+XG4gICAgICAgIHt0ZXh0fVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuKTtcblxuU2NyZWVuUmVhZGVyVGV4dC5kZWZhdWx0UHJvcHMgPSB7XG4gICdhcmlhLWhpZGRlbic6IHVuZGVmaW5lZCxcbiAgaWQ6IHVuZGVmaW5lZFxufTtcblxuU2NyZWVuUmVhZGVyVGV4dC5wcm9wVHlwZXMgPSB7XG4gICdhcmlhLWhpZGRlbic6IFByb3BUeXBlcy5ib29sLFxuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcbiAgdGV4dDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTY3JlZW5SZWFkZXJUZXh0O1xuIl19