"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = _callee;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _effects = require("redux-saga/effects");

var _botframeworkDirectlinejs = require("botframework-directlinejs");

var _jwtDecode = _interopRequireDefault(require("jwt-decode"));

var _connect = require("../actions/connect");

var _createPromiseQueue = _interopRequireDefault(require("../createPromiseQueue"));

var _forkPut = _interopRequireDefault(require("./effects/forkPut"));

var _uniqueID = _interopRequireDefault(require("../utils/uniqueID"));

var _updateConnectionStatus = _interopRequireWildcard(require("../actions/updateConnectionStatus"));

var _disconnect = require("../actions/disconnect");

var _reconnect = require("../actions/reconnect");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var _marked = /*#__PURE__*/_regenerator["default"].mark(observeAndPutConnectionStatusUpdate),
    _marked2 = /*#__PURE__*/_regenerator["default"].mark(connectSaga),
    _marked3 = /*#__PURE__*/_regenerator["default"].mark(reconnectSaga),
    _marked4 = /*#__PURE__*/_regenerator["default"].mark(runAsyncEffect),
    _marked5 = /*#__PURE__*/_regenerator["default"].mark(takeDisconnectAsError),
    _marked6 = /*#__PURE__*/_regenerator["default"].mark(_callee);

var CONNECTING = _botframeworkDirectlinejs.ConnectionStatus.Connecting,
    ONLINE = _botframeworkDirectlinejs.ConnectionStatus.Online,
    UNINITIALIZED = _botframeworkDirectlinejs.ConnectionStatus.Uninitialized;

function randomUserID() {
  return "r_".concat((0, _uniqueID["default"])().substr(0, 10));
}

function observeAndPutConnectionStatusUpdate(directLine) {
  var connectionStatusQueue, connectionStatusSubscription, connectionStatus;
  return _regenerator["default"].wrap(function observeAndPutConnectionStatusUpdate$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          connectionStatusQueue = (0, _createPromiseQueue["default"])();
          connectionStatusSubscription = directLine.connectionStatus$.subscribe({
            next: connectionStatusQueue.push
          });
          _context.prev = 2;

        case 3:
          _context.next = 5;
          return (0, _effects.call)(connectionStatusQueue.shift);

        case 5:
          connectionStatus = _context.sent;
          _context.next = 8;
          return (0, _effects.put)((0, _updateConnectionStatus["default"])(connectionStatus));

        case 8:
          _context.next = 3;
          break;

        case 10:
          _context.prev = 10;
          connectionStatusSubscription.unsubscribe();
          return _context.finish(10);

        case 13:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[2,, 10, 13]]);
} // TODO: [P2] We should move this check and rectification to DirectLineJS.


function rectifyUserID(directLine, userIDFromAction) {
  var token = directLine.token;
  var userIDFromToken; // TODO: Add test to make sure "jwt-decode" work as expected.

  try {
    userIDFromToken = ((0, _jwtDecode["default"])(token) || {}).user; // eslint-disable-next-line no-empty
  } catch (err) {}

  var result = {
    fromAction: userIDFromAction,
    fromToken: userIDFromToken
  };

  if (userIDFromToken) {
    if (userIDFromAction && userIDFromAction !== userIDFromToken) {
      console.warn('Web Chat: user ID is both specified in the Direct Line token and passed in, will use the user ID from the token.');
    }

    result["final"] = userIDFromToken;
  } else if (userIDFromAction) {
    if (typeof userIDFromAction !== 'string') {
      console.warn('Web Chat: user ID must be a string.');
      result["final"] = randomUserID();
    } else if (/^dl_/.test(userIDFromAction)) {
      console.warn('Web Chat: user ID prefixed with "dl_" is reserved and must be embedded into the Direct Line token to prevent forgery.');
      result["final"] = randomUserID();
    } else {
      result["final"] = userIDFromAction;
    }
  } else {
    result["final"] = randomUserID();
  }

  return result;
} // We could make this a Promise instead of saga (function generator) to make the code cleaner, if:
// 1. We found a way to cancel Promise
// 2. subscribe() are shared amongst all subscriptions, e.g. turn Observable into events


function connectSaga(directLine) {
  var activitySubscription, unsubscribeActivity, _yield$take, connectionStatus;

  return _regenerator["default"].wrap(function connectSaga$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          // DirectLineJS starts the connection only after the first subscriber for activity$, not connectionStatus$
          activitySubscription = directLine.activity$.subscribe({
            next: function next() {
              return 0;
            }
          });
          unsubscribeActivity = activitySubscription.unsubscribe.bind(activitySubscription);
          _context2.prev = 2;

        case 3:
          _context2.next = 5;
          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);

        case 5:
          _yield$take = _context2.sent;
          connectionStatus = _yield$take.payload.connectionStatus;

          if (!(connectionStatus === ONLINE)) {
            _context2.next = 11;
            break;
          }

          return _context2.abrupt("return", function () {
            unsubscribeActivity();
            directLine.end();
          });

        case 11:
          if (!(connectionStatus !== UNINITIALIZED && connectionStatus !== CONNECTING)) {
            _context2.next = 13;
            break;
          }

          throw new Error("Failed to connect, DirectLineJS returned ".concat(connectionStatus, "."));

        case 13:
          _context2.next = 3;
          break;

        case 15:
          _context2.next = 21;
          break;

        case 17:
          _context2.prev = 17;
          _context2.t0 = _context2["catch"](2);
          // We will unsubscribe if we failed to connect or got cancelled only.
          // We should not unsubscribe in happy case, because DirectLineJS should relying on the subscription to connect/disconnect.
          unsubscribeActivity();
          throw _context2.t0;

        case 21:
          _context2.prev = 21;
          _context2.next = 24;
          return (0, _effects.cancelled)();

        case 24:
          if (!_context2.sent) {
            _context2.next = 26;
            break;
          }

          unsubscribeActivity();

        case 26:
          return _context2.finish(21);

        case 27:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[2, 17, 21, 27]]);
}

function reconnectSaga() {
  var _yield$take2, connectionStatus;

  return _regenerator["default"].wrap(function reconnectSaga$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);

        case 2:
          _yield$take2 = _context3.sent;
          connectionStatus = _yield$take2.payload.connectionStatus;

          if (!(connectionStatus === ONLINE)) {
            _context3.next = 8;
            break;
          }

          return _context3.abrupt("break", 12);

        case 8:
          if (!(connectionStatus !== CONNECTING)) {
            _context3.next = 10;
            break;
          }

          throw new Error("Failed to reconnect. DirectLineJS returned ".concat(connectionStatus, "."));

        case 10:
          _context3.next = 0;
          break;

        case 12:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked3);
} // This is similar to behavior of redux-promise-middleware, but using saga instead of Promise.
// We guarantee PENDING -> FULFILLING -> FULFILLED, or PENDING -> REJECTED. This will help us simplify logic in other part of code.
// Note that after the saga is cancelled, subsequent call to put() will be ignored silently.


function runAsyncEffect(_ref, callEffectFactory) {
  var type, meta, payload, result;
  return _regenerator["default"].wrap(function runAsyncEffect$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          type = _ref.type, meta = _ref.meta, payload = _ref.payload;
          _context4.prev = 1;
          _context4.next = 4;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_PENDING"),
            meta: meta,
            payload: payload
          });

        case 4:
          _context4.next = 6;
          return callEffectFactory();

        case 6:
          result = _context4.sent;
          _context4.next = 9;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_FULFILLING"),
            meta: meta,
            payload: payload
          }, {
            type: "".concat(type, "_FULFILLED"),
            meta: meta,
            payload: payload
          });

        case 9:
          return _context4.abrupt("return", result);

        case 12:
          _context4.prev = 12;
          _context4.t0 = _context4["catch"](1);
          _context4.next = 16;
          return (0, _forkPut["default"])({
            type: "".concat(type, "_REJECTED"),
            error: true,
            meta: meta,
            payload: _context4.t0
          });

        case 16:
          throw _context4.t0;

        case 17:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked4, null, [[1, 12]]);
}

function takeDisconnectAsError() {
  return _regenerator["default"].wrap(function takeDisconnectAsError$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return (0, _effects.take)(_disconnect.DISCONNECT);

        case 2:
          throw new Error('disconnected');

        case 3:
        case "end":
          return _context5.stop();
      }
    }
  }, _marked5);
}

function runAsyncEffectUntilDisconnect(baseAction, callEffectFactory) {
  // We cannot use saga cancel() here, because cancelling saga will prohibit us from sending *_REJECTED.
  // Without REJECTED, it impacts our assumptions around PENDING/FULFILLED/REJECTED.
  return runAsyncEffect(baseAction, /*#__PURE__*/_regenerator["default"].mark(function runUntilDisconnect() {
    var _yield$race, result;

    return _regenerator["default"].wrap(function runUntilDisconnect$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return (0, _effects.race)({
              _: takeDisconnectAsError(),
              result: callEffectFactory()
            });

          case 2:
            _yield$race = _context6.sent;
            result = _yield$race.result;
            return _context6.abrupt("return", result);

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, runUntilDisconnect);
  }));
}

function _callee() {
  var _loop;

  return _regenerator["default"].wrap(function _callee$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _loop = /*#__PURE__*/_regenerator["default"].mark(function _loop() {
            var _yield$take3, _yield$take3$payload, directLine, userIDFromAction, username, updateConnectionStatusTask, rectifiedUserID, meta, disconnectMeta, endDirectLine, _yield$race2, _yield$race2$updateCo, _yield$race2$updateCo2, connectionStatus;

            return _regenerator["default"].wrap(function _loop$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    _context7.next = 2;
                    return (0, _effects.take)(_connect.CONNECT);

                  case 2:
                    _yield$take3 = _context7.sent;
                    _yield$take3$payload = _yield$take3.payload;
                    directLine = _yield$take3$payload.directLine;
                    userIDFromAction = _yield$take3$payload.userID;
                    username = _yield$take3$payload.username;
                    _context7.next = 9;
                    return (0, _effects.fork)(observeAndPutConnectionStatusUpdate, directLine);

                  case 9:
                    updateConnectionStatusTask = _context7.sent;
                    rectifiedUserID = rectifyUserID(directLine, userIDFromAction); // TODO: [P2] Checks if this attached subtask will get killed if the parent task is complete (peacefully), errored out, or cancelled.

                    meta = {
                      userID: rectifiedUserID["final"],
                      username: username
                    }; // Send user ID to DirectLineJS if it was specified from props of <API.Composer>.
                    // However, DirectLineJS may still prefer the user ID from token if it is burnt into the token.
                    // To prevent DirectLineJS giving false warnings, we will only call setUserId() if it is different than the token.

                    directLine.setUserId && rectifiedUserID.fromToken !== meta.userID && directLine.setUserId(meta.userID);
                    disconnectMeta = void 0; // We will dispatch CONNECT_PENDING, wait for connect completed, errored, or cancelled (thru disconnect).
                    // Then dispatch CONNECT_FULFILLED/CONNECT_REJECTED as needed.

                    _context7.prev = 14;
                    _context7.next = 17;
                    return runAsyncEffectUntilDisconnect({
                      type: _connect.CONNECT,
                      meta: meta,
                      payload: {
                        directLine: directLine
                      }
                    }, function () {
                      return (0, _effects.call)(connectSaga, directLine);
                    });

                  case 17:
                    endDirectLine = _context7.sent;
                    _context7.prev = 18;

                  case 19:
                    _context7.next = 21;
                    return (0, _effects.race)({
                      _: (0, _effects.take)(_disconnect.DISCONNECT),
                      updateConnectionStatusAction: (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS)
                    });

                  case 21:
                    _yield$race2 = _context7.sent;
                    _yield$race2$updateCo = _yield$race2.updateConnectionStatusAction;
                    _yield$race2$updateCo = _yield$race2$updateCo === void 0 ? {} : _yield$race2$updateCo;
                    _yield$race2$updateCo2 = _yield$race2$updateCo.payload;
                    _yield$race2$updateCo2 = _yield$race2$updateCo2 === void 0 ? {} : _yield$race2$updateCo2;
                    connectionStatus = _yield$race2$updateCo2.connectionStatus; // If it is not disconnect action, connectionStatus will not be undefined.

                    if (!(connectionStatus === CONNECTING)) {
                      _context7.next = 32;
                      break;
                    }

                    _context7.next = 30;
                    return runAsyncEffectUntilDisconnect({
                      type: _reconnect.RECONNECT,
                      meta: meta,
                      payload: {
                        directLine: directLine
                      }
                    }, function () {
                      return (0, _effects.call)(reconnectSaga);
                    });

                  case 30:
                    _context7.next = 38;
                    break;

                  case 32:
                    if (!(connectionStatus !== ONLINE)) {
                      _context7.next = 38;
                      break;
                    }

                    if (!(typeof connectionStatus !== 'undefined')) {
                      _context7.next = 37;
                      break;
                    }

                    throw new Error("Connection status changed to ".concat(connectionStatus));

                  case 37:
                    return _context7.abrupt("break", 40);

                  case 38:
                    _context7.next = 19;
                    break;

                  case 40:
                    _context7.prev = 40;
                    endDirectLine();
                    return _context7.finish(40);

                  case 43:
                    _context7.next = 48;
                    break;

                  case 45:
                    _context7.prev = 45;
                    _context7.t0 = _context7["catch"](14);
                    disconnectMeta = {
                      error: _context7.t0
                    };

                  case 48:
                    _context7.prev = 48;
                    _context7.next = 51;
                    return (0, _effects.cancel)(updateConnectionStatusTask);

                  case 51:
                    _context7.next = 53;
                    return (0, _forkPut["default"])({
                      type: _disconnect.DISCONNECT_PENDING,
                      meta: disconnectMeta,
                      payload: {
                        directLine: directLine
                      }
                    }, {
                      type: _disconnect.DISCONNECT_FULFILLED,
                      meta: disconnectMeta,
                      payload: {
                        directLine: directLine
                      }
                    });

                  case 53:
                    return _context7.finish(48);

                  case 54:
                  case "end":
                    return _context7.stop();
                }
              }
            }, _loop, null, [[14, 45, 48, 54], [18,, 40, 43]]);
          });

        case 1:
          return _context8.delegateYield(_loop(), "t0", 2);

        case 2:
          _context8.next = 1;
          break;

        case 4:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked6);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zYWdhcy9jb25uZWN0U2FnYS5qcyJdLCJuYW1lcyI6WyJvYnNlcnZlQW5kUHV0Q29ubmVjdGlvblN0YXR1c1VwZGF0ZSIsImNvbm5lY3RTYWdhIiwicmVjb25uZWN0U2FnYSIsInJ1bkFzeW5jRWZmZWN0IiwidGFrZURpc2Nvbm5lY3RBc0Vycm9yIiwiQ09OTkVDVElORyIsIkNvbm5lY3Rpb25TdGF0dXMiLCJDb25uZWN0aW5nIiwiT05MSU5FIiwiT25saW5lIiwiVU5JTklUSUFMSVpFRCIsIlVuaW5pdGlhbGl6ZWQiLCJyYW5kb21Vc2VySUQiLCJzdWJzdHIiLCJkaXJlY3RMaW5lIiwiY29ubmVjdGlvblN0YXR1c1F1ZXVlIiwiY29ubmVjdGlvblN0YXR1c1N1YnNjcmlwdGlvbiIsImNvbm5lY3Rpb25TdGF0dXMkIiwic3Vic2NyaWJlIiwibmV4dCIsInB1c2giLCJzaGlmdCIsImNvbm5lY3Rpb25TdGF0dXMiLCJ1bnN1YnNjcmliZSIsInJlY3RpZnlVc2VySUQiLCJ1c2VySURGcm9tQWN0aW9uIiwidG9rZW4iLCJ1c2VySURGcm9tVG9rZW4iLCJ1c2VyIiwiZXJyIiwicmVzdWx0IiwiZnJvbUFjdGlvbiIsImZyb21Ub2tlbiIsImNvbnNvbGUiLCJ3YXJuIiwidGVzdCIsImFjdGl2aXR5U3Vic2NyaXB0aW9uIiwiYWN0aXZpdHkkIiwidW5zdWJzY3JpYmVBY3Rpdml0eSIsImJpbmQiLCJVUERBVEVfQ09OTkVDVElPTl9TVEFUVVMiLCJwYXlsb2FkIiwiZW5kIiwiRXJyb3IiLCJjYWxsRWZmZWN0RmFjdG9yeSIsInR5cGUiLCJtZXRhIiwiZXJyb3IiLCJESVNDT05ORUNUIiwicnVuQXN5bmNFZmZlY3RVbnRpbERpc2Nvbm5lY3QiLCJiYXNlQWN0aW9uIiwicnVuVW50aWxEaXNjb25uZWN0IiwiXyIsIkNPTk5FQ1QiLCJ1c2VySUQiLCJ1c2VybmFtZSIsInVwZGF0ZUNvbm5lY3Rpb25TdGF0dXNUYXNrIiwicmVjdGlmaWVkVXNlcklEIiwic2V0VXNlcklkIiwiZGlzY29ubmVjdE1ldGEiLCJlbmREaXJlY3RMaW5lIiwidXBkYXRlQ29ubmVjdGlvblN0YXR1c0FjdGlvbiIsIlJFQ09OTkVDVCIsIkRJU0NPTk5FQ1RfUEVORElORyIsIkRJU0NPTk5FQ1RfRlVMRklMTEVEIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozt3REFRVUEsbUM7eURBZ0VBQyxXO3lEQXFDQUMsYTt5REFpQkFDLGM7eURBZ0JBQyxxQjs7O0FBNUlWLElBQW9CQyxVQUFwQixHQUFpRkMsMENBQWpGLENBQVFDLFVBQVI7QUFBQSxJQUF3Q0MsTUFBeEMsR0FBaUZGLDBDQUFqRixDQUFnQ0csTUFBaEM7QUFBQSxJQUErREMsYUFBL0QsR0FBaUZKLDBDQUFqRixDQUFnREssYUFBaEQ7O0FBRUEsU0FBU0MsWUFBVCxHQUF3QjtBQUN0QixxQkFBWSw0QkFBV0MsTUFBWCxDQUFrQixDQUFsQixFQUFxQixFQUFyQixDQUFaO0FBQ0Q7O0FBRUQsU0FBVWIsbUNBQVYsQ0FBOENjLFVBQTlDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNRQyxVQUFBQSxxQkFEUixHQUNnQyxxQ0FEaEM7QUFFUUMsVUFBQUEsNEJBRlIsR0FFdUNGLFVBQVUsQ0FBQ0csaUJBQVgsQ0FBNkJDLFNBQTdCLENBQXVDO0FBQUVDLFlBQUFBLElBQUksRUFBRUoscUJBQXFCLENBQUNLO0FBQTlCLFdBQXZDLENBRnZDO0FBQUE7O0FBQUE7QUFBQTtBQU0rQixpQkFBTSxtQkFBS0wscUJBQXFCLENBQUNNLEtBQTNCLENBQU47O0FBTi9CO0FBTVlDLFVBQUFBLGdCQU5aO0FBQUE7QUFRTSxpQkFBTSxrQkFBSSx3Q0FBdUJBLGdCQUF2QixDQUFKLENBQU47O0FBUk47QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFXSU4sVUFBQUEsNEJBQTRCLENBQUNPLFdBQTdCO0FBWEo7O0FBQUE7QUFBQTtBQUFB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LHdCQUFBQSxVQUFVLEVBQVZBO0FBQUY7QUFBM0QscUJBREksRUFFSjtBQUFFK0Isc0JBQUFBLElBQUksRUFBRW1CLGdDQUFSO0FBQThCbEIsc0JBQUFBLElBQUksRUFBRWEsY0FBcEM7QUFBb0RsQixzQkFBQUEsT0FBTyxFQUFFO0FBQUUzQix3QkFBQUEsVUFBVSxFQUFWQTtBQUFGO0FBQTdELHFCQUZJLENBQU47O0FBekVTO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiY29yZTovLy8iLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogW1wiZXJyb3JcIiwgeyBcImlnbm9yZVwiOiBbMCwgMTBdIH1dICovXG5cbmltcG9ydCB7IGNhbGwsIGNhbmNlbCwgY2FuY2VsbGVkLCBmb3JrLCBwdXQsIHJhY2UsIHRha2UgfSBmcm9tICdyZWR1eC1zYWdhL2VmZmVjdHMnO1xuXG5pbXBvcnQgeyBDb25uZWN0aW9uU3RhdHVzIH0gZnJvbSAnYm90ZnJhbWV3b3JrLWRpcmVjdGxpbmVqcyc7XG5pbXBvcnQgZGVjb2RlIGZyb20gJ2p3dC1kZWNvZGUnO1xuXG5pbXBvcnQgeyBDT05ORUNUIH0gZnJvbSAnLi4vYWN0aW9ucy9jb25uZWN0JztcbmltcG9ydCBjcmVhdGVQcm9taXNlUXVldWUgZnJvbSAnLi4vY3JlYXRlUHJvbWlzZVF1ZXVlJztcbmltcG9ydCBmb3JrUHV0IGZyb20gJy4vZWZmZWN0cy9mb3JrUHV0JztcbmltcG9ydCB1bmlxdWVJRCBmcm9tICcuLi91dGlscy91bmlxdWVJRCc7XG5pbXBvcnQgdXBkYXRlQ29ubmVjdGlvblN0YXR1cywgeyBVUERBVEVfQ09OTkVDVElPTl9TVEFUVVMgfSBmcm9tICcuLi9hY3Rpb25zL3VwZGF0ZUNvbm5lY3Rpb25TdGF0dXMnO1xuXG5pbXBvcnQgeyBESVNDT05ORUNULCBESVNDT05ORUNUX1BFTkRJTkcsIERJU0NPTk5FQ1RfRlVMRklMTEVEIH0gZnJvbSAnLi4vYWN0aW9ucy9kaXNjb25uZWN0JztcblxuaW1wb3J0IHsgUkVDT05ORUNUIH0gZnJvbSAnLi4vYWN0aW9ucy9yZWNvbm5lY3QnO1xuXG5jb25zdCB7IENvbm5lY3Rpbmc6IENPTk5FQ1RJTkcsIE9ubGluZTogT05MSU5FLCBVbmluaXRpYWxpemVkOiBVTklOSVRJQUxJWkVEIH0gPSBDb25uZWN0aW9uU3RhdHVzO1xuXG5mdW5jdGlvbiByYW5kb21Vc2VySUQoKSB7XG4gIHJldHVybiBgcl8ke3VuaXF1ZUlEKCkuc3Vic3RyKDAsIDEwKX1gO1xufVxuXG5mdW5jdGlvbiogb2JzZXJ2ZUFuZFB1dENvbm5lY3Rpb25TdGF0dXNVcGRhdGUoZGlyZWN0TGluZSkge1xuICBjb25zdCBjb25uZWN0aW9uU3RhdHVzUXVldWUgPSBjcmVhdGVQcm9taXNlUXVldWUoKTtcbiAgY29uc3QgY29ubmVjdGlvblN0YXR1c1N1YnNjcmlwdGlvbiA9IGRpcmVjdExpbmUuY29ubmVjdGlvblN0YXR1cyQuc3Vic2NyaWJlKHsgbmV4dDogY29ubmVjdGlvblN0YXR1c1F1ZXVlLnB1c2ggfSk7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uU3RhdHVzID0geWllbGQgY2FsbChjb25uZWN0aW9uU3RhdHVzUXVldWUuc2hpZnQpO1xuXG4gICAgICB5aWVsZCBwdXQodXBkYXRlQ29ubmVjdGlvblN0YXR1cyhjb25uZWN0aW9uU3RhdHVzKSk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGNvbm5lY3Rpb25TdGF0dXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBbUDJdIFdlIHNob3VsZCBtb3ZlIHRoaXMgY2hlY2sgYW5kIHJlY3RpZmljYXRpb24gdG8gRGlyZWN0TGluZUpTLlxuZnVuY3Rpb24gcmVjdGlmeVVzZXJJRChkaXJlY3RMaW5lLCB1c2VySURGcm9tQWN0aW9uKSB7XG4gIGNvbnN0IHsgdG9rZW4gfSA9IGRpcmVjdExpbmU7XG5cbiAgbGV0IHVzZXJJREZyb21Ub2tlbjtcblxuICAvLyBUT0RPOiBBZGQgdGVzdCB0byBtYWtlIHN1cmUgXCJqd3QtZGVjb2RlXCIgd29yayBhcyBleHBlY3RlZC5cbiAgdHJ5IHtcbiAgICB1c2VySURGcm9tVG9rZW4gPSAoZGVjb2RlKHRva2VuKSB8fCB7fSkudXNlcjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBmcm9tQWN0aW9uOiB1c2VySURGcm9tQWN0aW9uLFxuICAgIGZyb21Ub2tlbjogdXNlcklERnJvbVRva2VuXG4gIH07XG5cbiAgaWYgKHVzZXJJREZyb21Ub2tlbikge1xuICAgIGlmICh1c2VySURGcm9tQWN0aW9uICYmIHVzZXJJREZyb21BY3Rpb24gIT09IHVzZXJJREZyb21Ub2tlbikge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnV2ViIENoYXQ6IHVzZXIgSUQgaXMgYm90aCBzcGVjaWZpZWQgaW4gdGhlIERpcmVjdCBMaW5lIHRva2VuIGFuZCBwYXNzZWQgaW4sIHdpbGwgdXNlIHRoZSB1c2VyIElEIGZyb20gdGhlIHRva2VuLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmVzdWx0LmZpbmFsID0gdXNlcklERnJvbVRva2VuO1xuICB9IGVsc2UgaWYgKHVzZXJJREZyb21BY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIHVzZXJJREZyb21BY3Rpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dlYiBDaGF0OiB1c2VyIElEIG11c3QgYmUgYSBzdHJpbmcuJyk7XG5cbiAgICAgIHJlc3VsdC5maW5hbCA9IHJhbmRvbVVzZXJJRCgpO1xuICAgIH0gZWxzZSBpZiAoL15kbF8vdS50ZXN0KHVzZXJJREZyb21BY3Rpb24pKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdXZWIgQ2hhdDogdXNlciBJRCBwcmVmaXhlZCB3aXRoIFwiZGxfXCIgaXMgcmVzZXJ2ZWQgYW5kIG11c3QgYmUgZW1iZWRkZWQgaW50byB0aGUgRGlyZWN0IExpbmUgdG9rZW4gdG8gcHJldmVudCBmb3JnZXJ5LidcbiAgICAgICk7XG5cbiAgICAgIHJlc3VsdC5maW5hbCA9IHJhbmRvbVVzZXJJRCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuZmluYWwgPSB1c2VySURGcm9tQWN0aW9uO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQuZmluYWwgPSByYW5kb21Vc2VySUQoKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIFdlIGNvdWxkIG1ha2UgdGhpcyBhIFByb21pc2UgaW5zdGVhZCBvZiBzYWdhIChmdW5jdGlvbiBnZW5lcmF0b3IpIHRvIG1ha2UgdGhlIGNvZGUgY2xlYW5lciwgaWY6XG4vLyAxLiBXZSBmb3VuZCBhIHdheSB0byBjYW5jZWwgUHJvbWlzZVxuLy8gMi4gc3Vic2NyaWJlKCkgYXJlIHNoYXJlZCBhbW9uZ3N0IGFsbCBzdWJzY3JpcHRpb25zLCBlLmcuIHR1cm4gT2JzZXJ2YWJsZSBpbnRvIGV2ZW50c1xuZnVuY3Rpb24qIGNvbm5lY3RTYWdhKGRpcmVjdExpbmUpIHtcbiAgLy8gRGlyZWN0TGluZUpTIHN0YXJ0cyB0aGUgY29ubmVjdGlvbiBvbmx5IGFmdGVyIHRoZSBmaXJzdCBzdWJzY3JpYmVyIGZvciBhY3Rpdml0eSQsIG5vdCBjb25uZWN0aW9uU3RhdHVzJFxuICBjb25zdCBhY3Rpdml0eVN1YnNjcmlwdGlvbiA9IGRpcmVjdExpbmUuYWN0aXZpdHkkLnN1YnNjcmliZSh7IG5leHQ6ICgpID0+IDAgfSk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlQWN0aXZpdHkgPSBhY3Rpdml0eVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZS5iaW5kKGFjdGl2aXR5U3Vic2NyaXB0aW9uKTtcblxuICB0cnkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGF5bG9hZDogeyBjb25uZWN0aW9uU3RhdHVzIH1cbiAgICAgIH0gPSB5aWVsZCB0YWtlKFVQREFURV9DT05ORUNUSU9OX1NUQVRVUyk7XG5cbiAgICAgIGlmIChjb25uZWN0aW9uU3RhdHVzID09PSBPTkxJTkUpIHtcbiAgICAgICAgLy8gVE9ETzogW1AyXSBEaXJlY3RMaW5lSlMgc2hvdWxkIGtpbGwgdGhlIGNvbm5lY3Rpb24gd2hlbiB3ZSB1bnN1YnNjcmliZVxuICAgICAgICAvLyAgICAgICBCdXQgY3VycmVudGx5IGluIHYzLCBEaXJlY3RMaW5lSlMgZG9lcyBub3QgaGF2ZSB0aGlzIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgLy8gICAgICAgVGh1cywgd2UgbmVlZCB0byBjYWxsIFwiZW5kKClcIiBleHBsaWNpdGx5XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICB1bnN1YnNjcmliZUFjdGl2aXR5KCk7XG4gICAgICAgICAgZGlyZWN0TGluZS5lbmQoKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXR1cyAhPT0gVU5JTklUSUFMSVpFRCAmJiBjb25uZWN0aW9uU3RhdHVzICE9PSBDT05ORUNUSU5HKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNvbm5lY3QsIERpcmVjdExpbmVKUyByZXR1cm5lZCAke2Nvbm5lY3Rpb25TdGF0dXN9LmApO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gV2Ugd2lsbCB1bnN1YnNjcmliZSBpZiB3ZSBmYWlsZWQgdG8gY29ubmVjdCBvciBnb3QgY2FuY2VsbGVkIG9ubHkuXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCB1bnN1YnNjcmliZSBpbiBoYXBweSBjYXNlLCBiZWNhdXNlIERpcmVjdExpbmVKUyBzaG91bGQgcmVseWluZyBvbiB0aGUgc3Vic2NyaXB0aW9uIHRvIGNvbm5lY3QvZGlzY29ubmVjdC5cbiAgICB1bnN1YnNjcmliZUFjdGl2aXR5KCk7XG5cbiAgICB0aHJvdyBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgaWYgKHlpZWxkIGNhbmNlbGxlZCgpKSB7XG4gICAgICB1bnN1YnNjcmliZUFjdGl2aXR5KCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uKiByZWNvbm5lY3RTYWdhKCkge1xuICBmb3IgKDs7KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGF5bG9hZDogeyBjb25uZWN0aW9uU3RhdHVzIH1cbiAgICB9ID0geWllbGQgdGFrZShVUERBVEVfQ09OTkVDVElPTl9TVEFUVVMpO1xuXG4gICAgaWYgKGNvbm5lY3Rpb25TdGF0dXMgPT09IE9OTElORSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdHVzICE9PSBDT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZWNvbm5lY3QuIERpcmVjdExpbmVKUyByZXR1cm5lZCAke2Nvbm5lY3Rpb25TdGF0dXN9LmApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIGlzIHNpbWlsYXIgdG8gYmVoYXZpb3Igb2YgcmVkdXgtcHJvbWlzZS1taWRkbGV3YXJlLCBidXQgdXNpbmcgc2FnYSBpbnN0ZWFkIG9mIFByb21pc2UuXG4vLyBXZSBndWFyYW50ZWUgUEVORElORyAtPiBGVUxGSUxMSU5HIC0+IEZVTEZJTExFRCwgb3IgUEVORElORyAtPiBSRUpFQ1RFRC4gVGhpcyB3aWxsIGhlbHAgdXMgc2ltcGxpZnkgbG9naWMgaW4gb3RoZXIgcGFydCBvZiBjb2RlLlxuLy8gTm90ZSB0aGF0IGFmdGVyIHRoZSBzYWdhIGlzIGNhbmNlbGxlZCwgc3Vic2VxdWVudCBjYWxsIHRvIHB1dCgpIHdpbGwgYmUgaWdub3JlZCBzaWxlbnRseS5cbmZ1bmN0aW9uKiBydW5Bc3luY0VmZmVjdCh7IHR5cGUsIG1ldGEsIHBheWxvYWQgfSwgY2FsbEVmZmVjdEZhY3RvcnkpIHtcbiAgdHJ5IHtcbiAgICB5aWVsZCBmb3JrUHV0KHsgdHlwZTogYCR7dHlwZX1fUEVORElOR2AsIG1ldGEsIHBheWxvYWQgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBjYWxsRWZmZWN0RmFjdG9yeSgpO1xuXG4gICAgeWllbGQgZm9ya1B1dCh7IHR5cGU6IGAke3R5cGV9X0ZVTEZJTExJTkdgLCBtZXRhLCBwYXlsb2FkIH0sIHsgdHlwZTogYCR7dHlwZX1fRlVMRklMTEVEYCwgbWV0YSwgcGF5bG9hZCB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKHBheWxvYWQpIHtcbiAgICB5aWVsZCBmb3JrUHV0KHsgdHlwZTogYCR7dHlwZX1fUkVKRUNURURgLCBlcnJvcjogdHJ1ZSwgbWV0YSwgcGF5bG9hZCB9KTtcblxuICAgIHRocm93IHBheWxvYWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24qIHRha2VEaXNjb25uZWN0QXNFcnJvcigpIHtcbiAgeWllbGQgdGFrZShESVNDT05ORUNUKTtcblxuICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc2Nvbm5lY3RlZCcpO1xufVxuXG5mdW5jdGlvbiBydW5Bc3luY0VmZmVjdFVudGlsRGlzY29ubmVjdChiYXNlQWN0aW9uLCBjYWxsRWZmZWN0RmFjdG9yeSkge1xuICAvLyBXZSBjYW5ub3QgdXNlIHNhZ2EgY2FuY2VsKCkgaGVyZSwgYmVjYXVzZSBjYW5jZWxsaW5nIHNhZ2Egd2lsbCBwcm9oaWJpdCB1cyBmcm9tIHNlbmRpbmcgKl9SRUpFQ1RFRC5cbiAgLy8gV2l0aG91dCBSRUpFQ1RFRCwgaXQgaW1wYWN0cyBvdXIgYXNzdW1wdGlvbnMgYXJvdW5kIFBFTkRJTkcvRlVMRklMTEVEL1JFSkVDVEVELlxuICByZXR1cm4gcnVuQXN5bmNFZmZlY3QoYmFzZUFjdGlvbiwgZnVuY3Rpb24qIHJ1blVudGlsRGlzY29ubmVjdCgpIHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0geWllbGQgcmFjZSh7XG4gICAgICBfOiB0YWtlRGlzY29ubmVjdEFzRXJyb3IoKSxcbiAgICAgIHJlc3VsdDogY2FsbEVmZmVjdEZhY3RvcnkoKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKiAoKSB7XG4gIGZvciAoOzspIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXlsb2FkOiB7IGRpcmVjdExpbmUsIHVzZXJJRDogdXNlcklERnJvbUFjdGlvbiwgdXNlcm5hbWUgfVxuICAgIH0gPSB5aWVsZCB0YWtlKENPTk5FQ1QpO1xuXG4gICAgY29uc3QgdXBkYXRlQ29ubmVjdGlvblN0YXR1c1Rhc2sgPSB5aWVsZCBmb3JrKG9ic2VydmVBbmRQdXRDb25uZWN0aW9uU3RhdHVzVXBkYXRlLCBkaXJlY3RMaW5lKTtcbiAgICBjb25zdCByZWN0aWZpZWRVc2VySUQgPSByZWN0aWZ5VXNlcklEKGRpcmVjdExpbmUsIHVzZXJJREZyb21BY3Rpb24pO1xuXG4gICAgLy8gVE9ETzogW1AyXSBDaGVja3MgaWYgdGhpcyBhdHRhY2hlZCBzdWJ0YXNrIHdpbGwgZ2V0IGtpbGxlZCBpZiB0aGUgcGFyZW50IHRhc2sgaXMgY29tcGxldGUgKHBlYWNlZnVsbHkpLCBlcnJvcmVkIG91dCwgb3IgY2FuY2VsbGVkLlxuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICB1c2VySUQ6IHJlY3RpZmllZFVzZXJJRC5maW5hbCxcbiAgICAgIHVzZXJuYW1lXG4gICAgfTtcblxuICAgIC8vIFNlbmQgdXNlciBJRCB0byBEaXJlY3RMaW5lSlMgaWYgaXQgd2FzIHNwZWNpZmllZCBmcm9tIHByb3BzIG9mIDxBUEkuQ29tcG9zZXI+LlxuICAgIC8vIEhvd2V2ZXIsIERpcmVjdExpbmVKUyBtYXkgc3RpbGwgcHJlZmVyIHRoZSB1c2VyIElEIGZyb20gdG9rZW4gaWYgaXQgaXMgYnVybnQgaW50byB0aGUgdG9rZW4uXG4gICAgLy8gVG8gcHJldmVudCBEaXJlY3RMaW5lSlMgZ2l2aW5nIGZhbHNlIHdhcm5pbmdzLCB3ZSB3aWxsIG9ubHkgY2FsbCBzZXRVc2VySWQoKSBpZiBpdCBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgdG9rZW4uXG4gICAgZGlyZWN0TGluZS5zZXRVc2VySWQgJiYgcmVjdGlmaWVkVXNlcklELmZyb21Ub2tlbiAhPT0gbWV0YS51c2VySUQgJiYgZGlyZWN0TGluZS5zZXRVc2VySWQobWV0YS51c2VySUQpO1xuXG4gICAgbGV0IGRpc2Nvbm5lY3RNZXRhO1xuXG4gICAgLy8gV2Ugd2lsbCBkaXNwYXRjaCBDT05ORUNUX1BFTkRJTkcsIHdhaXQgZm9yIGNvbm5lY3QgY29tcGxldGVkLCBlcnJvcmVkLCBvciBjYW5jZWxsZWQgKHRocnUgZGlzY29ubmVjdCkuXG4gICAgLy8gVGhlbiBkaXNwYXRjaCBDT05ORUNUX0ZVTEZJTExFRC9DT05ORUNUX1JFSkVDVEVEIGFzIG5lZWRlZC5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5kRGlyZWN0TGluZSA9IHlpZWxkIHJ1bkFzeW5jRWZmZWN0VW50aWxEaXNjb25uZWN0KFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogQ09OTkVDVCxcbiAgICAgICAgICBtZXRhLFxuICAgICAgICAgIHBheWxvYWQ6IHsgZGlyZWN0TGluZSB9XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IGNhbGwoY29ubmVjdFNhZ2EsIGRpcmVjdExpbmUpXG4gICAgICApO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgLy8gV2UgYXJlIHdhaXRpbmcgZm9yIGNvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZSBvciBkaXNjb25uZWN0IGFjdGlvbi5cbiAgICAgICAgICBjb25zdCB7IHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXNBY3Rpb246IHsgcGF5bG9hZDogeyBjb25uZWN0aW9uU3RhdHVzIH0gPSB7fSB9ID0ge30gfSA9IHlpZWxkIHJhY2Uoe1xuICAgICAgICAgICAgXzogdGFrZShESVNDT05ORUNUKSxcbiAgICAgICAgICAgIHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXNBY3Rpb246IHRha2UoVVBEQVRFX0NPTk5FQ1RJT05fU1RBVFVTKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gSWYgaXQgaXMgbm90IGRpc2Nvbm5lY3QgYWN0aW9uLCBjb25uZWN0aW9uU3RhdHVzIHdpbGwgbm90IGJlIHVuZGVmaW5lZC5cbiAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXR1cyA9PT0gQ09OTkVDVElORykge1xuICAgICAgICAgICAgLy8gSWYgRGlyZWN0TGluZUpTIGNoYW5nZWQgY29ubmVjdGlvblN0YXR1cyB0byBDT05ORUNUSU5HLCB3ZSB3aWxsIHRyZWF0IGl0IGFzIHJlY29ubmVjdCBzdGF0dXMuXG4gICAgICAgICAgICB5aWVsZCBydW5Bc3luY0VmZmVjdFVudGlsRGlzY29ubmVjdChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFJFQ09OTkVDVCxcbiAgICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHsgZGlyZWN0TGluZSB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICgpID0+IGNhbGwocmVjb25uZWN0U2FnYSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdHVzICE9PSBPTkxJTkUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29ubmVjdGlvblN0YXR1cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBraWxsIHRoZSBjb25uZWN0aW9uIGJlY2F1c2UgRGlyZWN0TGluZUpTIHdhbnQgdG8gY2xvc2UgaXQuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiBzdGF0dXMgY2hhbmdlZCB0byAke2Nvbm5lY3Rpb25TdGF0dXN9YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBTb21lb25lIGRpc3BhdGNoZWQgZGlzY29ubmVjdCBhY3Rpb24uXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZW5kRGlyZWN0TGluZSgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkaXNjb25uZWN0TWV0YSA9IHsgZXJyb3IgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgeWllbGQgY2FuY2VsKHVwZGF0ZUNvbm5lY3Rpb25TdGF0dXNUYXNrKTtcblxuICAgICAgLy8gRXZlbiBpZiB0aGUgY29ubmVjdGlvbiBpcyBpbnRlcnJ1cHRlZCwgd2Ugd2lsbCBzdGlsbCBlbWl0IERJU0NPTk5FQ1RfUEVORElORy5cbiAgICAgIC8vIFRoaXMgd2lsbCBtYWtlcyBoYW5kbGluZyBsb2dpYyBlYXNpZXIuIElmIENPTk5FQ1RfRlVMRklMTEVELCB3ZSBndWFyYW50ZWUgRElTQ09OTkVDVF9QRU5ESU5HLlxuICAgICAgeWllbGQgZm9ya1B1dChcbiAgICAgICAgeyB0eXBlOiBESVNDT05ORUNUX1BFTkRJTkcsIG1ldGE6IGRpc2Nvbm5lY3RNZXRhLCBwYXlsb2FkOiB7IGRpcmVjdExpbmUgfSB9LFxuICAgICAgICB7IHR5cGU6IERJU0NPTk5FQ1RfRlVMRklMTEVELCBtZXRhOiBkaXNjb25uZWN0TWV0YSwgcGF5bG9hZDogeyBkaXJlY3RMaW5lIH0gfVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==