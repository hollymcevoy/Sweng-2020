"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyMiddleware;
exports.forLegacyRenderer = forLegacyRenderer;
exports.forRenderer = forRenderer;

var _react = _interopRequireWildcard(require("react"));

var _ErrorBox = _interopRequireDefault(require("../internal/ErrorBox"));

var _concatMiddleware = _interopRequireDefault(require("./concatMiddleware"));

var _UserlandBoundary = _interopRequireDefault(require("./UserlandBoundary"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function applyMiddleware(type) {
  for (var _len = arguments.length, middleware = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    middleware[_key - 1] = arguments[_key];
  }

  return function () {
    return _concatMiddleware.default.apply(void 0, middleware).apply(void 0, arguments)(function () {
      throw new Error("reached terminator of ".concat(type));
    });
  };
}

function forLegacyRenderer(type) {
  for (var _len2 = arguments.length, middleware = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    middleware[_key2 - 1] = arguments[_key2];
  }

  return function () {
    var fn = _concatMiddleware.default.apply(void 0, middleware).apply(void 0, arguments)(function () {
      throw new Error("reached terminator of ".concat(type));
    });

    return function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return /*#__PURE__*/_react.default.createElement(_UserlandBoundary.default, {
        type: "render of ".concat(type)
      }, function () {
        try {
          return fn.apply(void 0, args);
        } catch (err) {
          return /*#__PURE__*/_react.default.createElement(_ErrorBox.default, {
            error: err,
            type: "render of ".concat(type)
          });
        }
      });
    };
  };
}
/**
 *
 * @param {string} type Required. String equivalent of type of container to be rendered.
 * @param { strict = false } - Used to enforce new middleware format which cooperates with new activity grouping.
 * @see See {@link https://github.com/microsoft/BotFramework-WebChat/blob/main/CHANGELOG.md#4100---2020-08-18} and {@link https://github.com/microsoft/BotFramework-WebChat/pull/3365} for middleware breaking changes.
 * @param  {middleware[]} middleware list of middleware to be applied.
 * 'createRendererArgs' is "what to render"; for example, an activity.
 * @returns  Returns a function if there is a renderer *committed* to render OR returns false if nothing should be rendered.
 */


function forRenderer(type) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$strict = _ref.strict,
      strict = _ref$strict === void 0 ? false : _ref$strict;

  for (var _len4 = arguments.length, middleware = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
    middleware[_key4 - 2] = arguments[_key4];
  }

  return function () {
    var runMiddleware = _concatMiddleware.default.apply(void 0, middleware).apply(void 0, arguments)(function () {
      return /*#__PURE__*/_react.default.createElement(_ErrorBox.default, {
        error: new Error("reached terminator of ".concat(type)),
        type: type
      });
    });

    return function () {
      try {
        var render = runMiddleware.apply(void 0, arguments);

        if (!render) {
          return false;
        } else if ( /*#__PURE__*/(0, _react.isValidElement)(render)) {
          if (strict) {
            console.error("botframework-webchat: ".concat(type, " should only return either false or a render function."));
            return false;
          }

          return /*#__PURE__*/_react.default.createElement(_UserlandBoundary.default, {
            type: "render of ".concat(type)
          }, render);
        }

        return function () {
          for (var _len5 = arguments.length, renderTimeArgs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
            renderTimeArgs[_key5] = arguments[_key5];
          }

          return /*#__PURE__*/_react.default.createElement(_UserlandBoundary.default, {
            type: "render of ".concat(type)
          }, function () {
            try {
              var element = render.apply(void 0, renderTimeArgs);

              if (strict && ! /*#__PURE__*/(0, _react.isValidElement)(element)) {
                console.error("botframework-webchat: ".concat(type, " should return React element only."));
              }

              return element;
            } catch (err) {
              return /*#__PURE__*/_react.default.createElement(_ErrorBox.default, {
                error: err,
                type: "render of ".concat(type)
              });
            }
          });
        };
      } catch (err) {
        return /*#__PURE__*/_react.default.createElement(_ErrorBox.default, {
          error: err,
          type: "render of ".concat(type)
        });
      }
    };
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ob29rcy9taWRkbGV3YXJlL2FwcGx5TWlkZGxld2FyZS5qcyJdLCJuYW1lcyI6WyJhcHBseU1pZGRsZXdhcmUiLCJ0eXBlIiwibWlkZGxld2FyZSIsImNvbmNhdE1pZGRsZXdhcmUiLCJFcnJvciIsImZvckxlZ2FjeVJlbmRlcmVyIiwiZm4iLCJhcmdzIiwiZXJyIiwiZm9yUmVuZGVyZXIiLCJzdHJpY3QiLCJydW5NaWRkbGV3YXJlIiwicmVuZGVyIiwiY29uc29sZSIsImVycm9yIiwicmVuZGVyVGltZUFyZ3MiLCJlbGVtZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztBQUVlLFNBQVNBLGVBQVQsQ0FBeUJDLElBQXpCLEVBQThDO0FBQUEsb0NBQVpDLFVBQVk7QUFBWkEsSUFBQUEsVUFBWTtBQUFBOztBQUMzRCxTQUFPO0FBQUEsV0FDTEMsd0NBQW9CRCxVQUFwQiwyQkFBOEMsWUFBTTtBQUNsRCxZQUFNLElBQUlFLEtBQUosaUNBQW1DSCxJQUFuQyxFQUFOO0FBQ0QsS0FGRCxDQURLO0FBQUEsR0FBUDtBQUlEOztBQUVNLFNBQVNJLGlCQUFULENBQTJCSixJQUEzQixFQUFnRDtBQUFBLHFDQUFaQyxVQUFZO0FBQVpBLElBQUFBLFVBQVk7QUFBQTs7QUFDckQsU0FBTyxZQUFrQjtBQUN2QixRQUFNSSxFQUFFLEdBQUdILHdDQUFvQkQsVUFBcEIsMkJBQThDLFlBQU07QUFDN0QsWUFBTSxJQUFJRSxLQUFKLGlDQUFtQ0gsSUFBbkMsRUFBTjtBQUNELEtBRlUsQ0FBWDs7QUFJQSxXQUFPO0FBQUEseUNBQUlNLElBQUo7QUFBSUEsUUFBQUEsSUFBSjtBQUFBOztBQUFBLDBCQUNMLDZCQUFDLHlCQUFEO0FBQWtCLFFBQUEsSUFBSSxzQkFBZU4sSUFBZjtBQUF0QixTQUNHLFlBQU07QUFDTCxZQUFJO0FBQ0YsaUJBQU9LLEVBQUUsTUFBRixTQUFNQyxJQUFOLENBQVA7QUFDRCxTQUZELENBRUUsT0FBT0MsR0FBUCxFQUFZO0FBQ1osOEJBQU8sNkJBQUMsaUJBQUQ7QUFBVSxZQUFBLEtBQUssRUFBRUEsR0FBakI7QUFBc0IsWUFBQSxJQUFJLHNCQUFlUCxJQUFmO0FBQTFCLFlBQVA7QUFDRDtBQUNGLE9BUEgsQ0FESztBQUFBLEtBQVA7QUFXRCxHQWhCRDtBQWlCRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ08sU0FBU1EsV0FBVCxDQUFxQlIsSUFBckIsRUFBbUU7QUFBQSxpRkFBbkIsRUFBbUI7QUFBQSx5QkFBdENTLE1BQXNDO0FBQUEsTUFBdENBLE1BQXNDLDRCQUE3QixLQUE2Qjs7QUFBQSxxQ0FBWlIsVUFBWTtBQUFaQSxJQUFBQSxVQUFZO0FBQUE7O0FBQ3hFLFNBQU8sWUFBa0I7QUFDdkIsUUFBTVMsYUFBYSxHQUFHUix3Q0FBb0JELFVBQXBCLDJCQUE4QztBQUFBLDBCQUNsRSw2QkFBQyxpQkFBRDtBQUFVLFFBQUEsS0FBSyxFQUFFLElBQUlFLEtBQUosaUNBQW1DSCxJQUFuQyxFQUFqQjtBQUE2RCxRQUFBLElBQUksRUFBRUE7QUFBbkUsUUFEa0U7QUFBQSxLQUE5QyxDQUF0Qjs7QUFJQSxXQUFPLFlBQTJCO0FBQ2hDLFVBQUk7QUFDRixZQUFNVyxNQUFNLEdBQUdELGFBQWEsTUFBYixtQkFBZjs7QUFFQSxZQUFJLENBQUNDLE1BQUwsRUFBYTtBQUNYLGlCQUFPLEtBQVA7QUFDRCxTQUZELE1BRU8sa0JBQUksMkJBQWVBLE1BQWYsQ0FBSixFQUE0QjtBQUNqQyxjQUFJRixNQUFKLEVBQVk7QUFDVkcsWUFBQUEsT0FBTyxDQUFDQyxLQUFSLGlDQUF1Q2IsSUFBdkM7QUFFQSxtQkFBTyxLQUFQO0FBQ0Q7O0FBRUQsOEJBQU8sNkJBQUMseUJBQUQ7QUFBa0IsWUFBQSxJQUFJLHNCQUFlQSxJQUFmO0FBQXRCLGFBQThDVyxNQUE5QyxDQUFQO0FBQ0Q7O0FBRUQsZUFBTztBQUFBLDZDQUFJRyxjQUFKO0FBQUlBLFlBQUFBLGNBQUo7QUFBQTs7QUFBQSw4QkFDTCw2QkFBQyx5QkFBRDtBQUFrQixZQUFBLElBQUksc0JBQWVkLElBQWY7QUFBdEIsYUFDRyxZQUFNO0FBQ0wsZ0JBQUk7QUFDRixrQkFBTWUsT0FBTyxHQUFHSixNQUFNLE1BQU4sU0FBVUcsY0FBVixDQUFoQjs7QUFFQSxrQkFBSUwsTUFBTSxJQUFJLGVBQUMsMkJBQWVNLE9BQWYsQ0FBZixFQUF3QztBQUN0Q0gsZ0JBQUFBLE9BQU8sQ0FBQ0MsS0FBUixpQ0FBdUNiLElBQXZDO0FBQ0Q7O0FBRUQscUJBQU9lLE9BQVA7QUFDRCxhQVJELENBUUUsT0FBT1IsR0FBUCxFQUFZO0FBQ1osa0NBQU8sNkJBQUMsaUJBQUQ7QUFBVSxnQkFBQSxLQUFLLEVBQUVBLEdBQWpCO0FBQXNCLGdCQUFBLElBQUksc0JBQWVQLElBQWY7QUFBMUIsZ0JBQVA7QUFDRDtBQUNGLFdBYkgsQ0FESztBQUFBLFNBQVA7QUFpQkQsT0FoQ0QsQ0FnQ0UsT0FBT08sR0FBUCxFQUFZO0FBQ1osNEJBQU8sNkJBQUMsaUJBQUQ7QUFBVSxVQUFBLEtBQUssRUFBRUEsR0FBakI7QUFBc0IsVUFBQSxJQUFJLHNCQUFlUCxJQUFmO0FBQTFCLFVBQVA7QUFDRDtBQUNGLEtBcENEO0FBcUNELEdBMUNEO0FBMkNEIiwic291cmNlUm9vdCI6ImNvbXBvbmVudDovLy8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgaXNWYWxpZEVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRXJyb3JCb3ggZnJvbSAnLi4vaW50ZXJuYWwvRXJyb3JCb3gnO1xuaW1wb3J0IGNvbmNhdE1pZGRsZXdhcmUgZnJvbSAnLi9jb25jYXRNaWRkbGV3YXJlJztcbmltcG9ydCBVc2VybGFuZEJvdW5kYXJ5IGZyb20gJy4vVXNlcmxhbmRCb3VuZGFyeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSh0eXBlLCAuLi5taWRkbGV3YXJlKSB7XG4gIHJldHVybiAoLi4uc2V0dXBBcmdzKSA9PlxuICAgIGNvbmNhdE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZSkoLi4uc2V0dXBBcmdzKSgoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlYWNoZWQgdGVybWluYXRvciBvZiAke3R5cGV9YCk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JMZWdhY3lSZW5kZXJlcih0eXBlLCAuLi5taWRkbGV3YXJlKSB7XG4gIHJldHVybiAoLi4uc2V0dXBBcmdzKSA9PiB7XG4gICAgY29uc3QgZm4gPSBjb25jYXRNaWRkbGV3YXJlKC4uLm1pZGRsZXdhcmUpKC4uLnNldHVwQXJncykoKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWFjaGVkIHRlcm1pbmF0b3Igb2YgJHt0eXBlfWApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiAoXG4gICAgICA8VXNlcmxhbmRCb3VuZGFyeSB0eXBlPXtgcmVuZGVyIG9mICR7dHlwZX1gfT5cbiAgICAgICAgeygpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuKC4uLmFyZ3MpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIDxFcnJvckJveCBlcnJvcj17ZXJyfSB0eXBlPXtgcmVuZGVyIG9mICR7dHlwZX1gfSAvPjtcbiAgICAgICAgICB9XG4gICAgICAgIH19XG4gICAgICA8L1VzZXJsYW5kQm91bmRhcnk+XG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgUmVxdWlyZWQuIFN0cmluZyBlcXVpdmFsZW50IG9mIHR5cGUgb2YgY29udGFpbmVyIHRvIGJlIHJlbmRlcmVkLlxuICogQHBhcmFtIHsgc3RyaWN0ID0gZmFsc2UgfSAtIFVzZWQgdG8gZW5mb3JjZSBuZXcgbWlkZGxld2FyZSBmb3JtYXQgd2hpY2ggY29vcGVyYXRlcyB3aXRoIG5ldyBhY3Rpdml0eSBncm91cGluZy5cbiAqIEBzZWUgU2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L0JvdEZyYW1ld29yay1XZWJDaGF0L2Jsb2IvbWFpbi9DSEFOR0VMT0cubWQjNDEwMC0tLTIwMjAtMDgtMTh9IGFuZCB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9Cb3RGcmFtZXdvcmstV2ViQ2hhdC9wdWxsLzMzNjV9IGZvciBtaWRkbGV3YXJlIGJyZWFraW5nIGNoYW5nZXMuXG4gKiBAcGFyYW0gIHttaWRkbGV3YXJlW119IG1pZGRsZXdhcmUgbGlzdCBvZiBtaWRkbGV3YXJlIHRvIGJlIGFwcGxpZWQuXG4gKiAnY3JlYXRlUmVuZGVyZXJBcmdzJyBpcyBcIndoYXQgdG8gcmVuZGVyXCI7IGZvciBleGFtcGxlLCBhbiBhY3Rpdml0eS5cbiAqIEByZXR1cm5zICBSZXR1cm5zIGEgZnVuY3Rpb24gaWYgdGhlcmUgaXMgYSByZW5kZXJlciAqY29tbWl0dGVkKiB0byByZW5kZXIgT1IgcmV0dXJucyBmYWxzZSBpZiBub3RoaW5nIHNob3VsZCBiZSByZW5kZXJlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvclJlbmRlcmVyKHR5cGUsIHsgc3RyaWN0ID0gZmFsc2UgfSA9IHt9LCAuLi5taWRkbGV3YXJlKSB7XG4gIHJldHVybiAoLi4uc2V0dXBBcmdzKSA9PiB7XG4gICAgY29uc3QgcnVuTWlkZGxld2FyZSA9IGNvbmNhdE1pZGRsZXdhcmUoLi4ubWlkZGxld2FyZSkoLi4uc2V0dXBBcmdzKSgoKSA9PiAoXG4gICAgICA8RXJyb3JCb3ggZXJyb3I9e25ldyBFcnJvcihgcmVhY2hlZCB0ZXJtaW5hdG9yIG9mICR7dHlwZX1gKX0gdHlwZT17dHlwZX0gLz5cbiAgICApKTtcblxuICAgIHJldHVybiAoLi4uY3JlYXRlUmVuZGVyZXJBcmdzKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZW5kZXIgPSBydW5NaWRkbGV3YXJlKC4uLmNyZWF0ZVJlbmRlcmVyQXJncyk7XG5cbiAgICAgICAgaWYgKCFyZW5kZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQocmVuZGVyKSkge1xuICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGJvdGZyYW1ld29yay13ZWJjaGF0OiAke3R5cGV9IHNob3VsZCBvbmx5IHJldHVybiBlaXRoZXIgZmFsc2Ugb3IgYSByZW5kZXIgZnVuY3Rpb24uYCk7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gPFVzZXJsYW5kQm91bmRhcnkgdHlwZT17YHJlbmRlciBvZiAke3R5cGV9YH0+e3JlbmRlcn08L1VzZXJsYW5kQm91bmRhcnk+O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICguLi5yZW5kZXJUaW1lQXJncykgPT4gKFxuICAgICAgICAgIDxVc2VybGFuZEJvdW5kYXJ5IHR5cGU9e2ByZW5kZXIgb2YgJHt0eXBlfWB9PlxuICAgICAgICAgICAgeygpID0+IHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVuZGVyKC4uLnJlbmRlclRpbWVBcmdzKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIWlzVmFsaWRFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBib3RmcmFtZXdvcmstd2ViY2hhdDogJHt0eXBlfSBzaG91bGQgcmV0dXJuIFJlYWN0IGVsZW1lbnQgb25seS5gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDxFcnJvckJveCBlcnJvcj17ZXJyfSB0eXBlPXtgcmVuZGVyIG9mICR7dHlwZX1gfSAvPjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA8L1VzZXJsYW5kQm91bmRhcnk+XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIDxFcnJvckJveCBlcnJvcj17ZXJyfSB0eXBlPXtgcmVuZGVyIG9mICR7dHlwZX1gfSAvPjtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuIl19