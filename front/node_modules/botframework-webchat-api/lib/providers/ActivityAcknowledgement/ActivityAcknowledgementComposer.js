"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _Context = _interopRequireDefault(require("./private/Context"));

var _findLastIndex = _interopRequireDefault(require("../../utils/findLastIndex"));

var _useActivities3 = _interopRequireDefault(require("../../hooks/useActivities"));

var _useActivityKeys3 = _interopRequireDefault(require("../ActivityKeyer/useActivityKeys"));

var _usePrevious = _interopRequireDefault(require("../../hooks/internal/usePrevious"));

var _useValueRef = _interopRequireDefault(require("../../hooks/internal/useValueRef"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function findClosestActivityKeyIfNotExists(activityKey, keys, prevKeys) {
  if (keys.includes(activityKey)) {
    return activityKey;
  } else if (!prevKeys || !activityKey) {
    // Initially, when the transcript was empty, there should be nothing read.
    return;
  } // If the last activity key is no longer in this activities (say, deleted), we try to find the closest one.


  var prevIndex = prevKeys.indexOf(activityKey);

  if (~prevIndex) {
    // List out all previously activity keys, find the closest one that is in the new transcript.
    var acknowledgedActivityKeys = prevKeys.slice(0, prevIndex).reverse();

    var _iterator = _createForOfIteratorHelper(acknowledgedActivityKeys),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var prevAcknowledgedActivityKey = _step.value;

        if (keys.includes(prevAcknowledgedActivityKey)) {
          return prevAcknowledgedActivityKey;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } // If nothing is found, return `undefined`.

}

var ActivityAcknowledgementComposer = function ActivityAcknowledgementComposer(_ref) {
  var children = _ref.children;

  var _useActivities = (0, _useActivities3.default)(),
      _useActivities2 = _slicedToArray(_useActivities, 1),
      activities = _useActivities2[0];

  var _useActivityKeys = (0, _useActivityKeys3.default)(),
      _useActivityKeys2 = _slicedToArray(_useActivityKeys, 1),
      allActivityKeys = _useActivityKeys2[0];

  var _useState = (0, _react.useState)(),
      _useState2 = _slicedToArray(_useState, 2),
      rawLastAcknowledgedActivityKey = _useState2[0],
      setRawLastAcknowledgedActivityKey = _useState2[1];

  var _useState3 = (0, _react.useState)(),
      _useState4 = _slicedToArray(_useState3, 2),
      rawLastReadActivityKey = _useState4[0],
      setRawLastReadActivityKey = _useState4[1];

  var allActivityKeysRef = (0, _useValueRef.default)(allActivityKeys);
  var prevAllActivityKeys = (0, _usePrevious.default)(allActivityKeys);
  var lastOutgoingActivityKeyIndex = (0, _react.useMemo)(function () {
    return (0, _findLastIndex.default)(activities, function (activity) {
      var _activity$from;

      return ((_activity$from = activity.from) === null || _activity$from === void 0 ? void 0 : _activity$from.role) === 'user';
    });
  }, [activities]); // Make sure when we return "lastReadActivityKey" exists in the current transcript.

  var lastReadActivityKey = (0, _react.useMemo)(function () {
    rawLastReadActivityKey && !~prevAllActivityKeys.includes(rawLastReadActivityKey) && console.warn("botframework-webchat internal assertion: \"rawLastReadActivityKey\" of value ".concat(rawLastReadActivityKey, " should be in the \"prevAllActivityKeys\" array."));
    return findClosestActivityKeyIfNotExists(rawLastReadActivityKey, allActivityKeys, prevAllActivityKeys);
  }, [allActivityKeys, prevAllActivityKeys, rawLastReadActivityKey]);
  var lastReadActivityKeyRef = (0, _useValueRef.default)(lastReadActivityKey); // Make sure when we return "lastAcknowledgedActivityKey" exists in the current transcript.

  var lastAcknowledgedActivityKey = (0, _react.useMemo)(function () {
    rawLastAcknowledgedActivityKey && !~prevAllActivityKeys.includes(rawLastAcknowledgedActivityKey) && console.warn("botframework-webchat internal assertion: \"rawLastAcknowledgedActivityKey\" of value ".concat(rawLastAcknowledgedActivityKey, " should be in the \"prevAllActivityKeys\" array."));
    var lastAcknowledgedActivityKey = findClosestActivityKeyIfNotExists(rawLastAcknowledgedActivityKey, allActivityKeys, prevAllActivityKeys); // TODO: [P2] Since Direct Line may send history and does not have read receipt.
    //            Thus, if we don't assume everything is acknowledged initially, while displaying the history,
    //            the transcript would soon stop scrolling.
    //            Thus, before the first outgoing activity is detected, we need to assume everything is acknowledged.

    return allActivityKeys[Math.max(allActivityKeys.indexOf(lastAcknowledgedActivityKey), lastOutgoingActivityKeyIndex)] || allActivityKeys[allActivityKeys.length - 1];
  }, [allActivityKeys, lastOutgoingActivityKeyIndex, prevAllActivityKeys, rawLastAcknowledgedActivityKey]);
  var activityAcknowledgements = (0, _react.useMemo)(function () {
    var activityAcknowledgements = new Map();
    var lastAcknowledgedIndex = allActivityKeys.indexOf(lastAcknowledgedActivityKey);
    var lastReadIndex = allActivityKeys.indexOf(lastReadActivityKey);
    allActivityKeys.forEach(function (activityKey, index) {
      activityAcknowledgements.set(activityKey, {
        acknowledged: index <= lastAcknowledgedIndex,
        read: index <= lastReadIndex
      });
    });
    return Object.freeze(activityAcknowledgements);
  }, [allActivityKeys, lastAcknowledgedActivityKey, lastReadActivityKey]);
  var activityAcknowledgementsRef = (0, _useValueRef.default)(activityAcknowledgements);
  var getHasAcknowledgedByActivityKey = (0, _react.useCallback)(function (activityKey) {
    var _activityAcknowledgem;

    return (_activityAcknowledgem = activityAcknowledgementsRef.current.get(activityKey)) === null || _activityAcknowledgem === void 0 ? void 0 : _activityAcknowledgem.acknowledged;
  }, [activityAcknowledgementsRef]); // TODO: [P2] Memoize with `useMemoWithPrevious` for better memoization of arrays.

  var activityKeysByReadState = (0, _react.useMemo)(function () {
    var index = allActivityKeys.indexOf(lastReadActivityKey);
    return Object.freeze([Object.freeze(allActivityKeys.slice(0, index + 1)), Object.freeze(allActivityKeys.slice(index + 1))]);
  }, [allActivityKeys, lastReadActivityKey]);
  var markAllAsAcknowledged = (0, _react.useCallback)(function () {
    var allActivityKeys = allActivityKeysRef.current;
    setRawLastAcknowledgedActivityKey(allActivityKeys[allActivityKeys.length - 1]);
  }, [allActivityKeysRef, setRawLastAcknowledgedActivityKey]);
  var markActivityKeyAsRead = (0, _react.useCallback)(function (activityKey) {
    var allActivityKeys = allActivityKeysRef.current;
    var index = allActivityKeys.indexOf(activityKey);

    if (!~index) {
      return console.warn("botframework-webchat: Cannot mark activity with key ".concat(activityKey, " as read because it is not in the transcript."));
    }

    index > allActivityKeys.indexOf(lastReadActivityKeyRef.current) && setRawLastReadActivityKey(activityKey);
  }, [allActivityKeysRef, lastReadActivityKeyRef, setRawLastReadActivityKey]);

  if (activityKeysByReadState[0].length + activityKeysByReadState[1].length !== allActivityKeys.length) {
    console.warn('botframework-webchat internal: Sum of count of read and unread activity keys MUST equals to total number of activity keys.');
  }

  var contextValue = (0, _react.useMemo)(function () {
    return {
      activityKeysByReadState: activityKeysByReadState,
      getHasAcknowledgedByActivityKey: getHasAcknowledgedByActivityKey,
      lastAcknowledgedActivityKeyState: Object.freeze([lastAcknowledgedActivityKey]),
      lastReadActivityKeyState: Object.freeze([lastReadActivityKey]),
      markActivityKeyAsRead: markActivityKeyAsRead,
      markAllAsAcknowledged: markAllAsAcknowledged
    };
  }, [activityKeysByReadState, getHasAcknowledgedByActivityKey, lastAcknowledgedActivityKey, lastReadActivityKey, markActivityKeyAsRead, markAllAsAcknowledged]);
  return /*#__PURE__*/_react.default.createElement(_Context.default.Provider, {
    value: contextValue
  }, children);
};

var _default = ActivityAcknowledgementComposer;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wcm92aWRlcnMvQWN0aXZpdHlBY2tub3dsZWRnZW1lbnQvQWN0aXZpdHlBY2tub3dsZWRnZW1lbnRDb21wb3Nlci50c3giXSwibmFtZXMiOlsiZmluZENsb3Nlc3RBY3Rpdml0eUtleUlmTm90RXhpc3RzIiwiYWN0aXZpdHlLZXkiLCJrZXlzIiwicHJldktleXMiLCJpbmNsdWRlcyIsInByZXZJbmRleCIsImluZGV4T2YiLCJhY2tub3dsZWRnZWRBY3Rpdml0eUtleXMiLCJzbGljZSIsInJldmVyc2UiLCJwcmV2QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXkiLCJBY3Rpdml0eUFja25vd2xlZGdlbWVudENvbXBvc2VyIiwiY2hpbGRyZW4iLCJhY3Rpdml0aWVzIiwiYWxsQWN0aXZpdHlLZXlzIiwicmF3TGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5Iiwic2V0UmF3TGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5IiwicmF3TGFzdFJlYWRBY3Rpdml0eUtleSIsInNldFJhd0xhc3RSZWFkQWN0aXZpdHlLZXkiLCJhbGxBY3Rpdml0eUtleXNSZWYiLCJwcmV2QWxsQWN0aXZpdHlLZXlzIiwibGFzdE91dGdvaW5nQWN0aXZpdHlLZXlJbmRleCIsImFjdGl2aXR5IiwiZnJvbSIsInJvbGUiLCJsYXN0UmVhZEFjdGl2aXR5S2V5IiwiY29uc29sZSIsIndhcm4iLCJsYXN0UmVhZEFjdGl2aXR5S2V5UmVmIiwibGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5IiwiTWF0aCIsIm1heCIsImxlbmd0aCIsImFjdGl2aXR5QWNrbm93bGVkZ2VtZW50cyIsIk1hcCIsImxhc3RBY2tub3dsZWRnZWRJbmRleCIsImxhc3RSZWFkSW5kZXgiLCJmb3JFYWNoIiwiaW5kZXgiLCJzZXQiLCJhY2tub3dsZWRnZWQiLCJyZWFkIiwiT2JqZWN0IiwiZnJlZXplIiwiYWN0aXZpdHlBY2tub3dsZWRnZW1lbnRzUmVmIiwiZ2V0SGFzQWNrbm93bGVkZ2VkQnlBY3Rpdml0eUtleSIsImN1cnJlbnQiLCJnZXQiLCJhY3Rpdml0eUtleXNCeVJlYWRTdGF0ZSIsIm1hcmtBbGxBc0Fja25vd2xlZGdlZCIsIm1hcmtBY3Rpdml0eUtleUFzUmVhZCIsImNvbnRleHRWYWx1ZSIsImxhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleVN0YXRlIiwibGFzdFJlYWRBY3Rpdml0eUtleVN0YXRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFJQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1BLFNBQVNBLGlDQUFULENBQ0VDLFdBREYsRUFFRUMsSUFGRixFQUdFQyxRQUhGLEVBSXNCO0FBQ3BCLE1BQUlELElBQUksQ0FBQ0UsUUFBTCxDQUFjSCxXQUFkLENBQUosRUFBZ0M7QUFDOUIsV0FBT0EsV0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJLENBQUNFLFFBQUQsSUFBYSxDQUFDRixXQUFsQixFQUErQjtBQUNwQztBQUNBO0FBQ0QsR0FObUIsQ0FRcEI7OztBQUNBLE1BQU1JLFNBQVMsR0FBR0YsUUFBUSxDQUFDRyxPQUFULENBQWlCTCxXQUFqQixDQUFsQjs7QUFFQSxNQUFJLENBQUNJLFNBQUwsRUFBZ0I7QUFDZDtBQUNBLFFBQU1FLHdCQUF3QixHQUFHSixRQUFRLENBQUNLLEtBQVQsQ0FBZSxDQUFmLEVBQWtCSCxTQUFsQixFQUE2QkksT0FBN0IsRUFBakM7O0FBRmMsK0NBSTRCRix3QkFKNUI7QUFBQTs7QUFBQTtBQUlkLDBEQUFvRTtBQUFBLFlBQXpERywyQkFBeUQ7O0FBQ2xFLFlBQUlSLElBQUksQ0FBQ0UsUUFBTCxDQUFjTSwyQkFBZCxDQUFKLEVBQWdEO0FBQzlDLGlCQUFPQSwyQkFBUDtBQUNEO0FBQ0Y7QUFSYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU2YsR0FwQm1CLENBc0JwQjs7QUFDRDs7QUFFRCxJQUFNQywrQkFBeUUsR0FBRyxTQUE1RUEsK0JBQTRFLE9BQWtCO0FBQUEsTUFBZkMsUUFBZSxRQUFmQSxR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QUEsR0FEbUIsRUFTbkIsQ0FDRUQsdUJBREYsRUFFRUgsK0JBRkYsRUFHRWhCLDJCQUhGLEVBSUVKLG1CQUpGLEVBS0V5QixxQkFMRixFQU1FRCxxQkFORixDQVRtQixDQUFyQjtBQW1CQSxzQkFDRSw2QkFBQyxnQkFBRCxDQUFnQyxRQUFoQztBQUF5QyxJQUFBLEtBQUssRUFBRUU7QUFBaEQsS0FBK0R2QyxRQUEvRCxDQURGO0FBR0QsQ0FySUQ7O2VBdUllRCwrQiIsInNvdXJjZVJvb3QiOiJjb21wb25lbnQ6Ly8vIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VNZW1vLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHR5cGUgeyBGQywgUHJvcHNXaXRoQ2hpbGRyZW4gfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBBY3Rpdml0eUFja25vd2xlZGdlbWVudENvbnRleHQsIHsgQWN0aXZpdHlBY2tub3dsZWRnZW1lbnRDb250ZXh0VHlwZSB9IGZyb20gJy4vcHJpdmF0ZS9Db250ZXh0JztcbmltcG9ydCBmaW5kTGFzdEluZGV4IGZyb20gJy4uLy4uL3V0aWxzL2ZpbmRMYXN0SW5kZXgnO1xuaW1wb3J0IHVzZUFjdGl2aXRpZXMgZnJvbSAnLi4vLi4vaG9va3MvdXNlQWN0aXZpdGllcyc7XG5pbXBvcnQgdXNlQWN0aXZpdHlLZXlzIGZyb20gJy4uL0FjdGl2aXR5S2V5ZXIvdXNlQWN0aXZpdHlLZXlzJztcbmltcG9ydCB1c2VQcmV2aW91cyBmcm9tICcuLi8uLi9ob29rcy9pbnRlcm5hbC91c2VQcmV2aW91cyc7XG5pbXBvcnQgdXNlVmFsdWVSZWYgZnJvbSAnLi4vLi4vaG9va3MvaW50ZXJuYWwvdXNlVmFsdWVSZWYnO1xuXG5pbXBvcnQgdHlwZSB7IEFjdGl2aXR5QWNrbm93bGVkZ2VtZW50IH0gZnJvbSAnLi9wcml2YXRlL3R5cGVzJztcblxudHlwZSBBY3Rpdml0eUFja25vd2xlZGdlbWVudENvbXBvc2VyUHJvcHMgPSBQcm9wc1dpdGhDaGlsZHJlbjx7fT47XG5cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0QWN0aXZpdHlLZXlJZk5vdEV4aXN0cyhcbiAgYWN0aXZpdHlLZXk6IHN0cmluZyxcbiAga2V5czogcmVhZG9ubHkgc3RyaW5nW10sXG4gIHByZXZLZXlzOiByZWFkb25seSBzdHJpbmdbXVxuKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGtleXMuaW5jbHVkZXMoYWN0aXZpdHlLZXkpKSB7XG4gICAgcmV0dXJuIGFjdGl2aXR5S2V5O1xuICB9IGVsc2UgaWYgKCFwcmV2S2V5cyB8fCAhYWN0aXZpdHlLZXkpIHtcbiAgICAvLyBJbml0aWFsbHksIHdoZW4gdGhlIHRyYW5zY3JpcHQgd2FzIGVtcHR5LCB0aGVyZSBzaG91bGQgYmUgbm90aGluZyByZWFkLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIHRoZSBsYXN0IGFjdGl2aXR5IGtleSBpcyBubyBsb25nZXIgaW4gdGhpcyBhY3Rpdml0aWVzIChzYXksIGRlbGV0ZWQpLCB3ZSB0cnkgdG8gZmluZCB0aGUgY2xvc2VzdCBvbmUuXG4gIGNvbnN0IHByZXZJbmRleCA9IHByZXZLZXlzLmluZGV4T2YoYWN0aXZpdHlLZXkpO1xuXG4gIGlmICh+cHJldkluZGV4KSB7XG4gICAgLy8gTGlzdCBvdXQgYWxsIHByZXZpb3VzbHkgYWN0aXZpdHkga2V5cywgZmluZCB0aGUgY2xvc2VzdCBvbmUgdGhhdCBpcyBpbiB0aGUgbmV3IHRyYW5zY3JpcHQuXG4gICAgY29uc3QgYWNrbm93bGVkZ2VkQWN0aXZpdHlLZXlzID0gcHJldktleXMuc2xpY2UoMCwgcHJldkluZGV4KS5yZXZlcnNlKCk7XG5cbiAgICBmb3IgKGNvbnN0IHByZXZBY2tub3dsZWRnZWRBY3Rpdml0eUtleSBvZiBhY2tub3dsZWRnZWRBY3Rpdml0eUtleXMpIHtcbiAgICAgIGlmIChrZXlzLmluY2x1ZGVzKHByZXZBY2tub3dsZWRnZWRBY3Rpdml0eUtleSkpIHtcbiAgICAgICAgcmV0dXJuIHByZXZBY2tub3dsZWRnZWRBY3Rpdml0eUtleTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiBub3RoaW5nIGlzIGZvdW5kLCByZXR1cm4gYHVuZGVmaW5lZGAuXG59XG5cbmNvbnN0IEFjdGl2aXR5QWNrbm93bGVkZ2VtZW50Q29tcG9zZXI6IEZDPEFjdGl2aXR5QWNrbm93bGVkZ2VtZW50Q29tcG9zZXJQcm9wcz4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFthY3Rpdml0aWVzXSA9IHVzZUFjdGl2aXRpZXMoKTtcbiAgY29uc3QgW2FsbEFjdGl2aXR5S2V5c10gPSB1c2VBY3Rpdml0eUtleXMoKTtcbiAgY29uc3QgW3Jhd0xhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleSwgc2V0UmF3TGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5XSA9IHVzZVN0YXRlPHN0cmluZyB8IHVuZGVmaW5lZD4oKTtcbiAgY29uc3QgW3Jhd0xhc3RSZWFkQWN0aXZpdHlLZXksIHNldFJhd0xhc3RSZWFkQWN0aXZpdHlLZXldID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPigpO1xuXG4gIGNvbnN0IGFsbEFjdGl2aXR5S2V5c1JlZiA9IHVzZVZhbHVlUmVmKGFsbEFjdGl2aXR5S2V5cyk7XG4gIGNvbnN0IHByZXZBbGxBY3Rpdml0eUtleXMgPSB1c2VQcmV2aW91cyhhbGxBY3Rpdml0eUtleXMpO1xuXG4gIGNvbnN0IGxhc3RPdXRnb2luZ0FjdGl2aXR5S2V5SW5kZXggPSB1c2VNZW1vKFxuICAgICgpID0+IGZpbmRMYXN0SW5kZXgoYWN0aXZpdGllcywgYWN0aXZpdHkgPT4gYWN0aXZpdHkuZnJvbT8ucm9sZSA9PT0gJ3VzZXInKSxcbiAgICBbYWN0aXZpdGllc11cbiAgKTtcblxuICAvLyBNYWtlIHN1cmUgd2hlbiB3ZSByZXR1cm4gXCJsYXN0UmVhZEFjdGl2aXR5S2V5XCIgZXhpc3RzIGluIHRoZSBjdXJyZW50IHRyYW5zY3JpcHQuXG4gIGNvbnN0IGxhc3RSZWFkQWN0aXZpdHlLZXkgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByYXdMYXN0UmVhZEFjdGl2aXR5S2V5ICYmXG4gICAgICAhfnByZXZBbGxBY3Rpdml0eUtleXMuaW5jbHVkZXMocmF3TGFzdFJlYWRBY3Rpdml0eUtleSkgJiZcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYGJvdGZyYW1ld29yay13ZWJjaGF0IGludGVybmFsIGFzc2VydGlvbjogXCJyYXdMYXN0UmVhZEFjdGl2aXR5S2V5XCIgb2YgdmFsdWUgJHtyYXdMYXN0UmVhZEFjdGl2aXR5S2V5fSBzaG91bGQgYmUgaW4gdGhlIFwicHJldkFsbEFjdGl2aXR5S2V5c1wiIGFycmF5LmBcbiAgICAgICk7XG5cbiAgICByZXR1cm4gZmluZENsb3Nlc3RBY3Rpdml0eUtleUlmTm90RXhpc3RzKHJhd0xhc3RSZWFkQWN0aXZpdHlLZXksIGFsbEFjdGl2aXR5S2V5cywgcHJldkFsbEFjdGl2aXR5S2V5cyk7XG4gIH0sIFthbGxBY3Rpdml0eUtleXMsIHByZXZBbGxBY3Rpdml0eUtleXMsIHJhd0xhc3RSZWFkQWN0aXZpdHlLZXldKTtcblxuICBjb25zdCBsYXN0UmVhZEFjdGl2aXR5S2V5UmVmID0gdXNlVmFsdWVSZWYobGFzdFJlYWRBY3Rpdml0eUtleSk7XG5cbiAgLy8gTWFrZSBzdXJlIHdoZW4gd2UgcmV0dXJuIFwibGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5XCIgZXhpc3RzIGluIHRoZSBjdXJyZW50IHRyYW5zY3JpcHQuXG4gIGNvbnN0IGxhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJhd0xhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleSAmJlxuICAgICAgIX5wcmV2QWxsQWN0aXZpdHlLZXlzLmluY2x1ZGVzKHJhd0xhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleSkgJiZcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYGJvdGZyYW1ld29yay13ZWJjaGF0IGludGVybmFsIGFzc2VydGlvbjogXCJyYXdMYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXlcIiBvZiB2YWx1ZSAke3Jhd0xhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleX0gc2hvdWxkIGJlIGluIHRoZSBcInByZXZBbGxBY3Rpdml0eUtleXNcIiBhcnJheS5gXG4gICAgICApO1xuXG4gICAgY29uc3QgbGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5ID0gZmluZENsb3Nlc3RBY3Rpdml0eUtleUlmTm90RXhpc3RzKFxuICAgICAgcmF3TGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5LFxuICAgICAgYWxsQWN0aXZpdHlLZXlzLFxuICAgICAgcHJldkFsbEFjdGl2aXR5S2V5c1xuICAgICk7XG5cbiAgICAvLyBUT0RPOiBbUDJdIFNpbmNlIERpcmVjdCBMaW5lIG1heSBzZW5kIGhpc3RvcnkgYW5kIGRvZXMgbm90IGhhdmUgcmVhZCByZWNlaXB0LlxuICAgIC8vICAgICAgICAgICAgVGh1cywgaWYgd2UgZG9uJ3QgYXNzdW1lIGV2ZXJ5dGhpbmcgaXMgYWNrbm93bGVkZ2VkIGluaXRpYWxseSwgd2hpbGUgZGlzcGxheWluZyB0aGUgaGlzdG9yeSxcbiAgICAvLyAgICAgICAgICAgIHRoZSB0cmFuc2NyaXB0IHdvdWxkIHNvb24gc3RvcCBzY3JvbGxpbmcuXG4gICAgLy8gICAgICAgICAgICBUaHVzLCBiZWZvcmUgdGhlIGZpcnN0IG91dGdvaW5nIGFjdGl2aXR5IGlzIGRldGVjdGVkLCB3ZSBuZWVkIHRvIGFzc3VtZSBldmVyeXRoaW5nIGlzIGFja25vd2xlZGdlZC5cbiAgICByZXR1cm4gKFxuICAgICAgYWxsQWN0aXZpdHlLZXlzW01hdGgubWF4KGFsbEFjdGl2aXR5S2V5cy5pbmRleE9mKGxhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleSksIGxhc3RPdXRnb2luZ0FjdGl2aXR5S2V5SW5kZXgpXSB8fFxuICAgICAgYWxsQWN0aXZpdHlLZXlzW2FsbEFjdGl2aXR5S2V5cy5sZW5ndGggLSAxXVxuICAgICk7XG4gIH0sIFthbGxBY3Rpdml0eUtleXMsIGxhc3RPdXRnb2luZ0FjdGl2aXR5S2V5SW5kZXgsIHByZXZBbGxBY3Rpdml0eUtleXMsIHJhd0xhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleV0pO1xuXG4gIGNvbnN0IGFjdGl2aXR5QWNrbm93bGVkZ2VtZW50cyA9IHVzZU1lbW88UmVhZG9ubHk8TWFwPHN0cmluZywgQWN0aXZpdHlBY2tub3dsZWRnZW1lbnQ+Pj4oKCkgPT4ge1xuICAgIGNvbnN0IGFjdGl2aXR5QWNrbm93bGVkZ2VtZW50cyA9IG5ldyBNYXA8c3RyaW5nLCBBY3Rpdml0eUFja25vd2xlZGdlbWVudD4oKTtcbiAgICBjb25zdCBsYXN0QWNrbm93bGVkZ2VkSW5kZXggPSBhbGxBY3Rpdml0eUtleXMuaW5kZXhPZihsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXkpO1xuICAgIGNvbnN0IGxhc3RSZWFkSW5kZXggPSBhbGxBY3Rpdml0eUtleXMuaW5kZXhPZihsYXN0UmVhZEFjdGl2aXR5S2V5KTtcblxuICAgIGFsbEFjdGl2aXR5S2V5cy5mb3JFYWNoKChhY3Rpdml0eUtleSwgaW5kZXgpID0+IHtcbiAgICAgIGFjdGl2aXR5QWNrbm93bGVkZ2VtZW50cy5zZXQoYWN0aXZpdHlLZXksIHtcbiAgICAgICAgYWNrbm93bGVkZ2VkOiBpbmRleCA8PSBsYXN0QWNrbm93bGVkZ2VkSW5kZXgsXG4gICAgICAgIHJlYWQ6IGluZGV4IDw9IGxhc3RSZWFkSW5kZXhcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoYWN0aXZpdHlBY2tub3dsZWRnZW1lbnRzKTtcbiAgfSwgW2FsbEFjdGl2aXR5S2V5cywgbGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5LCBsYXN0UmVhZEFjdGl2aXR5S2V5XSk7XG5cbiAgY29uc3QgYWN0aXZpdHlBY2tub3dsZWRnZW1lbnRzUmVmID0gdXNlVmFsdWVSZWYoYWN0aXZpdHlBY2tub3dsZWRnZW1lbnRzKTtcblxuICBjb25zdCBnZXRIYXNBY2tub3dsZWRnZWRCeUFjdGl2aXR5S2V5ID0gdXNlQ2FsbGJhY2s8KGFjdGl2aXR5S2V5OiBzdHJpbmcpID0+IGJvb2xlYW4+KFxuICAgIChhY3Rpdml0eUtleTogc3RyaW5nKSA9PiBhY3Rpdml0eUFja25vd2xlZGdlbWVudHNSZWYuY3VycmVudC5nZXQoYWN0aXZpdHlLZXkpPy5hY2tub3dsZWRnZWQsXG4gICAgW2FjdGl2aXR5QWNrbm93bGVkZ2VtZW50c1JlZl1cbiAgKTtcblxuICAvLyBUT0RPOiBbUDJdIE1lbW9pemUgd2l0aCBgdXNlTWVtb1dpdGhQcmV2aW91c2AgZm9yIGJldHRlciBtZW1vaXphdGlvbiBvZiBhcnJheXMuXG4gIGNvbnN0IGFjdGl2aXR5S2V5c0J5UmVhZFN0YXRlID0gdXNlTWVtbzxyZWFkb25seSBbcmVhZG9ubHkgc3RyaW5nW10sIHJlYWRvbmx5IHN0cmluZ1tdXT4oKCkgPT4ge1xuICAgIGNvbnN0IGluZGV4ID0gYWxsQWN0aXZpdHlLZXlzLmluZGV4T2YobGFzdFJlYWRBY3Rpdml0eUtleSk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShbXG4gICAgICBPYmplY3QuZnJlZXplKGFsbEFjdGl2aXR5S2V5cy5zbGljZSgwLCBpbmRleCArIDEpKSxcbiAgICAgIE9iamVjdC5mcmVlemUoYWxsQWN0aXZpdHlLZXlzLnNsaWNlKGluZGV4ICsgMSkpXG4gICAgXSkgYXMgcmVhZG9ubHkgW3JlYWRvbmx5IHN0cmluZ1tdLCByZWFkb25seSBzdHJpbmdbXV07XG4gIH0sIFthbGxBY3Rpdml0eUtleXMsIGxhc3RSZWFkQWN0aXZpdHlLZXldKTtcblxuICBjb25zdCBtYXJrQWxsQXNBY2tub3dsZWRnZWQgPSB1c2VDYWxsYmFjaygoKTogdm9pZCA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50OiBhbGxBY3Rpdml0eUtleXMgfSA9IGFsbEFjdGl2aXR5S2V5c1JlZjtcblxuICAgIHNldFJhd0xhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleShhbGxBY3Rpdml0eUtleXNbYWxsQWN0aXZpdHlLZXlzLmxlbmd0aCAtIDFdKTtcbiAgfSwgW2FsbEFjdGl2aXR5S2V5c1JlZiwgc2V0UmF3TGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5XSk7XG5cbiAgY29uc3QgbWFya0FjdGl2aXR5S2V5QXNSZWFkID0gdXNlQ2FsbGJhY2soXG4gICAgKGFjdGl2aXR5S2V5OiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICAgIGNvbnN0IHsgY3VycmVudDogYWxsQWN0aXZpdHlLZXlzIH0gPSBhbGxBY3Rpdml0eUtleXNSZWY7XG4gICAgICBjb25zdCBpbmRleCA9IGFsbEFjdGl2aXR5S2V5cy5pbmRleE9mKGFjdGl2aXR5S2V5KTtcblxuICAgICAgaWYgKCF+aW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgYm90ZnJhbWV3b3JrLXdlYmNoYXQ6IENhbm5vdCBtYXJrIGFjdGl2aXR5IHdpdGgga2V5ICR7YWN0aXZpdHlLZXl9IGFzIHJlYWQgYmVjYXVzZSBpdCBpcyBub3QgaW4gdGhlIHRyYW5zY3JpcHQuYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpbmRleCA+IGFsbEFjdGl2aXR5S2V5cy5pbmRleE9mKGxhc3RSZWFkQWN0aXZpdHlLZXlSZWYuY3VycmVudCkgJiYgc2V0UmF3TGFzdFJlYWRBY3Rpdml0eUtleShhY3Rpdml0eUtleSk7XG4gICAgfSxcbiAgICBbYWxsQWN0aXZpdHlLZXlzUmVmLCBsYXN0UmVhZEFjdGl2aXR5S2V5UmVmLCBzZXRSYXdMYXN0UmVhZEFjdGl2aXR5S2V5XVxuICApO1xuXG4gIGlmIChhY3Rpdml0eUtleXNCeVJlYWRTdGF0ZVswXS5sZW5ndGggKyBhY3Rpdml0eUtleXNCeVJlYWRTdGF0ZVsxXS5sZW5ndGggIT09IGFsbEFjdGl2aXR5S2V5cy5sZW5ndGgpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnYm90ZnJhbWV3b3JrLXdlYmNoYXQgaW50ZXJuYWw6IFN1bSBvZiBjb3VudCBvZiByZWFkIGFuZCB1bnJlYWQgYWN0aXZpdHkga2V5cyBNVVNUIGVxdWFscyB0byB0b3RhbCBudW1iZXIgb2YgYWN0aXZpdHkga2V5cy4nXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW88QWN0aXZpdHlBY2tub3dsZWRnZW1lbnRDb250ZXh0VHlwZT4oXG4gICAgKCkgPT4gKHtcbiAgICAgIGFjdGl2aXR5S2V5c0J5UmVhZFN0YXRlLFxuICAgICAgZ2V0SGFzQWNrbm93bGVkZ2VkQnlBY3Rpdml0eUtleSxcbiAgICAgIGxhc3RBY2tub3dsZWRnZWRBY3Rpdml0eUtleVN0YXRlOiBPYmplY3QuZnJlZXplKFtsYXN0QWNrbm93bGVkZ2VkQWN0aXZpdHlLZXldKSBhcyByZWFkb25seSBbc3RyaW5nXSxcbiAgICAgIGxhc3RSZWFkQWN0aXZpdHlLZXlTdGF0ZTogT2JqZWN0LmZyZWV6ZShbbGFzdFJlYWRBY3Rpdml0eUtleV0pIGFzIHJlYWRvbmx5IFtzdHJpbmddLFxuICAgICAgbWFya0FjdGl2aXR5S2V5QXNSZWFkLFxuICAgICAgbWFya0FsbEFzQWNrbm93bGVkZ2VkXG4gICAgfSksXG4gICAgW1xuICAgICAgYWN0aXZpdHlLZXlzQnlSZWFkU3RhdGUsXG4gICAgICBnZXRIYXNBY2tub3dsZWRnZWRCeUFjdGl2aXR5S2V5LFxuICAgICAgbGFzdEFja25vd2xlZGdlZEFjdGl2aXR5S2V5LFxuICAgICAgbGFzdFJlYWRBY3Rpdml0eUtleSxcbiAgICAgIG1hcmtBY3Rpdml0eUtleUFzUmVhZCxcbiAgICAgIG1hcmtBbGxBc0Fja25vd2xlZGdlZFxuICAgIF1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxBY3Rpdml0eUFja25vd2xlZGdlbWVudENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRWYWx1ZX0+e2NoaWxkcmVufTwvQWN0aXZpdHlBY2tub3dsZWRnZW1lbnRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQWN0aXZpdHlBY2tub3dsZWRnZW1lbnRDb21wb3NlcjtcbiJdfQ==