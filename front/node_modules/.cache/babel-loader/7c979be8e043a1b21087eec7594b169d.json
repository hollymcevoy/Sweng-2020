{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _botframeworkWebchatApi = require(\"botframework-webchat-api\");\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _detectBrowser = require(\"../Utils/detectBrowser\");\n\nvar _FocusTrap = _interopRequireDefault(require(\"./FocusTrap\"));\n\nvar _ScreenReaderText = _interopRequireDefault(require(\"../ScreenReaderText\"));\n\nvar _Speak = _interopRequireDefault(require(\"../Activity/Speak\"));\n\nvar _useActiveDescendantId = _interopRequireDefault(require(\"../providers/TranscriptFocus/useActiveDescendantId\"));\n\nvar _useActivityAccessibleName = _interopRequireDefault(require(\"./useActivityAccessibleName\"));\n\nvar _useFocusByActivityKey = _interopRequireDefault(require(\"../providers/TranscriptFocus/useFocusByActivityKey\"));\n\nvar _useGetDescendantIdByActivityKey = _interopRequireDefault(require(\"../providers/TranscriptFocus/useGetDescendantIdByActivityKey\"));\n\nvar _useValueRef = _interopRequireDefault(require(\"../hooks/internal/useValueRef\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar useActivityKeysByRead = _botframeworkWebchatApi.hooks.useActivityKeysByRead,\n    useGetHasAcknowledgedByActivityKey = _botframeworkWebchatApi.hooks.useGetHasAcknowledgedByActivityKey,\n    useGetKeyByActivity = _botframeworkWebchatApi.hooks.useGetKeyByActivity;\nvar ActivityRow = /*#__PURE__*/(0, _react.forwardRef)(function (_ref, ref) {\n  var _activity$channelData, _activity$channelData2;\n\n  var activity = _ref.activity,\n      children = _ref.children;\n\n  var _useActiveDescendantI = (0, _useActiveDescendantId.default)(),\n      _useActiveDescendantI2 = _slicedToArray(_useActiveDescendantI, 1),\n      activeDescendantId = _useActiveDescendantI2[0];\n\n  var _useActivityKeysByRea = useActivityKeysByRead(),\n      _useActivityKeysByRea2 = _slicedToArray(_useActivityKeysByRea, 1),\n      readActivityKeys = _useActivityKeysByRea2[0];\n\n  var bodyRef = (0, _react.useRef)();\n  var focusByActivityKey = (0, _useFocusByActivityKey.default)();\n  var getKeyByActivity = useGetKeyByActivity(); // TODO: [P2] #2858 We should use core/definitions/speakingActivity for this predicate instead\n\n  var shouldSpeak = (_activity$channelData = activity.channelData) === null || _activity$channelData === void 0 ? void 0 : _activity$channelData.speak;\n\n  var _useActivityAccessibl = (0, _useActivityAccessibleName.default)(activity, bodyRef),\n      _useActivityAccessibl2 = _slicedToArray(_useActivityAccessibl, 1),\n      accessibleName = _useActivityAccessibl2[0];\n\n  var activityKey = getKeyByActivity(activity);\n  var acknowledged = useGetHasAcknowledgedByActivityKey()(activityKey);\n  var activityKeyRef = (0, _useValueRef.default)(activityKey);\n  var descendantId = (0, _useGetDescendantIdByActivityKey.default)()(activityKey);\n  var descendantLabelId = \"webchat__basic-transcript__active-descendant-label--\".concat(activityKey);\n  var isActiveDescendant = descendantId === activeDescendantId;\n  var read = readActivityKeys.includes(activityKey);\n  var focusSelf = (0, _react.useCallback)(function (withFocus) {\n    return focusByActivityKey(activityKeyRef.current, withFocus);\n  }, [activityKeyRef, focusByActivityKey]); // When a child of the activity receives focus, notify the transcript to set the `aria-activedescendant` to this activity.\n\n  var handleDescendantFocus = (0, _react.useCallback)(function () {\n    return focusSelf(false);\n  }, [focusSelf]); // When receive Escape key from descendant, focus back to the activity.\n\n  var handleLeaveFocusTrap = (0, _react.useCallback)(function () {\n    return focusSelf();\n  }, [focusSelf]); // When the user press UP/DOWN arrow keys, we put a visual focus indicator around the focused activity.\n  // We should do the same for mouse, when the user click on the activity, we should also put a visual focus indicator around the activity.\n  // We are doing it in event capture phase to prevent descendants from stopping event propagation to us.\n\n  var handleMouseDownCapture = (0, _react.useCallback)(function () {\n    return focusSelf(false);\n  }, [focusSelf]);\n  return (\n    /*#__PURE__*/\n    // TODO: [P2] Add `aria-roledescription=\"message\"` for better AX, need localization strings.\n    _react.default.createElement(\"article\", {\n      \"aria-hidden\": ((_activity$channelData2 = activity.channelData) === null || _activity$channelData2 === void 0 ? void 0 : _activity$channelData2['webchat:fallback-text']) === '',\n      className: (0, _classnames.default)('webchat__basic-transcript__activity', {\n        'webchat__basic-transcript__activity--acknowledged': acknowledged,\n        'webchat__basic-transcript__activity--read': read\n      }) // When NVDA is in browse mode, using up/down arrow key to \"browse\" will dispatch \"click\" and \"mousedown\" events for <article> element (inside <ScreenReaderActivity>).\n      ,\n      onMouseDownCapture: handleMouseDownCapture,\n      ref: ref\n    }, !_detectBrowser.android && /*#__PURE__*/_react.default.createElement(\"div\", {\n      \"aria-labelledby\": descendantLabelId,\n      className: \"webchat__basic-transcript__activity-active-descendant\" // \"id\" is required for \"aria-labelledby\"\n      // eslint-disable-next-line react/forbid-dom-props\n      ,\n      id: descendantId,\n      role: \"article\"\n    }, /*#__PURE__*/_react.default.createElement(_ScreenReaderText.default, {\n      \"aria-hidden\": true,\n      id: descendantLabelId,\n      text: accessibleName\n    })), /*#__PURE__*/_react.default.createElement(_FocusTrap.default, {\n      onFocus: handleDescendantFocus,\n      onLeave: handleLeaveFocusTrap\n    }, /*#__PURE__*/_react.default.createElement(\"div\", {\n      className: \"webchat__basic-transcript__activity-body\",\n      ref: bodyRef\n    }, children)), shouldSpeak && /*#__PURE__*/_react.default.createElement(_Speak.default, {\n      activity: activity\n    }), /*#__PURE__*/_react.default.createElement(\"div\", {\n      className: (0, _classnames.default)('webchat__basic-transcript__activity-indicator', {\n        'webchat__basic-transcript__activity-indicator--focus': isActiveDescendant\n      })\n    }))\n  );\n});\nActivityRow.defaultProps = {\n  children: undefined\n};\nActivityRow.propTypes = {\n  activity: _propTypes.default.shape({\n    channelData: _propTypes.default.shape({\n      speak: _propTypes.default.bool,\n      'webchat:fallback-text': _propTypes.default.string\n    })\n  }).isRequired,\n  children: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.arrayOf(_propTypes.default.element)])\n};\nvar _default = ActivityRow;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["useActivityKeysByRead","hooks","useGetHasAcknowledgedByActivityKey","useGetKeyByActivity","ActivityRow","ref","activity","children","activeDescendantId","readActivityKeys","bodyRef","focusByActivityKey","getKeyByActivity","shouldSpeak","channelData","_activity$channelData","speak","accessibleName","activityKey","acknowledged","activityKeyRef","descendantId","descendantLabelId","isActiveDescendant","read","includes","focusSelf","withFocus","current","handleDescendantFocus","handleLeaveFocusTrap","handleMouseDownCapture","_react","className","onMouseDownCapture","android","id","role","_ScreenReaderText","text","_FocusTrap","onFocus","onLeave","_Speak","defaultProps","undefined","propTypes","PropTypes","shape","bool","string","isRequired","oneOfType","element","arrayOf"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-component/lib/src/Transcript/ActivityRow.tsx"],"sourcesContent":["import { hooks } from 'botframework-webchat-api';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport React, { forwardRef, useCallback, useRef } from 'react';\n\nimport type { DirectLineActivity } from 'botframework-webchat-core';\nimport type { MouseEventHandler, PropsWithChildren } from 'react';\n\nimport { android } from '../Utils/detectBrowser';\nimport FocusTrap from './FocusTrap';\nimport ScreenReaderText from '../ScreenReaderText';\nimport SpeakActivity from '../Activity/Speak';\nimport useActiveDescendantId from '../providers/TranscriptFocus/useActiveDescendantId';\nimport useActivityAccessibleName from './useActivityAccessibleName';\nimport useFocusByActivityKey from '../providers/TranscriptFocus/useFocusByActivityKey';\nimport useGetDescendantIdByActivityKey from '../providers/TranscriptFocus/useGetDescendantIdByActivityKey';\nimport useValueRef from '../hooks/internal/useValueRef';\n\nconst { useActivityKeysByRead, useGetHasAcknowledgedByActivityKey, useGetKeyByActivity } = hooks;\n\ntype ActivityRowProps = PropsWithChildren<{\n  activity: DirectLineActivity;\n}>;\n\nconst ActivityRow = forwardRef<HTMLLIElement, ActivityRowProps>(({ activity, children }, ref) => {\n  const [activeDescendantId] = useActiveDescendantId();\n  const [readActivityKeys] = useActivityKeysByRead();\n  const bodyRef = useRef<HTMLDivElement>();\n  const focusByActivityKey = useFocusByActivityKey();\n  const getKeyByActivity = useGetKeyByActivity();\n  // TODO: [P2] #2858 We should use core/definitions/speakingActivity for this predicate instead\n  const shouldSpeak = activity.channelData?.speak;\n\n  const [accessibleName] = useActivityAccessibleName(activity, bodyRef);\n  const activityKey = getKeyByActivity(activity);\n\n  const acknowledged = useGetHasAcknowledgedByActivityKey()(activityKey);\n  const activityKeyRef = useValueRef<string>(activityKey);\n  const descendantId = useGetDescendantIdByActivityKey()(activityKey);\n  const descendantLabelId = `webchat__basic-transcript__active-descendant-label--${activityKey}`;\n\n  const isActiveDescendant = descendantId === activeDescendantId;\n  const read = readActivityKeys.includes(activityKey);\n\n  const focusSelf = useCallback<(withFocus?: boolean) => void>(\n    (withFocus?: boolean) => focusByActivityKey(activityKeyRef.current, withFocus),\n    [activityKeyRef, focusByActivityKey]\n  );\n\n  // When a child of the activity receives focus, notify the transcript to set the `aria-activedescendant` to this activity.\n  const handleDescendantFocus: () => void = useCallback(() => focusSelf(false), [focusSelf]);\n\n  // When receive Escape key from descendant, focus back to the activity.\n  const handleLeaveFocusTrap = useCallback(() => focusSelf(), [focusSelf]);\n\n  // When the user press UP/DOWN arrow keys, we put a visual focus indicator around the focused activity.\n  // We should do the same for mouse, when the user click on the activity, we should also put a visual focus indicator around the activity.\n  // We are doing it in event capture phase to prevent descendants from stopping event propagation to us.\n  const handleMouseDownCapture: MouseEventHandler = useCallback(() => focusSelf(false), [focusSelf]);\n\n  return (\n    // TODO: [P2] Add `aria-roledescription=\"message\"` for better AX, need localization strings.\n    <article\n      aria-hidden={activity.channelData?.['webchat:fallback-text'] === ''}\n      className={classNames('webchat__basic-transcript__activity', {\n        'webchat__basic-transcript__activity--acknowledged': acknowledged,\n        'webchat__basic-transcript__activity--read': read\n      })}\n      // When NVDA is in browse mode, using up/down arrow key to \"browse\" will dispatch \"click\" and \"mousedown\" events for <article> element (inside <ScreenReaderActivity>).\n      onMouseDownCapture={handleMouseDownCapture}\n      ref={ref}\n    >\n      {/* TODO: [P1] File a crbug for TalkBack. It should not able to read the content twice when scanning. */}\n\n      {/* The following <div> is designed for active descendant only.\n          We want to prevent screen reader from scanning the content that is authored only for active descendant.\n          The specific content should only read when user press UP/DOWN arrow keys to change `aria-activedescendant`.\n          However, Android TalkBack 12.1 is buggy when the there is an element with ID of one of the `aria-activedescendant` potential candidates,\n          TalkBack will narrate the message content twice (i.e. content of `bodyRef`), regardless whether the ID is currently set as `aria-activedescendant` or not.\n          As Android does not support active descendant, we are hiding the whole DOM element altogether. */}\n\n      {!android && (\n        <div\n          aria-labelledby={descendantLabelId}\n          className=\"webchat__basic-transcript__activity-active-descendant\"\n          // \"id\" is required for \"aria-labelledby\"\n          // eslint-disable-next-line react/forbid-dom-props\n          id={descendantId}\n          role=\"article\"\n        >\n          <ScreenReaderText aria-hidden={true} id={descendantLabelId} text={accessibleName} />\n        </div>\n      )}\n      {/* Add tests for focus trap */}\n      <FocusTrap onFocus={handleDescendantFocus} onLeave={handleLeaveFocusTrap}>\n        <div className=\"webchat__basic-transcript__activity-body\" ref={bodyRef}>\n          {children}\n        </div>\n      </FocusTrap>\n      {shouldSpeak && <SpeakActivity activity={activity} />}\n      <div\n        className={classNames('webchat__basic-transcript__activity-indicator', {\n          'webchat__basic-transcript__activity-indicator--focus': isActiveDescendant\n        })}\n      />\n    </article>\n  );\n});\n\nActivityRow.defaultProps = {\n  children: undefined\n};\n\nActivityRow.propTypes = {\n  activity: PropTypes.shape({\n    channelData: PropTypes.shape({\n      speak: PropTypes.bool,\n      'webchat:fallback-text': PropTypes.string\n    })\n  }).isRequired,\n  children: PropTypes.oneOfType([PropTypes.element, PropTypes.arrayOf(PropTypes.element)])\n};\n\nexport default ActivityRow;\n"]},"metadata":{},"sourceType":"script"}