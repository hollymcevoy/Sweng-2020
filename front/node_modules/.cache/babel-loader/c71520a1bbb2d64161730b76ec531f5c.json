{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _botframeworkWebchatComponent = require(\"botframework-webchat-component\");\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _useAdaptiveCardsHostConfig = _interopRequireDefault(require(\"../hooks/useAdaptiveCardsHostConfig\"));\n\nvar _useAdaptiveCardsPackage = _interopRequireDefault(require(\"../hooks/useAdaptiveCardsPackage\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [-1, 0, 2] }] */\n\n\nvar ErrorBox = _botframeworkWebchatComponent.Components.ErrorBox;\nvar useDisabled = _botframeworkWebchatComponent.hooks.useDisabled,\n    useLocalizer = _botframeworkWebchatComponent.hooks.useLocalizer,\n    usePerformCardAction = _botframeworkWebchatComponent.hooks.usePerformCardAction,\n    useRenderMarkdownAsHTML = _botframeworkWebchatComponent.hooks.useRenderMarkdownAsHTML,\n    useScrollToEnd = _botframeworkWebchatComponent.hooks.useScrollToEnd,\n    useStyleSet = _botframeworkWebchatComponent.hooks.useStyleSet;\nvar node_env = undefined || \"production\";\n\nfunction bunchUndos() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function () {\n    return fns.forEach(function (fn) {\n      return fn === null || fn === void 0 ? void 0 : fn();\n    });\n  };\n}\n/**\n * Adds a class to the `HTMLElement`. Returns `true` if the class is added, otherwise, `undefined`.\n */\n\n\nfunction addClass(element, className) {\n  var classList = element.classList;\n\n  if (!classList.contains(className)) {\n    classList.add(className);\n    return true;\n  }\n}\n/**\n * Adds a class to the `HTMLElement` and re-add on mutations.\n *\n * @returns {function} A function, when called, will restore to previous state.\n */\n\n\nfunction addPersistentClassWithUndo(element, className) {\n  if (!element) {\n    return;\n  }\n\n  if (addClass(element, className)) {\n    // After we add the class, keep observing the element to make sure the class is not removed.\n    var observer = new MutationObserver(function () {\n      return addClass(element, className);\n    });\n    observer.observe(element, {\n      attributes: true,\n      attributeFilter: ['class']\n    });\n    return function () {\n      var classNames = new Set(element.className.split(' '));\n      classNames.delete(className);\n      element.className = Array.from(classNames).join(' ');\n      observer.disconnect();\n    };\n  }\n}\n/**\n * Returns `true`, if the object is a plain object and not a class, otherwise, `false`.\n */\n\n\nfunction isPlainObject(obj) {\n  return Object.getPrototypeOf(obj) === Object.prototype;\n}\n/**\n * Sets an attribute.\n *\n * @returns {function} A function, when called, will restore to previous state.\n */\n\n\nfunction setAttributeWithUndo(element, qualifiedName, nextValue) {\n  if (!element) {\n    return;\n  }\n\n  var value = element.getAttribute(qualifiedName);\n\n  if (value !== nextValue) {\n    element.setAttribute(qualifiedName, nextValue);\n    return function () {\n      return value ? element.setAttribute(qualifiedName, value) : element.removeAttribute(qualifiedName);\n    };\n  }\n}\n/**\n * An event handler for disabling event bubbling and propagation.\n */\n\n\nvar disabledHandler = function disabledHandler(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n};\n/**\n * Listens to event once. Returns a function, when called, will stop listening.\n */\n\n\nfunction addEventListenerOnceWithUndo(element, name, handler) {\n  if (!element) {\n    return;\n  }\n  /* eslint-disable-next-line prefer-const */\n\n\n  var detach;\n\n  var detachingHandler = function detachingHandler(event) {\n    try {\n      handler(event);\n    } finally {\n      // IE11 does not support { once: true }, so we need to detach manually.\n      detach();\n    }\n  };\n\n  detach = function detach() {\n    return element.removeEventListener(name, detachingHandler);\n  };\n\n  element.addEventListener(name, detachingHandler, {\n    once: true\n  });\n  return detach;\n}\n/**\n * Listens to event. Returns a function, when called, will stop listening.\n */\n\n\nfunction addEventListenerWithUndo(element, name, handler) {\n  if (!element) {\n    return;\n  }\n\n  element.addEventListener(name, handler);\n  return function () {\n    return element.removeEventListener(name, handler);\n  };\n}\n/**\n * Disables an element with undo function.\n *\n * @returns {function} A function, when called, will restore to previous state.\n */\n\n\nfunction disableElementWithUndo(element) {\n  if (!element) {\n    return;\n  }\n\n  var undoStack = [];\n  var isActive = element === document.activeElement;\n  var tag = element.nodeName.toLowerCase();\n  /* eslint-disable-next-line default-case */\n\n  switch (tag) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      undoStack.push(setAttributeWithUndo(element, 'aria-disabled', 'true'));\n\n      if (isActive) {\n        undoStack.push(addEventListenerOnceWithUndo(element, 'blur', function () {\n          return undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'));\n        }));\n      } else {\n        undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'));\n      }\n\n      if (tag === 'input' || tag === 'textarea') {\n        undoStack.push(addEventListenerWithUndo(element, 'click', disabledHandler));\n        undoStack.push(setAttributeWithUndo(element, 'readonly', 'readonly'));\n      } else if (tag === 'select') {\n        undoStack.push.apply(undoStack, (0, _toConsumableArray2.default)([].map.call(element.querySelectorAll('option'), function (option) {\n          return setAttributeWithUndo(option, 'disabled', 'disabled');\n        })));\n      }\n\n      break;\n  }\n\n  return bunchUndos.apply(void 0, undoStack);\n}\n/**\n * Disables all inputtable descendants.\n *\n * @param {HTMLElement | undefined} element Container element to start looking for inputtable descendants.\n * @param {boolean} observeSubtree `true` to applies to all future inputtable descendants, otherwise, `false`.\n *\n * @returns {function} A function, when called, will restore to previous state.\n */\n\n\nfunction disableInputElementsWithUndo(element) {\n  var observeSubtree = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!element) {\n    return;\n  }\n\n  var undoStack = [].map.call(element.querySelectorAll('button, input, select, textarea'), function (element) {\n    return disableElementWithUndo(element);\n  });\n  var tag = element.nodeName.toLowerCase(); // Only set tabindex=\"-1\" on focusable element. Otherwise, we will make <div> focusable by mouse.\n\n  (tag === 'a' || tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea') && undoStack.push(setAttributeWithUndo(element, 'tabindex', '-1'));\n\n  if (observeSubtree) {\n    var observer = new MutationObserver(function (mutations) {\n      return mutations.forEach(function (_ref) {\n        var addedNodes = _ref.addedNodes;\n        return undoStack.push.apply(undoStack, (0, _toConsumableArray2.default)([].map.call(addedNodes, function (addedNode) {\n          return disableInputElementsWithUndo(addedNode, false);\n        })));\n      });\n    });\n    observer.observe(element, {\n      childList: true,\n      subtree: true\n    });\n    undoStack.push(function () {\n      return observer.disconnect();\n    });\n  }\n\n  return bunchUndos.apply(void 0, (0, _toConsumableArray2.default)(undoStack));\n}\n/**\n * Gets the value of an attribute from an element.\n *\n * @returns {false | string} The value of the attribute. `false` if the attribute was not set.\n */\n\n\nfunction getAttribute(element, qualifiedName) {\n  return !!element && element.hasAttribute(qualifiedName) && (element.getAttribute(qualifiedName) || '');\n}\n/**\n * Sets or removes an attribute from an element.\n *\n * @param {HTMLElement} element - The element to set or remove attribute from.\n * @param {string} qualifiedName - The name of the attribute.\n * @param {false | string} value - The value of the attribute. When passing `false`, remove the attribute.\n */\n\n\nfunction setOrRemoveAttribute(element, qualifiedName, value) {\n  if (value === false) {\n    element === null || element === void 0 ? void 0 : element.removeAttribute(qualifiedName);\n  } else {\n    element === null || element === void 0 ? void 0 : element.setAttribute(qualifiedName, value);\n  }\n}\n/**\n * Sets or removes an attribute from an element with an undo function.\n *\n * @param {HTMLElement} element - The element to set or remove attribute from.\n * @param {string} qualifiedName - The name of the attribute.\n * @param {false | string} value - The value of the attribute. When passing `false`, remove the attribute.\n *\n * @returns {() => void} The undo function, when called, will undo all manipulations by restoring values recorded at the time of the function call.\n */\n\n\nfunction setOrRemoveAttributeWithUndo(element, qualifiedName, value) {\n  if (!element) {\n    return;\n  }\n\n  var prevValue = getAttribute(element, qualifiedName);\n  setOrRemoveAttribute(element, qualifiedName, value);\n  return function () {\n    return setOrRemoveAttribute(element, qualifiedName, prevValue);\n  };\n}\n/**\n * Finds the first ancestor that fulfill the predicate.\n *\n * @param {HTMLElement} element - The starting element. This element will not be checked against the predicate.\n * @param {(ancestor: HTMLElement) => boolean} predicate - The predicate to fulfill.\n *\n * @returns {HTMLElement | undefined} The first ancestor that fulfill the predicate, otherwise, `undefined`.\n */\n\n\nfunction findAncestor(element, predicate) {\n  var current = element;\n\n  while (current = current.parentElement) {\n    if (predicate.call(element, current)) {\n      return current;\n    }\n  }\n}\n/**\n * Indicates the action selected by performing a series of manipulations, with undo:\n *\n * - Accessibility: set `aria-pressed` to `true`\n * - Applies `styleOptions.actionPerformedClassName`\n *\n * @param {HTMLElement[]} selectedActionElements - An array of elements that are representing the action and is selected.\n * @param {string?} actionPerformedClassName - The name of the class to apply to all elements.\n *\n * @returns {() => void} The undo function, when called, will undo all manipulations by restoring values recorded at the time of the function call.\n */\n\n\nfunction indicateActionSelectionWithUndo(selectedActionElements, actionPerformedClassName) {\n  if (!(selectedActionElements !== null && selectedActionElements !== void 0 && selectedActionElements.length)) {\n    return;\n  } // Verify all input elements are \"ac-pushButton\", could belongs to ActionSet or \"card actions\".\n\n\n  if (selectedActionElements.some(function (actionElement) {\n    return !actionElement.classList.contains('ac-pushButton');\n  })) {\n    console.warn('botframework-webchat: Cannot mark selected action in the card, some elements are not an \"ac-pushButton\".');\n    return;\n  } // A distinct set of action set containers which has selections, excluding containers without actions.\n  // Multiple submission in an Adaptive Card is still a vague area and TBD.\n  // We might want to disable the whole card, just buttons in same container, or do nothing (today).\n\n\n  var actionSetElements = new Set();\n  selectedActionElements.forEach(function (selectedActionElement) {\n    var actionSetElement = findAncestor(selectedActionElement, function (ancestor) {\n      return ancestor.getAttribute('role') === 'menubar';\n    });\n    actionSetElement && actionSetElements.add(actionSetElement);\n  });\n  var undoStack = [];\n  actionSetElements.forEach(function (actionSetElement) {\n    // Remove \"role\" from every \"ac-actionSet\" container.\n    undoStack.push(setOrRemoveAttributeWithUndo(actionSetElement, 'role', false)); // Modify \"role\" of every actions in the container.\n\n    Array.from(actionSetElement.querySelectorAll('.ac-pushButton')).forEach(function (actionElement) {\n      if (selectedActionElements.includes(actionElement)) {\n        // Add \"aria-pressed\" and set \"role\" attribute to \"button\" (which is required by \"aria-pressed\").\n        undoStack.push(setOrRemoveAttributeWithUndo(actionElement, 'aria-pressed', 'true'));\n        undoStack.push(setOrRemoveAttributeWithUndo(actionElement, 'role', 'button')); // Highlight actions by applying `styleOptions.actionPerformedClassName`.\n\n        actionPerformedClassName && undoStack.push(addPersistentClassWithUndo(actionElement, actionPerformedClassName));\n      } else {\n        // We removed \"role=menubar\" from the container, we must remove \"role=menuitem\" from unselected actions.\n        undoStack.push(setOrRemoveAttributeWithUndo(actionElement, 'role', false));\n      }\n    });\n  });\n  return bunchUndos.apply(void 0, undoStack);\n}\n/**\n * Fixes accessibility issues from Adaptive Card, with undo.\n *\n * @returns {() => void} The undo function, when called, will undo all manipulations by restoring values recorded at the time of the function call.\n */\n\n\nfunction fixAccessibilityIssuesWithUndo(element) {\n  if (!element) {\n    return;\n  } // These hacks should be done in Adaptive Cards library instead.\n  // Related to #3949: All action buttons inside role=\"menubar\" should be role=\"menuitem\".\n\n\n  var undoStack = Array.from(element.querySelectorAll('.ac-actionSet[role=\"menubar\"] [role=\"button\"]')).map(function (actionButton) {\n    return setAttributeWithUndo(actionButton, 'role', 'menuitem');\n  });\n  return function () {\n    return undoStack.forEach(function (undo) {\n      return undo === null || undo === void 0 ? void 0 : undo();\n    });\n  };\n}\n\nfunction getFocusableElements(element) {\n  return [].filter.call(element.querySelectorAll(['a', 'body', 'button', 'frame', 'iframe', 'img', 'input', 'isindex', 'object', 'select', 'textarea', '[tabindex]'].join(', ')), function (element) {\n    var tabIndex = (0, _botframeworkWebchatComponent.getTabIndex)(element);\n    return typeof tabIndex === 'number' && tabIndex >= 0;\n  });\n}\n\nfunction restoreActiveElementIndex(element, activeElementIndex) {\n  var _getFocusableElements;\n\n  (_getFocusableElements = getFocusableElements(element)[+activeElementIndex]) === null || _getFocusableElements === void 0 ? void 0 : _getFocusableElements.focus();\n}\n\nfunction saveActiveElementIndex(element) {\n  return getFocusableElements(element).indexOf(document.activeElement);\n}\n\nfunction restoreInputValues(element, inputValues) {\n  var inputs = element.querySelectorAll('input, select, textarea');\n  [].forEach.call(inputs, function (input, index) {\n    var value = inputValues[+index];\n\n    if (typeof value !== 'undefined') {\n      var tagName = input.tagName,\n          type = input.type;\n\n      if (tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {\n        if (typeof value === 'boolean') {\n          input.checked = value;\n        }\n      } else if (typeof value === 'string') {\n        input.value = value;\n      }\n    }\n  });\n}\n\nfunction saveInputValues(element) {\n  var inputs = element.querySelectorAll('input, select, textarea');\n  return [].map.call(inputs, function (input) {\n    var type = input.type;\n\n    if (input.tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {\n      return input.checked;\n    }\n\n    return input.value;\n  });\n}\n\nvar AdaptiveCardRenderer = function AdaptiveCardRenderer(_ref2) {\n  var actionPerformedClassName = _ref2.actionPerformedClassName,\n      adaptiveCard = _ref2.adaptiveCard,\n      disabledFromProps = _ref2.disabled,\n      tapAction = _ref2.tapAction;\n\n  var _useStyleSet = useStyleSet(),\n      _useStyleSet2 = (0, _slicedToArray2.default)(_useStyleSet, 1),\n      adaptiveCardRendererStyleSet = _useStyleSet2[0].adaptiveCardRenderer;\n\n  var _useAdaptiveCardsPack = (0, _useAdaptiveCardsPackage.default)(),\n      _useAdaptiveCardsPack2 = (0, _slicedToArray2.default)(_useAdaptiveCardsPack, 1),\n      _useAdaptiveCardsPack3 = _useAdaptiveCardsPack2[0],\n      GlobalSettings = _useAdaptiveCardsPack3.GlobalSettings,\n      HostConfig = _useAdaptiveCardsPack3.HostConfig;\n\n  var _useState = (0, _react.useState)([]),\n      _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n      actionsPerformed = _useState2[0],\n      setActionsPerformed = _useState2[1];\n\n  var _useAdaptiveCardsHost = (0, _useAdaptiveCardsHostConfig.default)(),\n      _useAdaptiveCardsHost2 = (0, _slicedToArray2.default)(_useAdaptiveCardsHost, 1),\n      adaptiveCardsHostConfig = _useAdaptiveCardsHost2[0];\n\n  var _useDisabled = useDisabled(),\n      _useDisabled2 = (0, _slicedToArray2.default)(_useDisabled, 1),\n      disabledFromComposer = _useDisabled2[0];\n\n  var _useState3 = (0, _react.useState)([]),\n      _useState4 = (0, _slicedToArray2.default)(_useState3, 2),\n      errors = _useState4[0],\n      setErrors = _useState4[1];\n\n  var _useState5 = (0, _react.useState)(0),\n      _useState6 = (0, _slicedToArray2.default)(_useState5, 2),\n      lastRender = _useState6[0],\n      setLastRender = _useState6[1];\n\n  var activeElementIndexRef = (0, _react.useRef)(-1);\n  var adaptiveCardElementRef = (0, _react.useRef)();\n  var contentRef = (0, _react.useRef)();\n  var inputValuesRef = (0, _react.useRef)([]);\n  var localize = useLocalizer();\n  var performCardAction = usePerformCardAction();\n  var renderMarkdownAsHTML = useRenderMarkdownAsHTML();\n  var scrollToEnd = useScrollToEnd();\n  var disabled = disabledFromComposer || disabledFromProps; // TODO: [P2] #3199 We should consider using `adaptiveCard.selectAction` instead.\n  // The null check for \"tapAction\" is in \"handleClickAndKeyPressForTapAction\".\n\n  var handleClickAndKeyPress = (0, _react.useCallback)(function (event) {\n    var _ref3 = event,\n        key = _ref3.key,\n        type = _ref3.type;\n    var target = event.target; // Some items, e.g. tappable text, cannot be disabled thru DOM attributes\n\n    var current = contentRef.current;\n    var adaptiveCardRoot = current.querySelector('.ac-adaptiveCard[tabindex=\"0\"]');\n\n    if (!adaptiveCardRoot) {\n      return console.warn('botframework-webchat: No Adaptive Card root container can be found; the card is probably on an unsupported Adaptive Card version.');\n    } // For \"keypress\" event, we only listen to ENTER and SPACEBAR key.\n\n\n    if (type === 'keypress') {\n      if (key !== 'Enter' && key !== ' ') {\n        return;\n      }\n\n      event.preventDefault();\n    } // We will call performCardAction if either:\n    // 1. We are on the target, or\n    // 2. The event-dispatching element is not interactive\n\n\n    if (target !== adaptiveCardRoot) {\n      var tabIndex = (0, _botframeworkWebchatComponent.getTabIndex)(target); // If the user is clicking on something that is already clickable, do not allow them to click the card.\n      // E.g. a hero card can be tappable, and image and buttons inside the hero card can also be tappable.\n\n      if (typeof tabIndex === 'number' && tabIndex >= 0) {\n        return;\n      }\n    }\n\n    performCardAction(tapAction);\n    scrollToEnd();\n  }, [contentRef, performCardAction, scrollToEnd, tapAction]); // Only listen to event if it is not disabled and have \"tapAction\" prop.\n\n  var handleClickAndKeyPressForTapAction = !disabled && tapAction ? handleClickAndKeyPress : undefined;\n  var addActionsPerformed = (0, _react.useCallback)(function (action) {\n    return !~actionsPerformed.indexOf(action) && setActionsPerformed([].concat((0, _toConsumableArray2.default)(actionsPerformed), [action]));\n  }, [actionsPerformed, setActionsPerformed]);\n  var handleExecuteAction = (0, _react.useCallback)(function (action) {\n    // Some items, e.g. tappable image, cannot be disabled thru DOM attributes\n    if (disabled) {\n      return;\n    }\n\n    addActionsPerformed(action);\n    var actionTypeName = action.getJsonTypeName();\n    var image = action.iconUrl,\n        title = action.title; // We cannot use \"instanceof\" check here, because web devs may bring their own version of Adaptive Cards package.\n    // We need to check using \"getJsonTypeName()\" instead.\n\n    if (actionTypeName === 'Action.OpenUrl') {\n      var _ref4 = action,\n          value = _ref4.url;\n      performCardAction({\n        image: image,\n        title: title,\n        type: 'openUrl',\n        value: value\n      });\n    } else if (actionTypeName === 'Action.Submit') {\n      var _ref5 = action,\n          data = _ref5.data;\n\n      if (typeof data !== 'undefined') {\n        if (typeof data === 'string') {\n          performCardAction({\n            image: image,\n            title: title,\n            type: 'imBack',\n            value: data\n          });\n        } else if (data.__isBotFrameworkCardAction) {\n          performCardAction(data.cardAction);\n        } else {\n          performCardAction({\n            image: image,\n            title: title,\n            type: 'postBack',\n            value: data\n          });\n        }\n      }\n\n      scrollToEnd();\n    } else {\n      console.error(\"Web Chat: received unknown action from Adaptive Cards\");\n      console.error(action);\n    }\n  }, [addActionsPerformed, disabled, performCardAction, scrollToEnd]);\n  (0, _react.useLayoutEffect)(function () {\n    var current = contentRef.current;\n\n    if (!current || !adaptiveCard) {\n      activeElementIndexRef.current = -1;\n      inputValuesRef.current = [];\n    } // Currently, the only way to set the Markdown engine is to set it thru static member of AdaptiveCard class\n    // TODO: [P3] Checks if we could make the \"renderMarkdownAsHTML\" per card\n    //       This could be limitations from Adaptive Cards package (not supported as of 1.2.5)\n    //       Because there could be timing difference between .parse and .render, we could be using wrong Markdown engine\n    // \"onProcessMarkdown\" is a static function but we are trying to scope it to the current object instead.\n    // eslint-disable-next-line dot-notation\n\n\n    adaptiveCard.constructor['onProcessMarkdown'] = function (text, result) {\n      if (renderMarkdownAsHTML) {\n        result.outputHtml = renderMarkdownAsHTML(text);\n        result.didProcess = true;\n      }\n    };\n\n    if (adaptiveCardsHostConfig) {\n      adaptiveCard.hostConfig = isPlainObject(adaptiveCardsHostConfig) ? new HostConfig(adaptiveCardsHostConfig) : adaptiveCardsHostConfig;\n    } // For accessibility issue #1340, `tabindex=\"0\"` must not be set for the root container if it is not interactive.\n\n\n    GlobalSettings.setTabIndexAtCardRoot = !!tapAction;\n\n    var _adaptiveCard$validat = adaptiveCard.validateProperties(),\n        validationEvents = _adaptiveCard$validat.validationEvents;\n\n    if (validationEvents.length) {\n      return setErrors(validationEvents.reduce(function (items, _ref6) {\n        var message = _ref6.message;\n        return [].concat((0, _toConsumableArray2.default)(items), [new Error(message)]);\n      }, []));\n    }\n\n    var element;\n\n    try {\n      element = adaptiveCard.render();\n    } catch (error) {\n      return setErrors([error]);\n    }\n\n    if (!element) {\n      return setErrors([new Error('Adaptive Card rendered as empty element')]);\n    } // Clear errors on next render\n\n\n    setErrors([]);\n    restoreInputValues(element, inputValuesRef.current);\n    current.appendChild(element);\n    adaptiveCardElementRef.current = element; // Focus can only be restored after the DOM is attached.\n\n    restoreActiveElementIndex(element, activeElementIndexRef.current);\n    setLastRender(Date.now());\n    return function () {\n      activeElementIndexRef.current = saveActiveElementIndex(element);\n      inputValuesRef.current = saveInputValues(element);\n      current.removeChild(adaptiveCardElementRef.current);\n      adaptiveCardElementRef.current = undefined;\n    };\n  }, [adaptiveCard, adaptiveCardsHostConfig, contentRef, GlobalSettings, HostConfig, renderMarkdownAsHTML, setErrors, tapAction]);\n  (0, _react.useEffect)(function () {\n    // Set onExecuteAction without causing unnecessary re-render.\n    adaptiveCard.onExecuteAction = disabled ? undefined : handleExecuteAction;\n  }, [adaptiveCard, disabled, handleExecuteAction]);\n  (0, _react.useEffect)(function () {\n    return fixAccessibilityIssuesWithUndo(adaptiveCardElementRef.current);\n  }, [adaptiveCardElementRef, lastRender]);\n  (0, _react.useEffect)(function () {\n    // If the Adaptive Card get re-rendered, re-disable elements as needed.\n    if (disabled) {\n      return disableInputElementsWithUndo(adaptiveCardElementRef.current);\n    }\n  }, [adaptiveCardElementRef, disabled, lastRender]);\n  (0, _react.useEffect)(function () {\n    // If the Adaptive Card changed, reset all actions performed.\n    setActionsPerformed([]);\n  }, [adaptiveCard]);\n  (0, _react.useEffect)(function () {\n    return indicateActionSelectionWithUndo( // Actions that do not have \"renderedElement\" means it is the Adaptive Card itself, such as \"selectAction\" (AC) or \"tapAction\" (rich cards).\n    // We do not need to mark the whole card as performed.\n    actionsPerformed.map(function (_ref7) {\n      var renderedElement = _ref7.renderedElement;\n      return renderedElement;\n    }).filter(function (renderedElement) {\n      return renderedElement;\n    }), actionPerformedClassName);\n  }, [actionsPerformed, actionPerformedClassName, lastRender]);\n  return errors.length ? node_env === 'development' && /*#__PURE__*/_react.default.createElement(ErrorBox, {\n    error: errors[0],\n    type: localize('ADAPTIVE_CARD_ERROR_BOX_TITLE_RENDER')\n  }) : /*#__PURE__*/_react.default.createElement(\"div\", {\n    className: (0, _classnames.default)(adaptiveCardRendererStyleSet + '', 'webchat__adaptive-card-renderer'),\n    onClick: handleClickAndKeyPressForTapAction,\n    onKeyPress: handleClickAndKeyPressForTapAction,\n    ref: contentRef\n  });\n};\n\nAdaptiveCardRenderer.defaultProps = {\n  actionPerformedClassName: '',\n  disabled: undefined,\n  tapAction: undefined\n};\nAdaptiveCardRenderer.propTypes = {\n  actionPerformedClassName: _propTypes.default.string,\n  adaptiveCard: _propTypes.default.any.isRequired,\n  disabled: _propTypes.default.bool,\n  // TypeScript class is not mappable to PropTypes.func\n  // @ts-ignore\n  tapAction: _propTypes.default.shape({\n    image: _propTypes.default.string,\n    title: _propTypes.default.string,\n    type: _propTypes.default.string.isRequired,\n    value: _propTypes.default.string\n  })\n};\nvar _default = AdaptiveCardRenderer;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["ErrorBox","Components","useDisabled","hooks","useLocalizer","usePerformCardAction","useRenderMarkdownAsHTML","useScrollToEnd","useStyleSet","node_env","undefined","bunchUndos","fns","arguments","forEach","fn","addClass","element","className","classList","contains","add","addPersistentClassWithUndo","observer","MutationObserver","observe","attributes","attributeFilter","classNames","Set","split","delete","Array","from","join","disconnect","isPlainObject","obj","Object","getPrototypeOf","prototype","setAttributeWithUndo","qualifiedName","nextValue","value","getAttribute","setAttribute","removeAttribute","disabledHandler","event","preventDefault","stopImmediatePropagation","stopPropagation","addEventListenerOnceWithUndo","name","handler","detach","detachingHandler","removeEventListener","addEventListener","once","addEventListenerWithUndo","disableElementWithUndo","undoStack","isActive","document","activeElement","tag","nodeName","toLowerCase","push","map","call","querySelectorAll","option","disableInputElementsWithUndo","observeSubtree","mutations","addedNodes","addedNode","childList","subtree","hasAttribute","setOrRemoveAttribute","setOrRemoveAttributeWithUndo","prevValue","findAncestor","predicate","current","parentElement","indicateActionSelectionWithUndo","selectedActionElements","actionPerformedClassName","length","some","actionElement","console","warn","actionSetElements","actionSetElement","selectedActionElement","ancestor","includes","fixAccessibilityIssuesWithUndo","actionButton","undo","getFocusableElements","filter","tabIndex","restoreActiveElementIndex","activeElementIndex","focus","saveActiveElementIndex","indexOf","restoreInputValues","inputValues","inputs","input","index","tagName","type","checked","saveInputValues","AdaptiveCardRenderer","adaptiveCard","disabledFromProps","disabled","tapAction","adaptiveCardRendererStyleSet","adaptiveCardRenderer","GlobalSettings","HostConfig","actionsPerformed","setActionsPerformed","adaptiveCardsHostConfig","disabledFromComposer","errors","setErrors","lastRender","setLastRender","activeElementIndexRef","adaptiveCardElementRef","contentRef","inputValuesRef","localize","performCardAction","renderMarkdownAsHTML","scrollToEnd","handleClickAndKeyPress","key","target","adaptiveCardRoot","querySelector","handleClickAndKeyPressForTapAction","addActionsPerformed","action","handleExecuteAction","actionTypeName","getJsonTypeName","image","iconUrl","title","url","data","__isBotFrameworkCardAction","cardAction","error","constructor","text","result","outputHtml","didProcess","hostConfig","setTabIndexAtCardRoot","validateProperties","validationEvents","reduce","items","message","Error","render","appendChild","Date","now","removeChild","onExecuteAction","renderedElement","_react","onClick","onKeyPress","ref","defaultProps","propTypes","PropTypes","string","any","isRequired","bool","shape"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat/lib/src/adaptiveCards/Attachment/AdaptiveCardRenderer.tsx"],"sourcesContent":["/* eslint no-magic-numbers: [\"error\", { \"ignore\": [-1, 0, 2] }] */\n\nimport {\n  Action as AdaptiveCardAction,\n  AdaptiveCard,\n  IMarkdownProcessingResult,\n  OpenUrlAction,\n  SubmitAction\n} from 'adaptivecards';\nimport { Components, getTabIndex, hooks } from 'botframework-webchat-component';\nimport { DirectLineCardAction } from 'botframework-webchat-core';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport React, {\n  KeyboardEventHandler,\n  MouseEventHandler,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState,\n  VFC\n} from 'react';\n\nimport { BotFrameworkCardAction } from './AdaptiveCardBuilder';\nimport useAdaptiveCardsHostConfig from '../hooks/useAdaptiveCardsHostConfig';\nimport useAdaptiveCardsPackage from '../hooks/useAdaptiveCardsPackage';\n\nconst { ErrorBox } = Components;\nconst { useDisabled, useLocalizer, usePerformCardAction, useRenderMarkdownAsHTML, useScrollToEnd, useStyleSet } = hooks;\n\nconst node_env = process.env.node_env || process.env.NODE_ENV;\n\ntype UndoFunction = (() => void) | undefined;\n\nfunction bunchUndos(...fns: UndoFunction[]): UndoFunction {\n  return () => fns.forEach(fn => fn?.());\n}\n\n/**\n * Adds a class to the `HTMLElement`. Returns `true` if the class is added, otherwise, `undefined`.\n */\nfunction addClass(element: HTMLElement, className: string): true | undefined {\n  const { classList } = element;\n\n  if (!classList.contains(className)) {\n    classList.add(className);\n\n    return true;\n  }\n}\n\n/**\n * Adds a class to the `HTMLElement` and re-add on mutations.\n *\n * @returns {function} A function, when called, will restore to previous state.\n */\nfunction addPersistentClassWithUndo(element: HTMLElement | undefined, className: string): UndoFunction {\n  if (!element) {\n    return;\n  }\n\n  if (addClass(element, className)) {\n    // After we add the class, keep observing the element to make sure the class is not removed.\n    const observer = new MutationObserver(() => addClass(element, className));\n\n    observer.observe(element, { attributes: true, attributeFilter: ['class'] });\n\n    return () => {\n      const classNames = new Set(element.className.split(' '));\n\n      classNames.delete(className);\n\n      element.className = Array.from(classNames).join(' ');\n      observer.disconnect();\n    };\n  }\n}\n\n/**\n * Returns `true`, if the object is a plain object and not a class, otherwise, `false`.\n */\nfunction isPlainObject(obj) {\n  return Object.getPrototypeOf(obj) === Object.prototype;\n}\n\n/**\n * Sets an attribute.\n *\n * @returns {function} A function, when called, will restore to previous state.\n */\nfunction setAttributeWithUndo(\n  element: HTMLElement | undefined,\n  qualifiedName: string,\n  nextValue: string\n): UndoFunction {\n  if (!element) {\n    return;\n  }\n\n  const value = element.getAttribute(qualifiedName);\n\n  if (value !== nextValue) {\n    element.setAttribute(qualifiedName, nextValue);\n\n    return () => (value ? element.setAttribute(qualifiedName, value) : element.removeAttribute(qualifiedName));\n  }\n}\n\n/**\n * An event handler for disabling event bubbling and propagation.\n */\nconst disabledHandler = (event: Event) => {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n};\n\n/**\n * Listens to event once. Returns a function, when called, will stop listening.\n */\nfunction addEventListenerOnceWithUndo(\n  element: HTMLElement | undefined,\n  name: string,\n  handler: EventListener\n): UndoFunction {\n  if (!element) {\n    return;\n  }\n\n  /* eslint-disable-next-line prefer-const */\n  let detach: () => void;\n  const detachingHandler = event => {\n    try {\n      handler(event);\n    } finally {\n      // IE11 does not support { once: true }, so we need to detach manually.\n      detach();\n    }\n  };\n\n  detach = () => element.removeEventListener(name, detachingHandler);\n\n  element.addEventListener(name, detachingHandler, { once: true });\n\n  return detach;\n}\n\n/**\n * Listens to event. Returns a function, when called, will stop listening.\n */\nfunction addEventListenerWithUndo(\n  element: HTMLElement | undefined,\n  name: string,\n  handler: EventListener\n): UndoFunction {\n  if (!element) {\n    return;\n  }\n\n  element.addEventListener(name, handler);\n\n  return () => element.removeEventListener(name, handler);\n}\n\n/**\n * Disables an element with undo function.\n *\n * @returns {function} A function, when called, will restore to previous state.\n */\nfunction disableElementWithUndo(element: HTMLElement | undefined): UndoFunction {\n  if (!element) {\n    return;\n  }\n\n  const undoStack: UndoFunction[] = [];\n  const isActive = element === document.activeElement;\n  const tag = element.nodeName.toLowerCase();\n\n  /* eslint-disable-next-line default-case */\n  switch (tag) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      undoStack.push(setAttributeWithUndo(element, 'aria-disabled', 'true'));\n\n      if (isActive) {\n        undoStack.push(\n          addEventListenerOnceWithUndo(element, 'blur', () =>\n            undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'))\n          )\n        );\n      } else {\n        undoStack.push(setAttributeWithUndo(element, 'disabled', 'disabled'));\n      }\n\n      if (tag === 'input' || tag === 'textarea') {\n        undoStack.push(addEventListenerWithUndo(element, 'click', disabledHandler));\n        undoStack.push(setAttributeWithUndo(element, 'readonly', 'readonly'));\n      } else if (tag === 'select') {\n        undoStack.push(\n          ...[].map.call(element.querySelectorAll('option'), option =>\n            setAttributeWithUndo(option, 'disabled', 'disabled')\n          )\n        );\n      }\n\n      break;\n  }\n\n  return bunchUndos(...undoStack);\n}\n\n/**\n * Disables all inputtable descendants.\n *\n * @param {HTMLElement | undefined} element Container element to start looking for inputtable descendants.\n * @param {boolean} observeSubtree `true` to applies to all future inputtable descendants, otherwise, `false`.\n *\n * @returns {function} A function, when called, will restore to previous state.\n */\nfunction disableInputElementsWithUndo(element: HTMLElement | undefined, observeSubtree = true): UndoFunction {\n  if (!element) {\n    return;\n  }\n\n  const undoStack: (() => void)[] = [].map.call(element.querySelectorAll('button, input, select, textarea'), element =>\n    disableElementWithUndo(element)\n  );\n\n  const tag = element.nodeName.toLowerCase();\n\n  // Only set tabindex=\"-1\" on focusable element. Otherwise, we will make <div> focusable by mouse.\n  (tag === 'a' || tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea') &&\n    undoStack.push(setAttributeWithUndo(element, 'tabindex', '-1'));\n\n  if (observeSubtree) {\n    const observer = new MutationObserver(mutations =>\n      mutations.forEach(({ addedNodes }) =>\n        undoStack.push(...[].map.call(addedNodes, addedNode => disableInputElementsWithUndo(addedNode, false)))\n      )\n    );\n\n    observer.observe(element, { childList: true, subtree: true });\n\n    undoStack.push(() => observer.disconnect());\n  }\n\n  return bunchUndos(...undoStack);\n}\n\n/**\n * Gets the value of an attribute from an element.\n *\n * @returns {false | string} The value of the attribute. `false` if the attribute was not set.\n */\nfunction getAttribute(element: HTMLElement, qualifiedName: string): false | string {\n  return !!element && element.hasAttribute(qualifiedName) && (element.getAttribute(qualifiedName) || '');\n}\n\n/**\n * Sets or removes an attribute from an element.\n *\n * @param {HTMLElement} element - The element to set or remove attribute from.\n * @param {string} qualifiedName - The name of the attribute.\n * @param {false | string} value - The value of the attribute. When passing `false`, remove the attribute.\n */\nfunction setOrRemoveAttribute(element: HTMLElement | undefined, qualifiedName: string, value: false | string): void {\n  if (value === false) {\n    element?.removeAttribute(qualifiedName);\n  } else {\n    element?.setAttribute(qualifiedName, value);\n  }\n}\n\n/**\n * Sets or removes an attribute from an element with an undo function.\n *\n * @param {HTMLElement} element - The element to set or remove attribute from.\n * @param {string} qualifiedName - The name of the attribute.\n * @param {false | string} value - The value of the attribute. When passing `false`, remove the attribute.\n *\n * @returns {() => void} The undo function, when called, will undo all manipulations by restoring values recorded at the time of the function call.\n */\nfunction setOrRemoveAttributeWithUndo(\n  element: HTMLElement | undefined,\n  qualifiedName: string,\n  value: false | string\n): UndoFunction {\n  if (!element) {\n    return;\n  }\n\n  const prevValue = getAttribute(element, qualifiedName);\n\n  setOrRemoveAttribute(element, qualifiedName, value);\n\n  return () => setOrRemoveAttribute(element, qualifiedName, prevValue);\n}\n\n/**\n * Finds the first ancestor that fulfill the predicate.\n *\n * @param {HTMLElement} element - The starting element. This element will not be checked against the predicate.\n * @param {(ancestor: HTMLElement) => boolean} predicate - The predicate to fulfill.\n *\n * @returns {HTMLElement | undefined} The first ancestor that fulfill the predicate, otherwise, `undefined`.\n */\nfunction findAncestor(element: HTMLElement, predicate: (ancestor: HTMLElement) => boolean): HTMLElement | undefined {\n  let current = element;\n\n  while ((current = current.parentElement)) {\n    if (predicate.call(element, current)) {\n      return current;\n    }\n  }\n}\n\n/**\n * Indicates the action selected by performing a series of manipulations, with undo:\n *\n * - Accessibility: set `aria-pressed` to `true`\n * - Applies `styleOptions.actionPerformedClassName`\n *\n * @param {HTMLElement[]} selectedActionElements - An array of elements that are representing the action and is selected.\n * @param {string?} actionPerformedClassName - The name of the class to apply to all elements.\n *\n * @returns {() => void} The undo function, when called, will undo all manipulations by restoring values recorded at the time of the function call.\n */\nfunction indicateActionSelectionWithUndo(\n  selectedActionElements: HTMLElement[] | undefined,\n  actionPerformedClassName?: string\n): UndoFunction {\n  if (!selectedActionElements?.length) {\n    return;\n  }\n\n  // Verify all input elements are \"ac-pushButton\", could belongs to ActionSet or \"card actions\".\n  if (selectedActionElements.some(actionElement => !actionElement.classList.contains('ac-pushButton'))) {\n    console.warn(\n      'botframework-webchat: Cannot mark selected action in the card, some elements are not an \"ac-pushButton\".'\n    );\n\n    return;\n  }\n\n  // A distinct set of action set containers which has selections, excluding containers without actions.\n  // Multiple submission in an Adaptive Card is still a vague area and TBD.\n  // We might want to disable the whole card, just buttons in same container, or do nothing (today).\n  const actionSetElements = new Set<HTMLElement>();\n\n  selectedActionElements.forEach(selectedActionElement => {\n    const actionSetElement = findAncestor(\n      selectedActionElement,\n      ancestor => ancestor.getAttribute('role') === 'menubar'\n    );\n\n    actionSetElement && actionSetElements.add(actionSetElement);\n  });\n\n  const undoStack: (() => void)[] = [];\n\n  actionSetElements.forEach(actionSetElement => {\n    // Remove \"role\" from every \"ac-actionSet\" container.\n    undoStack.push(setOrRemoveAttributeWithUndo(actionSetElement, 'role', false));\n\n    // Modify \"role\" of every actions in the container.\n    Array.from(actionSetElement.querySelectorAll('.ac-pushButton') as NodeListOf<HTMLElement>).forEach(\n      actionElement => {\n        if (selectedActionElements.includes(actionElement)) {\n          // Add \"aria-pressed\" and set \"role\" attribute to \"button\" (which is required by \"aria-pressed\").\n          undoStack.push(setOrRemoveAttributeWithUndo(actionElement, 'aria-pressed', 'true'));\n          undoStack.push(setOrRemoveAttributeWithUndo(actionElement, 'role', 'button'));\n\n          // Highlight actions by applying `styleOptions.actionPerformedClassName`.\n          actionPerformedClassName &&\n            undoStack.push(addPersistentClassWithUndo(actionElement, actionPerformedClassName));\n        } else {\n          // We removed \"role=menubar\" from the container, we must remove \"role=menuitem\" from unselected actions.\n          undoStack.push(setOrRemoveAttributeWithUndo(actionElement, 'role', false));\n        }\n      }\n    );\n  });\n\n  return bunchUndos(...undoStack);\n}\n\n/**\n * Fixes accessibility issues from Adaptive Card, with undo.\n *\n * @returns {() => void} The undo function, when called, will undo all manipulations by restoring values recorded at the time of the function call.\n */\nfunction fixAccessibilityIssuesWithUndo(element: HTMLElement): UndoFunction {\n  if (!element) {\n    return;\n  }\n\n  // These hacks should be done in Adaptive Cards library instead.\n  // Related to #3949: All action buttons inside role=\"menubar\" should be role=\"menuitem\".\n  const undoStack: UndoFunction[] = Array.from(\n    element.querySelectorAll('.ac-actionSet[role=\"menubar\"] [role=\"button\"]') as NodeListOf<HTMLElement>\n  ).map(actionButton => setAttributeWithUndo(actionButton, 'role', 'menuitem'));\n\n  return () => undoStack.forEach(undo => undo?.());\n}\n\nfunction getFocusableElements(element: HTMLElement) {\n  return [].filter.call(\n    element.querySelectorAll(\n      [\n        'a',\n        'body',\n        'button',\n        'frame',\n        'iframe',\n        'img',\n        'input',\n        'isindex',\n        'object',\n        'select',\n        'textarea',\n        '[tabindex]'\n      ].join(', ')\n    ) as NodeListOf<HTMLElement>,\n    element => {\n      const tabIndex = getTabIndex(element);\n\n      return typeof tabIndex === 'number' && tabIndex >= 0;\n    }\n  );\n}\n\nfunction restoreActiveElementIndex(element: HTMLElement, activeElementIndex: number) {\n  getFocusableElements(element)[+activeElementIndex]?.focus();\n}\n\nfunction saveActiveElementIndex(element: HTMLElement) {\n  return getFocusableElements(element).indexOf(document.activeElement);\n}\n\nfunction restoreInputValues(element: HTMLElement, inputValues: (boolean | string)[]) {\n  const inputs = element.querySelectorAll('input, select, textarea') as NodeListOf<\n    HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\n  >;\n\n  [].forEach.call(inputs, (input: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement, index: number) => {\n    const value = inputValues[+index];\n\n    if (typeof value !== 'undefined') {\n      const { tagName, type } = input;\n\n      if (tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {\n        if (typeof value === 'boolean') {\n          (input as HTMLInputElement).checked = value;\n        }\n      } else if (typeof value === 'string') {\n        input.value = value;\n      }\n    }\n  });\n}\n\nfunction saveInputValues(element: HTMLElement): (boolean | string)[] {\n  const inputs = element.querySelectorAll('input, select, textarea') as NodeListOf<\n    HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\n  >;\n\n  return [].map.call(inputs, (input: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement) => {\n    const { type } = input;\n\n    if (input.tagName === 'INPUT' && (type === 'checkbox' || type === 'radio')) {\n      return (input as HTMLInputElement).checked;\n    }\n\n    return input.value;\n  });\n}\n\ntype AdaptiveCardRendererProps = {\n  actionPerformedClassName?: string;\n  adaptiveCard: AdaptiveCard;\n  disabled?: boolean;\n  tapAction?: DirectLineCardAction;\n};\n\nconst AdaptiveCardRenderer: VFC<AdaptiveCardRendererProps> = ({\n  actionPerformedClassName,\n  adaptiveCard,\n  disabled: disabledFromProps,\n  tapAction\n}) => {\n  const [{ adaptiveCardRenderer: adaptiveCardRendererStyleSet }] = useStyleSet();\n  const [{ GlobalSettings, HostConfig }] = useAdaptiveCardsPackage();\n  const [actionsPerformed, setActionsPerformed] = useState<AdaptiveCardAction[]>([]);\n  const [adaptiveCardsHostConfig] = useAdaptiveCardsHostConfig();\n  const [disabledFromComposer] = useDisabled();\n  const [errors, setErrors] = useState([]);\n  const [lastRender, setLastRender] = useState(0);\n  const activeElementIndexRef = useRef(-1);\n  const adaptiveCardElementRef = useRef<HTMLElement>();\n  const contentRef = useRef<HTMLDivElement>();\n  const inputValuesRef = useRef<(boolean | string)[]>([]);\n  const localize = useLocalizer();\n  const performCardAction = usePerformCardAction();\n  const renderMarkdownAsHTML = useRenderMarkdownAsHTML();\n  const scrollToEnd = useScrollToEnd();\n\n  const disabled = disabledFromComposer || disabledFromProps;\n\n  // TODO: [P2] #3199 We should consider using `adaptiveCard.selectAction` instead.\n  // The null check for \"tapAction\" is in \"handleClickAndKeyPressForTapAction\".\n  const handleClickAndKeyPress = useCallback(\n    (event: KeyboardEvent | MouseEvent): void => {\n      const { key, type } = event as KeyboardEvent;\n      const target = event.target as HTMLDivElement;\n\n      // Some items, e.g. tappable text, cannot be disabled thru DOM attributes\n      const { current } = contentRef;\n      const adaptiveCardRoot = current.querySelector('.ac-adaptiveCard[tabindex=\"0\"]');\n\n      if (!adaptiveCardRoot) {\n        return console.warn(\n          'botframework-webchat: No Adaptive Card root container can be found; the card is probably on an unsupported Adaptive Card version.'\n        );\n      }\n\n      // For \"keypress\" event, we only listen to ENTER and SPACEBAR key.\n      if (type === 'keypress') {\n        if (key !== 'Enter' && key !== ' ') {\n          return;\n        }\n\n        event.preventDefault();\n      }\n\n      // We will call performCardAction if either:\n      // 1. We are on the target, or\n      // 2. The event-dispatching element is not interactive\n      if (target !== adaptiveCardRoot) {\n        const tabIndex = getTabIndex(target);\n\n        // If the user is clicking on something that is already clickable, do not allow them to click the card.\n        // E.g. a hero card can be tappable, and image and buttons inside the hero card can also be tappable.\n        if (typeof tabIndex === 'number' && tabIndex >= 0) {\n          return;\n        }\n      }\n\n      performCardAction(tapAction);\n      scrollToEnd();\n    },\n    [contentRef, performCardAction, scrollToEnd, tapAction]\n  );\n\n  // Only listen to event if it is not disabled and have \"tapAction\" prop.\n  const handleClickAndKeyPressForTapAction = !disabled && tapAction ? handleClickAndKeyPress : undefined;\n\n  const addActionsPerformed = useCallback(\n    (action: AdaptiveCardAction): void =>\n      !~actionsPerformed.indexOf(action) && setActionsPerformed([...actionsPerformed, action]),\n    [actionsPerformed, setActionsPerformed]\n  );\n\n  const handleExecuteAction = useCallback(\n    (action: AdaptiveCardAction): void => {\n      // Some items, e.g. tappable image, cannot be disabled thru DOM attributes\n      if (disabled) {\n        return;\n      }\n\n      addActionsPerformed(action);\n\n      const actionTypeName = action.getJsonTypeName();\n      const { iconUrl: image, title } = action;\n\n      // We cannot use \"instanceof\" check here, because web devs may bring their own version of Adaptive Cards package.\n      // We need to check using \"getJsonTypeName()\" instead.\n      if (actionTypeName === 'Action.OpenUrl') {\n        const { url: value } = action as OpenUrlAction;\n\n        performCardAction({\n          image,\n          title,\n          type: 'openUrl',\n          value\n        });\n      } else if (actionTypeName === 'Action.Submit') {\n        const { data } = action as SubmitAction as {\n          data: string | BotFrameworkCardAction;\n        };\n\n        if (typeof data !== 'undefined') {\n          if (typeof data === 'string') {\n            performCardAction({\n              image,\n              title,\n              type: 'imBack',\n              value: data\n            });\n          } else if (data.__isBotFrameworkCardAction) {\n            performCardAction(data.cardAction);\n          } else {\n            performCardAction({\n              image,\n              title,\n              type: 'postBack',\n              value: data\n            });\n          }\n        }\n\n        scrollToEnd();\n      } else {\n        console.error(`Web Chat: received unknown action from Adaptive Cards`);\n        console.error(action);\n      }\n    },\n    [addActionsPerformed, disabled, performCardAction, scrollToEnd]\n  );\n\n  useLayoutEffect(() => {\n    const { current } = contentRef;\n\n    if (!current || !adaptiveCard) {\n      activeElementIndexRef.current = -1;\n      inputValuesRef.current = [];\n    }\n\n    // Currently, the only way to set the Markdown engine is to set it thru static member of AdaptiveCard class\n\n    // TODO: [P3] Checks if we could make the \"renderMarkdownAsHTML\" per card\n    //       This could be limitations from Adaptive Cards package (not supported as of 1.2.5)\n    //       Because there could be timing difference between .parse and .render, we could be using wrong Markdown engine\n\n    // \"onProcessMarkdown\" is a static function but we are trying to scope it to the current object instead.\n    // eslint-disable-next-line dot-notation\n    adaptiveCard.constructor['onProcessMarkdown'] = (text: string, result: IMarkdownProcessingResult) => {\n      if (renderMarkdownAsHTML) {\n        result.outputHtml = renderMarkdownAsHTML(text);\n        result.didProcess = true;\n      }\n    };\n\n    if (adaptiveCardsHostConfig) {\n      adaptiveCard.hostConfig = isPlainObject(adaptiveCardsHostConfig)\n        ? new HostConfig(adaptiveCardsHostConfig)\n        : adaptiveCardsHostConfig;\n    }\n\n    // For accessibility issue #1340, `tabindex=\"0\"` must not be set for the root container if it is not interactive.\n    GlobalSettings.setTabIndexAtCardRoot = !!tapAction;\n\n    const { validationEvents } = adaptiveCard.validateProperties();\n\n    if (validationEvents.length) {\n      return setErrors(validationEvents.reduce((items, { message }) => [...items, new Error(message)], []));\n    }\n\n    let element: HTMLElement;\n\n    try {\n      element = adaptiveCard.render();\n    } catch (error) {\n      return setErrors([error]);\n    }\n\n    if (!element) {\n      return setErrors([new Error('Adaptive Card rendered as empty element')]);\n    }\n\n    // Clear errors on next render\n    setErrors([]);\n\n    restoreInputValues(element, inputValuesRef.current);\n\n    current.appendChild(element);\n    adaptiveCardElementRef.current = element;\n\n    // Focus can only be restored after the DOM is attached.\n    restoreActiveElementIndex(element, activeElementIndexRef.current);\n\n    setLastRender(Date.now());\n\n    return () => {\n      activeElementIndexRef.current = saveActiveElementIndex(element);\n      inputValuesRef.current = saveInputValues(element);\n\n      current.removeChild(adaptiveCardElementRef.current);\n\n      adaptiveCardElementRef.current = undefined;\n    };\n  }, [\n    adaptiveCard,\n    adaptiveCardsHostConfig,\n    contentRef,\n    GlobalSettings,\n    HostConfig,\n    renderMarkdownAsHTML,\n    setErrors,\n    tapAction\n  ]);\n\n  useEffect(() => {\n    // Set onExecuteAction without causing unnecessary re-render.\n    adaptiveCard.onExecuteAction = disabled ? undefined : handleExecuteAction;\n  }, [adaptiveCard, disabled, handleExecuteAction]);\n\n  useEffect(() => fixAccessibilityIssuesWithUndo(adaptiveCardElementRef.current), [adaptiveCardElementRef, lastRender]);\n\n  useEffect(() => {\n    // If the Adaptive Card get re-rendered, re-disable elements as needed.\n    if (disabled) {\n      return disableInputElementsWithUndo(adaptiveCardElementRef.current);\n    }\n  }, [adaptiveCardElementRef, disabled, lastRender]);\n\n  useEffect(() => {\n    // If the Adaptive Card changed, reset all actions performed.\n    setActionsPerformed([]);\n  }, [adaptiveCard]);\n\n  useEffect(\n    () =>\n      indicateActionSelectionWithUndo(\n        // Actions that do not have \"renderedElement\" means it is the Adaptive Card itself, such as \"selectAction\" (AC) or \"tapAction\" (rich cards).\n        // We do not need to mark the whole card as performed.\n        actionsPerformed.map(({ renderedElement }) => renderedElement).filter(renderedElement => renderedElement),\n        actionPerformedClassName\n      ),\n    [actionsPerformed, actionPerformedClassName, lastRender]\n  );\n\n  return errors.length ? (\n    node_env === 'development' && <ErrorBox error={errors[0]} type={localize('ADAPTIVE_CARD_ERROR_BOX_TITLE_RENDER')} />\n  ) : (\n    <div\n      className={classNames(adaptiveCardRendererStyleSet + '', 'webchat__adaptive-card-renderer')}\n      onClick={handleClickAndKeyPressForTapAction as unknown as MouseEventHandler<HTMLDivElement>}\n      onKeyPress={handleClickAndKeyPressForTapAction as unknown as KeyboardEventHandler<HTMLDivElement>}\n      ref={contentRef}\n    />\n  );\n};\n\nAdaptiveCardRenderer.defaultProps = {\n  actionPerformedClassName: '',\n  disabled: undefined,\n  tapAction: undefined\n};\n\nAdaptiveCardRenderer.propTypes = {\n  actionPerformedClassName: PropTypes.string,\n  adaptiveCard: PropTypes.any.isRequired,\n  disabled: PropTypes.bool,\n\n  // TypeScript class is not mappable to PropTypes.func\n  // @ts-ignore\n  tapAction: PropTypes.shape({\n    image: PropTypes.string,\n    title: PropTypes.string,\n    type: PropTypes.string.isRequired,\n    value: PropTypes.string\n  })\n};\n\nexport default AdaptiveCardRenderer;\n"]},"metadata":{},"sourceType":"script"}