{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useMemoize;\n\nvar _react = require(\"react\");\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/**\n * `useMemoize` will memoize multiple calls to the same memoize function.\n *\n * This is similar to `useMemo`. But instead of calling it once, `useMemoize` enables multiple calls while the `callback` function is executed.\n *\n * @param {Fn<TArgs, TIntermediate>} fn - The function to be memoized.\n * @param {(fn: Fn<TArgs, TIntermediate>) => TFinal} callback - When called, this function should execute the memoizing function.\n * @param {DependencyList[]} deps - Dependencies to detect for chagnes.\n */\n\n\nfunction useMemoize(fn, callback, deps) {\n  if (typeof fn !== 'function') {\n    throw new Error('The first argument must be a function.');\n  } else if (typeof callback !== 'function') {\n    throw new Error('The second argument must be a function.');\n  } else if (!Array.isArray(deps)) {\n    throw new Error('The third argument must be an array.');\n  }\n\n  var memoizedFn = (0, _react.useMemo)(function () {\n    var cache = [];\n    return function (run) {\n      var nextCache = [];\n      var result = run(function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var _ref = [].concat(_toConsumableArray(cache), nextCache).find(function (_ref2) {\n          var cachedArgs = _ref2.args;\n          return args.length === cachedArgs.length && args.every(function (arg, index) {\n            return Object.is(arg, cachedArgs[+index]);\n          });\n        }) || {\n          result: fn.apply(void 0, args)\n        },\n            result = _ref.result;\n\n        nextCache.push({\n          args: args,\n          result: result\n        });\n        return result;\n      });\n      cache = nextCache;\n      return result;\n    }; // We are manually creating the deps here. The \"callback\" arg is also designed not to be impact deps, similar to useEffect(fn), where \"fn\" is not in deps.\n\n    /* eslint-disable-next-line react-hooks/exhaustive-deps */\n  }, [fn].concat(_toConsumableArray(deps)));\n  return memoizedFn(callback);\n}","map":{"version":3,"mappings":";;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACe,SAASA,UAAT,CACbC,EADa,EAEbC,QAFa,EAGbC,IAHa,EAIL;AACR,MAAI,OAAOF,EAAP,KAAc,UAAlB,EAA8B;AAC5B,UAAM,IAAIG,KAAJ,CAAU,wCAAV,CAAN;AADF,SAEO,IAAI,OAAOF,QAAP,KAAoB,UAAxB,EAAoC;AACzC,UAAM,IAAIE,KAAJ,CAAU,yCAAV,CAAN;AADK,SAEA,IAAI,CAACC,KAAK,CAACC,OAAND,CAAcF,IAAdE,CAAL,EAA0B;AAC/B,UAAM,IAAID,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,MAAMG,UAAU,GAAG,oBAAQ,YAAM;AAC/B,QAAIC,KAAoC,GAAG,EAA3C;AAEA,WAAO,UAACC,GAAD,EAAmD;AACxD,UAAMC,SAAwC,GAAG,EAAjD;AACA,UAAMC,MAAM,GAAGF,GAAG,CAAC,YAAa;AAAA,0CAATG,IAAS;AAATA,cAAS,MAATA,GAASC,eAATD;AAAS;;AAC9B,mBAAmB,6BAAIJ,KAAJ,GAAcE,SAAd,EAAyBI,IAAzB,CACjB;AAAA,cAASC,UAAT,SAAGH,IAAH;AAAA,iBACEA,IAAI,CAACI,MAALJ,KAAgBG,UAAU,CAACC,MAA3BJ,IAAqCA,IAAI,CAACK,KAALL,CAAW,UAACM,GAAD,EAAMC,KAAN;AAAA,mBAAgBC,MAAM,CAACC,EAAPD,CAAUF,GAAVE,EAAeL,UAAU,CAAC,CAACI,KAAF,CAAzBC,CAAhB;AAAX,YADvC;AADiB,cAGd;AAAET,gBAAM,EAAEV,EAAE,MAAFA,SAAMW,IAANX;AAAV,SAHL;AAAA,YAAQU,MAAR,QAAQA,MAAR;;AAKAD,iBAAS,CAACY,IAAVZ,CAAe;AAAEE,cAAI,EAAJA,IAAF;AAAQD,gBAAM,EAANA;AAAR,SAAfD;AAEA,eAAOC,MAAP;AARgB,QAAlB;AAWAH,WAAK,GAAGE,SAARF;AAEA,aAAOG,MAAP;AAfF,MAH+B,CAoB/B;;AACA;AArBiB,MAsBfV,EAtBe,4BAsBRE,IAtBQ,GAAnB;AAwBA,SAAOI,UAAU,CAACL,QAAD,CAAjB;AACD","names":["useMemoize","fn","callback","deps","Error","Array","isArray","memoizedFn","cache","run","nextCache","result","args","arguments","find","cachedArgs","length","every","arg","index","Object","is","push"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-component/lib/src/hooks/internal/useMemoize.ts"],"sourcesContent":["import { DependencyList, useMemo } from 'react';\n\ntype Cache<TArgs, TResult> = { args: TArgs[]; result: TResult };\ntype Fn<TArgs, TResult> = (...args: TArgs[]) => TResult;\n\n/**\n * `useMemoize` will memoize multiple calls to the same memoize function.\n *\n * This is similar to `useMemo`. But instead of calling it once, `useMemoize` enables multiple calls while the `callback` function is executed.\n *\n * @param {Fn<TArgs, TIntermediate>} fn - The function to be memoized.\n * @param {(fn: Fn<TArgs, TIntermediate>) => TFinal} callback - When called, this function should execute the memoizing function.\n * @param {DependencyList[]} deps - Dependencies to detect for chagnes.\n */\nexport default function useMemoize<TArgs extends [], TIntermediate, TFinal>(\n  fn: Fn<TArgs, TIntermediate>,\n  callback: (fn: Fn<TArgs, TIntermediate>) => TFinal,\n  deps: DependencyList[]\n): TFinal {\n  if (typeof fn !== 'function') {\n    throw new Error('The first argument must be a function.');\n  } else if (typeof callback !== 'function') {\n    throw new Error('The second argument must be a function.');\n  } else if (!Array.isArray(deps)) {\n    throw new Error('The third argument must be an array.');\n  }\n\n  const memoizedFn = useMemo(() => {\n    let cache: Cache<TArgs, TIntermediate>[] = [];\n\n    return (run: (fn: Fn<TArgs, TIntermediate>) => TFinal) => {\n      const nextCache: Cache<TArgs, TIntermediate>[] = [];\n      const result = run((...args) => {\n        const { result } = [...cache, ...nextCache].find(\n          ({ args: cachedArgs }) =>\n            args.length === cachedArgs.length && args.every((arg, index) => Object.is(arg, cachedArgs[+index]))\n        ) || { result: fn(...args) };\n\n        nextCache.push({ args, result });\n\n        return result;\n      });\n\n      cache = nextCache;\n\n      return result;\n    };\n    // We are manually creating the deps here. The \"callback\" arg is also designed not to be impact deps, similar to useEffect(fn), where \"fn\" is not in deps.\n    /* eslint-disable-next-line react-hooks/exhaustive-deps */\n  }, [fn, ...deps]);\n\n  return memoizedFn(callback);\n}\n"]},"metadata":{},"sourceType":"script"}