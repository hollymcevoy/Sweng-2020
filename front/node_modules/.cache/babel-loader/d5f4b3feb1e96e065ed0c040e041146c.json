{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subscriber_1 = require('../Subscriber');\n\nfunction refCount() {\n  return function refCountOperatorFunction(source) {\n    return source.lift(new RefCountOperator(source));\n  };\n}\n\nexports.refCount = refCount;\n\nvar RefCountOperator = function () {\n  function RefCountOperator(connectable) {\n    this.connectable = connectable;\n  }\n\n  RefCountOperator.prototype.call = function (subscriber, source) {\n    var connectable = this.connectable;\n    connectable._refCount++;\n    var refCounter = new RefCountSubscriber(subscriber, connectable);\n    var subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n\n    return subscription;\n  };\n\n  return RefCountOperator;\n}();\n\nvar RefCountSubscriber = function (_super) {\n  __extends(RefCountSubscriber, _super);\n\n  function RefCountSubscriber(destination, connectable) {\n    _super.call(this, destination);\n\n    this.connectable = connectable;\n  }\n  /** @deprecated internal use only */\n\n\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    var refCount = connectable._refCount;\n\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    connectable._refCount = refCount - 1;\n\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    } ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n\n\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n\n  return RefCountSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"mappings":";;;;;;;;;;;;AACA,2BAA2B,eAA3B;;AAMA;AACE,SAAO,kCAAkCA,MAAlC,EAAkE;AACvE,WAAOA,MAAM,CAACC,IAAP,CAAY,IAAIC,gBAAJ,CAAqBF,MAArB,CAAZ,CAAP;AACD,GAFD;AAGD;;AAJeG,mBAAQC,QAAR;;AAMhB;AACE,4BAAoBC,WAApB,EAAyD;AAArC;AACnB;;AACDH,8CAAKI,UAAL,EAAgCN,MAAhC,EAA2C;AAEjC;AACDK,eAAY,CAACE,SAAb;AAEP,QAAMC,UAAU,GAAG,IAAIC,kBAAJ,CAAuBH,UAAvB,EAAmCD,WAAnC,CAAnB;AACA,QAAMK,YAAY,GAAGV,MAAM,CAACW,SAAP,CAAiBH,UAAjB,CAArB;;AAEA,QAAI,CAACA,UAAU,CAACI,MAAhB,EAAwB;AACfJ,gBAAW,CAACK,UAAZ,GAAyBR,WAAW,CAACS,OAAZ,EAAzB;AACR;;AAED,WAAOJ,YAAP;AACD,GAbD;;AAcF;AAAC,CAjBD;;AAmBA;AAAoCK;;AAIlC,8BAAYC,WAAZ,EACoBX,WADpB,EACyD;AACvDY,sBAAMD,WAAN;;AADkB;AAEnB;AAED;;;AAAqCP;AAE3B;;AACR,QAAI,CAACJ,WAAL,EAAkB;AAChB,WAAKQ,UAAL,GAAkB,IAAlB;AACA;AACD;;AAED,SAAKR,WAAL,GAAmB,IAAnB;AACA,QAAMD,QAAQ,GAAUC,WAAY,CAACE,SAArC;;AACA,QAAIH,QAAQ,IAAI,CAAhB,EAAmB;AACjB,WAAKS,UAAL,GAAkB,IAAlB;AACA;AACD;;AAEMR,eAAY,CAACE,SAAb,GAAyBH,QAAQ,GAAG,CAApC;;AACP,QAAIA,QAAQ,GAAG,CAAf,EAAkB;AAChB,WAAKS,UAAL,GAAkB,IAAlB;AACA;AACD,KAnBkC,CAqBnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ;AACR,QAAMK,gBAAgB,GAAUb,WAAY,CAACc,WAA7C;AACA,SAAKN,UAAL,GAAkB,IAAlB;;AAEA,QAAIK,gBAAgB,KAAK,CAACL,UAAD,IAAeK,gBAAgB,KAAKL,UAAzC,CAApB,EAA0E;AACxEK,sBAAgB,CAACE,WAAjB;AACD;AACF,GAnDoC;;AAoDvC;AA7DA,EAAoCC,uBAApC","names":["source","lift","RefCountOperator","exports","refCount","connectable","subscriber","_refCount","refCounter","RefCountSubscriber","subscription","subscribe","closed","connection","connect","__extends","destination","_super","sharedConnection","_connection","unsubscribe","Subscriber_1"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/src/operators/refCount.ts"],"sourcesContent":["import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../interfaces';\nimport { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Observable } from '../Observable';\n\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return function refCountOperatorFunction(source: ConnectableObservable<T>): Observable<T> {\n    return source.lift(new RefCountOperator(source));\n  };\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}