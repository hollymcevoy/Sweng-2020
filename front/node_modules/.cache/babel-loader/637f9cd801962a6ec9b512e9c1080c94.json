{"ast":null,"code":"\"use strict\";\n\nvar root_1 = require('./root');\n\nvar isArrayLike_1 = require('./isArrayLike');\n\nvar isPromise_1 = require('./isPromise');\n\nvar isObject_1 = require('./isObject');\n\nvar Observable_1 = require('../Observable');\n\nvar iterator_1 = require('../symbol/iterator');\n\nvar InnerSubscriber_1 = require('../InnerSubscriber');\n\nvar observable_1 = require('../symbol/observable');\n\nfunction subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n  var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable_1.Observable) {\n    if (result._isScalar) {\n      destination.next(result.value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike_1.isArrayLike(result)) {\n    for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise_1.isPromise(result)) {\n    result.then(function (value) {\n      if (!destination.closed) {\n        destination.next(value);\n        destination.complete();\n      }\n    }, function (err) {\n      return destination.error(err);\n    }).then(null, function (err) {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root_1.root.setTimeout(function () {\n        throw err;\n      });\n    });\n    return destination;\n  } else if (result && typeof result[iterator_1.iterator] === 'function') {\n    var iterator = result[iterator_1.iterator]();\n\n    do {\n      var item = iterator.next();\n\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n\n      destination.next(item.value);\n\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[observable_1.observable] === 'function') {\n    var obs = result[observable_1.observable]();\n\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n    var msg = \"You provided \" + value + \" where a stream was expected.\" + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n\n  return null;\n}\n\nexports.subscribeToResult = subscribeToResult;","map":{"version":3,"mappings":"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","names":["outerSubscriber","result","outerValue","outerIndex","destination","InnerSubscriber_1","closed","Observable_1","_isScalar","next","value","complete","syncErrorThrowable","subscribe","isArrayLike_1","i","len","length","isPromise_1","then","err","error","root_1","setTimeout","iterator_1","iterator","item","done","observable_1","obs","TypeError","isObject_1","msg","exports","subscribeToResult"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/src/util/subscribeToResult.ts"],"sourcesContent":["import { root } from './root';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, ObservableInput } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>,\n                                        result: any,\n                                        outerValue?: T,\n                                        outerIndex?: number): Subscription;\nexport function subscribeToResult<T>(outerSubscriber: OuterSubscriber<any, any>,\n                                     result: ObservableInput<T>,\n                                     outerValue?: T,\n                                     outerIndex?: number): Subscription {\n  let destination: Subscriber<any> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable) {\n    if (result._isScalar) {\n      destination.next((<any>result).value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike(result)) {\n    for (let i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise(result)) {\n    result.then(\n      (value) => {\n        if (!destination.closed) {\n          destination.next(<any>value);\n          destination.complete();\n        }\n      },\n      (err: any) => destination.error(err)\n    )\n    .then(null, (err: any) => {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root.setTimeout(() => { throw err; });\n    });\n    return destination;\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    const iterator = <any>result[Symbol_iterator]();\n    do {\n      let item = iterator.next();\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n      destination.next(item.value);\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    const obs = result[Symbol_observable]();\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n  return null;\n}\n"]},"metadata":{},"sourceType":"script"}