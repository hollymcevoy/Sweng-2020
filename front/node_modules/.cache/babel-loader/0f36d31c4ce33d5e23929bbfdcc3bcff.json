{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Observable_1 = require('../Observable');\n\nvar ScalarObservable_1 = require('./ScalarObservable');\n\nvar EmptyObservable_1 = require('./EmptyObservable');\n\nvar isScheduler_1 = require('../util/isScheduler');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar ArrayObservable = function (_super) {\n  __extends(ArrayObservable, _super);\n\n  function ArrayObservable(array, scheduler) {\n    _super.call(this);\n\n    this.array = array;\n    this.scheduler = scheduler;\n\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  ArrayObservable.create = function (array, scheduler) {\n    return new ArrayObservable(array, scheduler);\n  };\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n\n\n  ArrayObservable.of = function () {\n    var array = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      array[_i - 0] = arguments[_i];\n    }\n\n    var scheduler = array[array.length - 1];\n\n    if (isScheduler_1.isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    var len = array.length;\n\n    if (len > 1) {\n      return new ArrayObservable(array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n    } else {\n      return new EmptyObservable_1.EmptyObservable(scheduler);\n    }\n  };\n\n  ArrayObservable.dispatch = function (state) {\n    var array = state.array,\n        index = state.index,\n        count = state.count,\n        subscriber = state.subscriber;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n    this.schedule(state);\n  };\n  /** @deprecated internal use only */\n\n\n  ArrayObservable.prototype._subscribe = function (subscriber) {\n    var index = 0;\n    var array = this.array;\n    var count = array.length;\n    var scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array: array,\n        index: index,\n        count: count,\n        subscriber: subscriber\n      });\n    } else {\n      for (var i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n\n      subscriber.complete();\n    }\n  };\n\n  return ArrayObservable;\n}(Observable_1.Observable);\n\nexports.ArrayObservable = ArrayObservable;","map":{"version":3,"mappings":";;;;;;;;;;;;AACA,2BAA2B,eAA3B;;AACA,iCAAiC,oBAAjC;;AACA,gCAAgC,mBAAhC;;AAEA,4BAA4B,qBAA5B;AAGA;;;;;;;AAKA;AAAwCA;;AA0FtC,2BAAoBC,KAApB,EAAwCC,SAAxC,EAA8D;AAC5DC;;AADkB;AAAoB;;AAEtC,QAAI,CAACD,SAAD,IAAcD,KAAK,CAACG,MAAN,KAAiB,CAAnC,EAAsC;AACpC,WAAKC,SAAL,GAAiB,IAAjB;AACA,WAAKC,KAAL,GAAaL,KAAK,CAAC,CAAD,CAAlB;AACD;AACF;;AA9FMM,2BAAP,UAAiBN,KAAjB,EAA6BC,SAA7B,EAAmD;AACjD,WAAO,IAAIK,eAAJ,CAAoBN,KAApB,EAA2BC,SAA3B,CAAP;AACD,GAFM;AAWP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCOK,uBAAP;AAAa;;SAAA,yCAA+B;AAA/BN;;;AACX,QAAIC,SAAS,GAAeD,KAAK,CAACA,KAAK,CAACG,MAAN,GAAe,CAAhB,CAAjC;;AACA,QAAII,0BAAYN,SAAZ,CAAJ,EAA4B;AAC1BD,WAAK,CAACQ,GAAN;AACD,KAFD,MAEO;AACLP,eAAS,GAAG,IAAZ;AACD;;AAED,QAAMQ,GAAG,GAAGT,KAAK,CAACG,MAAlB;;AACA,QAAIM,GAAG,GAAG,CAAV,EAAa;AACX,aAAO,IAAIH,eAAJ,CAA4BN,KAA5B,EAAmCC,SAAnC,CAAP;AACD,KAFD,MAEO,IAAIQ,GAAG,KAAK,CAAZ,EAAe;AACpB,aAAO,IAAIC,mCAAJ,CAA6BV,KAAK,CAAC,CAAD,CAAlC,EAAuCC,SAAvC,CAAP;AACD,KAFM,MAEA;AACL,aAAO,IAAIU,iCAAJ,CAAuBV,SAAvB,CAAP;AACD;AACF,GAhBM;;AAkBAK,6BAAP,UAAgBM,KAAhB,EAA0B;AAEhB;AAAA,QAAOC,mBAAP;AAAA,QAAcC,mBAAd;AAAA,QAAqBC,6BAArB;;AAER,QAAIF,KAAK,IAAIC,KAAb,EAAoB;AAClBC,gBAAU,CAACC,QAAX;AACA;AACD;;AAEDD,cAAU,CAACE,IAAX,CAAgBjB,KAAK,CAACa,KAAD,CAArB;;AAEA,QAAIE,UAAU,CAACG,MAAf,EAAuB;AACrB;AACD;;AAEDN,SAAK,CAACC,KAAN,GAAcA,KAAK,GAAG,CAAtB;AAEO,SAAMM,QAAN,CAAeP,KAAf;AACR,GAlBM;AA+BP;;;AAAqCN,mDAAWS,UAAX,EAAoC;AACvE,QAAIF,KAAK,GAAG,CAAZ;AACA,QAAMb,KAAK,GAAG,KAAKA,KAAnB;AACA,QAAMc,KAAK,GAAGd,KAAK,CAACG,MAApB;AACA,QAAMF,SAAS,GAAG,KAAKA,SAAvB;;AAEA,QAAIA,SAAJ,EAAe;AACb,aAAOA,SAAS,CAACkB,QAAV,CAAmBb,eAAe,CAACc,QAAnC,EAA6C,CAA7C,EAAgD;AACrDpB,oBADqD;AAC9Ca,oBAD8C;AACvCC,oBADuC;AAChCC;AADgC,OAAhD,CAAP;AAGD,KAJD,MAIO;AACL,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,KAAJ,IAAa,CAACC,UAAU,CAACG,MAAzC,EAAiDG,CAAC,EAAlD,EAAsD;AACpDN,kBAAU,CAACE,IAAX,CAAgBjB,KAAK,CAACqB,CAAD,CAArB;AACD;;AACDN,gBAAU,CAACC,QAAX;AACD;AACF,GAhBoC;;AAiBvC;AAnHA,EAAwCM,uBAAxC;;AAAaC,0BAAejB,eAAf","names":["__extends","array","scheduler","_super","length","_isScalar","value","ArrayObservable","isScheduler_1","pop","len","ScalarObservable_1","EmptyObservable_1","state","index","count","subscriber","complete","next","closed","schedule","dispatch","i","Observable_1","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/src/observable/ArrayObservable.ts"],"sourcesContent":["import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ScalarObservable } from './ScalarObservable';\nimport { EmptyObservable } from './EmptyObservable';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ArrayObservable<T> extends Observable<T> {\n\n  static create<T>(array: T[], scheduler?: IScheduler): Observable<T> {\n    return new ArrayObservable(array, scheduler);\n  }\n\n  static of<T>(item1: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, item6: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(...array: Array<T | IScheduler>): Observable<T>;\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n  static of<T>(...array: Array<T | IScheduler>): Observable<T> {\n    let scheduler = <IScheduler>array[array.length - 1];\n    if (isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    const len = array.length;\n    if (len > 1) {\n      return new ArrayObservable<T>(<any>array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable<T>(<any>array[0], scheduler);\n    } else {\n      return new EmptyObservable<T>(scheduler);\n    }\n  }\n\n  static dispatch(state: any) {\n\n    const { array, index, count, subscriber } = state;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  // value used if Array has one value and _isScalar\n  value: any;\n\n  constructor(private array: T[], private scheduler?: IScheduler) {\n    super();\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    let index = 0;\n    const array = this.array;\n    const count = array.length;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array, index, count, subscriber\n      });\n    } else {\n      for (let i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n      subscriber.complete();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}