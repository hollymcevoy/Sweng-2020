{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _botframeworkWebchatApi = require(\"botframework-webchat-api\");\n\nvar _reactScrollToBottom = require(\"react-scroll-to-bottom\");\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _detectBrowser = require(\"./Utils/detectBrowser\");\n\nvar _ActivityRow = _interopRequireDefault(require(\"./Transcript/ActivityRow\"));\n\nvar _BasicTypingIndicator = _interopRequireDefault(require(\"./BasicTypingIndicator\"));\n\nvar _FocusRedirector = _interopRequireDefault(require(\"./Utils/FocusRedirector\"));\n\nvar _inputtableKey = _interopRequireDefault(require(\"./Utils/TypeFocusSink/inputtableKey\"));\n\nvar _isZeroOrPositive = _interopRequireDefault(require(\"./Utils/isZeroOrPositive\"));\n\nvar _KeyboardHelp = _interopRequireDefault(require(\"./Transcript/KeyboardHelp\"));\n\nvar _LiveRegionTranscript = _interopRequireDefault(require(\"./Transcript/LiveRegionTranscript\"));\n\nvar _tabbableElements = _interopRequireDefault(require(\"./Utils/tabbableElements\"));\n\nvar _TranscriptFocusComposer = _interopRequireDefault(require(\"./providers/TranscriptFocus/TranscriptFocusComposer\"));\n\nvar _useActiveDescendantId = _interopRequireDefault(require(\"./providers/TranscriptFocus/useActiveDescendantId\"));\n\nvar _useActivityTreeWithRenderer = _interopRequireDefault(require(\"./providers/ActivityTree/useActivityTreeWithRenderer\"));\n\nvar _useDispatchScrollPosition = _interopRequireDefault(require(\"./hooks/internal/useDispatchScrollPosition\"));\n\nvar _useDispatchTranscriptFocusByActivityKey = _interopRequireDefault(require(\"./hooks/internal/useDispatchTranscriptFocusByActivityKey\"));\n\nvar _useFocus = _interopRequireDefault(require(\"./hooks/useFocus\"));\n\nvar _useFocusByActivityKey = _interopRequireDefault(require(\"./providers/TranscriptFocus/useFocusByActivityKey\"));\n\nvar _useFocusedActivityKey = _interopRequireDefault(require(\"./providers/TranscriptFocus/useFocusedActivityKey\"));\n\nvar _useFocusedExplicitly3 = _interopRequireDefault(require(\"./providers/TranscriptFocus/useFocusedExplicitly\"));\n\nvar _useFocusRelativeActivity = _interopRequireDefault(require(\"./providers/TranscriptFocus/useFocusRelativeActivity\"));\n\nvar _useObserveFocusVisible = _interopRequireDefault(require(\"./hooks/internal/useObserveFocusVisible\"));\n\nvar _usePrevious = _interopRequireDefault(require(\"./hooks/internal/usePrevious\"));\n\nvar _useRegisterFocusTranscript = _interopRequireDefault(require(\"./hooks/internal/useRegisterFocusTranscript\"));\n\nvar _useRegisterScrollRelative = _interopRequireDefault(require(\"./hooks/internal/useRegisterScrollRelative\"));\n\nvar _useRegisterScrollTo = _interopRequireDefault(require(\"./hooks/internal/useRegisterScrollTo\"));\n\nvar _useRegisterScrollToEnd = _interopRequireDefault(require(\"./hooks/internal/useRegisterScrollToEnd\"));\n\nvar _useStyleSet5 = _interopRequireDefault(require(\"./hooks/useStyleSet\"));\n\nvar _useStyleToEmotionObject = _interopRequireDefault(require(\"./hooks/internal/useStyleToEmotionObject\"));\n\nvar _useUniqueId = _interopRequireDefault(require(\"./hooks/internal/useUniqueId\"));\n\nvar _useValueRef = _interopRequireDefault(require(\"./hooks/internal/useValueRef\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar useActivityKeys = _botframeworkWebchatApi.hooks.useActivityKeys,\n    useActivityKeysByRead = _botframeworkWebchatApi.hooks.useActivityKeysByRead,\n    useCreateActivityStatusRenderer = _botframeworkWebchatApi.hooks.useCreateActivityStatusRenderer,\n    useCreateAvatarRenderer = _botframeworkWebchatApi.hooks.useCreateAvatarRenderer,\n    useCreateScrollToEndButtonRenderer = _botframeworkWebchatApi.hooks.useCreateScrollToEndButtonRenderer,\n    useDirection = _botframeworkWebchatApi.hooks.useDirection,\n    useGetActivityByKey = _botframeworkWebchatApi.hooks.useGetActivityByKey,\n    useGetKeyByActivity = _botframeworkWebchatApi.hooks.useGetKeyByActivity,\n    useGetKeyByActivityId = _botframeworkWebchatApi.hooks.useGetKeyByActivityId,\n    useLastAcknowledgedActivityKey = _botframeworkWebchatApi.hooks.useLastAcknowledgedActivityKey,\n    useLocalizer = _botframeworkWebchatApi.hooks.useLocalizer,\n    useMarkActivityKeyAsRead = _botframeworkWebchatApi.hooks.useMarkActivityKeyAsRead,\n    useMarkAllAsAcknowledged = _botframeworkWebchatApi.hooks.useMarkAllAsAcknowledged,\n    useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions;\nvar ROOT_STYLE = {\n  '&.webchat__basic-transcript': {\n    display: 'flex',\n    flexDirection: 'column',\n    overflow: 'hidden',\n    // Make sure to set \"position: relative\" here to form another stacking context for the scroll-to-end button.\n    // Stacking context help isolating elements that use \"z-index\" from global pollution.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n    position: 'relative',\n    '& .webchat__basic-transcript__filler': {\n      flex: 1\n    },\n    '& .webchat__basic-transcript__scrollable': {\n      display: 'flex',\n      flexDirection: 'column',\n      overflowX: 'hidden',\n      WebkitOverflowScrolling: 'touch'\n    },\n    '& .webchat__basic-transcript__transcript': {\n      listStyleType: 'none'\n    }\n  }\n}; // TODO: [P1] #4133 Add telemetry for computing how many re-render done so far.\n\nvar InternalTranscript = /*#__PURE__*/(0, _react.forwardRef)(function (_ref, ref) {\n  var activityElementMapRef = _ref.activityElementMapRef,\n      className = _ref.className;\n\n  var _useStyleSet = (0, _useStyleSet5.default)(),\n      _useStyleSet2 = _slicedToArray(_useStyleSet, 1),\n      basicTranscriptStyleSet = _useStyleSet2[0].basicTranscript;\n\n  var _useStyleOptions = useStyleOptions(),\n      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),\n      _useStyleOptions2$ = _useStyleOptions2[0],\n      bubbleFromUserNubOffset = _useStyleOptions2$.bubbleFromUserNubOffset,\n      bubbleNubOffset = _useStyleOptions2$.bubbleNubOffset,\n      groupTimestamp = _useStyleOptions2$.groupTimestamp,\n      showAvatarInGroup = _useStyleOptions2$.showAvatarInGroup;\n\n  var _useActiveDescendantI = (0, _useActiveDescendantId.default)(),\n      _useActiveDescendantI2 = _slicedToArray(_useActiveDescendantI, 1),\n      activeDescendantId = _useActiveDescendantI2[0];\n\n  var _useActivityTreeWithR = (0, _useActivityTreeWithRenderer.default)(),\n      _useActivityTreeWithR2 = _slicedToArray(_useActivityTreeWithR, 1),\n      activityWithRendererTree = _useActivityTreeWithR2[0];\n\n  var _useDirection = useDirection(),\n      _useDirection2 = _slicedToArray(_useDirection, 1),\n      direction = _useDirection2[0];\n\n  var _useFocusedActivityKe = (0, _useFocusedActivityKey.default)(),\n      _useFocusedActivityKe2 = _slicedToArray(_useFocusedActivityKe, 1),\n      focusedActivityKey = _useFocusedActivityKe2[0];\n\n  var _useFocusedExplicitly = (0, _useFocusedExplicitly3.default)(),\n      _useFocusedExplicitly2 = _slicedToArray(_useFocusedExplicitly, 1),\n      focusedExplicitly = _useFocusedExplicitly2[0];\n\n  var createActivityStatusRenderer = useCreateActivityStatusRenderer();\n  var createAvatarRenderer = useCreateAvatarRenderer();\n  var focus = (0, _useFocus.default)();\n  var focusByActivityKey = (0, _useFocusByActivityKey.default)();\n  var focusRelativeActivity = (0, _useFocusRelativeActivity.default)();\n  var getActivityByKey = useGetActivityByKey();\n  var getKeyByActivity = useGetKeyByActivity();\n  var getKeyByActivityId = useGetKeyByActivityId();\n  var localize = useLocalizer();\n  var rootClassName = (0, _useStyleToEmotionObject.default)()(ROOT_STYLE) + '';\n  var rootElementRef = (0, _react.useRef)();\n  var terminatorLabelId = (0, _useUniqueId.default)('webchat__basic-transcript__terminator-label');\n  var terminatorRef = (0, _react.useRef)();\n  var focusedActivityKeyRef = (0, _useValueRef.default)(focusedActivityKey);\n  var hideAllTimestamps = groupTimestamp === false;\n  var terminatorText = localize('TRANSCRIPT_TERMINATOR_TEXT');\n  var transcriptAriaLabel = localize('TRANSCRIPT_ARIA_LABEL_ALT');\n  var callbackRef = (0, _react.useCallback)(function (element) {\n    if (typeof ref === 'function') {\n      ref(element);\n    } else {\n      ref.current = element;\n    }\n\n    rootElementRef.current = element;\n  }, [ref, rootElementRef]); // Flatten the tree back into an array with information related to rendering.\n\n  var renderingElements = (0, _react.useMemo)(function () {\n    var renderingElements = [];\n    var topSideBotNub = (0, _isZeroOrPositive.default)(bubbleNubOffset);\n    var topSideUserNub = (0, _isZeroOrPositive.default)(bubbleFromUserNubOffset);\n    activityWithRendererTree.forEach(function (entriesWithSameSender) {\n      var _entriesWithSameSende = _slicedToArray(entriesWithSameSender, 1),\n          _entriesWithSameSende2 = _slicedToArray(_entriesWithSameSende[0], 1),\n          firstActivity = _entriesWithSameSende2[0].activity;\n\n      var renderAvatar = createAvatarRenderer({\n        activity: firstActivity\n      });\n      entriesWithSameSender.forEach(function (entriesWithSameSenderAndStatus, indexWithinSenderGroup) {\n        var firstInSenderGroup = !indexWithinSenderGroup;\n        var lastInSenderGroup = indexWithinSenderGroup === entriesWithSameSender.length - 1;\n        entriesWithSameSenderAndStatus.forEach(function (_ref2, indexWithinSenderAndStatusGroup) {\n          var _activity$from;\n\n          var activity = _ref2.activity,\n              renderActivity = _ref2.renderActivity; // We only show the timestamp at the end of the sender group. But we always show the \"Send failed, retry\" prompt.\n\n          var firstInSenderAndStatusGroup = !indexWithinSenderAndStatusGroup;\n          var key = getKeyByActivity(activity);\n          var lastInSenderAndStatusGroup = indexWithinSenderAndStatusGroup === entriesWithSameSenderAndStatus.length - 1;\n          var renderActivityStatus = createActivityStatusRenderer({\n            activity: activity,\n            nextVisibleActivity: undefined\n          });\n          var topSideNub = ((_activity$from = activity.from) === null || _activity$from === void 0 ? void 0 : _activity$from.role) === 'user' ? topSideUserNub : topSideBotNub;\n          var showCallout; // Depending on the \"showAvatarInGroup\" setting, the avatar will render in different positions.\n\n          if (showAvatarInGroup === 'sender') {\n            if (topSideNub) {\n              showCallout = firstInSenderGroup && firstInSenderAndStatusGroup;\n            } else {\n              showCallout = lastInSenderGroup && lastInSenderAndStatusGroup;\n            }\n          } else if (showAvatarInGroup === 'status') {\n            if (topSideNub) {\n              showCallout = firstInSenderAndStatusGroup;\n            } else {\n              showCallout = lastInSenderAndStatusGroup;\n            }\n          } else {\n            showCallout = true;\n          }\n\n          renderingElements.push({\n            activity: activity,\n            // After the element is mounted, set it to activityElementsRef.\n            callbackRef: function callbackRef(activityElement) {\n              activityElement ? activityElementMapRef.current.set(key, activityElement) : activityElementMapRef.current.delete(key);\n            },\n            // \"hideTimestamp\" is a render-time parameter for renderActivityStatus().\n            // If true, it will hide the timestamp, but it will continue to show the\n            // retry prompt. And show the screen reader version of the timestamp.\n            hideTimestamp: hideAllTimestamps || indexWithinSenderAndStatusGroup !== entriesWithSameSenderAndStatus.length - 1,\n            key: key,\n            renderActivity: renderActivity,\n            renderActivityStatus: renderActivityStatus,\n            renderAvatar: renderAvatar,\n            showCallout: showCallout\n          });\n        });\n      });\n    });\n    return renderingElements;\n  }, [activityElementMapRef, activityWithRendererTree, bubbleFromUserNubOffset, bubbleNubOffset, createActivityStatusRenderer, createAvatarRenderer, getKeyByActivity, hideAllTimestamps, showAvatarInGroup]);\n  var scrollToBottomScrollTo = (0, _reactScrollToBottom.useScrollTo)();\n  var scrollToBottomScrollToEnd = (0, _reactScrollToBottom.useScrollToEnd)();\n  var scrollTo = (0, _react.useCallback)(function (position) {\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref3$behavior = _ref3.behavior,\n        behavior = _ref3$behavior === void 0 ? 'auto' : _ref3$behavior;\n\n    if (!position) {\n      throw new Error('botframework-webchat: First argument passed to \"useScrollTo\" must be a ScrollPosition object.');\n    }\n\n    var activityId = position.activityID,\n        scrollTop = position.scrollTop;\n\n    if (typeof scrollTop !== 'undefined') {\n      scrollToBottomScrollTo(scrollTop, {\n        behavior: behavior\n      });\n    } else if (typeof activityId !== 'undefined') {\n      var _activityElementMapRe;\n\n      var activityBoundingBoxElement = (_activityElementMapRe = activityElementMapRef.current.get(getKeyByActivityId(activityId))) === null || _activityElementMapRe === void 0 ? void 0 : _activityElementMapRe.querySelector('.webchat__basic-transcript__activity-active-descendant');\n      var scrollableElement = rootElementRef.current.querySelector('.webchat__basic-transcript__scrollable');\n\n      if (scrollableElement && activityBoundingBoxElement) {\n        // ESLint conflict with TypeScript. The result of getClientRects() is not an Array but DOMRectList, and cannot be destructured.\n        // eslint-disable-next-line prefer-destructuring\n        var activityBoundingBoxElementClientRect = activityBoundingBoxElement.getClientRects()[0]; // ESLint conflict with TypeScript. The result of getClientRects() is not an Array but DOMRectList, and cannot be destructured.\n        // eslint-disable-next-line prefer-destructuring\n\n        var scrollableElementClientRect = scrollableElement.getClientRects()[0]; // If either the activity or the transcript scrollable is not on DOM, we will not scroll the view.\n\n        if (activityBoundingBoxElementClientRect && scrollableElementClientRect) {\n          var activityHeight = activityBoundingBoxElementClientRect.height,\n              activityY = activityBoundingBoxElementClientRect.y;\n          var scrollableHeight = scrollableElementClientRect.height;\n          var activityOffsetTop = activityY + scrollableElement.scrollTop;\n\n          var _scrollTop = Math.min(activityOffsetTop, activityOffsetTop - scrollableHeight + activityHeight);\n\n          scrollToBottomScrollTo(_scrollTop, {\n            behavior: behavior\n          });\n        }\n      }\n    }\n  }, [activityElementMapRef, getKeyByActivityId, rootElementRef, scrollToBottomScrollTo]);\n  var scrollToEnd = (0, _react.useCallback)(function () {\n    return scrollToBottomScrollToEnd({\n      behavior: 'smooth'\n    });\n  }, [scrollToBottomScrollToEnd]);\n  var scrollRelative = (0, _react.useCallback)(function (direction) {\n    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        displacement = _ref4.displacement;\n\n    var rootElement = rootElementRef.current;\n\n    if (!rootElement) {\n      return;\n    }\n\n    var scrollable = rootElement.querySelector('.webchat__basic-transcript__scrollable');\n    var nextScrollTop;\n\n    if (typeof displacement === 'number') {\n      // eslint-disable-next-line no-magic-numbers\n      nextScrollTop = scrollable.scrollTop + (direction === 'down' ? 1 : -1) * displacement;\n    } else {\n      // eslint-disable-next-line no-magic-numbers\n      nextScrollTop = scrollable.scrollTop + (direction === 'down' ? 1 : -1) * scrollable.offsetHeight;\n    }\n\n    scrollTo({\n      scrollTop: Math.max(0, Math.min(scrollable.scrollHeight - scrollable.offsetHeight, nextScrollTop))\n    }, {\n      behavior: 'smooth'\n    });\n  }, [rootElementRef, scrollTo]); // Since there could be multiple instances of <BasicTranscript> inside the <Composer>, when the developer calls `scrollXXX`, we need to call it on all instances.\n  // We call `useRegisterScrollXXX` to register a callback function, the `useScrollXXX` will multiplex the call into each instance of <BasicTranscript>.\n\n  (0, _useRegisterScrollTo.default)(scrollTo);\n  (0, _useRegisterScrollToEnd.default)(scrollToEnd);\n  (0, _useRegisterScrollRelative.default)(scrollRelative);\n  var markActivityKeyAsRead = useMarkActivityKeyAsRead();\n  var dispatchScrollPositionWithActivityId = (0, _useDispatchScrollPosition.default)(); // TODO: [P2] We should use IntersectionObserver to track what activity is in the scrollable.\n  //            However, IntersectionObserver is not available on IE11, we need to make a limited polyfill in React style.\n\n  var handleScrollPosition = (0, _react.useCallback)(function (_ref5) {\n    var _ref6;\n\n    var scrollTop = _ref5.scrollTop;\n    var rootElement = rootElementRef.current;\n\n    if (!rootElement) {\n      return;\n    }\n\n    var scrollableElement = rootElement.querySelector('.webchat__basic-transcript__scrollable'); // \"getClientRects()\" is not returning an array, thus, it is not destructurable.\n    // eslint-disable-next-line prefer-destructuring\n\n    var scrollableElementClientRect = scrollableElement.getClientRects()[0]; // If the scrollable is not mounted, we cannot measure which activity is in view. Thus, we will not fire any events.\n\n    if (!scrollableElementClientRect) {\n      return;\n    }\n\n    var scrollableClientBottom = scrollableElementClientRect.bottom; // Find the activity just above scroll view bottom.\n    // If the scroll view is already on top, get the first activity.\n\n    var activityElements = Array.from(activityElementMapRef.current.entries());\n    var activityKeyJustAboveScrollBottom = (_ref6 = scrollableElement.scrollTop ? activityElements.reverse() // Add subpixel tolerance\n    .find(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 2),\n          element = _ref8[1]; // \"getClientRects()\" is not returning an array, thus, it is not destructurable.\n      // eslint-disable-next-line prefer-destructuring\n\n\n      var elementClientRect = element.getClientRects()[0]; // If the activity is not attached to DOM tree, we should not count it as \"bottommost visible activity\", as it is not visible.\n      // If the activity is not attached to DOM tree, we should not count it as \"bottommost visible activity\", as it is not visible.\n\n      return elementClientRect && elementClientRect.bottom < scrollableClientBottom + 1;\n    }) : activityElements[0]) === null || _ref6 === void 0 ? void 0 : _ref6[0]; // When the end-user slowly scrolling the view down, we will mark activity as read when the message fully appear on the screen.\n\n    activityKeyJustAboveScrollBottom && markActivityKeyAsRead(activityKeyJustAboveScrollBottom);\n\n    if (dispatchScrollPositionWithActivityId) {\n      var activity = getActivityByKey(activityKeyJustAboveScrollBottom);\n      dispatchScrollPositionWithActivityId(_objectSpread(_objectSpread({}, activity ? {\n        activityID: activity.id\n      } : {}), {}, {\n        scrollTop: scrollTop\n      }));\n    }\n  }, [activityElementMapRef, dispatchScrollPositionWithActivityId, getActivityByKey, markActivityKeyAsRead, rootElementRef]);\n  (0, _reactScrollToBottom.useObserveScrollPosition)(handleScrollPosition);\n  var handleTranscriptKeyDown = (0, _react.useCallback)(function (event) {\n    var target = event.target;\n    var fromEndOfTranscriptIndicator = target === terminatorRef.current;\n    var fromTranscript = target === event.currentTarget;\n\n    if (!fromEndOfTranscriptIndicator && !fromTranscript) {\n      return;\n    }\n\n    var handled = true;\n\n    switch (event.key) {\n      case 'ArrowDown':\n        focusRelativeActivity(fromEndOfTranscriptIndicator ? 0 : 1);\n        break;\n\n      case 'ArrowUp':\n        // eslint-disable-next-line no-magic-numbers\n        focusRelativeActivity(fromEndOfTranscriptIndicator ? 0 : -1);\n        break;\n\n      case 'End':\n        focusRelativeActivity(Infinity);\n        break;\n\n      case 'Enter':\n        // This is capturing plain ENTER.\n        // When screen reader is not running, or screen reader is running outside of scan mode, the ENTER key will be captured here.\n        if (!fromEndOfTranscriptIndicator) {\n          var _activityElementMapRe2, _tabbableElements$;\n\n          var body = (_activityElementMapRe2 = activityElementMapRef.current.get(focusedActivityKeyRef.current)) === null || _activityElementMapRe2 === void 0 ? void 0 : _activityElementMapRe2.querySelector('.webchat__basic-transcript__activity-body');\n          (_tabbableElements$ = (0, _tabbableElements.default)(body)[0]) === null || _tabbableElements$ === void 0 ? void 0 : _tabbableElements$.focus();\n        }\n\n        break;\n\n      case 'Escape':\n        focus('sendBoxWithoutKeyboard');\n        break;\n\n      case 'Home':\n        focusRelativeActivity(-Infinity);\n        break;\n\n      default:\n        handled = false;\n        break;\n    }\n\n    if (handled) {\n      event.preventDefault(); // If a custom HTML control wants to handle up/down arrow, we will prevent them from listening to this event to prevent bugs due to handling arrow keys twice.\n\n      event.stopPropagation();\n    }\n  }, [activityElementMapRef, focus, focusedActivityKeyRef, focusRelativeActivity, terminatorRef]);\n  var handleTranscriptKeyDownCapture = (0, _react.useCallback)(function (event) {\n    var altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        key = event.key,\n        metaKey = event.metaKey,\n        target = event.target;\n\n    if (altKey || ctrlKey && key !== 'v' || metaKey || !(0, _inputtableKey.default)(key) && key !== 'Backspace') {\n      // Ignore if one of the utility key (except SHIFT) is pressed\n      // E.g. CTRL-C on a link in one of the message should not jump to chat box\n      // E.g. \"A\" or \"Backspace\" should jump to chat box\n      return;\n    } // Send keystrokes to send box if we are focusing on the transcript or terminator.\n\n\n    if (target === event.currentTarget || target === terminatorRef.current) {\n      event.stopPropagation();\n      focus('sendBox');\n    }\n  }, [focus]);\n  (0, _useRegisterFocusTranscript.default)((0, _react.useCallback)(function () {\n    return focusByActivityKey(undefined);\n  }, [focusByActivityKey])); // When the focusing activity has changed, dispatch an event to observers of \"useObserveTranscriptFocus\".\n\n  var dispatchTranscriptFocusByActivityKey = (0, _useDispatchTranscriptFocusByActivityKey.default)(); // Dispatch a \"transcript focus\" event based on user selection.\n  // We should not dispatch \"transcript focus\" when a new activity come. Although the selection change, it is not initiated from the user.\n\n  (0, _react.useMemo)(function () {\n    return dispatchTranscriptFocusByActivityKey(focusedExplicitly ? focusedActivityKey : undefined);\n  }, [dispatchTranscriptFocusByActivityKey, focusedActivityKey, focusedExplicitly]); // When the transcript is being focused on, we should dispatch a \"transcriptfocus\" event.\n\n  var handleFocus = (0, _react.useCallback)( // We call \"focusByActivityKey\" with activity key of \"true\".\n  // It means, tries to focus on anything.\n  function (_ref9) {\n    var currentTarget = _ref9.currentTarget,\n        target = _ref9.target;\n    return target === currentTarget && focusByActivityKey(true, false);\n  }, [focusByActivityKey]); // This is required by IE11.\n  // When the user clicks on and empty space (a.k.a. filler) in an empty transcript, IE11 says the focus is on the <div className=\"filler\">,\n  // despite the fact there are no \"tabIndex\" attributes set on the filler.\n  // We need to artificially send the focus back to the transcript.\n\n  var handleFocusFiller = (0, _react.useCallback)(function () {\n    return focusByActivityKey(undefined);\n  }, [focusByActivityKey]); // When focus into the transcript using TAB/SHIFT-TAB, scroll the focused activity into view.\n\n  (0, _useObserveFocusVisible.default)(rootElementRef, (0, _react.useCallback)(function () {\n    return focusByActivityKey(undefined);\n  }, [focusByActivityKey]));\n  return /*#__PURE__*/_react.default.createElement(\"div\", {\n    // Although Android TalkBack 12.1 does not support `aria-activedescendant`, when used, it become buggy and will narrate content twice.\n    // We are disabling `aria-activedescendant` for Android. See <ActivityRow> for details.\n    \"aria-activedescendant\": _detectBrowser.android ? undefined : activeDescendantId,\n    \"aria-label\": transcriptAriaLabel,\n    className: (0, _classnames.default)('webchat__basic-transcript', basicTranscriptStyleSet + '', rootClassName, (className || '') + ''),\n    dir: direction,\n    onFocus: handleFocus,\n    onKeyDown: handleTranscriptKeyDown,\n    onKeyDownCapture: handleTranscriptKeyDownCapture,\n    ref: callbackRef // \"aria-activedescendant\" will only works with a number of roles and it must be explicitly set.\n    // https://www.w3.org/TR/wai-aria/#aria-activedescendant\n    ,\n    role: \"group\" // For up/down arrow key navigation across activities, this component must be included in the tab sequence.\n    // Otherwise, \"aria-activedescendant\" will not be narrated when the user press up/down arrow keys.\n    // https://www.w3.org/TR/wai-aria-practices-1.1/#kbd_focus_activedescendant\n    ,\n    tabIndex: 0\n  }, /*#__PURE__*/_react.default.createElement(_LiveRegionTranscript.default, {\n    activityElementMapRef: activityElementMapRef\n  }), /*#__PURE__*/_react.default.createElement(InternalTranscriptScrollable, {\n    onFocusFiller: handleFocusFiller,\n    terminatorRef: terminatorRef\n  }, renderingElements.map(function (_ref10) {\n    var activity = _ref10.activity,\n        callbackRef = _ref10.callbackRef,\n        hideTimestamp = _ref10.hideTimestamp,\n        key = _ref10.key,\n        renderActivity = _ref10.renderActivity,\n        renderActivityStatus = _ref10.renderActivityStatus,\n        renderAvatar = _ref10.renderAvatar,\n        showCallout = _ref10.showCallout;\n    return /*#__PURE__*/_react.default.createElement(_ActivityRow.default, {\n      activity: activity,\n      key: key,\n      ref: callbackRef\n    }, renderActivity({\n      hideTimestamp: hideTimestamp,\n      renderActivityStatus: renderActivityStatus,\n      renderAvatar: renderAvatar,\n      showCallout: showCallout\n    }));\n  })), !!renderingElements.length && /*#__PURE__*/_react.default.createElement(_react.Fragment, null, /*#__PURE__*/_react.default.createElement(_FocusRedirector.default, {\n    redirectRef: rootElementRef\n  }), /*#__PURE__*/_react.default.createElement(\"div\", {\n    \"aria-hidden\": true,\n    \"aria-labelledby\": terminatorLabelId,\n    className: \"webchat__basic-transcript__terminator\",\n    ref: terminatorRef,\n    role: \"note\",\n    tabIndex: 0\n  }, /*#__PURE__*/_react.default.createElement(\"div\", {\n    className: \"webchat__basic-transcript__terminator-body\"\n  }, /*#__PURE__*/_react.default.createElement(\"div\", {\n    className: \"webchat__basic-transcript__terminator-text\",\n    id: terminatorLabelId\n  }, terminatorText)))), /*#__PURE__*/_react.default.createElement(\"div\", {\n    className: \"webchat__basic-transcript__focus-indicator\"\n  }));\n});\nInternalTranscript.defaultProps = {\n  className: ''\n};\nInternalTranscript.propTypes = {\n  // PropTypes cannot validate precisely with its TypeScript counterpart.\n  // @ts-ignore\n  activityElementMapRef: _propTypes.default.shape({\n    current: _propTypes.default.instanceOf(Map)\n  }).isRequired,\n  className: _propTypes.default.string\n}; // Separating high-frequency hooks to improve performance.\n\nvar InternalTranscriptScrollable = function InternalTranscriptScrollable(_ref11) {\n  var children = _ref11.children,\n      onFocusFiller = _ref11.onFocusFiller,\n      terminatorRef = _ref11.terminatorRef;\n\n  var _useStyleSet3 = (0, _useStyleSet5.default)(),\n      _useStyleSet4 = _slicedToArray(_useStyleSet3, 1),\n      activitiesStyleSet = _useStyleSet4[0].activities;\n\n  var _useAnimatingToEnd = (0, _reactScrollToBottom.useAnimatingToEnd)(),\n      _useAnimatingToEnd2 = _slicedToArray(_useAnimatingToEnd, 1),\n      animatingToEnd = _useAnimatingToEnd2[0];\n\n  var _useAtEnd = (0, _reactScrollToBottom.useAtEnd)(),\n      _useAtEnd2 = _slicedToArray(_useAtEnd, 1),\n      atEnd = _useAtEnd2[0];\n\n  var _useActivityKeysByRea = useActivityKeysByRead(),\n      _useActivityKeysByRea2 = _slicedToArray(_useActivityKeysByRea, 2),\n      unreadActivityKeys = _useActivityKeysByRea2[1];\n\n  var _useSticky = (0, _reactScrollToBottom.useSticky)(),\n      _useSticky2 = _slicedToArray(_useSticky, 1),\n      sticky = _useSticky2[0];\n\n  var _useStyleOptions3 = useStyleOptions(),\n      _useStyleOptions4 = _slicedToArray(_useStyleOptions3, 1),\n      styleOptions = _useStyleOptions4[0];\n\n  var focusByActivityKey = (0, _useFocusByActivityKey.default)();\n  var localize = useLocalizer();\n  var markActivityKeyAsRead = useMarkActivityKeyAsRead();\n  var markAllAsAcknowledged = useMarkAllAsAcknowledged();\n  var scrollToEnd = (0, _reactScrollToBottom.useScrollToEnd)();\n  var prevSticky = (0, _usePrevious.default)(sticky);\n  var transcriptRoleDescription = localize('TRANSCRIPT_ARIA_ROLE_ALT');\n  var stickyChangedToTrue = prevSticky !== sticky && sticky; // Acknowledged means either:\n  // 1. The user sent a message\n  //    - We don't need a condition here. When Web Chat sends the user's message, it will scroll to bottom, and it will trigger condition 2 below.\n  // 2. The user scroll to the bottom of the transcript, from a non-bottom scroll position\n  //    - If the transcript is already at the bottom, the user needs to scroll up and then go back down\n  //    - What happens if we are relaxing \"scrolled from a non-bottom scroll position\":\n  //      1. The condition will become solely \"at the bottom of the transcript\"\n  //      2. Auto-scroll will always scroll the transcript to the bottom\n  //      3. Web Chat will always acknowledge all activities as it is at the bottom\n  //      4. Acknowledge flag become useless\n  //      5. Therefore, even the developer set \"pause after 3 activities\", if activities are coming in at a slow pace (not batched in a single render)\n  //         Web Chat will keep scrolling and not snapped/paused\n  // Note: When Web Chat is loaded, there are no activities acknowledged. We need to assume all arriving activities are acknowledged until end-user sends their first activity.\n  //       Activities loaded initially could be from conversation history. Without assuming acknowledgement, Web Chat will not scroll initially (as everything is not acknowledged).\n  //       It would be better if the chat adapter should let Web Chat know if the activity is loaded from history or not.\n  // TODO: [P2] #3670 Move the \"conversation history acknowledgement\" logic mentioned above to polyfill of chat adapters.\n  //       1. Chat adapter should send \"acknowledged\" as part of \"channelData\"\n  //       2. If \"acknowledged\" is \"undefined\", we set it to:\n  //          a. true, if there are no egress activities yet\n  //          b. Otherwise, false\n\n  (0, _react.useMemo)(function () {\n    return stickyChangedToTrue && // TODO: [P2] Both `markActivityKeyAsRead` and `markAllAsAcknowledged` hook are setters of useState.\n    //       This means, in a render loop, we will be calling setter and will cause another re-render.\n    //       This is not trivial but we should think if there is a way to avoid this.\n    markAllAsAcknowledged();\n  }, [markAllAsAcknowledged, stickyChangedToTrue]);\n\n  var _useActivityTreeWithR3 = (0, _useActivityTreeWithRenderer.default)({\n    flat: true\n  }),\n      _useActivityTreeWithR4 = _slicedToArray(_useActivityTreeWithR3, 1),\n      flattenedActivityTreeWithRenderer = _useActivityTreeWithR4[0];\n\n  var getKeyByActivity = useGetKeyByActivity();\n  var renderingActivityKeys = (0, _react.useMemo)(function () {\n    return flattenedActivityTreeWithRenderer.map(function (_ref12) {\n      var activity = _ref12.activity;\n      return getKeyByActivity(activity);\n    });\n  }, [flattenedActivityTreeWithRenderer, getKeyByActivity]);\n  var renderingActivityKeysRef = (0, _useValueRef.default)(renderingActivityKeys); // To prevent flashy button, we are not waiting for another render loop to update the `[readActivityKeys, unreadActivityKeys]` state.\n  // Instead, we are building the next one in this `useMemo` call.\n\n  var nextUnreadActivityKeys = (0, _react.useMemo)(function () {\n    // This code need to be careful reviewed as it will cause another render. The code should be converging.\n    // After we call `markActivityKeyAsRead`, everything will be read and nothing will be unread.\n    // That means, in next render, `unreadActivityKeys` will be emptied and the `markActivityKeyAsRead` will not get called again.\n    if (sticky && unreadActivityKeys.length) {\n      markActivityKeyAsRead(unreadActivityKeys[unreadActivityKeys.length - 1]);\n      return [];\n    }\n\n    return unreadActivityKeys;\n  }, [markActivityKeyAsRead, sticky, unreadActivityKeys]);\n  var nextUnreadActivityKeysRef = (0, _useValueRef.default)(nextUnreadActivityKeys); // If we are rendering anything that is unread, we should show the \"New messages\" button.\n  // Not everything in the `unreadActivityKeys` are rendered, say, bot typing indicator.\n  // We should not show the \"New messages\" button for bot typing indicator as it will confuse the user.\n\n  var unread = (0, _react.useMemo)(function () {\n    return nextUnreadActivityKeys.some(function (key) {\n      return renderingActivityKeys.includes(key);\n    });\n  }, [renderingActivityKeys, nextUnreadActivityKeys]);\n  var handleScrollToEndButtonClick = (0, _react.useCallback)(function () {\n    scrollToEnd({\n      behavior: 'smooth'\n    });\n    var renderingActivityKeys = renderingActivityKeysRef.current; // After the \"New message\" button is clicked, focus on the first unread activity which will be rendered.\n\n    var firstUnreadRenderingActivityKey = nextUnreadActivityKeysRef.current.find(function (key) {\n      return renderingActivityKeys.includes(key);\n    });\n\n    if (firstUnreadRenderingActivityKey) {\n      focusByActivityKey(firstUnreadRenderingActivityKey);\n    } else {\n      var _terminatorRef$curren; // If no unread activity, send the focus to the terminator block.\n\n\n      (_terminatorRef$curren = terminatorRef.current) === null || _terminatorRef$curren === void 0 ? void 0 : _terminatorRef$curren.focus();\n    }\n  }, [focusByActivityKey, nextUnreadActivityKeysRef, renderingActivityKeysRef, scrollToEnd, terminatorRef]);\n  var renderScrollToEndButton = useCreateScrollToEndButtonRenderer()({\n    atEnd: animatingToEnd || atEnd || sticky,\n    styleOptions: styleOptions,\n    unread: unread\n  });\n  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, renderScrollToEndButton && renderScrollToEndButton({\n    onClick: handleScrollToEndButtonClick\n  }), !!_react.default.Children.count(children) && /*#__PURE__*/_react.default.createElement(_FocusRedirector.default, {\n    redirectRef: terminatorRef\n  }), /*#__PURE__*/_react.default.createElement(_reactScrollToBottom.Panel, {\n    className: \"webchat__basic-transcript__scrollable\"\n  }, /*#__PURE__*/_react.default.createElement(\"div\", {\n    \"aria-hidden\": true,\n    className: \"webchat__basic-transcript__filler\",\n    onFocus: onFocusFiller\n  }), /*#__PURE__*/_react.default.createElement(\"section\", {\n    \"aria-roledescription\": transcriptRoleDescription,\n    className: (0, _classnames.default)(activitiesStyleSet + '', 'webchat__basic-transcript__transcript'),\n    role: \"feed\"\n  }, children), /*#__PURE__*/_react.default.createElement(_BasicTypingIndicator.default, null)));\n};\n\nInternalTranscriptScrollable.propTypes = {\n  children: _propTypes.default.any.isRequired,\n  onFocusFiller: _propTypes.default.func.isRequired,\n  terminatorRef: _propTypes.default.any.isRequired\n}; // \"scroller\" is the auto-scroll limiter, a.k.a. auto scroll snap.\n\nvar useScroller = function useScroller(activityElementMapRef) {\n  var _useActivityKeys = useActivityKeys(),\n      _useActivityKeys2 = _slicedToArray(_useActivityKeys, 1),\n      activityKeys = _useActivityKeys2[0];\n\n  var _useLastAcknowledgedA = useLastAcknowledgedActivityKey(),\n      _useLastAcknowledgedA2 = _slicedToArray(_useLastAcknowledgedA, 1),\n      lastAcknowledgedActivityKey = _useLastAcknowledgedA2[0];\n\n  var _useStyleOptions5 = useStyleOptions(),\n      _useStyleOptions6 = _slicedToArray(_useStyleOptions5, 1),\n      styleOptions = _useStyleOptions6[0];\n\n  var activityKeysRef = (0, _useValueRef.default)(activityKeys);\n  var lastAcknowledgedActivityKeyRef = (0, _useValueRef.default)(lastAcknowledgedActivityKey);\n  var styleOptionsRef = (0, _useValueRef.default)(styleOptions);\n  return (0, _react.useCallback)(function (_ref13) {\n    var offsetHeight = _ref13.offsetHeight,\n        scrollTop = _ref13.scrollTop;\n    var _styleOptionsRef$curr = styleOptionsRef.current,\n        autoScrollSnapOnActivity = _styleOptionsRef$curr.autoScrollSnapOnActivity,\n        autoScrollSnapOnActivityOffset = _styleOptionsRef$curr.autoScrollSnapOnActivityOffset,\n        autoScrollSnapOnPage = _styleOptionsRef$curr.autoScrollSnapOnPage,\n        autoScrollSnapOnPageOffset = _styleOptionsRef$curr.autoScrollSnapOnPageOffset;\n    var patchedAutoScrollSnapOnActivity = typeof autoScrollSnapOnActivity === 'number' ? Math.max(0, autoScrollSnapOnActivity) : autoScrollSnapOnActivity ? 1 : 0;\n    var patchedAutoScrollSnapOnPage = typeof autoScrollSnapOnPage === 'number' ? Math.max(0, Math.min(1, autoScrollSnapOnPage)) : autoScrollSnapOnPage ? 1 : 0;\n    var patchedAutoScrollSnapOnActivityOffset = typeof autoScrollSnapOnActivityOffset === 'number' ? autoScrollSnapOnActivityOffset : 0;\n    var patchedAutoScrollSnapOnPageOffset = typeof autoScrollSnapOnPageOffset === 'number' ? autoScrollSnapOnPageOffset : 0;\n\n    if (patchedAutoScrollSnapOnActivity || patchedAutoScrollSnapOnPage) {\n      var activityElementMap = activityElementMapRef.current;\n      var _activityKeys = activityKeysRef.current;\n      var _lastAcknowledgedActivityKey = lastAcknowledgedActivityKeyRef.current;\n      var values = [];\n\n      var lastAcknowledgedActivityKeyIndex = _activityKeys.indexOf(_lastAcknowledgedActivityKey);\n\n      if (~lastAcknowledgedActivityKeyIndex) {\n        // The activity that we acknowledged could be not rendered, such as post back activity.\n        // When calculating scroll snap, we can only base on the first unacknowledged-and-rendering activity.\n        var renderingActivityKeys = Array.from(activityElementMap.keys());\n        var firstUnacknowledgedActivityElementIndex = -1;\n\n        var _iterator = _createForOfIteratorHelper(_activityKeys.slice(0, lastAcknowledgedActivityKeyIndex + 1).reverse()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var acknowledgedActivityKey = _step.value;\n            var index = renderingActivityKeys.indexOf(acknowledgedActivityKey);\n\n            if (~index) {\n              if (index !== renderingActivityKeys.length - 1) {\n                firstUnacknowledgedActivityElementIndex = index + 1;\n              }\n\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        if (~firstUnacknowledgedActivityElementIndex) {\n          var activityElements = Array.from(activityElementMap.values());\n\n          if (patchedAutoScrollSnapOnActivity) {\n            // Gets the activity element which we should snap to.\n            var nthUnacknowledgedActivityElement = activityElements[firstUnacknowledgedActivityElementIndex + patchedAutoScrollSnapOnActivity - 1];\n\n            if (nthUnacknowledgedActivityElement) {\n              var nthUnacknowledgedActivityBoundingBoxElement = nthUnacknowledgedActivityElement === null || nthUnacknowledgedActivityElement === void 0 ? void 0 : nthUnacknowledgedActivityElement.querySelector('.webchat__basic-transcript__activity-active-descendant');\n              var nthUnacknowledgedActivityOffsetTop = nthUnacknowledgedActivityElement.offsetTop + nthUnacknowledgedActivityBoundingBoxElement.offsetTop;\n              values.push(nthUnacknowledgedActivityOffsetTop + nthUnacknowledgedActivityBoundingBoxElement.offsetHeight - offsetHeight - scrollTop + patchedAutoScrollSnapOnActivityOffset);\n            }\n          }\n\n          if (patchedAutoScrollSnapOnPage) {\n            var firstUnacknowledgedActivityElement = activityElements[+firstUnacknowledgedActivityElementIndex];\n            var firstUnacknowledgedActivityBoundingBoxElement = firstUnacknowledgedActivityElement.querySelector('.webchat__basic-transcript__activity-active-descendant');\n            var firstUnacknowledgedActivityOffsetTop = firstUnacknowledgedActivityElement.offsetTop + firstUnacknowledgedActivityBoundingBoxElement.offsetTop;\n            values.push(firstUnacknowledgedActivityOffsetTop - scrollTop - offsetHeight * (1 - patchedAutoScrollSnapOnPage) + patchedAutoScrollSnapOnPageOffset);\n          }\n        }\n      }\n\n      return Math.min.apply(Math, values);\n    }\n\n    return Infinity;\n  }, [activityElementMapRef, activityKeysRef, lastAcknowledgedActivityKeyRef, styleOptionsRef]);\n};\n\nvar BasicTranscript = function BasicTranscript(_ref14) {\n  var className = _ref14.className;\n  var activityElementMapRef = (0, _react.useRef)(new Map());\n  var containerRef = (0, _react.useRef)();\n  var scroller = useScroller(activityElementMapRef);\n  return /*#__PURE__*/_react.default.createElement(_TranscriptFocusComposer.default, {\n    containerRef: containerRef\n  }, /*#__PURE__*/_react.default.createElement(_reactScrollToBottom.Composer, {\n    scroller: scroller\n  }, /*#__PURE__*/_react.default.createElement(_KeyboardHelp.default, null), /*#__PURE__*/_react.default.createElement(InternalTranscript, {\n    activityElementMapRef: activityElementMapRef,\n    className: className,\n    ref: containerRef\n  })));\n};\n\nBasicTranscript.defaultProps = {\n  className: ''\n};\nBasicTranscript.propTypes = {\n  className: _propTypes.default.string\n};\nvar _default = BasicTranscript;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["useActivityKeys","hooks","useActivityKeysByRead","useCreateActivityStatusRenderer","useCreateAvatarRenderer","useCreateScrollToEndButtonRenderer","useDirection","useGetActivityByKey","useGetKeyByActivity","useGetKeyByActivityId","useLastAcknowledgedActivityKey","useLocalizer","useMarkActivityKeyAsRead","useMarkAllAsAcknowledged","useStyleOptions","ROOT_STYLE","display","flexDirection","overflow","position","flex","overflowX","WebkitOverflowScrolling","listStyleType","InternalTranscript","ref","activityElementMapRef","className","basicTranscriptStyleSet","basicTranscript","bubbleFromUserNubOffset","bubbleNubOffset","groupTimestamp","showAvatarInGroup","activeDescendantId","activityWithRendererTree","direction","focusedActivityKey","focusedExplicitly","createActivityStatusRenderer","createAvatarRenderer","focus","focusByActivityKey","focusRelativeActivity","getActivityByKey","getKeyByActivity","getKeyByActivityId","localize","rootClassName","rootElementRef","terminatorLabelId","terminatorRef","focusedActivityKeyRef","hideAllTimestamps","terminatorText","transcriptAriaLabel","callbackRef","element","current","renderingElements","topSideBotNub","topSideUserNub","forEach","entriesWithSameSender","firstActivity","activity","renderAvatar","entriesWithSameSenderAndStatus","indexWithinSenderGroup","firstInSenderGroup","lastInSenderGroup","length","indexWithinSenderAndStatusGroup","renderActivity","firstInSenderAndStatusGroup","key","lastInSenderAndStatusGroup","renderActivityStatus","nextVisibleActivity","undefined","topSideNub","from","role","showCallout","push","activityElement","set","delete","hideTimestamp","scrollToBottomScrollTo","scrollToBottomScrollToEnd","scrollTo","behavior","Error","activityId","activityID","scrollTop","activityBoundingBoxElement","get","_activityElementMapRe","querySelector","scrollableElement","activityBoundingBoxElementClientRect","getClientRects","scrollableElementClientRect","activityHeight","height","activityY","y","scrollableHeight","activityOffsetTop","Math","min","scrollToEnd","scrollRelative","displacement","rootElement","scrollable","nextScrollTop","offsetHeight","max","scrollHeight","markActivityKeyAsRead","dispatchScrollPositionWithActivityId","handleScrollPosition","scrollableClientBottom","bottom","activityElements","Array","entries","activityKeyJustAboveScrollBottom","reverse","find","elementClientRect","_ref6","id","handleTranscriptKeyDown","target","event","fromEndOfTranscriptIndicator","fromTranscript","currentTarget","handled","Infinity","body","_activityElementMapRe2","preventDefault","stopPropagation","handleTranscriptKeyDownCapture","altKey","ctrlKey","metaKey","dispatchTranscriptFocusByActivityKey","handleFocus","handleFocusFiller","_react","android","dir","onFocus","onKeyDown","onKeyDownCapture","tabIndex","_LiveRegionTranscript","InternalTranscriptScrollable","onFocusFiller","map","_ActivityRow","_FocusRedirector","redirectRef","defaultProps","propTypes","PropTypes","shape","instanceOf","Map","isRequired","string","children","activitiesStyleSet","activities","animatingToEnd","atEnd","unreadActivityKeys","sticky","styleOptions","markAllAsAcknowledged","prevSticky","transcriptRoleDescription","stickyChangedToTrue","flat","flattenedActivityTreeWithRenderer","renderingActivityKeys","renderingActivityKeysRef","nextUnreadActivityKeys","nextUnreadActivityKeysRef","unread","some","includes","handleScrollToEndButtonClick","firstUnreadRenderingActivityKey","renderScrollToEndButton","Fragment","onClick","React","Children","count","_reactScrollToBottom","_BasicTypingIndicator","any","func","useScroller","activityKeys","lastAcknowledgedActivityKey","activityKeysRef","lastAcknowledgedActivityKeyRef","styleOptionsRef","autoScrollSnapOnActivity","autoScrollSnapOnActivityOffset","autoScrollSnapOnPage","autoScrollSnapOnPageOffset","patchedAutoScrollSnapOnActivity","patchedAutoScrollSnapOnPage","patchedAutoScrollSnapOnActivityOffset","patchedAutoScrollSnapOnPageOffset","activityElementMap","values","lastAcknowledgedActivityKeyIndex","indexOf","keys","firstUnacknowledgedActivityElementIndex","slice","acknowledgedActivityKey","index","_iterator","nthUnacknowledgedActivityElement","nthUnacknowledgedActivityBoundingBoxElement","nthUnacknowledgedActivityOffsetTop","offsetTop","firstUnacknowledgedActivityElement","firstUnacknowledgedActivityBoundingBoxElement","firstUnacknowledgedActivityOffsetTop","BasicTranscript","containerRef","scroller","_TranscriptFocusComposer","_KeyboardHelp"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-component/lib/src/BasicTranscript.tsx"],"sourcesContent":["import { hooks } from 'botframework-webchat-api';\nimport {\n  Composer as ReactScrollToBottomComposer,\n  Panel as ReactScrollToBottomPanel,\n  useAnimatingToEnd,\n  useAtEnd,\n  useObserveScrollPosition,\n  useScrollTo,\n  useScrollToEnd,\n  useSticky\n} from 'react-scroll-to-bottom';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport React, { forwardRef, Fragment, useCallback, useMemo, useRef } from 'react';\n\nimport type { ActivityComponentFactory, AvatarComponentFactory } from 'botframework-webchat-api';\nimport type { ActivityElementMap } from './Transcript/types';\nimport type { DirectLineActivity } from 'botframework-webchat-core';\nimport type { FC, KeyboardEventHandler, MutableRefObject, ReactNode, VFC } from 'react';\n\nimport { android } from './Utils/detectBrowser';\nimport ActivityRow from './Transcript/ActivityRow';\nimport BasicTypingIndicator from './BasicTypingIndicator';\nimport FocusRedirector from './Utils/FocusRedirector';\nimport inputtableKey from './Utils/TypeFocusSink/inputtableKey';\nimport isZeroOrPositive from './Utils/isZeroOrPositive';\nimport KeyboardHelp from './Transcript/KeyboardHelp';\nimport LiveRegionTranscript from './Transcript/LiveRegionTranscript';\n// TODO: [P2] #4133 Rename to \"getTabbableElements\".\nimport tabbableElements from './Utils/tabbableElements';\nimport TranscriptFocusComposer from './providers/TranscriptFocus/TranscriptFocusComposer';\nimport useActiveDescendantId from './providers/TranscriptFocus/useActiveDescendantId';\nimport useActivityTreeWithRenderer from './providers/ActivityTree/useActivityTreeWithRenderer';\nimport useDispatchScrollPosition from './hooks/internal/useDispatchScrollPosition';\nimport useDispatchTranscriptFocusByActivityKey from './hooks/internal/useDispatchTranscriptFocusByActivityKey';\nimport useFocus from './hooks/useFocus';\nimport useFocusByActivityKey from './providers/TranscriptFocus/useFocusByActivityKey';\nimport useFocusedActivityKey from './providers/TranscriptFocus/useFocusedActivityKey';\nimport useFocusedExplicitly from './providers/TranscriptFocus/useFocusedExplicitly';\nimport useFocusRelativeActivity from './providers/TranscriptFocus/useFocusRelativeActivity';\nimport useObserveFocusVisible from './hooks/internal/useObserveFocusVisible';\nimport usePrevious from './hooks/internal/usePrevious';\nimport useRegisterFocusTranscript from './hooks/internal/useRegisterFocusTranscript';\nimport useRegisterScrollRelative from './hooks/internal/useRegisterScrollRelative';\nimport useRegisterScrollTo from './hooks/internal/useRegisterScrollTo';\nimport useRegisterScrollToEnd from './hooks/internal/useRegisterScrollToEnd';\nimport useStyleSet from './hooks/useStyleSet';\nimport useStyleToEmotionObject from './hooks/internal/useStyleToEmotionObject';\nimport useUniqueId from './hooks/internal/useUniqueId';\nimport useValueRef from './hooks/internal/useValueRef';\n\nconst {\n  useActivityKeys,\n  useActivityKeysByRead,\n  useCreateActivityStatusRenderer,\n  useCreateAvatarRenderer,\n  useCreateScrollToEndButtonRenderer,\n  useDirection,\n  useGetActivityByKey,\n  useGetKeyByActivity,\n  useGetKeyByActivityId,\n  useLastAcknowledgedActivityKey,\n  useLocalizer,\n  useMarkActivityKeyAsRead,\n  useMarkAllAsAcknowledged,\n  useStyleOptions\n} = hooks;\n\nconst ROOT_STYLE = {\n  '&.webchat__basic-transcript': {\n    display: 'flex',\n    flexDirection: 'column',\n    overflow: 'hidden',\n    // Make sure to set \"position: relative\" here to form another stacking context for the scroll-to-end button.\n    // Stacking context help isolating elements that use \"z-index\" from global pollution.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n    position: 'relative',\n\n    '& .webchat__basic-transcript__filler': {\n      flex: 1\n    },\n\n    '& .webchat__basic-transcript__scrollable': {\n      display: 'flex',\n      flexDirection: 'column',\n      overflowX: 'hidden',\n      WebkitOverflowScrolling: 'touch'\n    },\n\n    '& .webchat__basic-transcript__transcript': {\n      listStyleType: 'none'\n    }\n  }\n};\n\ntype RenderingElement = {\n  activity: DirectLineActivity & {\n    channelData?: {\n      ['webchat:fallback-text']: string;\n    };\n  };\n  callbackRef: (element: HTMLElement) => void;\n  hideTimestamp: boolean;\n  key: string;\n  renderActivity: Exclude<ReturnType<ActivityComponentFactory>, false>;\n  renderActivityStatus: (props: { hideTimestamp?: boolean }) => ReactNode;\n  renderAvatar: AvatarComponentFactory;\n  showCallout: boolean;\n};\n\ntype ScrollBehavior = 'auto' | 'smooth';\ntype ScrollToOptions = { behavior?: ScrollBehavior };\ntype ScrollToPosition = { activityID?: string; scrollTop?: number };\n\ntype InternalTranscriptProps = {\n  activityElementMapRef: MutableRefObject<ActivityElementMap>;\n  className?: string;\n};\n\n// TODO: [P1] #4133 Add telemetry for computing how many re-render done so far.\nconst InternalTranscript = forwardRef<HTMLDivElement, InternalTranscriptProps>(\n  ({ activityElementMapRef, className }, ref) => {\n    const [{ basicTranscript: basicTranscriptStyleSet }] = useStyleSet();\n    const [{ bubbleFromUserNubOffset, bubbleNubOffset, groupTimestamp, showAvatarInGroup }] = useStyleOptions();\n    const [activeDescendantId] = useActiveDescendantId();\n    const [activityWithRendererTree] = useActivityTreeWithRenderer();\n    const [direction] = useDirection();\n    const [focusedActivityKey] = useFocusedActivityKey();\n    const [focusedExplicitly] = useFocusedExplicitly();\n    const createActivityStatusRenderer = useCreateActivityStatusRenderer();\n    const createAvatarRenderer = useCreateAvatarRenderer();\n    const focus = useFocus();\n    const focusByActivityKey = useFocusByActivityKey();\n    const focusRelativeActivity = useFocusRelativeActivity();\n    const getActivityByKey = useGetActivityByKey();\n    const getKeyByActivity = useGetKeyByActivity();\n    const getKeyByActivityId = useGetKeyByActivityId();\n    const localize = useLocalizer();\n    const rootClassName = useStyleToEmotionObject()(ROOT_STYLE) + '';\n    const rootElementRef = useRef<HTMLDivElement>();\n    const terminatorLabelId = useUniqueId('webchat__basic-transcript__terminator-label');\n    const terminatorRef = useRef<HTMLDivElement>();\n\n    const focusedActivityKeyRef = useValueRef(focusedActivityKey);\n    const hideAllTimestamps = groupTimestamp === false;\n    const terminatorText = localize('TRANSCRIPT_TERMINATOR_TEXT');\n    const transcriptAriaLabel = localize('TRANSCRIPT_ARIA_LABEL_ALT');\n\n    const callbackRef = useCallback(\n      (element: HTMLDivElement) => {\n        if (typeof ref === 'function') {\n          ref(element);\n        } else {\n          ref.current = element;\n        }\n\n        rootElementRef.current = element;\n      },\n      [ref, rootElementRef]\n    );\n\n    // Flatten the tree back into an array with information related to rendering.\n    const renderingElements = useMemo(() => {\n      const renderingElements: RenderingElement[] = [];\n      const topSideBotNub = isZeroOrPositive(bubbleNubOffset);\n      const topSideUserNub = isZeroOrPositive(bubbleFromUserNubOffset);\n\n      activityWithRendererTree.forEach(entriesWithSameSender => {\n        const [[{ activity: firstActivity }]] = entriesWithSameSender;\n        const renderAvatar = createAvatarRenderer({ activity: firstActivity });\n\n        entriesWithSameSender.forEach((entriesWithSameSenderAndStatus, indexWithinSenderGroup) => {\n          const firstInSenderGroup = !indexWithinSenderGroup;\n          const lastInSenderGroup = indexWithinSenderGroup === entriesWithSameSender.length - 1;\n\n          entriesWithSameSenderAndStatus.forEach(({ activity, renderActivity }, indexWithinSenderAndStatusGroup) => {\n            // We only show the timestamp at the end of the sender group. But we always show the \"Send failed, retry\" prompt.\n            const firstInSenderAndStatusGroup = !indexWithinSenderAndStatusGroup;\n            const key: string = getKeyByActivity(activity);\n            const lastInSenderAndStatusGroup =\n              indexWithinSenderAndStatusGroup === entriesWithSameSenderAndStatus.length - 1;\n            const renderActivityStatus = createActivityStatusRenderer({\n              activity,\n              nextVisibleActivity: undefined\n            });\n            const topSideNub = activity.from?.role === 'user' ? topSideUserNub : topSideBotNub;\n\n            let showCallout: boolean;\n\n            // Depending on the \"showAvatarInGroup\" setting, the avatar will render in different positions.\n            if (showAvatarInGroup === 'sender') {\n              if (topSideNub) {\n                showCallout = firstInSenderGroup && firstInSenderAndStatusGroup;\n              } else {\n                showCallout = lastInSenderGroup && lastInSenderAndStatusGroup;\n              }\n            } else if (showAvatarInGroup === 'status') {\n              if (topSideNub) {\n                showCallout = firstInSenderAndStatusGroup;\n              } else {\n                showCallout = lastInSenderAndStatusGroup;\n              }\n            } else {\n              showCallout = true;\n            }\n\n            renderingElements.push({\n              activity,\n\n              // After the element is mounted, set it to activityElementsRef.\n              callbackRef: activityElement => {\n                activityElement\n                  ? activityElementMapRef.current.set(key, activityElement)\n                  : activityElementMapRef.current.delete(key);\n              },\n\n              // \"hideTimestamp\" is a render-time parameter for renderActivityStatus().\n              // If true, it will hide the timestamp, but it will continue to show the\n              // retry prompt. And show the screen reader version of the timestamp.\n              hideTimestamp:\n                hideAllTimestamps || indexWithinSenderAndStatusGroup !== entriesWithSameSenderAndStatus.length - 1,\n              key,\n              renderActivity,\n              renderActivityStatus,\n              renderAvatar,\n              showCallout\n            });\n          });\n        });\n      });\n\n      return renderingElements;\n    }, [\n      activityElementMapRef,\n      activityWithRendererTree,\n      bubbleFromUserNubOffset,\n      bubbleNubOffset,\n      createActivityStatusRenderer,\n      createAvatarRenderer,\n      getKeyByActivity,\n      hideAllTimestamps,\n      showAvatarInGroup\n    ]);\n\n    const scrollToBottomScrollTo: (scrollTop: number, options?: ScrollToOptions) => void = useScrollTo();\n    const scrollToBottomScrollToEnd: (options?: ScrollToOptions) => void = useScrollToEnd();\n\n    const scrollTo = useCallback(\n      (position: ScrollToPosition, { behavior = 'auto' }: ScrollToOptions = {}) => {\n        if (!position) {\n          throw new Error(\n            'botframework-webchat: First argument passed to \"useScrollTo\" must be a ScrollPosition object.'\n          );\n        }\n\n        const { activityID: activityId, scrollTop } = position;\n\n        if (typeof scrollTop !== 'undefined') {\n          scrollToBottomScrollTo(scrollTop, { behavior });\n        } else if (typeof activityId !== 'undefined') {\n          const activityBoundingBoxElement = activityElementMapRef.current\n            .get(getKeyByActivityId(activityId))\n            ?.querySelector('.webchat__basic-transcript__activity-active-descendant');\n\n          const scrollableElement = rootElementRef.current.querySelector('.webchat__basic-transcript__scrollable');\n\n          if (scrollableElement && activityBoundingBoxElement) {\n            // ESLint conflict with TypeScript. The result of getClientRects() is not an Array but DOMRectList, and cannot be destructured.\n            // eslint-disable-next-line prefer-destructuring\n            const activityBoundingBoxElementClientRect = activityBoundingBoxElement.getClientRects()[0];\n\n            // ESLint conflict with TypeScript. The result of getClientRects() is not an Array but DOMRectList, and cannot be destructured.\n            // eslint-disable-next-line prefer-destructuring\n            const scrollableElementClientRect = scrollableElement.getClientRects()[0];\n\n            // If either the activity or the transcript scrollable is not on DOM, we will not scroll the view.\n            if (activityBoundingBoxElementClientRect && scrollableElementClientRect) {\n              const { height: activityHeight, y: activityY } = activityBoundingBoxElementClientRect;\n              const { height: scrollableHeight } = scrollableElementClientRect;\n              const activityOffsetTop = activityY + scrollableElement.scrollTop;\n\n              const scrollTop = Math.min(activityOffsetTop, activityOffsetTop - scrollableHeight + activityHeight);\n\n              scrollToBottomScrollTo(scrollTop, { behavior });\n            }\n          }\n        }\n      },\n      [activityElementMapRef, getKeyByActivityId, rootElementRef, scrollToBottomScrollTo]\n    );\n\n    const scrollToEnd = useCallback(\n      () => scrollToBottomScrollToEnd({ behavior: 'smooth' }),\n      [scrollToBottomScrollToEnd]\n    );\n\n    const scrollRelative = useCallback(\n      (direction: 'down' | 'up', { displacement }: { displacement?: number } = {}) => {\n        const { current: rootElement } = rootElementRef;\n\n        if (!rootElement) {\n          return;\n        }\n\n        const scrollable: HTMLElement = rootElement.querySelector('.webchat__basic-transcript__scrollable');\n        let nextScrollTop: number;\n\n        if (typeof displacement === 'number') {\n          // eslint-disable-next-line no-magic-numbers\n          nextScrollTop = scrollable.scrollTop + (direction === 'down' ? 1 : -1) * displacement;\n        } else {\n          // eslint-disable-next-line no-magic-numbers\n          nextScrollTop = scrollable.scrollTop + (direction === 'down' ? 1 : -1) * scrollable.offsetHeight;\n        }\n\n        scrollTo(\n          {\n            scrollTop: Math.max(0, Math.min(scrollable.scrollHeight - scrollable.offsetHeight, nextScrollTop))\n          },\n          { behavior: 'smooth' }\n        );\n      },\n      [rootElementRef, scrollTo]\n    );\n\n    // Since there could be multiple instances of <BasicTranscript> inside the <Composer>, when the developer calls `scrollXXX`, we need to call it on all instances.\n    // We call `useRegisterScrollXXX` to register a callback function, the `useScrollXXX` will multiplex the call into each instance of <BasicTranscript>.\n    useRegisterScrollTo(scrollTo);\n    useRegisterScrollToEnd(scrollToEnd);\n    useRegisterScrollRelative(scrollRelative);\n\n    const markActivityKeyAsRead = useMarkActivityKeyAsRead();\n\n    const dispatchScrollPositionWithActivityId: (scrollPosition: ScrollToPosition) => void =\n      useDispatchScrollPosition();\n\n    // TODO: [P2] We should use IntersectionObserver to track what activity is in the scrollable.\n    //            However, IntersectionObserver is not available on IE11, we need to make a limited polyfill in React style.\n    const handleScrollPosition = useCallback(\n      ({ scrollTop }: { scrollTop: number }) => {\n        const { current: rootElement } = rootElementRef;\n\n        if (!rootElement) {\n          return;\n        }\n\n        const scrollableElement = rootElement.querySelector('.webchat__basic-transcript__scrollable');\n\n        // \"getClientRects()\" is not returning an array, thus, it is not destructurable.\n        // eslint-disable-next-line prefer-destructuring\n        const scrollableElementClientRect = scrollableElement.getClientRects()[0];\n\n        // If the scrollable is not mounted, we cannot measure which activity is in view. Thus, we will not fire any events.\n        if (!scrollableElementClientRect) {\n          return;\n        }\n\n        const { bottom: scrollableClientBottom } = scrollableElementClientRect;\n\n        // Find the activity just above scroll view bottom.\n        // If the scroll view is already on top, get the first activity.\n        const activityElements = Array.from(activityElementMapRef.current.entries());\n        const activityKeyJustAboveScrollBottom: string | undefined = (\n          scrollableElement.scrollTop\n            ? activityElements\n                .reverse()\n                // Add subpixel tolerance\n                .find(([, element]) => {\n                  // \"getClientRects()\" is not returning an array, thus, it is not destructurable.\n                  // eslint-disable-next-line prefer-destructuring\n                  const elementClientRect = element.getClientRects()[0];\n\n                  // If the activity is not attached to DOM tree, we should not count it as \"bottommost visible activity\", as it is not visible.\n                  return elementClientRect && elementClientRect.bottom < scrollableClientBottom + 1;\n                })\n            : activityElements[0]\n        )?.[0];\n\n        // When the end-user slowly scrolling the view down, we will mark activity as read when the message fully appear on the screen.\n        activityKeyJustAboveScrollBottom && markActivityKeyAsRead(activityKeyJustAboveScrollBottom);\n\n        if (dispatchScrollPositionWithActivityId) {\n          const activity = getActivityByKey(activityKeyJustAboveScrollBottom);\n\n          dispatchScrollPositionWithActivityId({ ...(activity ? { activityID: activity.id } : {}), scrollTop });\n        }\n      },\n      [\n        activityElementMapRef,\n        dispatchScrollPositionWithActivityId,\n        getActivityByKey,\n        markActivityKeyAsRead,\n        rootElementRef\n      ]\n    );\n\n    useObserveScrollPosition(handleScrollPosition);\n\n    const handleTranscriptKeyDown = useCallback<KeyboardEventHandler<HTMLDivElement>>(\n      event => {\n        const { target } = event;\n\n        const fromEndOfTranscriptIndicator = target === terminatorRef.current;\n        const fromTranscript = target === event.currentTarget;\n\n        if (!fromEndOfTranscriptIndicator && !fromTranscript) {\n          return;\n        }\n\n        let handled = true;\n\n        switch (event.key) {\n          case 'ArrowDown':\n            focusRelativeActivity(fromEndOfTranscriptIndicator ? 0 : 1);\n            break;\n\n          case 'ArrowUp':\n            // eslint-disable-next-line no-magic-numbers\n            focusRelativeActivity(fromEndOfTranscriptIndicator ? 0 : -1);\n            break;\n\n          case 'End':\n            focusRelativeActivity(Infinity);\n            break;\n\n          case 'Enter':\n            // This is capturing plain ENTER.\n            // When screen reader is not running, or screen reader is running outside of scan mode, the ENTER key will be captured here.\n            if (!fromEndOfTranscriptIndicator) {\n              const body: HTMLElement = activityElementMapRef.current\n                .get(focusedActivityKeyRef.current)\n                ?.querySelector('.webchat__basic-transcript__activity-body');\n\n              tabbableElements(body)[0]?.focus();\n            }\n\n            break;\n\n          case 'Escape':\n            focus('sendBoxWithoutKeyboard');\n            break;\n\n          case 'Home':\n            focusRelativeActivity(-Infinity);\n            break;\n\n          default:\n            handled = false;\n            break;\n        }\n\n        if (handled) {\n          event.preventDefault();\n\n          // If a custom HTML control wants to handle up/down arrow, we will prevent them from listening to this event to prevent bugs due to handling arrow keys twice.\n          event.stopPropagation();\n        }\n      },\n      [activityElementMapRef, focus, focusedActivityKeyRef, focusRelativeActivity, terminatorRef]\n    );\n\n    const handleTranscriptKeyDownCapture = useCallback<KeyboardEventHandler<HTMLDivElement>>(\n      event => {\n        const { altKey, ctrlKey, key, metaKey, target } = event;\n\n        if (altKey || (ctrlKey && key !== 'v') || metaKey || (!inputtableKey(key) && key !== 'Backspace')) {\n          // Ignore if one of the utility key (except SHIFT) is pressed\n          // E.g. CTRL-C on a link in one of the message should not jump to chat box\n          // E.g. \"A\" or \"Backspace\" should jump to chat box\n          return;\n        }\n\n        // Send keystrokes to send box if we are focusing on the transcript or terminator.\n        if (target === event.currentTarget || target === terminatorRef.current) {\n          event.stopPropagation();\n\n          focus('sendBox');\n        }\n      },\n      [focus]\n    );\n\n    useRegisterFocusTranscript(useCallback(() => focusByActivityKey(undefined), [focusByActivityKey]));\n\n    // When the focusing activity has changed, dispatch an event to observers of \"useObserveTranscriptFocus\".\n    const dispatchTranscriptFocusByActivityKey = useDispatchTranscriptFocusByActivityKey();\n\n    // Dispatch a \"transcript focus\" event based on user selection.\n    // We should not dispatch \"transcript focus\" when a new activity come. Although the selection change, it is not initiated from the user.\n    useMemo(\n      () => dispatchTranscriptFocusByActivityKey(focusedExplicitly ? focusedActivityKey : undefined),\n      [dispatchTranscriptFocusByActivityKey, focusedActivityKey, focusedExplicitly]\n    );\n\n    // When the transcript is being focused on, we should dispatch a \"transcriptfocus\" event.\n    const handleFocus = useCallback(\n      // We call \"focusByActivityKey\" with activity key of \"true\".\n      // It means, tries to focus on anything.\n      ({ currentTarget, target }) => target === currentTarget && focusByActivityKey(true, false),\n      [focusByActivityKey]\n    );\n\n    // This is required by IE11.\n    // When the user clicks on and empty space (a.k.a. filler) in an empty transcript, IE11 says the focus is on the <div className=\"filler\">,\n    // despite the fact there are no \"tabIndex\" attributes set on the filler.\n    // We need to artificially send the focus back to the transcript.\n    const handleFocusFiller = useCallback(() => focusByActivityKey(undefined), [focusByActivityKey]);\n\n    // When focus into the transcript using TAB/SHIFT-TAB, scroll the focused activity into view.\n    useObserveFocusVisible(\n      rootElementRef,\n      useCallback(() => focusByActivityKey(undefined), [focusByActivityKey])\n    );\n\n    return (\n      <div\n        // Although Android TalkBack 12.1 does not support `aria-activedescendant`, when used, it become buggy and will narrate content twice.\n        // We are disabling `aria-activedescendant` for Android. See <ActivityRow> for details.\n        aria-activedescendant={android ? undefined : activeDescendantId}\n        aria-label={transcriptAriaLabel}\n        className={classNames(\n          'webchat__basic-transcript',\n          basicTranscriptStyleSet + '',\n          rootClassName,\n          (className || '') + ''\n        )}\n        dir={direction}\n        onFocus={handleFocus}\n        onKeyDown={handleTranscriptKeyDown}\n        onKeyDownCapture={handleTranscriptKeyDownCapture}\n        ref={callbackRef}\n        // \"aria-activedescendant\" will only works with a number of roles and it must be explicitly set.\n        // https://www.w3.org/TR/wai-aria/#aria-activedescendant\n        role=\"group\"\n        // For up/down arrow key navigation across activities, this component must be included in the tab sequence.\n        // Otherwise, \"aria-activedescendant\" will not be narrated when the user press up/down arrow keys.\n        // https://www.w3.org/TR/wai-aria-practices-1.1/#kbd_focus_activedescendant\n        tabIndex={0}\n      >\n        <LiveRegionTranscript activityElementMapRef={activityElementMapRef} />\n        {/* TODO: [P2] Fix ESLint error `no-use-before-define` */}\n        {/* eslint-disable-next-line @typescript-eslint/no-use-before-define */}\n        <InternalTranscriptScrollable onFocusFiller={handleFocusFiller} terminatorRef={terminatorRef}>\n          {renderingElements.map(\n            ({\n              activity,\n              callbackRef,\n              hideTimestamp,\n              key,\n              renderActivity,\n              renderActivityStatus,\n              renderAvatar,\n              showCallout\n            }) => (\n              <ActivityRow activity={activity} key={key} ref={callbackRef}>\n                {renderActivity({\n                  hideTimestamp,\n                  renderActivityStatus,\n                  renderAvatar,\n                  showCallout\n                })}\n              </ActivityRow>\n            )\n          )}\n        </InternalTranscriptScrollable>\n        {!!renderingElements.length && (\n          <Fragment>\n            <FocusRedirector redirectRef={rootElementRef} />\n            <div\n              aria-hidden={true}\n              aria-labelledby={terminatorLabelId}\n              className=\"webchat__basic-transcript__terminator\"\n              ref={terminatorRef}\n              role=\"note\"\n              tabIndex={0}\n            >\n              <div className=\"webchat__basic-transcript__terminator-body\">\n                {/* `id` is required for `aria-labelledby` */}\n                {/* eslint-disable-next-line react/forbid-dom-props */}\n                <div className=\"webchat__basic-transcript__terminator-text\" id={terminatorLabelId}>\n                  {terminatorText}\n                </div>\n              </div>\n            </div>\n          </Fragment>\n        )}\n        <div className=\"webchat__basic-transcript__focus-indicator\" />\n      </div>\n    );\n  }\n);\n\nInternalTranscript.defaultProps = {\n  className: ''\n};\n\nInternalTranscript.propTypes = {\n  // PropTypes cannot validate precisely with its TypeScript counterpart.\n  // @ts-ignore\n  activityElementMapRef: PropTypes.shape({\n    current: PropTypes.instanceOf(Map)\n  }).isRequired,\n  className: PropTypes.string\n};\n\ntype InternalTranscriptScrollableProps = {\n  children?: ReactNode;\n  onFocusFiller: () => void;\n  terminatorRef: MutableRefObject<HTMLDivElement>;\n};\n\n// Separating high-frequency hooks to improve performance.\nconst InternalTranscriptScrollable: FC<InternalTranscriptScrollableProps> = ({\n  children,\n  onFocusFiller,\n  terminatorRef\n}) => {\n  const [{ activities: activitiesStyleSet }] = useStyleSet();\n  const [animatingToEnd]: [boolean] = useAnimatingToEnd();\n  const [atEnd]: [boolean] = useAtEnd();\n  const [, unreadActivityKeys] = useActivityKeysByRead();\n  const [sticky]: [boolean] = useSticky();\n  const [styleOptions] = useStyleOptions();\n  const focusByActivityKey = useFocusByActivityKey();\n  const localize = useLocalizer();\n  const markActivityKeyAsRead = useMarkActivityKeyAsRead();\n  const markAllAsAcknowledged = useMarkAllAsAcknowledged();\n  const scrollToEnd: (options?: ScrollToOptions) => void = useScrollToEnd();\n\n  const prevSticky = usePrevious(sticky);\n  const transcriptRoleDescription = localize('TRANSCRIPT_ARIA_ROLE_ALT');\n\n  const stickyChangedToTrue = prevSticky !== sticky && sticky;\n\n  // Acknowledged means either:\n  // 1. The user sent a message\n  //    - We don't need a condition here. When Web Chat sends the user's message, it will scroll to bottom, and it will trigger condition 2 below.\n  // 2. The user scroll to the bottom of the transcript, from a non-bottom scroll position\n  //    - If the transcript is already at the bottom, the user needs to scroll up and then go back down\n  //    - What happens if we are relaxing \"scrolled from a non-bottom scroll position\":\n  //      1. The condition will become solely \"at the bottom of the transcript\"\n  //      2. Auto-scroll will always scroll the transcript to the bottom\n  //      3. Web Chat will always acknowledge all activities as it is at the bottom\n  //      4. Acknowledge flag become useless\n  //      5. Therefore, even the developer set \"pause after 3 activities\", if activities are coming in at a slow pace (not batched in a single render)\n  //         Web Chat will keep scrolling and not snapped/paused\n\n  // Note: When Web Chat is loaded, there are no activities acknowledged. We need to assume all arriving activities are acknowledged until end-user sends their first activity.\n  //       Activities loaded initially could be from conversation history. Without assuming acknowledgement, Web Chat will not scroll initially (as everything is not acknowledged).\n  //       It would be better if the chat adapter should let Web Chat know if the activity is loaded from history or not.\n\n  // TODO: [P2] #3670 Move the \"conversation history acknowledgement\" logic mentioned above to polyfill of chat adapters.\n  //       1. Chat adapter should send \"acknowledged\" as part of \"channelData\"\n  //       2. If \"acknowledged\" is \"undefined\", we set it to:\n  //          a. true, if there are no egress activities yet\n  //          b. Otherwise, false\n\n  useMemo(\n    () =>\n      stickyChangedToTrue &&\n      // TODO: [P2] Both `markActivityKeyAsRead` and `markAllAsAcknowledged` hook are setters of useState.\n      //       This means, in a render loop, we will be calling setter and will cause another re-render.\n      //       This is not trivial but we should think if there is a way to avoid this.\n      markAllAsAcknowledged(),\n    [markAllAsAcknowledged, stickyChangedToTrue]\n  );\n\n  const [flattenedActivityTreeWithRenderer] = useActivityTreeWithRenderer({ flat: true });\n  const getKeyByActivity = useGetKeyByActivity();\n\n  const renderingActivityKeys: string[] = useMemo<string[]>(\n    () => flattenedActivityTreeWithRenderer.map(({ activity }) => getKeyByActivity(activity)),\n    [flattenedActivityTreeWithRenderer, getKeyByActivity]\n  );\n\n  const renderingActivityKeysRef = useValueRef(renderingActivityKeys);\n\n  // To prevent flashy button, we are not waiting for another render loop to update the `[readActivityKeys, unreadActivityKeys]` state.\n  // Instead, we are building the next one in this `useMemo` call.\n  const nextUnreadActivityKeys = useMemo(() => {\n    // This code need to be careful reviewed as it will cause another render. The code should be converging.\n    // After we call `markActivityKeyAsRead`, everything will be read and nothing will be unread.\n    // That means, in next render, `unreadActivityKeys` will be emptied and the `markActivityKeyAsRead` will not get called again.\n    if (sticky && unreadActivityKeys.length) {\n      markActivityKeyAsRead(unreadActivityKeys[unreadActivityKeys.length - 1]);\n\n      return [];\n    }\n\n    return unreadActivityKeys;\n  }, [markActivityKeyAsRead, sticky, unreadActivityKeys]);\n\n  const nextUnreadActivityKeysRef = useValueRef(nextUnreadActivityKeys);\n\n  // If we are rendering anything that is unread, we should show the \"New messages\" button.\n  // Not everything in the `unreadActivityKeys` are rendered, say, bot typing indicator.\n  // We should not show the \"New messages\" button for bot typing indicator as it will confuse the user.\n  const unread = useMemo(\n    () => nextUnreadActivityKeys.some(key => renderingActivityKeys.includes(key)),\n    [renderingActivityKeys, nextUnreadActivityKeys]\n  );\n\n  const handleScrollToEndButtonClick = useCallback(() => {\n    scrollToEnd({ behavior: 'smooth' });\n\n    const { current: renderingActivityKeys } = renderingActivityKeysRef;\n\n    // After the \"New message\" button is clicked, focus on the first unread activity which will be rendered.\n    const firstUnreadRenderingActivityKey = nextUnreadActivityKeysRef.current.find(key =>\n      renderingActivityKeys.includes(key)\n    );\n\n    if (firstUnreadRenderingActivityKey) {\n      focusByActivityKey(firstUnreadRenderingActivityKey);\n    } else {\n      // If no unread activity, send the focus to the terminator block.\n      terminatorRef.current?.focus();\n    }\n  }, [focusByActivityKey, nextUnreadActivityKeysRef, renderingActivityKeysRef, scrollToEnd, terminatorRef]);\n\n  const renderScrollToEndButton = useCreateScrollToEndButtonRenderer()({\n    atEnd: animatingToEnd || atEnd || sticky,\n    styleOptions,\n    unread\n  });\n\n  return (\n    <React.Fragment>\n      {renderScrollToEndButton && renderScrollToEndButton({ onClick: handleScrollToEndButtonClick })}\n      {!!React.Children.count(children) && <FocusRedirector redirectRef={terminatorRef} />}\n      <ReactScrollToBottomPanel className=\"webchat__basic-transcript__scrollable\">\n        <div aria-hidden={true} className=\"webchat__basic-transcript__filler\" onFocus={onFocusFiller} />\n        <section\n          aria-roledescription={transcriptRoleDescription}\n          className={classNames(activitiesStyleSet + '', 'webchat__basic-transcript__transcript')}\n          role=\"feed\"\n        >\n          {children}\n        </section>\n        <BasicTypingIndicator />\n      </ReactScrollToBottomPanel>\n    </React.Fragment>\n  );\n};\n\nInternalTranscriptScrollable.propTypes = {\n  children: PropTypes.any.isRequired,\n  onFocusFiller: PropTypes.func.isRequired,\n  terminatorRef: PropTypes.any.isRequired\n};\n\ntype Scroller = ({ offsetHeight, scrollTop }: { offsetHeight: number; scrollTop: number }) => number;\n\n// \"scroller\" is the auto-scroll limiter, a.k.a. auto scroll snap.\nconst useScroller = (activityElementMapRef: MutableRefObject<ActivityElementMap>): Scroller => {\n  const [activityKeys] = useActivityKeys();\n  const [lastAcknowledgedActivityKey] = useLastAcknowledgedActivityKey();\n  const [styleOptions] = useStyleOptions();\n\n  const activityKeysRef = useValueRef(activityKeys);\n  const lastAcknowledgedActivityKeyRef = useValueRef(lastAcknowledgedActivityKey);\n  const styleOptionsRef = useValueRef(styleOptions);\n\n  return useCallback(\n    ({ offsetHeight, scrollTop }) => {\n      const {\n        current: {\n          autoScrollSnapOnActivity,\n          autoScrollSnapOnActivityOffset,\n          autoScrollSnapOnPage,\n          autoScrollSnapOnPageOffset\n        }\n      } = styleOptionsRef;\n\n      const patchedAutoScrollSnapOnActivity =\n        typeof autoScrollSnapOnActivity === 'number'\n          ? Math.max(0, autoScrollSnapOnActivity)\n          : autoScrollSnapOnActivity\n          ? 1\n          : 0;\n      const patchedAutoScrollSnapOnPage =\n        typeof autoScrollSnapOnPage === 'number'\n          ? Math.max(0, Math.min(1, autoScrollSnapOnPage))\n          : autoScrollSnapOnPage\n          ? 1\n          : 0;\n      const patchedAutoScrollSnapOnActivityOffset =\n        typeof autoScrollSnapOnActivityOffset === 'number' ? autoScrollSnapOnActivityOffset : 0;\n      const patchedAutoScrollSnapOnPageOffset =\n        typeof autoScrollSnapOnPageOffset === 'number' ? autoScrollSnapOnPageOffset : 0;\n\n      if (patchedAutoScrollSnapOnActivity || patchedAutoScrollSnapOnPage) {\n        const { current: activityElementMap } = activityElementMapRef;\n        const { current: activityKeys } = activityKeysRef;\n        const { current: lastAcknowledgedActivityKey } = lastAcknowledgedActivityKeyRef;\n        const values: number[] = [];\n\n        const lastAcknowledgedActivityKeyIndex = activityKeys.indexOf(lastAcknowledgedActivityKey);\n\n        if (~lastAcknowledgedActivityKeyIndex) {\n          // The activity that we acknowledged could be not rendered, such as post back activity.\n          // When calculating scroll snap, we can only base on the first unacknowledged-and-rendering activity.\n          const renderingActivityKeys = Array.from(activityElementMap.keys());\n          let firstUnacknowledgedActivityElementIndex = -1;\n\n          for (const acknowledgedActivityKey of activityKeys.slice(0, lastAcknowledgedActivityKeyIndex + 1).reverse()) {\n            const index = renderingActivityKeys.indexOf(acknowledgedActivityKey);\n\n            if (~index) {\n              if (index !== renderingActivityKeys.length - 1) {\n                firstUnacknowledgedActivityElementIndex = index + 1;\n              }\n\n              break;\n            }\n          }\n\n          if (~firstUnacknowledgedActivityElementIndex) {\n            const activityElements = Array.from(activityElementMap.values());\n\n            if (patchedAutoScrollSnapOnActivity) {\n              // Gets the activity element which we should snap to.\n              const nthUnacknowledgedActivityElement =\n                activityElements[firstUnacknowledgedActivityElementIndex + patchedAutoScrollSnapOnActivity - 1];\n\n              if (nthUnacknowledgedActivityElement) {\n                const nthUnacknowledgedActivityBoundingBoxElement = nthUnacknowledgedActivityElement?.querySelector(\n                  '.webchat__basic-transcript__activity-active-descendant'\n                ) as HTMLElement;\n                const nthUnacknowledgedActivityOffsetTop =\n                  nthUnacknowledgedActivityElement.offsetTop + nthUnacknowledgedActivityBoundingBoxElement.offsetTop;\n\n                values.push(\n                  nthUnacknowledgedActivityOffsetTop +\n                    nthUnacknowledgedActivityBoundingBoxElement.offsetHeight -\n                    offsetHeight -\n                    scrollTop +\n                    patchedAutoScrollSnapOnActivityOffset\n                );\n              }\n            }\n\n            if (patchedAutoScrollSnapOnPage) {\n              const firstUnacknowledgedActivityElement = activityElements[+firstUnacknowledgedActivityElementIndex];\n              const firstUnacknowledgedActivityBoundingBoxElement = firstUnacknowledgedActivityElement.querySelector(\n                '.webchat__basic-transcript__activity-active-descendant'\n              ) as HTMLElement;\n              const firstUnacknowledgedActivityOffsetTop =\n                firstUnacknowledgedActivityElement.offsetTop + firstUnacknowledgedActivityBoundingBoxElement.offsetTop;\n\n              values.push(\n                firstUnacknowledgedActivityOffsetTop -\n                  scrollTop -\n                  offsetHeight * (1 - patchedAutoScrollSnapOnPage) +\n                  patchedAutoScrollSnapOnPageOffset\n              );\n            }\n          }\n        }\n\n        return Math.min(...values);\n      }\n\n      return Infinity;\n    },\n    [activityElementMapRef, activityKeysRef, lastAcknowledgedActivityKeyRef, styleOptionsRef]\n  );\n};\n\ntype BasicTranscriptProps = {\n  className?: string;\n};\n\nconst BasicTranscript: VFC<BasicTranscriptProps> = ({ className }) => {\n  const activityElementMapRef = useRef<ActivityElementMap>(new Map());\n  const containerRef = useRef<HTMLDivElement>();\n\n  const scroller = useScroller(activityElementMapRef);\n\n  return (\n    <TranscriptFocusComposer containerRef={containerRef}>\n      <ReactScrollToBottomComposer scroller={scroller}>\n        <KeyboardHelp />\n        <InternalTranscript activityElementMapRef={activityElementMapRef} className={className} ref={containerRef} />\n      </ReactScrollToBottomComposer>\n    </TranscriptFocusComposer>\n  );\n};\n\nBasicTranscript.defaultProps = {\n  className: ''\n};\n\nBasicTranscript.propTypes = {\n  className: PropTypes.string\n};\n\nexport default BasicTranscript;\n"]},"metadata":{},"sourceType":"script"}