{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChunkedArrayBufferStream = void 0;\n\nvar Exports_1 = require(\"./Exports\");\n\nvar ChunkedArrayBufferStream =\n/** @class */\nfunction (_super) {\n  __extends(ChunkedArrayBufferStream, _super);\n\n  function ChunkedArrayBufferStream(targetChunkSize, streamId) {\n    var _this = _super.call(this, streamId) || this;\n\n    _this.privTargetChunkSize = targetChunkSize;\n    _this.privNextBufferReadyBytes = 0;\n    return _this;\n  }\n\n  ChunkedArrayBufferStream.prototype.writeStreamChunk = function (chunk) {\n    // No pending write, and the buffer is the right size so write it.\n    if (chunk.isEnd || 0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize) {\n      _super.prototype.writeStreamChunk.call(this, chunk);\n\n      return;\n    }\n\n    var bytesCopiedFromBuffer = 0;\n\n    while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {\n      // Fill the next buffer.\n      if (undefined === this.privNextBufferToWrite) {\n        this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);\n        this.privNextBufferStartTime = chunk.timeReceived;\n      } // Find out how many bytes we can copy into the read buffer.\n\n\n      var bytesToCopy = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);\n      var targetView = new Uint8Array(this.privNextBufferToWrite);\n      var sourceView = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));\n      targetView.set(sourceView, this.privNextBufferReadyBytes);\n      this.privNextBufferReadyBytes += bytesToCopy;\n      bytesCopiedFromBuffer += bytesToCopy; // Are we ready to write?\n\n      if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {\n        _super.prototype.writeStreamChunk.call(this, {\n          buffer: this.privNextBufferToWrite,\n          isEnd: false,\n          timeReceived: this.privNextBufferStartTime\n        });\n\n        this.privNextBufferReadyBytes = 0;\n        this.privNextBufferToWrite = undefined;\n      }\n    }\n  };\n\n  ChunkedArrayBufferStream.prototype.close = function () {\n    // Send whatever is pending, then close the base class.\n    if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {\n      _super.prototype.writeStreamChunk.call(this, {\n        buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),\n        isEnd: false,\n        timeReceived: this.privNextBufferStartTime\n      });\n    }\n\n    _super.prototype.close.call(this);\n  };\n\n  return ChunkedArrayBufferStream;\n}(Exports_1.Stream);\n\nexports.ChunkedArrayBufferStream = ChunkedArrayBufferStream;","map":{"version":3,"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;AAEA;AAAA;AAAA;AAA8CA;;AAM1C,oCAAYC,eAAZ,EAAqCC,QAArC,EAAsD;AAAtD,gBACIC,kBAAMD,QAAN,KAAe,IADnB;;AAEIE,SAAI,CAACC,mBAAL,GAA2BJ,eAA3B;AACAG,SAAI,CAACE,wBAAL,GAAgC,CAAhC;;AACH;;AAEMC,wDAAP,UAAwBC,KAAxB,EAAwD;AACpD;AACA,QAAIA,KAAK,CAACC,KAAN,IACC,MAAM,KAAKH,wBAAX,IAAuCE,KAAK,CAACE,MAAN,CAAaC,UAAb,KAA4B,KAAKN,mBAD7E,EACmG;AAC/FF,uBAAMS,gBAAN,CAAsBC,IAAtB,CAAsB,IAAtB,EAAuBL,KAAvB;;AACA;AACH;;AAED,QAAIM,qBAAqB,GAAW,CAApC;;AAEA,WAAOA,qBAAqB,GAAGN,KAAK,CAACE,MAAN,CAAaC,UAA5C,EAAwD;AACpD;AACA,UAAII,SAAS,KAAK,KAAKC,qBAAvB,EAA8C;AAC1C,aAAKA,qBAAL,GAA6B,IAAIC,WAAJ,CAAgB,KAAKZ,mBAArB,CAA7B;AACA,aAAKa,uBAAL,GAA+BV,KAAK,CAACW,YAArC;AACH,OALmD,CAOpD;;;AACA,UAAMC,WAAW,GAAWC,IAAI,CAACC,GAAL,CAASd,KAAK,CAACE,MAAN,CAAaC,UAAb,GAA0BG,qBAAnC,EAA0D,KAAKT,mBAAL,GAA2B,KAAKC,wBAA1F,CAA5B;AACA,UAAMiB,UAAU,GAAe,IAAIC,UAAJ,CAAe,KAAKR,qBAApB,CAA/B;AACA,UAAMS,UAAU,GAAe,IAAID,UAAJ,CAAehB,KAAK,CAACE,MAAN,CAAagB,KAAb,CAAmBZ,qBAAnB,EAA0CM,WAAW,GAAGN,qBAAxD,CAAf,CAA/B;AAEAS,gBAAU,CAACI,GAAX,CAAeF,UAAf,EAA2B,KAAKnB,wBAAhC;AACA,WAAKA,wBAAL,IAAiCc,WAAjC;AACAN,2BAAqB,IAAIM,WAAzB,CAdoD,CAgBpD;;AACA,UAAI,KAAKd,wBAAL,KAAkC,KAAKD,mBAA3C,EAAgE;AAC5DF,yBAAMS,gBAAN,CAAsBC,IAAtB,CAAsB,IAAtB,EAAuB;AACnBH,gBAAM,EAAE,KAAKM,qBADM;AAEnBP,eAAK,EAAE,KAFY;AAGnBU,sBAAY,EAAE,KAAKD;AAHA,SAAvB;;AAKA,aAAKZ,wBAAL,GAAgC,CAAhC;AACA,aAAKU,qBAAL,GAA6BD,SAA7B;AACH;AACJ;AACJ,GArCM;;AAuCAR,6CAAP;AACI;AACA,QAAI,MAAM,KAAKD,wBAAX,IAAuC,CAAC,KAAKsB,QAAjD,EAA2D;AACvDzB,uBAAMS,gBAAN,CAAsBC,IAAtB,CAAsB,IAAtB,EAAuB;AACnBH,cAAM,EAAE,KAAKM,qBAAL,CAA2BU,KAA3B,CAAiC,CAAjC,EAAoC,KAAKpB,wBAAzC,CADW;AAEnBG,aAAK,EAAE,KAFY;AAGnBU,oBAAY,EAAE,KAAKD;AAHA,OAAvB;AAKH;;AAEDf,qBAAM0B,KAAN,CAAWhB,IAAX,CAAW,IAAX;AACH,GAXM;;AAYX;AAAC,CA/DD,CAA8CiB,gBAA9C;;AAAaC","names":["__extends","targetChunkSize","streamId","_super","_this","privTargetChunkSize","privNextBufferReadyBytes","ChunkedArrayBufferStream","chunk","isEnd","buffer","byteLength","writeStreamChunk","call","bytesCopiedFromBuffer","undefined","privNextBufferToWrite","ArrayBuffer","privNextBufferStartTime","timeReceived","bytesToCopy","Math","min","targetView","Uint8Array","sourceView","slice","set","isClosed","close","Exports_1","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/src/common/ChunkedArrayBufferStream.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { IStreamChunk, Stream } from \"./Exports\";\r\n\r\nexport class ChunkedArrayBufferStream extends Stream<ArrayBuffer> {\r\n    private privTargetChunkSize: number;\r\n    private privNextBufferToWrite: ArrayBuffer;\r\n    private privNextBufferStartTime: number;\r\n    private privNextBufferReadyBytes: number;\r\n\r\n    constructor(targetChunkSize: number, streamId?: string) {\r\n        super(streamId);\r\n        this.privTargetChunkSize = targetChunkSize;\r\n        this.privNextBufferReadyBytes = 0;\r\n    }\r\n\r\n    public writeStreamChunk(chunk: IStreamChunk<ArrayBuffer>): void {\r\n        // No pending write, and the buffer is the right size so write it.\r\n        if (chunk.isEnd ||\r\n            (0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize)) {\r\n            super.writeStreamChunk(chunk);\r\n            return;\r\n        }\r\n\r\n        let bytesCopiedFromBuffer: number = 0;\r\n\r\n        while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {\r\n            // Fill the next buffer.\r\n            if (undefined === this.privNextBufferToWrite) {\r\n                this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);\r\n                this.privNextBufferStartTime = chunk.timeReceived;\r\n            }\r\n\r\n            // Find out how many bytes we can copy into the read buffer.\r\n            const bytesToCopy: number = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);\r\n            const targetView: Uint8Array = new Uint8Array(this.privNextBufferToWrite);\r\n            const sourceView: Uint8Array = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));\r\n\r\n            targetView.set(sourceView, this.privNextBufferReadyBytes);\r\n            this.privNextBufferReadyBytes += bytesToCopy;\r\n            bytesCopiedFromBuffer += bytesToCopy;\r\n\r\n            // Are we ready to write?\r\n            if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {\r\n                super.writeStreamChunk({\r\n                    buffer: this.privNextBufferToWrite,\r\n                    isEnd: false,\r\n                    timeReceived: this.privNextBufferStartTime,\r\n                });\r\n                this.privNextBufferReadyBytes = 0;\r\n                this.privNextBufferToWrite = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    public close(): void {\r\n        // Send whatever is pending, then close the base class.\r\n        if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {\r\n            super.writeStreamChunk({\r\n                buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),\r\n                isEnd: false,\r\n                timeReceived: this.privNextBufferStartTime,\r\n            });\r\n        }\r\n\r\n        super.close();\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}