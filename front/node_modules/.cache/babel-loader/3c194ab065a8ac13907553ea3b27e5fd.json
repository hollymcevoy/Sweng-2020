{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Scheduler_1 = require('../Scheduler');\n\nvar AsyncScheduler = function (_super) {\n  __extends(AsyncScheduler, _super);\n\n  function AsyncScheduler() {\n    _super.apply(this, arguments);\n\n    this.actions = [];\n    /**\n     * A flag to indicate whether the Scheduler is currently executing a batch of\n     * queued actions.\n     * @type {boolean}\n     */\n\n    this.active = false;\n    /**\n     * An internal ID used to track the latest asynchronous task such as those\n     * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n     * others.\n     * @type {any}\n     */\n\n    this.scheduled = undefined;\n  }\n\n  AsyncScheduler.prototype.flush = function (action) {\n    var actions = this.actions;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    var error;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  return AsyncScheduler;\n}(Scheduler_1.Scheduler);\n\nexports.AsyncScheduler = AsyncScheduler;","map":{"version":3,"mappings":";;;;;;;;;;;;AAAA,0BAA0B,cAA1B;;AAGA;AAAoCA;;AAApC;AAAoCC;;AAC3B,mBAAmC,EAAnC;AACP;;;;;;AAKO,kBAAkB,KAAlB;AACP;;;;;;;AAMO,qBAAiBC,SAAjB;AA6BR;;AA3BQC,mCAAP,UAAaC,MAAb,EAAqC;AAE5B;;AAEP,QAAI,KAAKC,MAAT,EAAiB;AACfC,aAAO,CAACC,IAAR,CAAaH,MAAb;AACA;AACD;;AAED,QAAII,KAAJ;AACA,SAAKH,MAAL,GAAc,IAAd;;AAEA,OAAG;AACD,UAAIG,KAAK,GAAGJ,MAAM,CAACK,OAAP,CAAeL,MAAM,CAACM,KAAtB,EAA6BN,MAAM,CAACO,KAApC,CAAZ,EAAwD;AACtD;AACD;AACF,KAJD,QAISP,MAAM,GAAGE,OAAO,CAACM,KAAR,EAJlB,EAZmC,CAgBC;;;AAEpC,SAAKP,MAAL,GAAc,KAAd;;AAEA,QAAIG,KAAJ,EAAW;AACT,aAAOJ,MAAM,GAAGE,OAAO,CAACM,KAAR,EAAhB,EAAiC;AAC/BR,cAAM,CAACS,WAAP;AACD;;AACD,YAAML,KAAN;AACD;AACF,GA1BM;;AA2BT;AA3CA,EAAoCM,qBAApC;;AAAaC,yBAAcZ,cAAd","names":["__extends","_super","undefined","AsyncScheduler","action","active","actions","push","error","execute","state","delay","shift","unsubscribe","Scheduler_1","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/src/scheduler/AsyncScheduler.ts"],"sourcesContent":["import { Scheduler } from '../Scheduler';\nimport { AsyncAction } from './AsyncAction';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   */\n  public scheduled: any = undefined;\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}