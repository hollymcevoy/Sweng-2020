{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SynthesisTurn = void 0;\n\nvar Exports_1 = require(\"../common/Exports\");\n\nvar AudioOutputStream_1 = require(\"../sdk/Audio/AudioOutputStream\");\n\nvar SynthesisAdapterBase_1 = require(\"./SynthesisAdapterBase\");\n\nvar SynthesisEvents_1 = require(\"./SynthesisEvents\");\n\nvar SynthesisTurn =\n/** @class */\nfunction () {\n  function SynthesisTurn() {\n    var _this = this;\n\n    this.privIsDisposed = false;\n    this.privIsSynthesizing = false;\n    this.privIsSynthesisEnded = false;\n    this.privBytesReceived = 0;\n    this.privInTurn = false;\n    this.privTextOffset = 0;\n    this.privNextSearchTextIndex = 0;\n\n    this.onPreConnectionStart = function (authFetchEventId, connectionId) {\n      _this.privAuthFetchEventId = authFetchEventId;\n\n      _this.onEvent(new SynthesisEvents_1.ConnectingToSynthesisServiceEvent(_this.privRequestId, _this.privAuthFetchEventId));\n    };\n\n    this.onAuthCompleted = function (isError, error) {\n      if (isError) {\n        _this.onComplete();\n      }\n    };\n\n    this.onConnectionEstablishCompleted = function (statusCode, reason) {\n      if (statusCode === 200) {\n        _this.onEvent(new SynthesisEvents_1.SynthesisStartedEvent(_this.requestId, _this.privAuthFetchEventId));\n\n        _this.privBytesReceived = 0;\n        return;\n      } else if (statusCode === 403) {\n        _this.onComplete();\n      }\n    };\n\n    this.onServiceResponseMessage = function (responseJson) {\n      var response = JSON.parse(responseJson);\n      _this.streamId = response.audio.streamId;\n    };\n\n    this.onServiceTurnEndResponse = function () {\n      _this.privInTurn = false;\n\n      _this.privTurnDeferral.resolve();\n\n      _this.onComplete();\n    };\n\n    this.onServiceTurnStartResponse = function () {\n      if (!!_this.privTurnDeferral && !!_this.privInTurn) {\n        // What? How are we starting a turn with another not done?\n        _this.privTurnDeferral.reject(\"Another turn started before current completed.\"); // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n\n        /* tslint:disable:no-empty */\n\n\n        _this.privTurnDeferral.promise.then().catch(function () {});\n      }\n\n      _this.privInTurn = true;\n      _this.privTurnDeferral = new Exports_1.Deferred();\n    };\n\n    this.dispose = function (error) {\n      if (!_this.privIsDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        _this.privIsDisposed = true;\n      }\n    };\n\n    this.onEvent = function (event) {\n      Exports_1.Events.instance.onEvent(event);\n    };\n\n    this.onComplete = function () {\n      if (_this.privIsSynthesizing) {\n        _this.privIsSynthesizing = false;\n        _this.privIsSynthesisEnded = true;\n\n        _this.privAudioOutputStream.close();\n\n        _this.privInTurn = false;\n\n        if (_this.privTurnAudioDestination !== undefined) {\n          _this.privTurnAudioDestination.close();\n\n          _this.privTurnAudioDestination = undefined;\n        }\n      }\n    };\n\n    this.privRequestId = Exports_1.createNoDashGuid();\n    this.privTurnDeferral = new Exports_1.Deferred(); // We're not in a turn, so resolve.\n\n    this.privTurnDeferral.resolve();\n  }\n\n  Object.defineProperty(SynthesisTurn.prototype, \"requestId\", {\n    get: function () {\n      return this.privRequestId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SynthesisTurn.prototype, \"streamId\", {\n    get: function () {\n      return this.privStreamId;\n    },\n    set: function (value) {\n      this.privStreamId = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SynthesisTurn.prototype, \"audioOutputFormat\", {\n    get: function () {\n      return this.privAudioOutputFormat;\n    },\n    set: function (format) {\n      this.privAudioOutputFormat = format;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SynthesisTurn.prototype, \"turnCompletionPromise\", {\n    get: function () {\n      return this.privTurnDeferral.promise;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SynthesisTurn.prototype, \"isSynthesisEnded\", {\n    get: function () {\n      return this.privIsSynthesisEnded;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SynthesisTurn.prototype, \"isSynthesizing\", {\n    get: function () {\n      return this.privIsSynthesizing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SynthesisTurn.prototype, \"currentTextOffset\", {\n    get: function () {\n      return this.privTextOffset;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SynthesisTurn.prototype, \"bytesReceived\", {\n    // The number of bytes received for current turn\n    get: function () {\n      return this.privBytesReceived;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  SynthesisTurn.prototype.getAllReceivedAudio = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!this.privReceivedAudio) {\n              return [2\n              /*return*/\n              , Promise.resolve(this.privReceivedAudio)];\n            }\n\n            if (!this.privIsSynthesisEnded) {\n              return [2\n              /*return*/\n              , null];\n            }\n\n            return [4\n            /*yield*/\n            , this.readAllAudioFromStream()];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , Promise.resolve(this.privReceivedAudio)];\n        }\n      });\n    });\n  };\n\n  SynthesisTurn.prototype.getAllReceivedAudioWithHeader = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var audio;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!this.privReceivedAudioWithHeader) {\n              return [2\n              /*return*/\n              , this.privReceivedAudioWithHeader];\n            }\n\n            if (!this.privIsSynthesisEnded) {\n              return [2\n              /*return*/\n              , null];\n            }\n\n            if (!this.audioOutputFormat.hasHeader) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.getAllReceivedAudio()];\n\n          case 1:\n            audio = _a.sent();\n            this.privReceivedAudioWithHeader = SynthesisAdapterBase_1.SynthesisAdapterBase.addHeader(audio, this.audioOutputFormat);\n            return [2\n            /*return*/\n            , this.privReceivedAudioWithHeader];\n\n          case 2:\n            return [2\n            /*return*/\n            , this.getAllReceivedAudio()];\n        }\n      });\n    });\n  };\n\n  SynthesisTurn.prototype.startNewSynthesis = function (requestId, rawText, isSSML, audioDestination) {\n    this.privIsSynthesisEnded = false;\n    this.privIsSynthesizing = true;\n    this.privRequestId = requestId;\n    this.privRawText = rawText;\n    this.privIsSSML = isSSML;\n    this.privAudioOutputStream = new AudioOutputStream_1.PullAudioOutputStreamImpl();\n    this.privAudioOutputStream.format = this.privAudioOutputFormat;\n    this.privReceivedAudio = null;\n    this.privReceivedAudioWithHeader = null;\n    this.privBytesReceived = 0;\n    this.privTextOffset = 0;\n    this.privNextSearchTextIndex = 0;\n    this.privPartialVisemeAnimation = \"\";\n\n    if (audioDestination !== undefined) {\n      this.privTurnAudioDestination = audioDestination;\n      this.privTurnAudioDestination.format = this.privAudioOutputFormat;\n    }\n\n    this.onEvent(new SynthesisEvents_1.SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\n  };\n\n  SynthesisTurn.prototype.onAudioChunkReceived = function (data) {\n    if (this.isSynthesizing) {\n      this.privAudioOutputStream.write(data);\n      this.privBytesReceived += data.byteLength;\n\n      if (this.privTurnAudioDestination !== undefined) {\n        this.privTurnAudioDestination.write(data);\n      }\n    }\n  };\n\n  SynthesisTurn.prototype.onWordBoundaryEvent = function (text) {\n    this.updateTextOffset(text);\n  };\n\n  SynthesisTurn.prototype.onVisemeMetadataReceived = function (metadata) {\n    if (metadata.Data.AnimationChunk !== undefined) {\n      this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;\n    }\n  };\n\n  SynthesisTurn.prototype.onStopSynthesizing = function () {\n    this.onComplete();\n  };\n  /**\n   * Gets the viseme animation string (merged from animation chunk), and clears the internal\n   * partial animation.\n   */\n\n\n  SynthesisTurn.prototype.getAndClearVisemeAnimation = function () {\n    var animation = this.privPartialVisemeAnimation;\n    this.privPartialVisemeAnimation = \"\";\n    return animation;\n  };\n\n  SynthesisTurn.prototype.updateTextOffset = function (text) {\n    if (this.privTextOffset >= 0) {\n      this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\n\n      if (this.privTextOffset >= 0) {\n        this.privNextSearchTextIndex = this.privTextOffset + text.length;\n      }\n\n      if (this.privIsSSML) {\n        if (this.privRawText.indexOf(\"<\", this.privTextOffset + 1) > this.privRawText.indexOf(\">\", this.privTextOffset + 1)) {\n          this.updateTextOffset(text);\n        }\n      }\n    }\n  };\n\n  SynthesisTurn.prototype.readAllAudioFromStream = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.privIsSynthesisEnded) return [3\n            /*break*/\n            , 4];\n            this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.privAudioOutputStream.read(this.privReceivedAudio)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            this.privReceivedAudio = new ArrayBuffer(0);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return SynthesisTurn;\n}();\n\nexports.SynthesisTurn = SynthesisTurn;","map":{"version":3,"mappings":"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","names":["authFetchEventId","connectionId","_this","privAuthFetchEventId","onEvent","SynthesisEvents_1","privRequestId","isError","error","onComplete","statusCode","reason","requestId","privBytesReceived","responseJson","response","JSON","parse","streamId","audio","privInTurn","privTurnDeferral","resolve","reject","promise","then","catch","Exports_1","privIsDisposed","event","instance","privIsSynthesizing","privIsSynthesisEnded","privAudioOutputStream","close","privTurnAudioDestination","undefined","Object","SynthesisTurn","privStreamId","value","privAudioOutputFormat","format","privTextOffset","privReceivedAudio","Promise","readAllAudioFromStream","_a","privReceivedAudioWithHeader","audioOutputFormat","hasHeader","getAllReceivedAudio","SynthesisAdapterBase_1","addHeader","rawText","isSSML","audioDestination","privRawText","privIsSSML","AudioOutputStream_1","privNextSearchTextIndex","privPartialVisemeAnimation","id","data","isSynthesizing","write","byteLength","text","updateTextOffset","metadata","Data","AnimationChunk","animation","indexOf","length","ArrayBuffer","bytesReceived","read","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/src/common.speech/SynthesisTurn.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events, IAudioDestination\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport { ISynthesisMetadata } from \"./ServiceMessages/SynthesisAudioMetadata\";\r\nimport { SynthesisAdapterBase } from \"./SynthesisAdapterBase\";\r\nimport {\r\n    ConnectingToSynthesisServiceEvent,\r\n    SpeechSynthesisEvent,\r\n    SynthesisStartedEvent,\r\n    SynthesisTriggeredEvent,\r\n} from \"./SynthesisEvents\";\r\n\r\nexport interface ISynthesisResponseContext {\r\n    serviceTag: string;\r\n}\r\n\r\nexport interface ISynthesisResponseAudio {\r\n    type: string;\r\n    streamId: string;\r\n}\r\n\r\nexport interface ISynthesisResponse {\r\n    context: ISynthesisResponseContext;\r\n    audio: ISynthesisResponseAudio;\r\n}\r\n\r\nexport class SynthesisTurn {\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get streamId(): string {\r\n        return this.privStreamId;\r\n    }\r\n\r\n    public set streamId(value: string) {\r\n        this.privStreamId = value;\r\n    }\r\n\r\n    public get audioOutputFormat(): AudioOutputFormatImpl {\r\n        return this.privAudioOutputFormat;\r\n    }\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n    }\r\n\r\n    public get turnCompletionPromise(): Promise<void> {\r\n        return this.privTurnDeferral.promise;\r\n    }\r\n\r\n    public get isSynthesisEnded(): boolean {\r\n        return this.privIsSynthesisEnded;\r\n    }\r\n\r\n    public get isSynthesizing(): boolean {\r\n        return this.privIsSynthesizing;\r\n    }\r\n\r\n    public get currentTextOffset(): number {\r\n        return this.privTextOffset;\r\n    }\r\n\r\n    // The number of bytes received for current turn\r\n    public get bytesReceived(): number {\r\n        return this.privBytesReceived;\r\n    }\r\n\r\n    private privIsDisposed: boolean = false;\r\n    private privAuthFetchEventId: string;\r\n    private privIsSynthesizing: boolean = false;\r\n    private privIsSynthesisEnded: boolean = false;\r\n    private privBytesReceived: number = 0;\r\n    private privRequestId: string;\r\n    private privStreamId: string;\r\n    private privTurnDeferral: Deferred<void>;\r\n    private privInTurn: boolean = false;\r\n    private privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privAudioOutputStream: PullAudioOutputStreamImpl;\r\n    private privReceivedAudio: ArrayBuffer;\r\n    private privReceivedAudioWithHeader: ArrayBuffer;\r\n    private privTextOffset: number = 0;\r\n    private privNextSearchTextIndex: number = 0;\r\n    private privPartialVisemeAnimation: string;\r\n    private privRawText: string;\r\n    private privIsSSML: boolean;\r\n    private privTurnAudioDestination: IAudioDestination;\r\n\r\n    constructor() {\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privTurnDeferral = new Deferred<void>();\r\n\r\n        // We're not in a turn, so resolve.\r\n        this.privTurnDeferral.resolve();\r\n    }\r\n\r\n    public async getAllReceivedAudio(): Promise<ArrayBuffer> {\r\n        if (!!this.privReceivedAudio) {\r\n            return Promise.resolve(this.privReceivedAudio);\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        await this.readAllAudioFromStream();\r\n        return Promise.resolve(this.privReceivedAudio);\r\n    }\r\n\r\n    public async getAllReceivedAudioWithHeader(): Promise<ArrayBuffer> {\r\n        if (!!this.privReceivedAudioWithHeader) {\r\n            return this.privReceivedAudioWithHeader;\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        if (this.audioOutputFormat.hasHeader) {\r\n            const audio: ArrayBuffer = await this.getAllReceivedAudio();\r\n            this.privReceivedAudioWithHeader = SynthesisAdapterBase.addHeader(audio, this.audioOutputFormat);\r\n            return this.privReceivedAudioWithHeader;\r\n        } else {\r\n            return this.getAllReceivedAudio();\r\n        }\r\n    }\r\n\r\n    public startNewSynthesis(requestId: string, rawText: string, isSSML: boolean, audioDestination?: IAudioDestination): void {\r\n        this.privIsSynthesisEnded = false;\r\n        this.privIsSynthesizing = true;\r\n        this.privRequestId = requestId;\r\n        this.privRawText = rawText;\r\n        this.privIsSSML = isSSML;\r\n        this.privAudioOutputStream = new PullAudioOutputStreamImpl();\r\n        this.privAudioOutputStream.format = this.privAudioOutputFormat;\r\n        this.privReceivedAudio = null;\r\n        this.privReceivedAudioWithHeader = null;\r\n        this.privBytesReceived = 0;\r\n        this.privTextOffset = 0;\r\n        this.privNextSearchTextIndex = 0;\r\n        this.privPartialVisemeAnimation = \"\";\r\n        if (audioDestination !== undefined) {\r\n            this.privTurnAudioDestination = audioDestination;\r\n            this.privTurnAudioDestination.format = this.privAudioOutputFormat;\r\n        }\r\n        this.onEvent(new SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\r\n    }\r\n\r\n    public onPreConnectionStart = (authFetchEventId: string, connectionId: string): void => {\r\n        this.privAuthFetchEventId = authFetchEventId;\r\n        this.onEvent(new ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));\r\n    }\r\n\r\n    public onAuthCompleted = (isError: boolean, error?: string): void => {\r\n        if (isError) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onConnectionEstablishCompleted = (statusCode: number, reason?: string): void => {\r\n        if (statusCode === 200) {\r\n            this.onEvent(new SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));\r\n            this.privBytesReceived = 0;\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onServiceResponseMessage = (responseJson: string): void => {\r\n        const response: ISynthesisResponse = JSON.parse(responseJson);\r\n        this.streamId = response.audio.streamId;\r\n    }\r\n\r\n    public onServiceTurnEndResponse = (): void => {\r\n        this.privInTurn = false;\r\n        this.privTurnDeferral.resolve();\r\n        this.onComplete();\r\n    }\r\n\r\n    public onServiceTurnStartResponse = (): void => {\r\n        if (!!this.privTurnDeferral && !!this.privInTurn) {\r\n            // What? How are we starting a turn with another not done?\r\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\r\n            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\r\n            /* tslint:disable:no-empty */\r\n            this.privTurnDeferral.promise.then().catch(() => { });\r\n        }\r\n        this.privInTurn = true;\r\n        this.privTurnDeferral = new Deferred<void>();\r\n    }\r\n\r\n    public onAudioChunkReceived(data: ArrayBuffer): void {\r\n        if (this.isSynthesizing) {\r\n            this.privAudioOutputStream.write(data);\r\n            this.privBytesReceived += data.byteLength;\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.write(data);\r\n            }\r\n        }\r\n    }\r\n\r\n    public onWordBoundaryEvent(text: string): void {\r\n        this.updateTextOffset(text);\r\n    }\r\n\r\n    public onVisemeMetadataReceived(metadata: ISynthesisMetadata): void {\r\n        if (metadata.Data.AnimationChunk !== undefined) {\r\n            this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;\r\n        }\r\n    }\r\n\r\n    public dispose = (error?: string): void => {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n        }\r\n    }\r\n\r\n    public onStopSynthesizing(): void {\r\n        this.onComplete();\r\n    }\r\n\r\n    /**\r\n     * Gets the viseme animation string (merged from animation chunk), and clears the internal\r\n     * partial animation.\r\n     */\r\n    public getAndClearVisemeAnimation(): string {\r\n        const animation: string = this.privPartialVisemeAnimation;\r\n        this.privPartialVisemeAnimation = \"\";\r\n        return animation;\r\n    }\r\n\r\n    protected onEvent = (event: SpeechSynthesisEvent): void => {\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private updateTextOffset(text: string): void {\r\n        if (this.privTextOffset >= 0) {\r\n            this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\r\n            if (this.privTextOffset >= 0) {\r\n                this.privNextSearchTextIndex = this.privTextOffset + text.length;\r\n            }\r\n            if (this.privIsSSML) {\r\n                if (this.privRawText.indexOf(\"<\", this.privTextOffset + 1) > this.privRawText.indexOf(\">\", this.privTextOffset + 1)) {\r\n                    this.updateTextOffset(text);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onComplete = (): void => {\r\n        if (this.privIsSynthesizing) {\r\n            this.privIsSynthesizing = false;\r\n            this.privIsSynthesisEnded = true;\r\n            this.privAudioOutputStream.close();\r\n            this.privInTurn = false;\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.close();\r\n                this.privTurnAudioDestination = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    private async readAllAudioFromStream(): Promise<void> {\r\n        if (this.privIsSynthesisEnded) {\r\n            this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\r\n            try {\r\n                await this.privAudioOutputStream.read(this.privReceivedAudio);\r\n            } catch (e) {\r\n                this.privReceivedAudio = new ArrayBuffer(0);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}