{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _useStyleToEmotionObject = _interopRequireDefault(require(\"./hooks/internal/useStyleToEmotionObject\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint react/forbid-dom-props: [\"off\"] */\n\n\nvar ROOT_STYLE = {\n  // .sr-only - This component is intended to be invisible to the visual Web Chat user, but read by the AT when using a screen reader\n  color: 'transparent',\n  height: 1,\n  overflow: 'hidden',\n  position: 'absolute',\n  // We need to set top: 0, otherwise, it will repro:\n  // - Run NVDA\n  // - Make the transcript long enough to show the scrollbar\n  // - Press SHIFT-TAB, focus on upload button\n  // - Press up arrow multiple times\n  top: 0,\n  whiteSpace: 'nowrap',\n  width: 1\n};\nvar ScreenReaderText = /*#__PURE__*/(0, _react.forwardRef)(function (_ref, ref) {\n  var ariaHidden = _ref['aria-hidden'],\n      id = _ref.id,\n      text = _ref.text;\n  var rootClassName = (0, _useStyleToEmotionObject.default)()(ROOT_STYLE) + '';\n\n  if (ariaHidden && !id) {\n    console.warn('botframework-webchat assertion: when \"aria-hidden\" is set, the screen reader text should be read by \"aria-labelledby\". Thus, \"id\" must be set.');\n  }\n\n  return /*#__PURE__*/_react.default.createElement(\"div\", {\n    \"aria-hidden\": ariaHidden,\n    className: rootClassName,\n    id: id,\n    ref: ref\n  }, text);\n});\nScreenReaderText.defaultProps = {\n  'aria-hidden': undefined,\n  id: undefined\n};\nScreenReaderText.propTypes = {\n  'aria-hidden': _propTypes.default.bool,\n  id: _propTypes.default.string,\n  text: _propTypes.default.string.isRequired\n};\nvar _default = ScreenReaderText;\nexports.default = _default;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAEA;;AACA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAPA;;;AASA,IAAMA,UAAU,GAAG;AACjB;AACAC,OAAK,EAAE,aAFU;AAGjBC,QAAM,EAAE,CAHS;AAIjBC,UAAQ,EAAE,QAJO;AAKjBC,UAAQ,EAAE,UALO;AAMjB;AACA;AACA;AACA;AACA;AACAC,KAAG,EAAE,CAXY;AAYjBC,YAAU,EAAE,QAZK;AAajBC,OAAK,EAAE;AAbU,CAAnB;AAsBA,IAAMC,gBAA4C,gBAAG,uBACnD,gBAA0CC,GAA1C,EAAkD;AAAA,MAAhCC,UAAgC,QAA/C,aAA+C;AAAA,MAApBC,EAAoB,QAApBA,EAAoB;AAAA,MAAhBC,IAAgB,QAAhBA,IAAgB;AAChD,MAAMC,aAAa,GAAG,wCAA0Bb,UAA1B,IAAwC,EAA9D;;AAEA,MAAIU,UAAU,IAAI,CAACC,EAAnB,EAAuB;AACrBG,WAAO,CAACC,IAARD,CACE,gJADFA;AAGD;;AAED,sBACEE;AAAK,mBAAaN,UAAlB;AAA8BO,aAAS,EAAEJ,aAAzC;AAAwDF,MAAE,EAAEA,EAA5D;AAAgEF,OAAG,EAAEA;AAArE,KACGG,IADH,CADF;AAViD,EAArD;AAkBAJ,gBAAgB,CAACU,YAAjBV,GAAgC;AAC9B,iBAAeW,SADe;AAE9BR,IAAE,EAAEQ;AAF0B,CAAhCX;AAKAA,gBAAgB,CAACY,SAAjBZ,GAA6B;AAC3B,iBAAea,mBAAUC,IADE;AAE3BX,IAAE,EAAEU,mBAAUE,MAFa;AAG3BX,MAAI,EAAES,mBAAUE,MAAVF,CAAiBG;AAHI,CAA7BhB;eAMeA","names":["ROOT_STYLE","color","height","overflow","position","top","whiteSpace","width","ScreenReaderText","ref","ariaHidden","id","text","rootClassName","console","warn","_react","className","defaultProps","undefined","propTypes","PropTypes","bool","string","isRequired"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-component/lib/src/ScreenReaderText.tsx"],"sourcesContent":["/* eslint react/forbid-dom-props: [\"off\"] */\n\nimport PropTypes from 'prop-types';\nimport React, { forwardRef } from 'react';\n\nimport type { VFC } from 'react';\n\nimport useStyleToEmotionObject from './hooks/internal/useStyleToEmotionObject';\n\nconst ROOT_STYLE = {\n  // .sr-only - This component is intended to be invisible to the visual Web Chat user, but read by the AT when using a screen reader\n  color: 'transparent',\n  height: 1,\n  overflow: 'hidden',\n  position: 'absolute',\n  // We need to set top: 0, otherwise, it will repro:\n  // - Run NVDA\n  // - Make the transcript long enough to show the scrollbar\n  // - Press SHIFT-TAB, focus on upload button\n  // - Press up arrow multiple times\n  top: 0,\n  whiteSpace: 'nowrap',\n  width: 1\n};\n\ntype ScreenReaderTextProps = {\n  'aria-hidden'?: boolean;\n  id?: string;\n  text: string;\n};\n\nconst ScreenReaderText: VFC<ScreenReaderTextProps> = forwardRef<HTMLDivElement, ScreenReaderTextProps>(\n  ({ 'aria-hidden': ariaHidden, id, text }, ref) => {\n    const rootClassName = useStyleToEmotionObject()(ROOT_STYLE) + '';\n\n    if (ariaHidden && !id) {\n      console.warn(\n        'botframework-webchat assertion: when \"aria-hidden\" is set, the screen reader text should be read by \"aria-labelledby\". Thus, \"id\" must be set.'\n      );\n    }\n\n    return (\n      <div aria-hidden={ariaHidden} className={rootClassName} id={id} ref={ref}>\n        {text}\n      </div>\n    );\n  }\n);\n\nScreenReaderText.defaultProps = {\n  'aria-hidden': undefined,\n  id: undefined\n};\n\nScreenReaderText.propTypes = {\n  'aria-hidden': PropTypes.bool,\n  id: PropTypes.string,\n  text: PropTypes.string.isRequired\n};\n\nexport default ScreenReaderText;\n"]},"metadata":{},"sourceType":"script"}