{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar root_1 = require('../util/root');\n\nvar Action_1 = require('./Action');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\n\nvar AsyncAction = function (_super) {\n  __extends(AsyncAction, _super);\n\n  function AsyncAction(scheduler, work) {\n    _super.call(this, scheduler, work);\n\n    this.scheduler = scheduler;\n    this.pending = false;\n    this.work = work;\n  }\n\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (this.closed) {\n      return this;\n    } // Always replace the current state with the new state.\n\n\n    this.state = state; // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n\n    this.pending = true;\n    var id = this.id;\n    var scheduler = this.scheduler; //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.delay = delay; // If this action has already an async Id, don't request a new one.\n\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n\n  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n\n  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    } // If this action is rescheduled with the same delay time, don't clear the interval id.\n\n\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    } // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n\n\n    return root_1.root.clearInterval(id) && undefined || undefined;\n  };\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n\n\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n\n    var error = this._execute(state, delay);\n\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n\n  AsyncAction.prototype._execute = function (state, delay) {\n    var errored = false;\n    var errorValue = undefined;\n\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n  /** @deprecated internal use only */\n\n\n  AsyncAction.prototype._unsubscribe = function () {\n    var id = this.id;\n    var scheduler = this.scheduler;\n    var actions = scheduler.actions;\n    var index = actions.indexOf(this);\n    this.work = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  };\n\n  return AsyncAction;\n}(Action_1.Action);\n\nexports.AsyncAction = AsyncAction;","map":{"version":3,"mappings":"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","names":["__extends","scheduler","work","_super","AsyncAction","state","delay","closed","pending","id","recycleAsyncId","requestAsyncId","root_1","setInterval","flush","bind","clearInterval","undefined","Error","error","_execute","errored","errorValue","e","unsubscribe","actions","index","indexOf","splice","Action_1","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/src/scheduler/AsyncAction.ts"],"sourcesContent":["import { root } from '../util/root';\nimport { Action } from './Action';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n  protected work: (this: this, state?: T) => void;\n\n  constructor(protected scheduler: AsyncScheduler,\n              work: (this: AsyncAction<T>, state?: T) => void) {\n    super(scheduler, work);\n    this.work = work;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n     }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    return root.clearInterval(id) && undefined || undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}