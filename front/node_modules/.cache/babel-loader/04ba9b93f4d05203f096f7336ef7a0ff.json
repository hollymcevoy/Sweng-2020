{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebsocketMessageFormatter = void 0;\n\nvar Exports_1 = require(\"../common/Exports\");\n\nvar CRLF = \"\\r\\n\";\n\nvar WebsocketMessageFormatter =\n/** @class */\nfunction () {\n  function WebsocketMessageFormatter() {\n    var _this = this;\n\n    this.toConnectionMessage = function (message) {\n      var deferral = new Exports_1.Deferred();\n\n      try {\n        if (message.messageType === Exports_1.MessageType.Text) {\n          var textMessage = message.textContent;\n          var headers = {};\n          var body = null;\n\n          if (textMessage) {\n            var headerBodySplit = textMessage.split(\"\\r\\n\\r\\n\");\n\n            if (headerBodySplit && headerBodySplit.length > 0) {\n              headers = _this.parseHeaders(headerBodySplit[0]);\n\n              if (headerBodySplit.length > 1) {\n                body = headerBodySplit[1];\n              }\n            }\n          }\n\n          deferral.resolve(new Exports_1.ConnectionMessage(message.messageType, body, headers, message.id));\n        } else if (message.messageType === Exports_1.MessageType.Binary) {\n          var binaryMessage = message.binaryContent;\n          var headers = {};\n          var body = null;\n\n          if (!binaryMessage || binaryMessage.byteLength < 2) {\n            throw new Error(\"Invalid binary message format. Header length missing.\");\n          }\n\n          var dataView = new DataView(binaryMessage);\n          var headerLength = dataView.getInt16(0);\n\n          if (binaryMessage.byteLength < headerLength + 2) {\n            throw new Error(\"Invalid binary message format. Header content missing.\");\n          }\n\n          var headersString = \"\";\n\n          for (var i = 0; i < headerLength; i++) {\n            headersString += String.fromCharCode(dataView.getInt8(i + 2));\n          }\n\n          headers = _this.parseHeaders(headersString);\n\n          if (binaryMessage.byteLength > headerLength + 2) {\n            body = binaryMessage.slice(2 + headerLength);\n          }\n\n          deferral.resolve(new Exports_1.ConnectionMessage(message.messageType, body, headers, message.id));\n        }\n      } catch (e) {\n        deferral.reject(\"Error formatting the message. Error: \" + e);\n      }\n\n      return deferral.promise;\n    };\n\n    this.fromConnectionMessage = function (message) {\n      var deferral = new Exports_1.Deferred();\n\n      try {\n        if (message.messageType === Exports_1.MessageType.Text) {\n          var payload = \"\" + _this.makeHeaders(message) + CRLF + (message.textBody ? message.textBody : \"\");\n          deferral.resolve(new Exports_1.RawWebsocketMessage(Exports_1.MessageType.Text, payload, message.id));\n        } else if (message.messageType === Exports_1.MessageType.Binary) {\n          var headersString = _this.makeHeaders(message);\n\n          var content = message.binaryBody;\n\n          var headerBuffer = _this.stringToArrayBuffer(headersString);\n\n          var headerInt8Array = new Int8Array(headerBuffer);\n          var headerLength = headerInt8Array.byteLength;\n          var payloadInt8Array = new Int8Array(2 + headerLength + (content ? content.byteLength : 0));\n          payloadInt8Array[0] = headerLength >> 8 & 0xff;\n          payloadInt8Array[1] = headerLength & 0xff;\n          payloadInt8Array.set(headerInt8Array, 2);\n\n          if (content) {\n            var bodyInt8Array = new Int8Array(content);\n            payloadInt8Array.set(bodyInt8Array, 2 + headerLength);\n          }\n\n          var payload = payloadInt8Array.buffer;\n          deferral.resolve(new Exports_1.RawWebsocketMessage(Exports_1.MessageType.Binary, payload, message.id));\n        }\n      } catch (e) {\n        deferral.reject(\"Error formatting the message. \" + e);\n      }\n\n      return deferral.promise;\n    };\n\n    this.makeHeaders = function (message) {\n      var headersString = \"\";\n\n      if (message.headers) {\n        for (var header in message.headers) {\n          if (header) {\n            headersString += header + \": \" + message.headers[header] + CRLF;\n          }\n        }\n      }\n\n      return headersString;\n    };\n\n    this.parseHeaders = function (headersString) {\n      var headers = {};\n\n      if (headersString) {\n        var headerMatches = headersString.match(/[^\\r\\n]+/g);\n\n        if (headers) {\n          for (var _i = 0, headerMatches_1 = headerMatches; _i < headerMatches_1.length; _i++) {\n            var header = headerMatches_1[_i];\n\n            if (header) {\n              var separatorIndex = header.indexOf(\":\");\n              var headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;\n              var headerValue = separatorIndex > 0 && header.length > separatorIndex + 1 ? header.substr(separatorIndex + 1).trim() : \"\";\n              headers[headerName] = headerValue;\n            }\n          }\n        }\n      }\n\n      return headers;\n    };\n\n    this.stringToArrayBuffer = function (str) {\n      var buffer = new ArrayBuffer(str.length);\n      var view = new DataView(buffer);\n\n      for (var i = 0; i < str.length; i++) {\n        view.setUint8(i, str.charCodeAt(i));\n      }\n\n      return buffer;\n    };\n  }\n\n  return WebsocketMessageFormatter;\n}();\n\nexports.WebsocketMessageFormatter = WebsocketMessageFormatter;","map":{"version":3,"mappings":"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","names":["CRLF","message","deferral","Exports_1","messageType","Text","textMessage","textContent","headers","body","headerBodySplit","split","length","_this","parseHeaders","resolve","id","Binary","binaryMessage","binaryContent","byteLength","Error","dataView","DataView","headerLength","getInt16","headersString","i","String","fromCharCode","getInt8","slice","e","reject","promise","payload","makeHeaders","textBody","content","binaryBody","headerBuffer","stringToArrayBuffer","headerInt8Array","Int8Array","payloadInt8Array","set","bodyInt8Array","buffer","header","headerMatches","match","_i","separatorIndex","indexOf","headerName","substr","trim","toLowerCase","headerValue","str","ArrayBuffer","view","setUint8","charCodeAt","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/src/common.speech/WebsocketMessageFormatter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionMessage,\r\n    Deferred,\r\n    IStringDictionary,\r\n    IWebsocketMessageFormatter,\r\n    MessageType,\r\n    RawWebsocketMessage,\r\n} from \"../common/Exports\";\r\n\r\nconst CRLF: string = \"\\r\\n\";\r\n\r\nexport class WebsocketMessageFormatter implements IWebsocketMessageFormatter {\r\n\r\n    public toConnectionMessage = (message: RawWebsocketMessage): Promise<ConnectionMessage> => {\r\n        const deferral = new Deferred<ConnectionMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const textMessage: string = message.textContent;\r\n                let headers: IStringDictionary<string> = {};\r\n                let body: string = null;\r\n\r\n                if (textMessage) {\r\n                    const headerBodySplit = textMessage.split(\"\\r\\n\\r\\n\");\r\n                    if (headerBodySplit && headerBodySplit.length > 0) {\r\n                        headers = this.parseHeaders(headerBodySplit[0]);\r\n                        if (headerBodySplit.length > 1) {\r\n                            body = headerBodySplit[1];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\r\n            } else if (message.messageType === MessageType.Binary) {\r\n                const binaryMessage: ArrayBuffer = message.binaryContent;\r\n                let headers: IStringDictionary<string> = {};\r\n                let body: ArrayBuffer = null;\r\n\r\n                if (!binaryMessage || binaryMessage.byteLength < 2) {\r\n                    throw new Error(\"Invalid binary message format. Header length missing.\");\r\n                }\r\n\r\n                const dataView = new DataView(binaryMessage);\r\n                const headerLength = dataView.getInt16(0);\r\n\r\n                if (binaryMessage.byteLength < headerLength + 2) {\r\n                    throw new Error(\"Invalid binary message format. Header content missing.\");\r\n                }\r\n\r\n                let headersString = \"\";\r\n                for (let i = 0; i < headerLength; i++) {\r\n                    headersString += String.fromCharCode((dataView).getInt8(i + 2));\r\n                }\r\n\r\n                headers = this.parseHeaders(headersString);\r\n\r\n                if (binaryMessage.byteLength > headerLength + 2) {\r\n                    body = binaryMessage.slice(2 + headerLength);\r\n                }\r\n\r\n                deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. Error: ${e}`);\r\n        }\r\n\r\n        return deferral.promise;\r\n    }\r\n\r\n    public fromConnectionMessage = (message: ConnectionMessage): Promise<RawWebsocketMessage> => {\r\n        const deferral = new Deferred<RawWebsocketMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const payload = `${this.makeHeaders(message)}${CRLF}${message.textBody ? message.textBody : \"\"}`;\r\n\r\n                deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\r\n\r\n            } else if (message.messageType === MessageType.Binary) {\r\n                const headersString = this.makeHeaders(message);\r\n                const content = message.binaryBody;\r\n\r\n                const headerBuffer = this.stringToArrayBuffer(headersString);\r\n                const headerInt8Array = new Int8Array(headerBuffer);\r\n                const headerLength = headerInt8Array.byteLength;\r\n\r\n                const payloadInt8Array = new Int8Array(2 + headerLength + (content ? content.byteLength : 0));\r\n                payloadInt8Array[0] = ((headerLength >> 8) & 0xff);\r\n                payloadInt8Array[1] = headerLength & 0xff;\r\n                payloadInt8Array.set(headerInt8Array, 2);\r\n\r\n                if (content) {\r\n                    const bodyInt8Array = new Int8Array(content);\r\n                    payloadInt8Array.set(bodyInt8Array, 2 + headerLength);\r\n                }\r\n\r\n                const payload: ArrayBuffer = payloadInt8Array.buffer;\r\n\r\n                deferral.resolve(new RawWebsocketMessage(MessageType.Binary, payload, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. ${e}`);\r\n        }\r\n\r\n        return deferral.promise;\r\n    }\r\n\r\n    private makeHeaders = (message: ConnectionMessage): string => {\r\n        let headersString: string = \"\";\r\n\r\n        if (message.headers) {\r\n            for (const header in message.headers) {\r\n                if (header) {\r\n                    headersString += `${header}: ${message.headers[header]}${CRLF}`;\r\n                }\r\n            }\r\n        }\r\n\r\n        return headersString;\r\n    }\r\n\r\n    private parseHeaders = (headersString: string): IStringDictionary<string> => {\r\n        const headers: IStringDictionary<string> = {};\r\n\r\n        if (headersString) {\r\n            const headerMatches = headersString.match(/[^\\r\\n]+/g);\r\n            if (headers) {\r\n                for (const header of headerMatches) {\r\n                    if (header) {\r\n                        const separatorIndex = header.indexOf(\":\");\r\n                        const headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;\r\n                        const headerValue =\r\n                            separatorIndex > 0 && header.length > (separatorIndex + 1) ?\r\n                                header.substr(separatorIndex + 1).trim() :\r\n                                \"\";\r\n\r\n                        headers[headerName] = headerValue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return headers;\r\n    }\r\n\r\n    private stringToArrayBuffer = (str: string): ArrayBuffer => {\r\n        const buffer = new ArrayBuffer(str.length);\r\n        const view = new DataView(buffer);\r\n        for (let i = 0; i < str.length; i++) {\r\n            view.setUint8(i, str.charCodeAt(i));\r\n        }\r\n        return buffer;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}