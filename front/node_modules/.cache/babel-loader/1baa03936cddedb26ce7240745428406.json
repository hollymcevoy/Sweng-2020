{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar isFunction_1 = require('./util/isFunction');\n\nvar Subscription_1 = require('./Subscription');\n\nvar Observer_1 = require('./Observer');\n\nvar rxSubscriber_1 = require('./symbol/rxSubscriber');\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\n\n\nvar Subscriber = function (_super) {\n  __extends(Subscriber, _super);\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n\n\n  function Subscriber(destinationOrNext, error, complete) {\n    _super.call(this);\n\n    this.syncErrorValue = null;\n    this.syncErrorThrown = false;\n    this.syncErrorThrowable = false;\n    this.isStopped = false;\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = Observer_1.empty;\n        break;\n\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = Observer_1.empty;\n          break;\n        }\n\n        if (typeof destinationOrNext === 'object') {\n          // HACK(benlesh): To resolve an issue where Node users may have multiple\n          // copies of rxjs in their node_modules directory.\n          if (isTrustedSubscriber(destinationOrNext)) {\n            var trustedSubscriber = destinationOrNext[rxSubscriber_1.rxSubscriber]();\n            this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n            this.destination = trustedSubscriber;\n            trustedSubscriber.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber(this, destinationOrNext);\n          }\n\n          break;\n        }\n\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {\n    return this;\n  };\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n\n\n  Subscriber.create = function (next, error, complete) {\n    var subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  };\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n\n\n  Subscriber.prototype.next = function (value) {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  };\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n\n\n  Subscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._error(err);\n    }\n  };\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n\n\n  Subscriber.prototype.complete = function () {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._complete();\n    }\n  };\n\n  Subscriber.prototype.unsubscribe = function () {\n    if (this.closed) {\n      return;\n    }\n\n    this.isStopped = true;\n\n    _super.prototype.unsubscribe.call(this);\n  };\n\n  Subscriber.prototype._next = function (value) {\n    this.destination.next(value);\n  };\n\n  Subscriber.prototype._error = function (err) {\n    this.destination.error(err);\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._complete = function () {\n    this.destination.complete();\n    this.unsubscribe();\n  };\n  /** @deprecated internal use only */\n\n\n  Subscriber.prototype._unsubscribeAndRecycle = function () {\n    var _a = this,\n        _parent = _a._parent,\n        _parents = _a._parents;\n\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  };\n\n  return Subscriber;\n}(Subscription_1.Subscription);\n\nexports.Subscriber = Subscriber;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar SafeSubscriber = function (_super) {\n  __extends(SafeSubscriber, _super);\n\n  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n    _super.call(this);\n\n    this._parentSubscriber = _parentSubscriber;\n    var next;\n    var context = this;\n\n    if (isFunction_1.isFunction(observerOrNext)) {\n      next = observerOrNext;\n    } else if (observerOrNext) {\n      next = observerOrNext.next;\n      error = observerOrNext.error;\n      complete = observerOrNext.complete;\n\n      if (observerOrNext !== Observer_1.empty) {\n        context = Object.create(observerOrNext);\n\n        if (isFunction_1.isFunction(context.unsubscribe)) {\n          this.add(context.unsubscribe.bind(context));\n        }\n\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  SafeSubscriber.prototype.next = function (value) {\n    if (!this.isStopped && this._next) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parentSubscriber.syncErrorValue = err;\n        _parentSubscriber.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.complete = function () {\n    var _this = this;\n\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (this._complete) {\n        var wrappedComplete = function () {\n          return _this._complete.call(_this._context);\n        };\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n\n    return false;\n  };\n  /** @deprecated internal use only */\n\n\n  SafeSubscriber.prototype._unsubscribe = function () {\n    var _parentSubscriber = this._parentSubscriber;\n    this._context = null;\n    this._parentSubscriber = null;\n\n    _parentSubscriber.unsubscribe();\n  };\n\n  return SafeSubscriber;\n}(Subscriber);\n\nfunction isTrustedSubscriber(obj) {\n  return obj instanceof Subscriber || 'syncErrorThrowable' in obj && obj[rxSubscriber_1.rxSubscriber];\n}","map":{"version":3,"mappings":"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","names":["__extends","destinationOrNext","error","complete","_super","arguments","length","destination","Observer_1","isTrustedSubscriber","trustedSubscriber","rxSubscriber_1","syncErrorThrowable","add","SafeSubscriber","Subscriber","next","subscriber","value","isStopped","_next","err","_error","_complete","closed","unsubscribe","call","_parent","_parents","Subscription_1","exports","_parentSubscriber","observerOrNext","context","isFunction_1","Object","create","bind","_context","__tryOrUnsub","__tryOrSetError","syncErrorValue","syncErrorThrown","wrappedComplete","_this","fn","parent","obj"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/src/Subscriber.ts"],"sourcesContent":["import { isFunction } from './util/isFunction';\nimport { Observer, PartialObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { rxSubscriber as rxSubscriberSymbol } from './symbol/rxSubscriber';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  public syncErrorValue: any = null;\n  public syncErrorThrown: boolean = false;\n  public syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          // HACK(benlesh): To resolve an issue where Node users may have multiple\n          // copies of rxjs in their node_modules directory.\n          if (isTrustedSubscriber(destinationOrNext)) {\n            const trustedSubscriber = destinationOrNext[rxSubscriberSymbol]() as Subscriber<any>;\n            this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n            this.destination = trustedSubscriber;\n            trustedSubscriber.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated internal use only */ _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parentSubscriber.syncErrorValue = err;\n        _parentSubscriber.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n    return false;\n  }\n\n  /** @deprecated internal use only */ _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n\nfunction isTrustedSubscriber(obj: any) {\n  return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriberSymbol]);\n}\n"]},"metadata":{},"sourceType":"script"}