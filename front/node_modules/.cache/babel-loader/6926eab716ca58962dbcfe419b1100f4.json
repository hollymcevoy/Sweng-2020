{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _LiveRegionTwinContainer = _interopRequireDefault(require(\"./private/LiveRegionTwinContainer\"));\n\nvar _Context = _interopRequireDefault(require(\"./private/Context\"));\n\nvar _useValueRef = _interopRequireDefault(require(\"../../hooks/internal/useValueRef\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar DEFAULT_ARIA_LIVE = 'polite';\nvar DEFAULT_FADE_AFTER = 1000;\n/**\n * Live region twin is an UI component for queueing texts or elements to the screen reader using\n * a container element with `aria-live` attribute set.\n *\n * After the text is rendered and queued, it will be removed to reduce burden on the DOM tree.\n * Currently, we assume the assistive technologies should pick up the text within 1 second of rendering.\n * This value is configurable.\n *\n * By default, the live region is visible. If is is not desirable, the caller can use `className` prop to\n * hide its visuals.\n */\n\nvar LiveRegionTwinComposer = function LiveRegionTwinComposer(_ref) {\n  var ariaLabel = _ref['aria-label'],\n      _ref$ariaLive = _ref['aria-live'],\n      ariaLive = _ref$ariaLive === void 0 ? DEFAULT_ARIA_LIVE : _ref$ariaLive,\n      ariaRoleDescription = _ref['aria-roledescription'],\n      children = _ref.children,\n      className = _ref.className,\n      _ref$fadeAfter = _ref.fadeAfter,\n      fadeAfter = _ref$fadeAfter === void 0 ? DEFAULT_FADE_AFTER : _ref$fadeAfter,\n      role = _ref.role;\n\n  var _useState = (0, _react.useState)([]),\n      _useState2 = _slicedToArray(_useState, 2),\n      staticElementEntries = _useState2[0],\n      setStaticElementEntries = _useState2[1];\n\n  var fadeAfterRef = (0, _useValueRef.default)(fadeAfter);\n  var markAllAsRenderedTimeoutIdRef = (0, _react.useRef)();\n  var nextKeyRef = (0, _react.useRef)(1);\n  var staticElementEntriesRef = (0, _useValueRef.default)(staticElementEntries); // This function is called by an effect hook `useMarkAllAsRenderedEffect`, it must be designed with converging in mind.\n  // To prevent infinite render loop, after multiple calls to this function, it should eventually no-op.\n\n  var markAllAsRendered = (0, _react.useCallback)(function () {\n    if (!staticElementEntriesRef.current.length) {\n      // Nothing to remove.\n      return;\n    } // When removing each element one-by-one based on an individual timeout, Narrator would narrate them twice occasionally.\n    // Possibly it think some elements that is not removed during the current cycle, are new elements and queued them twice.\n    // Thus, we are removing all at once to prevent bugs in Narrator.\n\n\n    markAllAsRenderedTimeoutIdRef.current && clearTimeout(markAllAsRenderedTimeoutIdRef.current);\n    markAllAsRenderedTimeoutIdRef.current = setTimeout(function () {\n      // We are playing safe by using value ref to check its length here.\n      // If we are certain that `setStaticElements(emptyArray => emptyArray)` is a no-op,\n      // we could replace it with just the setter function.\n      staticElementEntriesRef.current.length && setStaticElementEntries([]);\n    }, fadeAfterRef.current);\n  }, [fadeAfterRef, markAllAsRenderedTimeoutIdRef, setStaticElementEntries, staticElementEntriesRef]); // When this component is unmounting, make sure all future `setTimeout` are cleared and should not be fired.\n\n  (0, _react.useEffect)(function () {\n    return function () {\n      return markAllAsRenderedTimeoutIdRef.current && clearTimeout(markAllAsRenderedTimeoutIdRef.current);\n    };\n  }, [markAllAsRenderedTimeoutIdRef]);\n  var queueStaticElement = (0, _react.useCallback)(function (element) {\n    var key = nextKeyRef.current;\n    nextKeyRef.current = nextKeyRef.current + 1;\n    setStaticElementEntries(function (entries) {\n      return [].concat(_toConsumableArray(entries), [{\n        element: element,\n        key: key\n      }]);\n    });\n  }, [nextKeyRef, setStaticElementEntries]);\n  var staticElementEntriesState = (0, _react.useMemo)(function () {\n    return Object.freeze([Object.freeze(staticElementEntries)]);\n  }, [staticElementEntries]);\n  var context = (0, _react.useMemo)(function () {\n    return {\n      markAllAsRendered: markAllAsRendered,\n      queueStaticElement: queueStaticElement,\n      staticElementEntriesState: staticElementEntriesState\n    };\n  }, [markAllAsRendered, queueStaticElement, staticElementEntriesState]);\n  return /*#__PURE__*/_react.default.createElement(_Context.default.Provider, {\n    value: context\n  }, /*#__PURE__*/_react.default.createElement(_LiveRegionTwinContainer.default, {\n    \"aria-label\": ariaLabel,\n    \"aria-live\": ariaLive,\n    \"aria-roledescription\": ariaRoleDescription,\n    className: className,\n    role: role\n  }), children);\n};\n\nLiveRegionTwinComposer.defaultProps = {\n  'aria-label': undefined,\n  'aria-live': DEFAULT_ARIA_LIVE,\n  'aria-roledescription': undefined,\n  children: undefined,\n  className: undefined,\n  fadeAfter: DEFAULT_FADE_AFTER,\n  role: undefined\n};\nLiveRegionTwinComposer.propTypes = {\n  'aria-label': _propTypes.default.string,\n  'aria-live': _propTypes.default.oneOf(['assertive', 'polite']),\n  'aria-roledescription': _propTypes.default.string,\n  children: _propTypes.default.any,\n  className: _propTypes.default.string,\n  fadeAfter: _propTypes.default.number,\n  role: _propTypes.default.string\n};\nvar _default = LiveRegionTwinComposer;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["DEFAULT_ARIA_LIVE","DEFAULT_FADE_AFTER","LiveRegionTwinComposer","ariaLabel","ariaLive","ariaRoleDescription","children","className","fadeAfter","role","staticElementEntries","setStaticElementEntries","fadeAfterRef","markAllAsRenderedTimeoutIdRef","nextKeyRef","staticElementEntriesRef","markAllAsRendered","current","length","clearTimeout","setTimeout","queueStaticElement","element","key","entries","staticElementEntriesState","Object","freeze","context","_react","_Context","Provider","value","_LiveRegionTwinContainer","defaultProps","undefined","propTypes","PropTypes","string","oneOf","any","number"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-component/lib/src/providers/LiveRegionTwin/LiveRegionTwinComposer.tsx"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport type { FC, PropsWithChildren } from 'react';\n\nimport LiveRegionTwinContainer from './private/LiveRegionTwinContainer';\nimport LiveRegionTwinContext from './private/Context';\nimport useValueRef from '../../hooks/internal/useValueRef';\n\nimport type { StaticElement, StaticElementEntry } from './private/types';\n\nconst DEFAULT_ARIA_LIVE = 'polite';\nconst DEFAULT_FADE_AFTER = 1000;\n\ntype LiveRegionTwinComposerProps = PropsWithChildren<{\n  /** Optional \"aria-label\" attribute for the live region twin container. */\n  'aria-label'?: string;\n\n  /** \"aria-live\" attribute for the live region twin container, defaults to `'polite'`. */\n  'aria-live'?: 'assertive' | 'polite';\n\n  /** Optional \"aria-roledescription\" attribute for the live region twin container. */\n  'aria-roledescription'?: string;\n\n  /** Optional \"className\" attribute for the live region twin container. */\n  className?: string;\n\n  /**\n   * Static elements will fade out after this timeout value specified in milliseconds, defaults to `1000`.\n   *\n   * When lowering this value, make sure screen reader can continue to pick up new static elements before fading out.\n   *\n   * If this prop is updated, it will be reflected in next queueing elements.\n   */\n  fadeAfter?: number;\n\n  /** Optional \"role\" attribute for the live region twin container. */\n  role?: string;\n}>;\n\n/**\n * Live region twin is an UI component for queueing texts or elements to the screen reader using\n * a container element with `aria-live` attribute set.\n *\n * After the text is rendered and queued, it will be removed to reduce burden on the DOM tree.\n * Currently, we assume the assistive technologies should pick up the text within 1 second of rendering.\n * This value is configurable.\n *\n * By default, the live region is visible. If is is not desirable, the caller can use `className` prop to\n * hide its visuals.\n */\nconst LiveRegionTwinComposer: FC<LiveRegionTwinComposerProps> = ({\n  'aria-label': ariaLabel,\n  'aria-live': ariaLive = DEFAULT_ARIA_LIVE,\n  'aria-roledescription': ariaRoleDescription,\n  children,\n  className,\n  fadeAfter = DEFAULT_FADE_AFTER,\n  role\n}) => {\n  const [staticElementEntries, setStaticElementEntries] = useState<StaticElementEntry[]>([]);\n  const fadeAfterRef = useValueRef(fadeAfter);\n  const markAllAsRenderedTimeoutIdRef = useRef<any>();\n  const nextKeyRef = useRef<number>(1);\n\n  const staticElementEntriesRef = useValueRef(staticElementEntries);\n\n  // This function is called by an effect hook `useMarkAllAsRenderedEffect`, it must be designed with converging in mind.\n  // To prevent infinite render loop, after multiple calls to this function, it should eventually no-op.\n  const markAllAsRendered = useCallback<() => void>(() => {\n    if (!staticElementEntriesRef.current.length) {\n      // Nothing to remove.\n      return;\n    }\n\n    // When removing each element one-by-one based on an individual timeout, Narrator would narrate them twice occasionally.\n    // Possibly it think some elements that is not removed during the current cycle, are new elements and queued them twice.\n    // Thus, we are removing all at once to prevent bugs in Narrator.\n    markAllAsRenderedTimeoutIdRef.current && clearTimeout(markAllAsRenderedTimeoutIdRef.current);\n\n    markAllAsRenderedTimeoutIdRef.current = setTimeout(() => {\n      // We are playing safe by using value ref to check its length here.\n      // If we are certain that `setStaticElements(emptyArray => emptyArray)` is a no-op,\n      // we could replace it with just the setter function.\n      staticElementEntriesRef.current.length && setStaticElementEntries([]);\n    }, fadeAfterRef.current);\n  }, [fadeAfterRef, markAllAsRenderedTimeoutIdRef, setStaticElementEntries, staticElementEntriesRef]);\n\n  // When this component is unmounting, make sure all future `setTimeout` are cleared and should not be fired.\n  useEffect(\n    () => () => markAllAsRenderedTimeoutIdRef.current && clearTimeout(markAllAsRenderedTimeoutIdRef.current),\n    [markAllAsRenderedTimeoutIdRef]\n  );\n\n  const queueStaticElement = useCallback<(staticElement: StaticElement) => void>(\n    (element: StaticElement): void => {\n      const key = nextKeyRef.current;\n\n      nextKeyRef.current = nextKeyRef.current + 1;\n\n      setStaticElementEntries(entries => [...entries, { element, key }]);\n    },\n    [nextKeyRef, setStaticElementEntries]\n  );\n\n  const staticElementEntriesState = useMemo<readonly [readonly StaticElementEntry[]]>(\n    () => Object.freeze([Object.freeze(staticElementEntries)]) as readonly [readonly StaticElementEntry[]],\n    [staticElementEntries]\n  );\n\n  const context = useMemo(\n    () => ({\n      markAllAsRendered,\n      queueStaticElement,\n      staticElementEntriesState\n    }),\n    [markAllAsRendered, queueStaticElement, staticElementEntriesState]\n  );\n\n  return (\n    <LiveRegionTwinContext.Provider value={context}>\n      <LiveRegionTwinContainer\n        aria-label={ariaLabel}\n        aria-live={ariaLive}\n        aria-roledescription={ariaRoleDescription}\n        className={className}\n        role={role}\n      />\n      {children}\n    </LiveRegionTwinContext.Provider>\n  );\n};\n\nLiveRegionTwinComposer.defaultProps = {\n  'aria-label': undefined,\n  'aria-live': DEFAULT_ARIA_LIVE,\n  'aria-roledescription': undefined,\n  children: undefined,\n  className: undefined,\n  fadeAfter: DEFAULT_FADE_AFTER,\n  role: undefined\n};\n\nLiveRegionTwinComposer.propTypes = {\n  'aria-label': PropTypes.string,\n  'aria-live': PropTypes.oneOf(['assertive', 'polite']),\n  'aria-roledescription': PropTypes.string,\n  children: PropTypes.any,\n  className: PropTypes.string,\n  fadeAfter: PropTypes.number,\n  role: PropTypes.string\n};\n\nexport default LiveRegionTwinComposer;\n"]},"metadata":{},"sourceType":"script"}