{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createAudioConfig;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _microsoftCognitiveservicesSpeechSdk = require(\"microsoft-cognitiveservices-speech-sdk\");\n\nvar _CustomAudioInputStream = _interopRequireDefault(require(\"./CustomAudioInputStream\"));\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2.default)(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2.default)(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar SYMBOL_ATTACH = Symbol('attach');\nvar SYMBOL_TURN_OFF = Symbol('turnOff');\n\nvar CreateAudioConfigAudioInputStream = /*#__PURE__*/function (_CustomAudioInputStre) {\n  (0, _inherits2.default)(CreateAudioConfigAudioInputStream, _CustomAudioInputStre);\n\n  var _super = _createSuper(CreateAudioConfigAudioInputStream);\n\n  function CreateAudioConfigAudioInputStream(_ref) {\n    var _this;\n\n    var attach = _ref.attach,\n        debug = _ref.debug,\n        turnOff = _ref.turnOff;\n    (0, _classCallCheck2.default)(this, CreateAudioConfigAudioInputStream);\n\n    if (!attach || typeof attach !== 'function') {\n      throw new Error('\"attach\" must be a function.');\n    }\n\n    if (turnOff && typeof turnOff !== 'function') {\n      throw new Error('\"turnOff\", if defined, must be a function.');\n    }\n\n    _this = _super.call(this, {\n      debug: debug\n    }); // False alarm: indexer is a constant of type Symbol.\n    // eslint-disable-next-line security/detect-object-injection\n\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), SYMBOL_ATTACH, void 0);\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), SYMBOL_TURN_OFF, void 0);\n    _this[SYMBOL_ATTACH] = attach; // False alarm: indexer is a constant of type Symbol.\n    // eslint-disable-next-line security/detect-object-injection\n\n    _this[SYMBOL_TURN_OFF] = turnOff;\n    return _this;\n  }\n\n  (0, _createClass2.default)(CreateAudioConfigAudioInputStream, [{\n    key: \"performAttach\",\n    value: function performAttach(audioNodeId) {\n      // False alarm: indexer is a constant of type Symbol.\n      // eslint-disable-next-line security/detect-object-injection\n      return this[SYMBOL_ATTACH](audioNodeId);\n    }\n  }, {\n    key: \"performTurnOff\",\n    value: function performTurnOff() {\n      var turnOff = this[SYMBOL_TURN_OFF];\n      return turnOff && turnOff();\n    }\n  }]);\n  return CreateAudioConfigAudioInputStream;\n}(_CustomAudioInputStream.default);\n\nfunction createAudioConfig(options) {\n  return _microsoftCognitiveservicesSpeechSdk.AudioConfig.fromStreamInput(new CreateAudioConfigAudioInputStream(options));\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAGA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA,IAAMA,aAAa,GAAGC,MAAM,CAAC,QAAD,CAA5B;AACA,IAAMC,eAAe,GAAGD,MAAM,CAAC,SAAD,CAA9B;;IAiBME,iC;;;;;AACJ,mDAAkE;AAAA;;AAAA,QAApDC,MAAoD,QAApDA,MAAoD;AAAA,QAA5CC,KAA4C,QAA5CA,KAA4C;AAAA,QAArCC,OAAqC,QAArCA,OAAqC;AAAA;;AAChE,QAAI,CAACF,MAAD,IAAW,OAAOA,MAAP,KAAkB,UAAjC,EAA6C;AAC3C,YAAM,IAAIG,KAAJ,CAAU,8BAAV,CAAN;AACD;;AAED,QAAID,OAAO,IAAI,OAAOA,OAAP,KAAmB,UAAlC,EAA8C;AAC5C,YAAM,IAAIC,KAAJ,CAAU,4CAAV,CAAN;AACD;;AAEDC,8BAAM;AAAEH,WAAK,EAALA;AAAF,KAAN,EATgE,CAWhE;AACA;;AAZgE,+EAoBjEL,aApBiE;AAAA,+EAqBjEE,eArBiE;AAahEM,UAAKR,aAAL,IAAsBI,MAAtB,CAbgE,CAehE;AACA;;AACAI,UAAKN,eAAL,IAAwBI,OAAxB;AAjBgE;AAkBjE;;;;WAKD,uBAAwBG,WAAxB,EAIG;AACD;AACA;AACA,aAAO,KAAKT,aAAL,EAAoBS,WAApB,CAAP;AACD;;;WAED,0BAA0C;AACxC,UAA2BH,OAA3B,GAAuC,KAA9BJ,eAA8B,CAAvC;AAEA,aAAOI,OAAO,IAAIA,OAAO,EAAzB;AACD;;;EAtC6CI,+B;;AAyCjC,SAASC,iBAAT,CAA2BC,OAA3B,EAA8D;AAC3E,SAAOC,iDAAYC,eAAZD,CAA4B,IAAIV,iCAAJ,CAAsCS,OAAtC,CAA5BC,CAAP;AACD","names":["SYMBOL_ATTACH","Symbol","SYMBOL_TURN_OFF","CreateAudioConfigAudioInputStream","attach","debug","turnOff","Error","_this","audioNodeId","CustomAudioInputStream","createAudioConfig","options","AudioConfig","fromStreamInput"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat/lib/src/speech/createAudioConfig.ts"],"sourcesContent":["// TODO: [P2] #3976 We should export this to allow web developers to bring in their own microphone.\n//       For example, it should enable React Native devs to bring in their microphone implementation and use Cognitive Services Speech Services.\n\nimport { AudioConfig } from 'microsoft-cognitiveservices-speech-sdk';\n\nimport CustomAudioInputStream, { AudioStreamNode, DeviceInfo, Format } from './CustomAudioInputStream';\n\ntype AttachFunction = (audioNodeId: string) => Promise<{\n  audioStreamNode: AudioStreamNode;\n  deviceInfo: DeviceInfo;\n  format: Format;\n}>;\n\ntype TurnOffFunction = () => Promise<void>;\n\nconst SYMBOL_ATTACH = Symbol('attach');\nconst SYMBOL_TURN_OFF = Symbol('turnOff');\n\ntype CreateAudioConfigOptions = {\n  /** Callback function for attaching the device by returning an audio node. */\n  attach: AttachFunction;\n\n  /** `true` to enable diagnostic information, otherwise, `false`. */\n  debug?: true;\n\n  /**\n   * Callback function for turning off the device before detaching its node from an audio graph.\n   *\n   * Note: this is not called for Direct Line Speech.\n   */\n  turnOff?: TurnOffFunction;\n};\n\nclass CreateAudioConfigAudioInputStream extends CustomAudioInputStream {\n  constructor({ attach, debug, turnOff }: CreateAudioConfigOptions) {\n    if (!attach || typeof attach !== 'function') {\n      throw new Error('\"attach\" must be a function.');\n    }\n\n    if (turnOff && typeof turnOff !== 'function') {\n      throw new Error('\"turnOff\", if defined, must be a function.');\n    }\n\n    super({ debug });\n\n    // False alarm: indexer is a constant of type Symbol.\n    // eslint-disable-next-line security/detect-object-injection\n    this[SYMBOL_ATTACH] = attach;\n\n    // False alarm: indexer is a constant of type Symbol.\n    // eslint-disable-next-line security/detect-object-injection\n    this[SYMBOL_TURN_OFF] = turnOff;\n  }\n\n  [SYMBOL_ATTACH]: AttachFunction;\n  [SYMBOL_TURN_OFF]: TurnOffFunction;\n\n  protected performAttach(audioNodeId: string): Promise<{\n    audioStreamNode: AudioStreamNode;\n    deviceInfo: DeviceInfo;\n    format: Format;\n  }> {\n    // False alarm: indexer is a constant of type Symbol.\n    // eslint-disable-next-line security/detect-object-injection\n    return this[SYMBOL_ATTACH](audioNodeId);\n  }\n\n  protected performTurnOff(): Promise<void> {\n    const { [SYMBOL_TURN_OFF]: turnOff } = this;\n\n    return turnOff && turnOff();\n  }\n}\n\nexport default function createAudioConfig(options: CreateAudioConfigOptions) {\n  return AudioConfig.fromStreamInput(new CreateAudioConfigAudioInputStream(options));\n}\n"]},"metadata":{},"sourceType":"script"}