{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MicAudioSource = exports.AudioWorkletSourceURLPropertyName = void 0;\n\nvar Exports_1 = require(\"../common.speech/Exports\");\n\nvar Exports_2 = require(\"../common/Exports\");\n\nvar AudioStreamFormat_1 = require(\"../sdk/Audio/AudioStreamFormat\");\n\nexports.AudioWorkletSourceURLPropertyName = \"MICROPHONE-WorkletSourceUrl\";\n\nvar MicAudioSource =\n/** @class */\nfunction () {\n  function MicAudioSource(privRecorder, deviceId, audioSourceId, mediaStream) {\n    var _this = this;\n\n    this.privRecorder = privRecorder;\n    this.deviceId = deviceId;\n    this.privStreams = {};\n\n    this.turnOn = function () {\n      if (_this.privInitializeDeferral) {\n        return _this.privInitializeDeferral.promise;\n      }\n\n      _this.privInitializeDeferral = new Exports_2.Deferred();\n\n      try {\n        _this.createAudioContext();\n      } catch (error) {\n        if (error instanceof Error) {\n          var typedError = error;\n\n          _this.privInitializeDeferral.reject(typedError.name + \": \" + typedError.message);\n        } else {\n          _this.privInitializeDeferral.reject(error);\n        }\n\n        return _this.privInitializeDeferral.promise;\n      }\n\n      var nav = window.navigator;\n      var getUserMedia = nav.getUserMedia || nav.webkitGetUserMedia || nav.mozGetUserMedia || nav.msGetUserMedia;\n\n      if (!!nav.mediaDevices) {\n        getUserMedia = function (constraints, successCallback, errorCallback) {\n          nav.mediaDevices.getUserMedia(constraints).then(successCallback).catch(errorCallback);\n        };\n      }\n\n      if (!getUserMedia) {\n        var errorMsg = \"Browser does not support getUserMedia.\";\n\n        _this.privInitializeDeferral.reject(errorMsg);\n\n        _this.onEvent(new Exports_2.AudioSourceErrorEvent(errorMsg, \"\")); // mic initialized error - no streamid at this point\n\n      } else {\n        var next = function () {\n          _this.onEvent(new Exports_2.AudioSourceInitializingEvent(_this.privId)); // no stream id\n\n\n          if (_this.privMediaStream && _this.privMediaStream.active) {\n            _this.onEvent(new Exports_2.AudioSourceReadyEvent(_this.privId));\n\n            _this.privInitializeDeferral.resolve();\n          } else {\n            getUserMedia({\n              audio: _this.deviceId ? {\n                deviceId: _this.deviceId\n              } : true,\n              video: false\n            }, function (mediaStream) {\n              _this.privMediaStream = mediaStream;\n\n              _this.onEvent(new Exports_2.AudioSourceReadyEvent(_this.privId));\n\n              _this.privInitializeDeferral.resolve();\n            }, function (error) {\n              var errorMsg = \"Error occurred during microphone initialization: \" + error;\n\n              _this.privInitializeDeferral.reject(errorMsg);\n\n              _this.onEvent(new Exports_2.AudioSourceErrorEvent(_this.privId, errorMsg));\n            });\n          }\n        };\n\n        if (_this.privContext.state === \"suspended\") {\n          // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.\n          // https://github.com/WebAudio/web-audio-api/issues/790\n          _this.privContext.resume().then(next).catch(function (reason) {\n            _this.privInitializeDeferral.reject(\"Failed to initialize audio context: \" + reason);\n          });\n        } else {\n          next();\n        }\n      }\n\n      return _this.privInitializeDeferral.promise;\n    };\n\n    this.id = function () {\n      return _this.privId;\n    };\n\n    this.attach = function (audioNodeId) {\n      _this.onEvent(new Exports_2.AudioStreamNodeAttachingEvent(_this.privId, audioNodeId));\n\n      return _this.listen(audioNodeId).then(function (stream) {\n        _this.onEvent(new Exports_2.AudioStreamNodeAttachedEvent(_this.privId, audioNodeId));\n\n        return {\n          detach: function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                stream.readEnded();\n                delete this.privStreams[audioNodeId];\n                this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                return [2\n                /*return*/\n                , this.turnOff()];\n              });\n            });\n          },\n          id: function () {\n            return audioNodeId;\n          },\n          read: function () {\n            return stream.read();\n          }\n        };\n      });\n    };\n\n    this.detach = function (audioNodeId) {\n      if (audioNodeId && _this.privStreams[audioNodeId]) {\n        _this.privStreams[audioNodeId].close();\n\n        delete _this.privStreams[audioNodeId];\n\n        _this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(_this.privId, audioNodeId));\n      }\n    };\n\n    this.listen = function (audioNodeId) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var stream, result;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.turnOn()];\n\n            case 1:\n              _a.sent();\n\n              stream = new Exports_2.ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);\n              this.privStreams[audioNodeId] = stream;\n\n              try {\n                this.privRecorder.record(this.privContext, this.privMediaStream, stream);\n              } catch (error) {\n                this.onEvent(new Exports_2.AudioStreamNodeErrorEvent(this.privId, audioNodeId, error));\n                throw error;\n              }\n\n              result = stream;\n              return [2\n              /*return*/\n              , result];\n          }\n        });\n      });\n    };\n\n    this.onEvent = function (event) {\n      _this.privEvents.onEvent(event);\n\n      Exports_2.Events.instance.onEvent(event);\n    };\n\n    this.createAudioContext = function () {\n      if (!!_this.privContext) {\n        return;\n      }\n\n      _this.privContext = AudioStreamFormat_1.AudioStreamFormatImpl.getAudioContext(MicAudioSource.AUDIOFORMAT.samplesPerSec);\n    };\n\n    this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10;\n    this.privId = audioSourceId ? audioSourceId : Exports_2.createNoDashGuid();\n    this.privEvents = new Exports_2.EventSource();\n    this.privMediaStream = mediaStream || null;\n  }\n\n  Object.defineProperty(MicAudioSource.prototype, \"format\", {\n    get: function () {\n      return Promise.resolve(MicAudioSource.AUDIOFORMAT);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MicAudioSource.prototype, \"blob\", {\n    get: function () {\n      return Promise.reject(\"Not implemented for Mic input\");\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MicAudioSource.prototype.turnOff = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var streamId, stream;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            for (streamId in this.privStreams) {\n              if (streamId) {\n                stream = this.privStreams[streamId];\n\n                if (stream) {\n                  stream.close();\n                }\n              }\n            }\n\n            this.onEvent(new Exports_2.AudioSourceOffEvent(this.privId)); // no stream now\n\n            if (!this.privInitializeDeferral) return [3\n            /*break*/\n            , 2]; // Correctly handle when browser forces mic off before turnOn() completes\n\n            return [4\n            /*yield*/\n            , this.privInitializeDeferral];\n\n          case 1:\n            // Correctly handle when browser forces mic off before turnOn() completes\n            _a.sent();\n\n            this.privInitializeDeferral = null;\n            _a.label = 2;\n\n          case 2:\n            return [4\n            /*yield*/\n            , this.destroyAudioContext()];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Object.defineProperty(MicAudioSource.prototype, \"events\", {\n    get: function () {\n      return this.privEvents;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(MicAudioSource.prototype, \"deviceInfo\", {\n    get: function () {\n      return this.getMicrophoneLabel().then(function (label) {\n        return {\n          bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,\n          channelcount: MicAudioSource.AUDIOFORMAT.channels,\n          connectivity: Exports_1.connectivity.Unknown,\n          manufacturer: \"Speech SDK\",\n          model: label,\n          samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,\n          type: Exports_1.type.Microphones\n        };\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  MicAudioSource.prototype.setProperty = function (name, value) {\n    if (name === exports.AudioWorkletSourceURLPropertyName) {\n      this.privRecorder.setWorkletUrl(value);\n    } else {\n      throw new Error(\"Property '\" + name + \"' is not supported on Microphone.\");\n    }\n  };\n\n  MicAudioSource.prototype.getMicrophoneLabel = function () {\n    var _this = this;\n\n    var defaultMicrophoneName = \"microphone\"; // If we did this already, return the value.\n\n    if (this.privMicrophoneLabel !== undefined) {\n      return Promise.resolve(this.privMicrophoneLabel);\n    } // If the stream isn't currently running, we can't query devices because security.\n\n\n    if (this.privMediaStream === undefined || !this.privMediaStream.active) {\n      return Promise.resolve(defaultMicrophoneName);\n    } // Setup a default\n\n\n    this.privMicrophoneLabel = defaultMicrophoneName; // Get the id of the device running the audio track.\n\n    var microphoneDeviceId = this.privMediaStream.getTracks()[0].getSettings().deviceId; // If the browser doesn't support getting the device ID, set a default and return.\n\n    if (undefined === microphoneDeviceId) {\n      return Promise.resolve(this.privMicrophoneLabel);\n    }\n\n    var deferred = new Exports_2.Deferred(); // Enumerate the media devices.\n\n    navigator.mediaDevices.enumerateDevices().then(function (devices) {\n      for (var _i = 0, devices_1 = devices; _i < devices_1.length; _i++) {\n        var device = devices_1[_i];\n\n        if (device.deviceId === microphoneDeviceId) {\n          // Found the device\n          _this.privMicrophoneLabel = device.label;\n          break;\n        }\n      }\n\n      deferred.resolve(_this.privMicrophoneLabel);\n    }, function () {\n      return deferred.resolve(_this.privMicrophoneLabel);\n    });\n    return deferred.promise;\n  };\n\n  MicAudioSource.prototype.destroyAudioContext = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var hasClose;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.privContext) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            this.privRecorder.releaseMediaResources(this.privContext);\n            hasClose = false;\n\n            if (\"close\" in this.privContext) {\n              hasClose = true;\n            }\n\n            if (!hasClose) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.privContext.close()];\n\n          case 1:\n            _a.sent();\n\n            this.privContext = null;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            if (!(null !== this.privContext && this.privContext.state === \"running\")) return [3\n            /*break*/\n            , 4]; // Suspend actually takes a callback, but analogous to the\n            // resume method, it'll be only fired if suspend is called\n            // in a direct response to a user action. The later is not always\n            // the case, as TurnOff is also called, when we receive an\n            // end-of-speech message from the service. So, doing a best effort\n            // fire-and-forget here.\n\n            return [4\n            /*yield*/\n            , this.privContext.suspend()];\n\n          case 3:\n            // Suspend actually takes a callback, but analogous to the\n            // resume method, it'll be only fired if suspend is called\n            // in a direct response to a user action. The later is not always\n            // the case, as TurnOff is also called, when we receive an\n            // end-of-speech message from the service. So, doing a best effort\n            // fire-and-forget here.\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  MicAudioSource.AUDIOFORMAT = AudioStreamFormat_1.AudioStreamFormat.getDefaultInputFormat();\n  return MicAudioSource;\n}();\n\nexports.MicAudioSource = MicAudioSource;","map":{"version":3,"mappings":"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","names":["exports","privRecorder","deviceId","audioSourceId","mediaStream","_this","privInitializeDeferral","promise","Exports_2","createAudioContext","error","Error","typedError","reject","name","message","nav","window","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","mediaDevices","constraints","successCallback","errorCallback","then","catch","errorMsg","onEvent","next","privId","privMediaStream","active","resolve","audio","video","privContext","state","resume","reason","audioNodeId","listen","stream","detach","readEnded","privStreams","turnOff","id","read","close","turnOn","_a","privOutputChunkSize","record","result","event","privEvents","instance","AudioStreamFormat_1","getAudioContext","MicAudioSource","AUDIOFORMAT","samplesPerSec","avgBytesPerSec","Object","Promise","streamId","destroyAudioContext","getMicrophoneLabel","label","bitspersample","bitsPerSample","channelcount","channels","connectivity","Exports_1","Unknown","manufacturer","model","samplerate","type","Microphones","value","setWorkletUrl","defaultMicrophoneName","privMicrophoneLabel","undefined","microphoneDeviceId","getTracks","getSettings","deferred","enumerateDevices","devices","_i","device","releaseMediaResources","hasClose","suspend","getDefaultInputFormat"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/src/common.browser/MicAudioSource.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    connectivity,\r\n    ISpeechConfigAudioDevice,\r\n    type\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioSourceEvent,\r\n    AudioSourceInitializingEvent,\r\n    AudioSourceOffEvent,\r\n    AudioSourceReadyEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ChunkedArrayBufferStream,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IStringDictionary,\r\n    Stream,\r\n} from \"../common/Exports\";\r\nimport {\r\n    AudioStreamFormat,\r\n    AudioStreamFormatImpl,\r\n} from \"../sdk/Audio/AudioStreamFormat\";\r\nimport { IRecorder } from \"./IRecorder\";\r\n\r\n// Extending the default definition with browser specific definitions for backward compatibility\r\ninterface INavigator extends Navigator {\r\n    webkitGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n    mozGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n    msGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n}\r\n\r\nexport const AudioWorkletSourceURLPropertyName = \"MICROPHONE-WorkletSourceUrl\";\r\n\r\nexport class MicAudioSource implements IAudioSource {\r\n\r\n    private static readonly AUDIOFORMAT: AudioStreamFormatImpl = AudioStreamFormat.getDefaultInputFormat() as AudioStreamFormatImpl;\r\n\r\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\r\n\r\n    private privId: string;\r\n\r\n    private privEvents: EventSource<AudioSourceEvent>;\r\n\r\n    private privInitializeDeferral: Deferred<void>;\r\n\r\n    private privMediaStream: MediaStream;\r\n\r\n    private privContext: AudioContext;\r\n\r\n    private privMicrophoneLabel: string;\r\n\r\n    private privOutputChunkSize: number;\r\n\r\n    public constructor(\r\n        private readonly privRecorder: IRecorder,\r\n        private readonly deviceId?: string,\r\n        audioSourceId?: string,\r\n        mediaStream?: MediaStream\r\n        ) {\r\n\r\n        this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10;\r\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\r\n        this.privEvents = new EventSource<AudioSourceEvent>();\r\n        this.privMediaStream = mediaStream || null;\r\n    }\r\n\r\n    public get format(): Promise<AudioStreamFormatImpl> {\r\n        return Promise.resolve(MicAudioSource.AUDIOFORMAT);\r\n    }\r\n\r\n    public get blob(): Promise<Blob> {\r\n        return Promise.reject(\"Not implemented for Mic input\");\r\n    }\r\n\r\n    public turnOn = (): Promise<void> => {\r\n        if (this.privInitializeDeferral) {\r\n            return this.privInitializeDeferral.promise;\r\n        }\r\n\r\n        this.privInitializeDeferral = new Deferred<void>();\r\n\r\n        try {\r\n            this.createAudioContext();\r\n        } catch (error) {\r\n            if (error instanceof Error) {\r\n                const typedError: Error = error as Error;\r\n                this.privInitializeDeferral.reject(typedError.name + \": \" + typedError.message);\r\n            } else {\r\n                this.privInitializeDeferral.reject(error);\r\n            }\r\n            return this.privInitializeDeferral.promise;\r\n        }\r\n\r\n        const nav = window.navigator as INavigator;\r\n\r\n        let getUserMedia = (\r\n            nav.getUserMedia ||\r\n            nav.webkitGetUserMedia ||\r\n            nav.mozGetUserMedia ||\r\n            nav.msGetUserMedia\r\n        );\r\n\r\n        if (!!nav.mediaDevices) {\r\n            getUserMedia = (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void => {\r\n                nav.mediaDevices\r\n                    .getUserMedia(constraints)\r\n                    .then(successCallback)\r\n                    .catch(errorCallback);\r\n            };\r\n        }\r\n\r\n        if (!getUserMedia) {\r\n            const errorMsg = \"Browser does not support getUserMedia.\";\r\n            this.privInitializeDeferral.reject(errorMsg);\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // mic initialized error - no streamid at this point\r\n        } else {\r\n            const next = () => {\r\n                this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\r\n                if (this.privMediaStream && this.privMediaStream.active) {\r\n                    this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n                    this.privInitializeDeferral.resolve();\r\n                } else {\r\n                    getUserMedia(\r\n                        { audio: this.deviceId ? { deviceId: this.deviceId } : true, video: false },\r\n                        (mediaStream: MediaStream) => {\r\n                            this.privMediaStream = mediaStream;\r\n                            this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n                            this.privInitializeDeferral.resolve();\r\n                        }, (error: MediaStreamError) => {\r\n                            const errorMsg = `Error occurred during microphone initialization: ${error}`;\r\n                            this.privInitializeDeferral.reject(errorMsg);\r\n                            this.onEvent(new AudioSourceErrorEvent(this.privId, errorMsg));\r\n                        });\r\n                }\r\n            };\r\n\r\n            if (this.privContext.state === \"suspended\") {\r\n                // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.\r\n                // https://github.com/WebAudio/web-audio-api/issues/790\r\n                this.privContext.resume()\r\n                    .then(next)\r\n                    .catch((reason: any) => {\r\n                        this.privInitializeDeferral.reject(`Failed to initialize audio context: ${reason}`);\r\n                    });\r\n            } else {\r\n                next();\r\n            }\r\n        }\r\n\r\n        return this.privInitializeDeferral.promise;\r\n    }\r\n\r\n    public id = (): string => {\r\n        return this.privId;\r\n    }\r\n\r\n    public attach = (audioNodeId: string): Promise<IAudioStreamNode> => {\r\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\r\n\r\n        return this.listen(audioNodeId).then<IAudioStreamNode>(\r\n            (stream: Stream<ArrayBuffer>) => {\r\n                this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\r\n                return {\r\n                    detach: async () => {\r\n                        stream.readEnded();\r\n                        delete this.privStreams[audioNodeId];\r\n                        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n                        return this.turnOff();\r\n                    },\r\n                    id: () => {\r\n                        return audioNodeId;\r\n                    },\r\n                    read: () => {\r\n                        return stream.read();\r\n                    },\r\n                };\r\n            });\r\n    }\r\n\r\n    public detach = (audioNodeId: string): void => {\r\n        if (audioNodeId && this.privStreams[audioNodeId]) {\r\n            this.privStreams[audioNodeId].close();\r\n            delete this.privStreams[audioNodeId];\r\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n        }\r\n    }\r\n\r\n    public async turnOff(): Promise<void> {\r\n        for (const streamId in this.privStreams) {\r\n            if (streamId) {\r\n                const stream = this.privStreams[streamId];\r\n                if (stream) {\r\n                    stream.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\r\n        if (this.privInitializeDeferral) {\r\n            // Correctly handle when browser forces mic off before turnOn() completes\r\n            await this.privInitializeDeferral;\r\n            this.privInitializeDeferral = null;\r\n        }\r\n\r\n        await this.destroyAudioContext();\r\n\r\n        return;\r\n    }\r\n\r\n    public get events(): EventSource<AudioSourceEvent> {\r\n        return this.privEvents;\r\n    }\r\n\r\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\r\n        return this.getMicrophoneLabel().then((label: string) => {\r\n            return {\r\n                bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,\r\n                channelcount: MicAudioSource.AUDIOFORMAT.channels,\r\n                connectivity: connectivity.Unknown,\r\n                manufacturer: \"Speech SDK\",\r\n                model: label,\r\n                samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,\r\n                type: type.Microphones,\r\n            };\r\n        });\r\n    }\r\n\r\n    public setProperty(name: string, value: string): void {\r\n        if (name === AudioWorkletSourceURLPropertyName) {\r\n            this.privRecorder.setWorkletUrl(value);\r\n        } else {\r\n            throw new Error(\"Property '\" + name + \"' is not supported on Microphone.\");\r\n        }\r\n    }\r\n\r\n    private getMicrophoneLabel(): Promise<string> {\r\n        const defaultMicrophoneName: string = \"microphone\";\r\n\r\n        // If we did this already, return the value.\r\n        if (this.privMicrophoneLabel !== undefined) {\r\n            return Promise.resolve(this.privMicrophoneLabel);\r\n        }\r\n\r\n        // If the stream isn't currently running, we can't query devices because security.\r\n        if (this.privMediaStream === undefined || !this.privMediaStream.active) {\r\n            return Promise.resolve(defaultMicrophoneName);\r\n        }\r\n\r\n        // Setup a default\r\n        this.privMicrophoneLabel = defaultMicrophoneName;\r\n\r\n        // Get the id of the device running the audio track.\r\n        const microphoneDeviceId: string = this.privMediaStream.getTracks()[0].getSettings().deviceId;\r\n\r\n        // If the browser doesn't support getting the device ID, set a default and return.\r\n        if (undefined === microphoneDeviceId) {\r\n            return Promise.resolve(this.privMicrophoneLabel);\r\n        }\r\n\r\n        const deferred: Deferred<string> = new Deferred<string>();\r\n\r\n        // Enumerate the media devices.\r\n        navigator.mediaDevices.enumerateDevices().then((devices: MediaDeviceInfo[]) => {\r\n            for (const device of devices) {\r\n                if (device.deviceId === microphoneDeviceId) {\r\n                    // Found the device\r\n                    this.privMicrophoneLabel = device.label;\r\n                    break;\r\n                }\r\n            }\r\n            deferred.resolve(this.privMicrophoneLabel);\r\n        }, () => deferred.resolve(this.privMicrophoneLabel));\r\n\r\n        return deferred.promise;\r\n    }\r\n\r\n    private listen = async (audioNodeId: string): Promise<Stream<ArrayBuffer>> => {\r\n        await this.turnOn();\r\n        const stream = new ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);\r\n        this.privStreams[audioNodeId] = stream;\r\n        try {\r\n            this.privRecorder.record(this.privContext, this.privMediaStream, stream);\r\n        } catch (error) {\r\n            this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, error));\r\n            throw error;\r\n        }\r\n        const result: Stream<ArrayBuffer> = stream;\r\n        return result;\r\n    }\r\n\r\n    private onEvent = (event: AudioSourceEvent): void => {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private createAudioContext = (): void => {\r\n        if (!!this.privContext) {\r\n            return;\r\n        }\r\n\r\n        this.privContext = AudioStreamFormatImpl.getAudioContext(MicAudioSource.AUDIOFORMAT.samplesPerSec);\r\n    }\r\n\r\n    private async destroyAudioContext(): Promise<void> {\r\n        if (!this.privContext) {\r\n            return;\r\n        }\r\n\r\n        this.privRecorder.releaseMediaResources(this.privContext);\r\n\r\n        // This pattern brought to you by a bug in the TypeScript compiler where it\r\n        // confuses the (\"close\" in this.privContext) with this.privContext always being null as the alternate.\r\n        // https://github.com/Microsoft/TypeScript/issues/11498\r\n        let hasClose: boolean = false;\r\n        if (\"close\" in this.privContext) {\r\n            hasClose = true;\r\n        }\r\n\r\n        if (hasClose) {\r\n            await this.privContext.close();\r\n            this.privContext = null;\r\n        } else if (null !== this.privContext && this.privContext.state === \"running\") {\r\n            // Suspend actually takes a callback, but analogous to the\r\n            // resume method, it'll be only fired if suspend is called\r\n            // in a direct response to a user action. The later is not always\r\n            // the case, as TurnOff is also called, when we receive an\r\n            // end-of-speech message from the service. So, doing a best effort\r\n            // fire-and-forget here.\r\n            await this.privContext.suspend();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}