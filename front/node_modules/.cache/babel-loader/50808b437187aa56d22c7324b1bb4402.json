{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 100] }] */\nimport memoize from 'memoize-one';\nimport { useEffect } from 'react';\nimport debounce from '../../util/debounce';\n\nfunction sleepZero() {\n  return new Promise(function (resolve) {\n    return setTimeout(function () {\n      return resolve();\n    });\n  });\n}\n\nexport default function useObserveScrollLeft(callbackRefWithSubscribe, observer) {\n  useEffect(function () {\n    return callbackRefWithSubscribe.subscribe(function (current) {\n      if (!current) {\n        return;\n      }\n\n      var memoizedEmitValue = memoize(function (initial, fraction, width) {\n        return observer && observer({\n          initial: initial,\n          fraction: fraction,\n          width: width\n        });\n      });\n\n      var emitValue = function emitValue(initial) {\n        var offsetWidth = current.offsetWidth,\n            scrollLeft = current.scrollLeft,\n            scrollWidth = current.scrollWidth;\n        memoizedEmitValue(initial, \"\".concat(scrollWidth === offsetWidth ? 0 : scrollLeft / (scrollWidth - offsetWidth) * 100, \"%\"), \"\".concat(offsetWidth / scrollWidth * 100, \"%\"));\n      };\n\n      var handleScroll = function handleScroll() {\n        return emitValue(false);\n      };\n\n      var handlePointerOver = debounce(function () {\n        // We need to send \"onScroll\" because \"scrollWidth\" might have changed\n        // For example, the container resized, the scroll width will be incorrect\n        // We will debounce to prevent \"pointerOver\" calculating too often\n        // We will memoize to prevent firing unnecessary \"onScroll\"\n        emitValue(false);\n      });\n      current.addEventListener('pointerover', handlePointerOver, {\n        passive: true\n      });\n      current.addEventListener('scroll', handleScroll, {\n        passive: true\n      }); // eslint-disable-next-line wrap-iife\n\n      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(current.scrollWidth === current.offsetWidth)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                _context.next = 3;\n                return sleepZero();\n\n              case 3:\n                emitValue(true);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n\n      return function () {\n        current.removeEventListener('pointerover', handlePointerOver);\n        current.removeEventListener('scroll', handleScroll);\n      };\n    });\n  }, [callbackRefWithSubscribe, observer]);\n}","map":{"version":3,"mappings":";;;AAAA;AAEA,OAAOA,OAAP,MAAoB,aAApB;AACA,SAASC,SAAT,QAA0B,OAA1B;AAEA,OAAOC,QAAP,MAAqB,qBAArB;;AAEA,SAASC,SAAT,GAAqB;AACnB,SAAO,IAAIC,OAAJ,CAAY,mBAAO;AAAA,WAAIC,UAAU,CAAC;AAAA,aAAMC,OAAO,EAAb;AAAD,MAAd;AAAnB,IAAP;AACD;;AAED,eAAe,SAASC,oBAAT,CAA8BC,wBAA9B,EAAwDC,QAAxD,EAAkE;AAC/ER,WAAS,CACP;AAAA,WACEO,wBAAwB,CAACE,SAAzBF,CAAmC,mBAAW;AAC5C,UAAI,CAACG,OAAL,EAAc;AACZ;AACD;;AAED,UAAMC,iBAAiB,GAAGZ,OAAO,CAC/B,UAACa,OAAD,EAAUC,QAAV,EAAoBC,KAApB;AAAA,eAA8BN,QAAQ,IAAIA,QAAQ,CAAC;AAAEI,iBAAO,EAAPA,OAAF;AAAWC,kBAAQ,EAARA,QAAX;AAAqBC,eAAK,EAALA;AAArB,SAAD,CAAlD;AAD+B,QAAjC;;AAIA,UAAMC,SAAS,GAAG,SAAZA,SAAY,UAAW;AAC3B,YAAQC,WAAR,GAAiDN,OAAjD,CAAQM,WAAR;AAAA,YAAqBC,UAArB,GAAiDP,OAAjD,CAAqBO,UAArB;AAAA,YAAiCC,WAAjC,GAAiDR,OAAjD,CAAiCQ,WAAjC;AAEAP,yBAAiB,CACfC,OADe,YAEZM,WAAW,KAAKF,WAAhBE,GAA8B,CAA9BA,GAAmCD,UAAU,IAAIC,WAAW,GAAGF,WAAlB,CAAVC,GAA4C,GAFnE,kBAGXD,WAAW,GAAGE,WAAdF,GAA6B,GAHlB,OAAjBL;AAHF;;AAUA,UAAMQ,YAAY,GAAG,SAAfA,YAAe;AAAA,eAAMJ,SAAS,CAAC,KAAD,CAAf;AAArB;;AAEA,UAAMK,iBAAiB,GAAGnB,QAAQ,CAAC,YAAM;AACvC;AACA;AACA;AACA;AACAc,iBAAS,CAAC,KAAD,CAATA;AALgC,QAAlC;AAQAL,aAAO,CAACW,gBAARX,CAAyB,aAAzBA,EAAwCU,iBAAxCV,EAA2D;AAAEY,eAAO,EAAE;AAAX,OAA3DZ;AACAA,aAAO,CAACW,gBAARX,CAAyB,QAAzBA,EAAmCS,YAAnCT,EAAiD;AAAEY,eAAO,EAAE;AAAX,OAAjDZ,EA9B4C,CAgC5C;;AACAa,+DAAC;AAAA;AAAA;AAAA;AAAA;AAAA,sBACKb,OAAO,CAACQ,WAARR,KAAwBA,OAAO,CAACM,WADrC;AAAAQ;AAAA;AAAA;;AAAAA;AAAA,uBAGStB,SAAS,EAHlB;;AAAA;AAMCa,yBAAS,CAAC,IAAD,CAATA;;AAND;AAAA;AAAA;AAAA;AAAA;AAAA;AAAD;;AASA,aAAO,YAAM;AACXL,eAAO,CAACe,mBAARf,CAA4B,aAA5BA,EAA2CU,iBAA3CV;AACAA,eAAO,CAACe,mBAARf,CAA4B,QAA5BA,EAAsCS,YAAtCT;AAFF;AA1CF,MADF;AADO,KAiDP,CAACH,wBAAD,EAA2BC,QAA3B,CAjDO,CAATR;AAmDD","names":["memoize","useEffect","debounce","sleepZero","Promise","setTimeout","resolve","useObserveScrollLeft","callbackRefWithSubscribe","observer","subscribe","current","memoizedEmitValue","initial","fraction","width","emitValue","offsetWidth","scrollLeft","scrollWidth","handleScroll","handlePointerOver","addEventListener","passive","_asyncToGenerator","_context","removeEventListener"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/react-film/src/hooks/internal/useObserveScrollLeft.js"],"sourcesContent":["/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 100] }] */\n\nimport memoize from 'memoize-one';\nimport { useEffect } from 'react';\n\nimport debounce from '../../util/debounce';\n\nfunction sleepZero() {\n  return new Promise(resolve => setTimeout(() => resolve()));\n}\n\nexport default function useObserveScrollLeft(callbackRefWithSubscribe, observer) {\n  useEffect(\n    () =>\n      callbackRefWithSubscribe.subscribe(current => {\n        if (!current) {\n          return;\n        }\n\n        const memoizedEmitValue = memoize(\n          (initial, fraction, width) => observer && observer({ initial, fraction, width })\n        );\n\n        const emitValue = initial => {\n          const { offsetWidth, scrollLeft, scrollWidth } = current;\n\n          memoizedEmitValue(\n            initial,\n            `${scrollWidth === offsetWidth ? 0 : (scrollLeft / (scrollWidth - offsetWidth)) * 100}%`,\n            `${(offsetWidth / scrollWidth) * 100}%`\n          );\n        };\n\n        const handleScroll = () => emitValue(false);\n\n        const handlePointerOver = debounce(() => {\n          // We need to send \"onScroll\" because \"scrollWidth\" might have changed\n          // For example, the container resized, the scroll width will be incorrect\n          // We will debounce to prevent \"pointerOver\" calculating too often\n          // We will memoize to prevent firing unnecessary \"onScroll\"\n          emitValue(false);\n        });\n\n        current.addEventListener('pointerover', handlePointerOver, { passive: true });\n        current.addEventListener('scroll', handleScroll, { passive: true });\n\n        // eslint-disable-next-line wrap-iife\n        (async function () {\n          if (current.scrollWidth === current.offsetWidth) {\n            // HACK: Chrome 66 will initially say scrollWidth equals to offsetWidth, until some time later\n            await sleepZero();\n          }\n\n          emitValue(true);\n        })();\n\n        return () => {\n          current.removeEventListener('pointerover', handlePointerOver);\n          current.removeEventListener('scroll', handleScroll);\n        };\n      }),\n    [callbackRefWithSubscribe, observer]\n  );\n}\n"]},"metadata":{},"sourceType":"module"}