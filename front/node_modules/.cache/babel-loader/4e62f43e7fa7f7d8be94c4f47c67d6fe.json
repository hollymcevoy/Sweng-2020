{"ast":null,"code":"\"use strict\"; //\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Connection = void 0;\n\nvar Exports_1 = require(\"../common.speech/Exports\");\n\nvar Exports_2 = require(\"../common/Exports\");\n\nvar ConnectionMessage_1 = require(\"./ConnectionMessage\");\n\nvar Contracts_1 = require(\"./Contracts\");\n\nvar Exports_3 = require(\"./Exports\");\n/**\n * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.\n * By default, a Recognizer autonomously manages connection to service when needed.\n * The Connection class provides additional methods for users to explicitly open or close a connection and\n * to subscribe to connection status changes.\n * The use of Connection is optional, and mainly for scenarios where fine tuning of application\n * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection\n * in advance before starting recognition on the Recognizer associated with this Connection.\n * If the Recognizer needs to connect or disconnect to service, it will\n * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection\n * status via Connected/Disconnected events.\n * Added in version 1.2.1.\n */\n\n\nvar Connection =\n/** @class */\nfunction () {\n  function Connection() {}\n  /**\n   * Gets the Connection instance from the specified recognizer.\n   * @param recognizer The recognizer associated with the connection.\n   * @return The Connection instance of the recognizer.\n   */\n\n\n  Connection.fromRecognizer = function (recognizer) {\n    var recoBase = recognizer.internalData;\n    var ret = new Connection();\n    ret.privInternalData = recoBase;\n    ret.setupEvents();\n    return ret;\n  };\n  /**\n   * Gets the Connection instance from the specified synthesizer.\n   * @param synthesizer The synthesizer associated with the connection.\n   * @return The Connection instance of the synthesizer.\n   */\n\n\n  Connection.fromSynthesizer = function (synthesizer) {\n    var synthBase = synthesizer.internalData;\n    var ret = new Connection();\n    ret.privInternalData = synthBase;\n    ret.setupEvents();\n    return ret;\n  };\n  /**\n   * Starts to set up connection to the service.\n   * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the\n   * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect\n   *\n   * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\n   * be notified when the connection is established.\n   */\n\n\n  Connection.prototype.openConnection = function (cb, err) {\n    Exports_2.marshalPromiseToCallbacks(this.privInternalData.connect(), cb, err);\n  };\n  /**\n   * Closes the connection the service.\n   * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.\n   *\n   * If closeConnection() is called during recognition, recognition will fail and cancel with an error.\n   */\n\n\n  Connection.prototype.closeConnection = function (cb, err) {\n    if (this.privInternalData instanceof Exports_1.SynthesisAdapterBase) {\n      throw new Error(\"Disconnecting a synthesizer's connection is currently not supported\");\n    } else {\n      Exports_2.marshalPromiseToCallbacks(this.privInternalData.disconnect(), cb, err);\n    }\n  };\n  /**\n   * Appends a parameter in a message to service.\n   * Added in version 1.12.1.\n   * @param path The path of the network message.\n   * @param propertyName Name of the property\n   * @param propertyValue Value of the property. This is a json string.\n   */\n\n\n  Connection.prototype.setMessageProperty = function (path, propertyName, propertyValue) {\n    Contracts_1.Contracts.throwIfNullOrWhitespace(propertyName, \"propertyName\");\n\n    if (this.privInternalData instanceof Exports_1.ServiceRecognizerBase) {\n      if (path.toLowerCase() !== \"speech.context\") {\n        throw new Error(\"Only speech.context message property sets are currently supported for recognizer\");\n      } else {\n        this.privInternalData.speechContext.setSection(propertyName, propertyValue);\n      }\n    } else if (this.privInternalData instanceof Exports_1.SynthesisAdapterBase) {\n      if (path.toLowerCase() !== \"synthesis.context\") {\n        throw new Error(\"Only synthesis.context message property sets are currently supported for synthesizer\");\n      } else {\n        this.privInternalData.synthesisContext.setSection(propertyName, propertyValue);\n      }\n    }\n  };\n  /**\n   * Sends a message to the speech service.\n   * Added in version 1.13.0.\n   * @param path The WebSocket path of the message\n   * @param payload The payload of the message. This is a json string or a ArrayBuffer.\n   * @param success A callback to indicate success.\n   * @param error A callback to indicate an error.\n   */\n\n\n  Connection.prototype.sendMessageAsync = function (path, payload, success, error) {\n    Exports_2.marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(path, payload), success, error);\n  };\n  /**\n   * Dispose of associated resources.\n   */\n\n\n  Connection.prototype.close = function () {\n    /* tslint:disable:no-empty */\n  };\n\n  Connection.prototype.setupEvents = function () {\n    var _this = this;\n\n    this.privEventListener = this.privInternalData.connectionEvents.attach(function (connectionEvent) {\n      if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\n        if (!!_this.connected) {\n          _this.connected(new Exports_3.ConnectionEventArgs(connectionEvent.connectionId));\n        }\n      } else if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        if (!!_this.disconnected) {\n          _this.disconnected(new Exports_3.ConnectionEventArgs(connectionEvent.connectionId));\n        }\n      } else if (connectionEvent.name === \"ConnectionMessageSentEvent\") {\n        if (!!_this.messageSent) {\n          _this.messageSent(new Exports_3.ConnectionMessageEventArgs(new ConnectionMessage_1.ConnectionMessageImpl(connectionEvent.message)));\n        }\n      } else if (connectionEvent.name === \"ConnectionMessageReceivedEvent\") {\n        if (!!_this.messageReceived) {\n          _this.messageReceived(new Exports_3.ConnectionMessageEventArgs(new ConnectionMessage_1.ConnectionMessageImpl(connectionEvent.message)));\n        }\n      }\n    });\n    this.privServiceEventListener = this.privInternalData.serviceEvents.attach(function (e) {\n      if (!!_this.receivedServiceMessage) {\n        _this.receivedServiceMessage(new Exports_3.ServiceEventArgs(e.jsonString, e.name));\n      }\n    });\n  };\n\n  return Connection;\n}();\n\nexports.Connection = Connection;","map":{"version":3,"mappings":"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","names":["Connection","recognizer","recoBase","internalData","ret","privInternalData","setupEvents","synthesizer","synthBase","cb","err","Exports_2","connect","Exports_1","Error","disconnect","path","propertyName","propertyValue","Contracts_1","throwIfNullOrWhitespace","toLowerCase","speechContext","setSection","synthesisContext","payload","success","error","sendNetworkMessage","privEventListener","connectionEvents","attach","connectionEvent","name","_this","connected","Exports_3","connectionId","disconnected","messageSent","ConnectionMessage_1","message","messageReceived","privServiceEventListener","serviceEvents","e","receivedServiceMessage","jsonString","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/src/sdk/Connection.ts"],"sourcesContent":["//\r\n// Copyright (c) Microsoft. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\r\n//\r\n\r\nimport {\r\n    ServiceRecognizerBase,\r\n    SynthesisAdapterBase,\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    ConnectionEvent,\r\n    ConnectionMessageReceivedEvent,\r\n    ConnectionMessageSentEvent,\r\n    IDetachable,\r\n    marshalPromiseToCallbacks,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport {\r\n    ConnectionMessageImpl\r\n} from \"./ConnectionMessage\";\r\nimport { Contracts } from \"./Contracts\";\r\nimport {\r\n    ConnectionEventArgs,\r\n    ConnectionMessageEventArgs,\r\n    Recognizer,\r\n    ServiceEventArgs,\r\n    SpeechSynthesizer,\r\n} from \"./Exports\";\r\n\r\n/**\r\n * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.\r\n * By default, a Recognizer autonomously manages connection to service when needed.\r\n * The Connection class provides additional methods for users to explicitly open or close a connection and\r\n * to subscribe to connection status changes.\r\n * The use of Connection is optional, and mainly for scenarios where fine tuning of application\r\n * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection\r\n * in advance before starting recognition on the Recognizer associated with this Connection.\r\n * If the Recognizer needs to connect or disconnect to service, it will\r\n * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection\r\n * status via Connected/Disconnected events.\r\n * Added in version 1.2.1.\r\n */\r\nexport class Connection {\r\n    private privInternalData: ServiceRecognizerBase | SynthesisAdapterBase;\r\n    private privEventListener: IDetachable;\r\n    private privServiceEventListener: IDetachable;\r\n\r\n    /**\r\n     * Gets the Connection instance from the specified recognizer.\r\n     * @param recognizer The recognizer associated with the connection.\r\n     * @return The Connection instance of the recognizer.\r\n     */\r\n    public static fromRecognizer(recognizer: Recognizer): Connection {\r\n        const recoBase: ServiceRecognizerBase = recognizer.internalData as ServiceRecognizerBase;\r\n\r\n        const ret: Connection = new Connection();\r\n\r\n        ret.privInternalData = recoBase;\r\n        ret.setupEvents();\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Gets the Connection instance from the specified synthesizer.\r\n     * @param synthesizer The synthesizer associated with the connection.\r\n     * @return The Connection instance of the synthesizer.\r\n     */\r\n    public static fromSynthesizer(synthesizer: SpeechSynthesizer): Connection {\r\n        const synthBase: SynthesisAdapterBase = synthesizer.internalData as SynthesisAdapterBase;\r\n\r\n        const ret: Connection = new Connection();\r\n\r\n        ret.privInternalData = synthBase;\r\n        ret.setupEvents();\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Starts to set up connection to the service.\r\n     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the\r\n     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect\r\n     *\r\n     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\r\n     * be notified when the connection is established.\r\n     */\r\n    public openConnection(cb?: () => void, err?: (error: string) => void): void {\r\n        marshalPromiseToCallbacks(this.privInternalData.connect(), cb, err);\r\n    }\r\n\r\n    /**\r\n     * Closes the connection the service.\r\n     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.\r\n     *\r\n     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.\r\n     */\r\n    public closeConnection(cb?: () => void, err?: (error: string) => void): void {\r\n        if (this.privInternalData instanceof SynthesisAdapterBase) {\r\n            throw new Error(\"Disconnecting a synthesizer's connection is currently not supported\");\r\n        } else {\r\n            marshalPromiseToCallbacks((this.privInternalData as ServiceRecognizerBase).disconnect(), cb, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Appends a parameter in a message to service.\r\n     * Added in version 1.12.1.\r\n     * @param path The path of the network message.\r\n     * @param propertyName Name of the property\r\n     * @param propertyValue Value of the property. This is a json string.\r\n     */\r\n    public setMessageProperty(path: string, propertyName: string, propertyValue: string): void {\r\n        Contracts.throwIfNullOrWhitespace(propertyName, \"propertyName\");\r\n\r\n        if (this.privInternalData instanceof ServiceRecognizerBase) {\r\n            if (path.toLowerCase() !== \"speech.context\") {\r\n                throw new Error(\"Only speech.context message property sets are currently supported for recognizer\");\r\n            } else {\r\n                (this.privInternalData as ServiceRecognizerBase).speechContext.setSection(propertyName, propertyValue);\r\n            }\r\n        } else if (this.privInternalData instanceof SynthesisAdapterBase) {\r\n            if (path.toLowerCase() !== \"synthesis.context\") {\r\n                throw new Error(\"Only synthesis.context message property sets are currently supported for synthesizer\");\r\n            } else {\r\n                (this.privInternalData as SynthesisAdapterBase).synthesisContext.setSection(propertyName, propertyValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sends a message to the speech service.\r\n     * Added in version 1.13.0.\r\n     * @param path The WebSocket path of the message\r\n     * @param payload The payload of the message. This is a json string or a ArrayBuffer.\r\n     * @param success A callback to indicate success.\r\n     * @param error A callback to indicate an error.\r\n     */\r\n    public sendMessageAsync(path: string, payload: string | ArrayBuffer, success?: () => void, error?: (error: string) => void): void {\r\n        marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(path, payload), success, error);\r\n    }\r\n\r\n    /**\r\n     * Any message from service that is not being processed by any other top level recognizers.\r\n     *\r\n     * Will be removed in 2.0.\r\n     */\r\n    public receivedServiceMessage: (args: ServiceEventArgs) => void;\r\n\r\n    /**\r\n     * Any message received from the Speech Service.\r\n     */\r\n    public messageReceived: (args: ConnectionMessageEventArgs) => void;\r\n\r\n    /**\r\n     * Any message sent to the Speech Service.\r\n     */\r\n    public messageSent: (args: ConnectionMessageEventArgs) => void;\r\n\r\n    /**\r\n     * The Connected event to indicate that the recognizer is connected to service.\r\n     */\r\n    public connected: (args: ConnectionEventArgs) => void;\r\n\r\n    /**\r\n     * The Disconnected event to indicate that the recognizer is disconnected from service.\r\n     */\r\n    public disconnected: (args: ConnectionEventArgs) => void;\r\n\r\n    /**\r\n     * Dispose of associated resources.\r\n     */\r\n    public close(): void {\r\n        /* tslint:disable:no-empty */\r\n    }\r\n\r\n    private setupEvents(): void {\r\n        this.privEventListener = this.privInternalData.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\r\n                if (!!this.connected) {\r\n                    this.connected(new ConnectionEventArgs(connectionEvent.connectionId));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                if (!!this.disconnected) {\r\n                    this.disconnected(new ConnectionEventArgs(connectionEvent.connectionId));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionMessageSentEvent\") {\r\n                if (!!this.messageSent) {\r\n                    this.messageSent(new ConnectionMessageEventArgs(new ConnectionMessageImpl((connectionEvent as ConnectionMessageSentEvent).message)));\r\n                }\r\n            } else if (connectionEvent.name === \"ConnectionMessageReceivedEvent\") {\r\n                if (!!this.messageReceived) {\r\n                    this.messageReceived(new ConnectionMessageEventArgs(new ConnectionMessageImpl((connectionEvent as ConnectionMessageReceivedEvent).message)));\r\n                }\r\n            }\r\n        });\r\n\r\n        this.privServiceEventListener = this.privInternalData.serviceEvents.attach((e: ServiceEvent): void => {\r\n            if (!!this.receivedServiceMessage) {\r\n                this.receivedServiceMessage(new ServiceEventArgs(e.jsonString, e.name));\r\n            }\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}