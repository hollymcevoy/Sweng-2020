{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _firstTabbableDescendant = require(\"../firstTabbableDescendant\");\n\nvar _Context = _interopRequireDefault(require(\"./internal/Context\"));\n\nvar _useNavigatorPlatform3 = _interopRequireDefault(require(\"../../hooks/internal/useNavigatorPlatform\"));\n\nvar _excluded = [\"children\"];\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar Surface = function Surface(_ref) {\n  var children = _ref.children,\n      otherProps = _objectWithoutProperties(_ref, _excluded);\n\n  var _useNavigatorPlatform = (0, _useNavigatorPlatform3.default)(),\n      _useNavigatorPlatform2 = _slicedToArray(_useNavigatorPlatform, 1),\n      apple = _useNavigatorPlatform2[0].apple;\n\n  var contextRef = (0, _react.useRef)({\n    focii: []\n  });\n  var handleKeyUp = (0, _react.useCallback)(function (event) {\n    var altKey = event.altKey,\n        ctrlKey = event.ctrlKey,\n        key = event.key,\n        shiftKey = event.shiftKey; // On Apple, most modern browsers use CTRL + OPTION as modifiers.\n    // Otherwise, we use ALT + SHIFT as modifierse.\n\n    if (altKey && (apple ? ctrlKey : shiftKey)) {\n      var focii = contextRef.current.focii.filter(function (entry) {\n        return entry.keys.includes(key);\n      });\n      var currentFocus = focii.findIndex(function (_ref2) {\n        var current = _ref2.ref.current;\n        return current === document.activeElement || current.contains(document.activeElement);\n      });\n      var nextFocus = focii[(currentFocus + 1) % focii.length];\n\n      if (nextFocus) {\n        event.preventDefault();\n        event.stopPropagation();\n        var tabbable = (0, _firstTabbableDescendant.orSelf)(nextFocus.ref.current);\n        tabbable && tabbable.focus();\n      }\n    }\n  }, [apple]);\n  return /*#__PURE__*/_react.default.createElement(_Context.default.Provider, {\n    value: contextRef.current\n  }, /*#__PURE__*/_react.default.createElement(\"div\", _extends({\n    onKeyUp: handleKeyUp\n  }, otherProps), children));\n};\n\nSurface.defaultProps = {\n  children: undefined\n};\nSurface.propTypes = {\n  children: _propTypes.default.any\n};\nvar _default = Surface;\nexports.default = _default;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAEA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,OAAO,GAAG,SAAVA,OAAU,OAAiC;AAAA,MAA9BC,QAA8B,QAA9BA,QAA8B;AAAA,MAAjBC,UAAiB;;AAC/C,8BAAoB,qCAApB;AAAA;AAAA,MAASC,KAAT,6BAASA,KAAT;;AACA,MAAMC,UAAU,GAAG,mBAAO;AAAEC,SAAK,EAAE;AAAT,GAAP,CAAnB;AAEA,MAAMC,WAAW,GAAG,wBAClB,iBAAS;AACP,QAAQC,MAAR,GAA2CC,KAA3C,CAAQD,MAAR;AAAA,QAAgBE,OAAhB,GAA2CD,KAA3C,CAAgBC,OAAhB;AAAA,QAAyBC,GAAzB,GAA2CF,KAA3C,CAAyBE,GAAzB;AAAA,QAA8BC,QAA9B,GAA2CH,KAA3C,CAA8BG,QAA9B,CADO,CAGP;AACA;;AACA,QAAIJ,MAAM,KAAKJ,KAAK,GAAGM,OAAH,GAAaE,QAAvB,CAAV,EAA4C;AAC1C,UAAMN,KAAK,GAAGD,UAAU,CAACQ,OAAXR,CAAmBC,KAAnBD,CAAyBS,MAAzBT,CAAgC,iBAAK;AAAA,eAAIU,KAAK,CAACC,IAAND,CAAWE,QAAXF,CAAoBJ,GAApBI,CAAJ;AAArC,QAAd;AAEA,UAAMG,YAAY,GAAGZ,KAAK,CAACa,SAANb,CACnB;AAAA,YAAUO,OAAV,SAAGO,GAAH,CAAUP,OAAV;AAAA,eAA0BA,OAAO,KAAKQ,QAAQ,CAACC,aAArBT,IAAsCA,OAAO,CAACU,QAARV,CAAiBQ,QAAQ,CAACC,aAA1BT,CAAhE;AADmB,QAArB;AAGA,UAAMW,SAAS,GAAGlB,KAAK,CAAC,CAACY,YAAY,GAAG,CAAhB,IAAqBZ,KAAK,CAACmB,MAA5B,CAAvB;;AAEA,UAAID,SAAJ,EAAe;AACbf,aAAK,CAACiB,cAANjB;AACAA,aAAK,CAACkB,eAANlB;AAEA,YAAMmB,QAAQ,GAAG,qCAA8BJ,SAAS,CAACJ,GAAVI,CAAcX,OAA5C,CAAjB;AAEAe,gBAAQ,IAAIA,QAAQ,CAACC,KAATD,EAAZA;AACD;AACF;AAtBe,KAwBlB,CAACxB,KAAD,CAxBkB,CAApB;AA2BA,sBACE0B,6BAACC,iBAAqBC,QAAtB;AAA+BC,SAAK,EAAE5B,UAAU,CAACQ;AAAjD,kBACEiB;AAAKI,WAAO,EAAE3B;AAAd,KAA+BJ,UAA/B,GACGD,QADH,CADF,CADF;AA/BF;;AAwCAD,OAAO,CAACkC,YAARlC,GAAuB;AACrBC,UAAQ,EAAEkC;AADW,CAAvBnC;AAIAA,OAAO,CAACoC,SAARpC,GAAoB;AAClBC,UAAQ,EAAEoC,mBAAUC;AADF,CAApBtC;eAIeA","names":["Surface","children","otherProps","apple","contextRef","focii","handleKeyUp","altKey","event","ctrlKey","key","shiftKey","current","filter","entry","keys","includes","currentFocus","findIndex","ref","document","activeElement","contains","nextFocus","length","preventDefault","stopPropagation","tabbable","focus","_react","_Context","Provider","value","onKeyUp","defaultProps","undefined","propTypes","PropTypes","any"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-component/lib/src/Utils/AccessKeySink/Surface.js"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React, { useCallback, useRef } from 'react';\n\nimport { orSelf as firstTabbableDescendantOrSelf } from '../firstTabbableDescendant';\nimport AccessKeySinkContext from './internal/Context';\nimport useNavigatorPlatform from '../../hooks/internal/useNavigatorPlatform';\n\nconst Surface = ({ children, ...otherProps }) => {\n  const [{ apple }] = useNavigatorPlatform();\n  const contextRef = useRef({ focii: [] });\n\n  const handleKeyUp = useCallback(\n    event => {\n      const { altKey, ctrlKey, key, shiftKey } = event;\n\n      // On Apple, most modern browsers use CTRL + OPTION as modifiers.\n      // Otherwise, we use ALT + SHIFT as modifierse.\n      if (altKey && (apple ? ctrlKey : shiftKey)) {\n        const focii = contextRef.current.focii.filter(entry => entry.keys.includes(key));\n\n        const currentFocus = focii.findIndex(\n          ({ ref: { current } }) => current === document.activeElement || current.contains(document.activeElement)\n        );\n        const nextFocus = focii[(currentFocus + 1) % focii.length];\n\n        if (nextFocus) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          const tabbable = firstTabbableDescendantOrSelf(nextFocus.ref.current);\n\n          tabbable && tabbable.focus();\n        }\n      }\n    },\n    [apple]\n  );\n\n  return (\n    <AccessKeySinkContext.Provider value={contextRef.current}>\n      <div onKeyUp={handleKeyUp} {...otherProps}>\n        {children}\n      </div>\n    </AccessKeySinkContext.Provider>\n  );\n};\n\nSurface.defaultProps = {\n  children: undefined\n};\n\nSurface.propTypes = {\n  children: PropTypes.any\n};\n\nexport default Surface;\n"]},"metadata":{},"sourceType":"script"}