{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _Context = _interopRequireDefault(require(\"./private/Context\"));\n\nvar _getActivityId = _interopRequireDefault(require(\"./private/getActivityId\"));\n\nvar _getClientActivityId = _interopRequireDefault(require(\"./private/getClientActivityId\"));\n\nvar _uniqueId = _interopRequireDefault(require(\"./private/uniqueId\"));\n\nvar _useActivities3 = _interopRequireDefault(require(\"../../hooks/useActivities\"));\n\nvar _useContext = _interopRequireDefault(require(\"./private/useContext\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/**\n * React context composer component to assign a perma-key to every activity.\n * This will support both `useGetActivityByKey` and `useGetKeyByActivity` custom hooks.\n *\n * Today, `activity.id` is only guaranteed for activity from others.\n * Not all activities sent by the local user has `activity.id`.\n *\n * To track outgoing activities, we added `activity.channelData.clientActivityId`.\n *\n * This component will create a local key, which can be used to track both\n * incoming and outgoing activities in a consistent way.\n *\n * Local key are only persisted in memory. On refresh, they will be a new random key.\n */\n\n\nvar ActivityKeyerComposer = function ActivityKeyerComposer(_ref) {\n  var children = _ref.children;\n  var existingContext = (0, _useContext.default)(false);\n\n  if (existingContext) {\n    throw new Error('botframework-webchat internal: <ActivityKeyerComposer> should not be nested.');\n  }\n\n  var _useActivities = (0, _useActivities3.default)(),\n      _useActivities2 = _slicedToArray(_useActivities, 1),\n      activities = _useActivities2[0];\n\n  var activityIdToKeyMapRef = (0, _react.useRef)(Object.freeze(new Map()));\n  var activityToKeyMapRef = (0, _react.useRef)(Object.freeze(new Map()));\n  var clientActivityIdToKeyMapRef = (0, _react.useRef)(Object.freeze(new Map()));\n  var keyToActivityMapRef = (0, _react.useRef)(Object.freeze(new Map())); // TODO: [P1] `useMemoWithPrevious` to check and cache the resulting array if it hasn't changed.\n\n  var activityKeysState = (0, _react.useMemo)(function () {\n    var activityIdToKeyMap = activityIdToKeyMapRef.current;\n    var activityToKeyMap = activityToKeyMapRef.current;\n    var clientActivityIdToKeyMap = clientActivityIdToKeyMapRef.current;\n    var nextActivityIdToKeyMap = new Map();\n    var nextActivityKeys = [];\n    var nextActivityToKeyMap = new Map();\n    var nextClientActivityIdToKeyMap = new Map();\n    var nextKeyToActivityMap = new Map();\n    activities.forEach(function (activity) {\n      var activityId = (0, _getActivityId.default)(activity);\n      var clientActivityId = (0, _getClientActivityId.default)(activity);\n      var key = clientActivityId && clientActivityIdToKeyMap.get(clientActivityId) || activityId && activityIdToKeyMap.get(activityId) || activityToKeyMap.get(activity) || (0, _uniqueId.default)();\n      activityId && nextActivityIdToKeyMap.set(activityId, key);\n      clientActivityId && nextClientActivityIdToKeyMap.set(clientActivityId, key);\n      nextActivityToKeyMap.set(activity, key);\n      nextKeyToActivityMap.set(key, activity);\n      nextActivityKeys.push(key);\n    });\n    activityIdToKeyMapRef.current = Object.freeze(nextActivityIdToKeyMap);\n    activityToKeyMapRef.current = Object.freeze(nextActivityToKeyMap);\n    clientActivityIdToKeyMapRef.current = Object.freeze(nextClientActivityIdToKeyMap);\n    keyToActivityMapRef.current = Object.freeze(nextKeyToActivityMap); // `nextActivityKeys` could potentially same as `prevActivityKeys` despite reference differences, we should memoize it.\n\n    return Object.freeze([Object.freeze(nextActivityKeys)]);\n  }, [activities, activityIdToKeyMapRef, activityToKeyMapRef, clientActivityIdToKeyMapRef, keyToActivityMapRef]);\n  var getActivityByKey = (0, _react.useCallback)(function (key) {\n    return key && keyToActivityMapRef.current.get(key);\n  }, [keyToActivityMapRef]);\n  var getKeyByActivity = (0, _react.useCallback)(function (activity) {\n    return activity && activityToKeyMapRef.current.get(activity);\n  }, [activityToKeyMapRef]);\n  var getKeyByActivityId = (0, _react.useCallback)(function (activityId) {\n    return activityId && activityIdToKeyMapRef.current.get(activityId);\n  }, [activityIdToKeyMapRef]);\n  var contextValue = (0, _react.useMemo)(function () {\n    return {\n      activityKeysState: activityKeysState,\n      getActivityByKey: getActivityByKey,\n      getKeyByActivity: getKeyByActivity,\n      getKeyByActivityId: getKeyByActivityId\n    };\n  }, [activityKeysState, getActivityByKey, getKeyByActivity, getKeyByActivityId]);\n  var numActivities = activities.length;\n\n  if (activityIdToKeyMapRef.current.size > numActivities) {\n    console.warn('botframework-webchat internal assertion: \"activityIdToKeyMap.size\" should be equal or less than \"activities.length\".');\n  }\n\n  if (activityToKeyMapRef.current.size !== numActivities) {\n    console.warn('botframework-webchat internal assertion: \"activityToKeyMap.size\" should be same as \"activities.length\".');\n  }\n\n  if (clientActivityIdToKeyMapRef.current.size > numActivities) {\n    console.warn('botframework-webchat internal assertion: \"clientActivityIdToKeyMap.size\" should be equal or less than \"activities.length\".');\n  }\n\n  if (keyToActivityMapRef.current.size !== numActivities) {\n    console.warn('botframework-webchat internal assertion: \"keyToActivityMap.size\" should be same as \"activities.length\".');\n  }\n\n  if (activityKeysState[0].length !== numActivities) {\n    console.warn('botframework-webchat internal assertion: \"activityKeys.length\" should be same as \"activities.length\".');\n  }\n\n  return /*#__PURE__*/_react.default.createElement(_Context.default.Provider, {\n    value: contextValue\n  }, children);\n};\n\nActivityKeyerComposer.defaultProps = {\n  children: undefined\n};\nActivityKeyerComposer.propTypes = {\n  children: _propTypes.default.any\n};\nvar _default = ActivityKeyerComposer;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["ActivityKeyerComposer","children","existingContext","Error","activities","activityIdToKeyMapRef","Object","freeze","Map","activityToKeyMapRef","clientActivityIdToKeyMapRef","keyToActivityMapRef","activityKeysState","activityIdToKeyMap","current","activityToKeyMap","clientActivityIdToKeyMap","nextActivityIdToKeyMap","nextActivityKeys","nextActivityToKeyMap","nextClientActivityIdToKeyMap","nextKeyToActivityMap","forEach","activityId","activity","clientActivityId","key","get","set","push","getActivityByKey","getKeyByActivity","getKeyByActivityId","contextValue","numActivities","length","size","console","warn","_react","_Context","Provider","value","defaultProps","undefined","propTypes","PropTypes","any"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-api/lib/src/providers/ActivityKeyer/ActivityKeyerComposer.tsx"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React, { useCallback, useMemo, useRef } from 'react';\n\nimport type { DirectLineActivity } from 'botframework-webchat-core';\nimport type { FC } from 'react';\n\nimport ActivityKeyerContext, { ActivityKeyerContextType } from './private/Context';\nimport getActivityId from './private/getActivityId';\nimport getClientActivityId from './private/getClientActivityId';\nimport uniqueId from './private/uniqueId';\nimport useActivities from '../../hooks/useActivities';\nimport useActivityKeyerContext from './private/useContext';\n\ntype ActivityIdToKeyMap = Map<string, string>;\ntype ActivityToKeyMap = Map<DirectLineActivity, string>;\ntype ClientActivityIdToKeyMap = Map<string, string>;\ntype KeyToActivityMap = Map<string, DirectLineActivity>;\n\n/**\n * React context composer component to assign a perma-key to every activity.\n * This will support both `useGetActivityByKey` and `useGetKeyByActivity` custom hooks.\n *\n * Today, `activity.id` is only guaranteed for activity from others.\n * Not all activities sent by the local user has `activity.id`.\n *\n * To track outgoing activities, we added `activity.channelData.clientActivityId`.\n *\n * This component will create a local key, which can be used to track both\n * incoming and outgoing activities in a consistent way.\n *\n * Local key are only persisted in memory. On refresh, they will be a new random key.\n */\nconst ActivityKeyerComposer: FC<{}> = ({ children }) => {\n  const existingContext = useActivityKeyerContext(false);\n\n  if (existingContext) {\n    throw new Error('botframework-webchat internal: <ActivityKeyerComposer> should not be nested.');\n  }\n\n  const [activities] = useActivities();\n  const activityIdToKeyMapRef = useRef<Readonly<ActivityIdToKeyMap>>(Object.freeze(new Map()));\n  const activityToKeyMapRef = useRef<Readonly<ActivityToKeyMap>>(Object.freeze(new Map()));\n  const clientActivityIdToKeyMapRef = useRef<Readonly<ClientActivityIdToKeyMap>>(Object.freeze(new Map()));\n  const keyToActivityMapRef = useRef<Readonly<KeyToActivityMap>>(Object.freeze(new Map()));\n\n  // TODO: [P1] `useMemoWithPrevious` to check and cache the resulting array if it hasn't changed.\n  const activityKeysState = useMemo<readonly [readonly string[]]>(() => {\n    const { current: activityIdToKeyMap } = activityIdToKeyMapRef;\n    const { current: activityToKeyMap } = activityToKeyMapRef;\n    const { current: clientActivityIdToKeyMap } = clientActivityIdToKeyMapRef;\n    const nextActivityIdToKeyMap: ActivityIdToKeyMap = new Map();\n    const nextActivityKeys: string[] = [];\n    const nextActivityToKeyMap: ActivityToKeyMap = new Map();\n    const nextClientActivityIdToKeyMap: ClientActivityIdToKeyMap = new Map();\n    const nextKeyToActivityMap: KeyToActivityMap = new Map();\n\n    activities.forEach(activity => {\n      const activityId = getActivityId(activity);\n      const clientActivityId = getClientActivityId(activity);\n\n      const key =\n        (clientActivityId && clientActivityIdToKeyMap.get(clientActivityId)) ||\n        (activityId && activityIdToKeyMap.get(activityId)) ||\n        activityToKeyMap.get(activity) ||\n        uniqueId();\n\n      activityId && nextActivityIdToKeyMap.set(activityId, key);\n      clientActivityId && nextClientActivityIdToKeyMap.set(clientActivityId, key);\n      nextActivityToKeyMap.set(activity, key);\n      nextKeyToActivityMap.set(key, activity);\n      nextActivityKeys.push(key);\n    });\n\n    activityIdToKeyMapRef.current = Object.freeze(nextActivityIdToKeyMap);\n    activityToKeyMapRef.current = Object.freeze(nextActivityToKeyMap);\n    clientActivityIdToKeyMapRef.current = Object.freeze(nextClientActivityIdToKeyMap);\n    keyToActivityMapRef.current = Object.freeze(nextKeyToActivityMap);\n\n    // `nextActivityKeys` could potentially same as `prevActivityKeys` despite reference differences, we should memoize it.\n    return Object.freeze([Object.freeze(nextActivityKeys)]) as readonly [readonly string[]];\n  }, [activities, activityIdToKeyMapRef, activityToKeyMapRef, clientActivityIdToKeyMapRef, keyToActivityMapRef]);\n\n  const getActivityByKey: (key?: string) => DirectLineActivity | undefined = useCallback(\n    (key?: string): DirectLineActivity | undefined => key && keyToActivityMapRef.current.get(key),\n    [keyToActivityMapRef]\n  );\n\n  const getKeyByActivity: (activity?: DirectLineActivity) => string | undefined = useCallback(\n    (activity?: DirectLineActivity) => activity && activityToKeyMapRef.current.get(activity),\n    [activityToKeyMapRef]\n  );\n\n  const getKeyByActivityId: (activityId?: string) => string | undefined = useCallback(\n    (activityId?: string) => activityId && activityIdToKeyMapRef.current.get(activityId),\n    [activityIdToKeyMapRef]\n  );\n\n  const contextValue = useMemo<ActivityKeyerContextType>(\n    () => ({\n      activityKeysState,\n      getActivityByKey,\n      getKeyByActivity,\n      getKeyByActivityId\n    }),\n    [activityKeysState, getActivityByKey, getKeyByActivity, getKeyByActivityId]\n  );\n\n  const { length: numActivities } = activities;\n\n  if (activityIdToKeyMapRef.current.size > numActivities) {\n    console.warn(\n      'botframework-webchat internal assertion: \"activityIdToKeyMap.size\" should be equal or less than \"activities.length\".'\n    );\n  }\n\n  if (activityToKeyMapRef.current.size !== numActivities) {\n    console.warn(\n      'botframework-webchat internal assertion: \"activityToKeyMap.size\" should be same as \"activities.length\".'\n    );\n  }\n\n  if (clientActivityIdToKeyMapRef.current.size > numActivities) {\n    console.warn(\n      'botframework-webchat internal assertion: \"clientActivityIdToKeyMap.size\" should be equal or less than \"activities.length\".'\n    );\n  }\n\n  if (keyToActivityMapRef.current.size !== numActivities) {\n    console.warn(\n      'botframework-webchat internal assertion: \"keyToActivityMap.size\" should be same as \"activities.length\".'\n    );\n  }\n\n  if (activityKeysState[0].length !== numActivities) {\n    console.warn(\n      'botframework-webchat internal assertion: \"activityKeys.length\" should be same as \"activities.length\".'\n    );\n  }\n\n  return <ActivityKeyerContext.Provider value={contextValue}>{children}</ActivityKeyerContext.Provider>;\n};\n\nActivityKeyerComposer.defaultProps = {\n  children: undefined\n};\n\nActivityKeyerComposer.propTypes = {\n  children: PropTypes.any\n};\n\nexport default ActivityKeyerComposer;\n"]},"metadata":{},"sourceType":"script"}