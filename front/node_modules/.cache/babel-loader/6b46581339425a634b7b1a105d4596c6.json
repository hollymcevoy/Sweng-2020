{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = createSynthesize;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _QueuedUtterance = _interopRequireDefault(require(\"./QueuedUtterance\"));\n\nfunction createSynthesize() {\n  var queueWithCurrent = [];\n  var running;\n\n  var run = /*#__PURE__*/function () {\n    var _ref = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n      return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!running) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 2:\n              running = true;\n              _context2.prev = 3;\n              return _context2.delegateYield( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n                var queuedUtterance;\n                return _regenerator[\"default\"].wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        if (!(queuedUtterance = queueWithCurrent[0])) {\n                          _context.next = 12;\n                          break;\n                        }\n\n                        _context.prev = 1;\n                        _context.next = 4;\n                        return queuedUtterance.speak();\n\n                      case 4:\n                        _context.next = 9;\n                        break;\n\n                      case 6:\n                        _context.prev = 6;\n                        _context.t0 = _context[\"catch\"](1); // TODO: If the error is due to Safari restriction on user touch\n                        //       The next loop on the next audio will also fail because it was not queued with a user touch\n\n                        _context.t0.message !== 'cancelled' && console.error(_context.t0);\n\n                      case 9:\n                        queueWithCurrent = queueWithCurrent.filter(function (target) {\n                          return target !== queuedUtterance;\n                        });\n                        _context.next = 0;\n                        break;\n\n                      case 12:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[1, 6]]);\n              })(), \"t0\", 5);\n\n            case 5:\n              _context2.prev = 5;\n              running = false;\n              return _context2.finish(5);\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[3,, 5, 8]]);\n    }));\n\n    return function run() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return function (ponyfill, utterance) {\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        onEnd = _ref2.onEnd,\n        onError = _ref2.onError,\n        onStart = _ref2.onStart;\n\n    if (!(utterance instanceof ponyfill.SpeechSynthesisUtterance)) {\n      throw new Error('utterance must be instance of the ponyfill');\n    }\n\n    var queuedUtterance = new _QueuedUtterance[\"default\"](ponyfill, utterance, {\n      onEnd: onEnd,\n      onError: onError,\n      onStart: onStart\n    });\n    queueWithCurrent = [].concat((0, _toConsumableArray2[\"default\"])(queueWithCurrent), [queuedUtterance]);\n    run();\n    return {\n      // The cancel() function returns a Promise\n      cancel: function cancel() {\n        return queuedUtterance.cancel();\n      },\n      promise: queuedUtterance.promise\n    };\n  };\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;AAAA;;AAEe,SAASA,gBAAT,GAA4B;AACzC,MAAIC,gBAAgB,GAAG,EAAvB;AACA,MAAIC,OAAJ;;AAEA,MAAMC,GAAG;AAAA,6FAAG;AAAA;AAAA;AAAA;AAAA;AAAA,mBACND,OADM;AAAAE;AAAA;AAAA;;AAAA;;AAAA;AAKVF,qBAAO,GAAG,IAAVA;AALUE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8BAUAC,eAAe,GAAGJ,gBAAgB,CAAC,CAAD,CAVlC;AAAAK;AAAA;AAAA;;AAAAA;AAAAA;AAAA,+BAYED,eAAe,CAACE,KAAhBF,EAZF;;AAAA;AAAAC;AAAA;;AAAA;AAAAA;AAAAA,4DAcJ;AACA;;AAEAA,oCAAIE,OAAJ,KAAgB,WAAhB,IAA+BC,OAAO,CAACC,KAARD,aAA/B;;AAjBI;AAoBNR,wCAAgB,GAAGA,gBAAgB,CAACU,MAAjBV,CAAwB,kBAAM;AAAA,iCAAIW,MAAM,KAAKP,eAAf;AAA9B,0BAAnBJ;AApBMK;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAAF;AAuBRF,qBAAO,GAAG,KAAVA;AAvBQ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAH;;AAAA,oBAAHC,GAAG;AAAA;AAAA;AAAA,KAAT;;AA2BA,SAAO,UAACU,QAAD,EAAWC,SAAX,EAA2D;AAAA,oFAAP,EAAO;AAAA,QAAnCC,KAAmC,SAAnCA,KAAmC;AAAA,QAA5BC,OAA4B,SAA5BA,OAA4B;AAAA,QAAnBC,OAAmB,SAAnBA,OAAmB;;AAChE,QAAI,EAAEH,SAAS,YAAYD,QAAQ,CAACK,wBAAhC,CAAJ,EAA+D;AAC7D,YAAM,IAAIC,KAAJ,CAAU,4CAAV,CAAN;AACD;;AAED,QAAMd,eAAe,GAAG,IAAIe,2BAAJ,CAAoBP,QAApB,EAA8BC,SAA9B,EAAyC;AAAEC,WAAK,EAALA,KAAF;AAASC,aAAO,EAAPA,OAAT;AAAkBC,aAAO,EAAPA;AAAlB,KAAzC,CAAxB;AAEAhB,oBAAgB,iDAAOA,gBAAP,IAAyBI,eAAzB,EAAhBJ;AACAE,OAAG;AAEH,WAAO;AACL;AACAkB,YAAM,EAAE;AAAA,eAAMhB,eAAe,CAACgB,MAAhBhB,EAAN;AAFH;AAGLiB,aAAO,EAAEjB,eAAe,CAACiB;AAHpB,KAAP;AAVF;AAgBD","names":["createSynthesize","queueWithCurrent","running","run","_context2","queuedUtterance","_context","speak","message","console","error","filter","target","ponyfill","utterance","onEnd","onError","onStart","SpeechSynthesisUtterance","Error","QueuedUtterance","cancel","promise"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/react-say/src/createSynthesize.js"],"sourcesContent":["import QueuedUtterance from './QueuedUtterance';\n\nexport default function createSynthesize() {\n  let queueWithCurrent = [];\n  let running;\n\n  const run = async () => {\n    if (running) {\n      return;\n    }\n\n    running = true;\n\n    try {\n      let queuedUtterance;\n\n      while ((queuedUtterance = queueWithCurrent[0])) {\n        try {\n          await queuedUtterance.speak();\n        } catch (err) {\n          // TODO: If the error is due to Safari restriction on user touch\n          //       The next loop on the next audio will also fail because it was not queued with a user touch\n\n          err.message !== 'cancelled' && console.error(err);\n        }\n\n        queueWithCurrent = queueWithCurrent.filter(target => target !== queuedUtterance);\n      }\n    } finally {\n      running = false;\n    }\n  }\n\n  return (ponyfill, utterance, { onEnd, onError, onStart } = {}) => {\n    if (!(utterance instanceof ponyfill.SpeechSynthesisUtterance)) {\n      throw new Error('utterance must be instance of the ponyfill');\n    }\n\n    const queuedUtterance = new QueuedUtterance(ponyfill, utterance, { onEnd, onError, onStart });\n\n    queueWithCurrent = [...queueWithCurrent, queuedUtterance];\n    run();\n\n    return {\n      // The cancel() function returns a Promise\n      cancel: () => queuedUtterance.cancel(),\n      promise: queuedUtterance.promise\n    };\n  };\n}\n"]},"metadata":{},"sourceType":"script"}