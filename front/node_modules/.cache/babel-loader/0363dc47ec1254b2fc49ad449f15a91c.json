{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useObserveFocusVisible;\n\nvar _react = require(\"react\");\n\nvar _supportPseudoClass = _interopRequireDefault(require(\"../../Utils/supportPseudoClass\"));\n\nvar _useNonce3 = _interopRequireDefault(require(\"./useNonce\"));\n\nvar _useValueRef = _interopRequireDefault(require(\"./useValueRef\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar INPUT_TYPES_ALLOW_LIST = ['date', 'datetime-local', 'datetime', 'email', 'month', 'number', 'password', 'search', 'tel', 'text', 'time', 'url', 'week'];\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} el\n * @return {boolean}\n */\n\nfunction focusTriggersKeyboardModality(el) {\n  var isContentEditable = el.isContentEditable,\n      readOnly = el.readOnly,\n      tagName = el.tagName,\n      type = el.type;\n  return tagName === 'INPUT' && INPUT_TYPES_ALLOW_LIST.includes(type) && !readOnly || tagName === 'TEXTAREA' && !readOnly || isContentEditable;\n}\n\nfunction createEventSubscription(target, types, handler) {\n  var subscribed;\n\n  var subscribe = function subscribe() {\n    if (!subscribed) {\n      types.forEach(function (type) {\n        return target.addEventListener(type, handler);\n      });\n      subscribed = true;\n    }\n  };\n\n  var unsubscribe = function unsubscribe() {\n    if (subscribed) {\n      types.forEach(function (type) {\n        return target.removeEventListener(type, handler);\n      });\n      subscribed = undefined;\n    }\n  };\n\n  return {\n    pause: unsubscribe,\n    resume: subscribe\n  };\n} // TODO: Add tests\n//       1. Focus via keyboard vs. mouse\n//       2. Focus via keyboard, switch app, switch back (expect to get another focusVisible after switch back)\n//       3. Focus via mouse, switch app, switch back (do NOT expect to get another focusVisible after switch back)\n\n\nfunction useObserveFocusVisibleForLegacyBrowsers(targetRef, onFocusVisibleRef) {\n  // This polyfill algorithm is adopted from https://github.com/WICG/focus-visible.\n  var blurSinceRef = (0, _react.useRef)(0);\n  var hadKeyboardEventRef = (0, _react.useRef)(true);\n  var hasFocusVisibleRef = (0, _react.useRef)(false);\n  var eventSubscription = (0, _react.useMemo)(function () {\n    return createEventSubscription(document, ['mousemove', 'mousedown', 'mouseup', 'pointermove', 'pointerdown', 'pointerup', 'touchmove', 'touchstart', 'touchend'], function (event) {\n      var _nodeName;\n\n      if (((_nodeName = event.target.nodeName) === null || _nodeName === void 0 ? void 0 : _nodeName.toLowerCase()) !== 'html') {\n        hadKeyboardEventRef.current = false;\n        eventSubscription.pause();\n      }\n    });\n  }, [hadKeyboardEventRef]);\n  var setHasFocusVisible = (0, _react.useCallback)(function (nextHasFocusVisible) {\n    if (hasFocusVisibleRef.current !== nextHasFocusVisible) {\n      hasFocusVisibleRef.current = nextHasFocusVisible;\n      nextHasFocusVisible && (onFocusVisibleRef === null || onFocusVisibleRef === void 0 ? void 0 : onFocusVisibleRef.current());\n    }\n  }, [hasFocusVisibleRef, onFocusVisibleRef]);\n  var handleKeyDown = (0, _react.useCallback)(function (event) {\n    if (event.altKey || event.ctrlKey || event.metaKey) {\n      return;\n    }\n\n    if (event.target === targetRef.current) {\n      setHasFocusVisible(true);\n    }\n\n    hadKeyboardEventRef.current = true;\n  }, [hadKeyboardEventRef, setHasFocusVisible, targetRef]);\n  var handlePointerDown = (0, _react.useCallback)(function () {\n    hadKeyboardEventRef.current = false;\n  }, [hadKeyboardEventRef]);\n  var handleFocus = (0, _react.useCallback)(function (_ref) {\n    var target = _ref.target;\n    target === targetRef.current && (hadKeyboardEventRef.current || focusTriggersKeyboardModality(target)) && setHasFocusVisible(true);\n  }, [hadKeyboardEventRef, setHasFocusVisible, targetRef]);\n  var handleBlur = (0, _react.useCallback)(function (event) {\n    if (event.target === targetRef.current && hasFocusVisibleRef.current) {\n      blurSinceRef.current = Date.now();\n      setHasFocusVisible(false);\n    }\n  }, [blurSinceRef, hasFocusVisibleRef, setHasFocusVisible, targetRef]);\n  var handleVisibilityChange = (0, _react.useCallback)(function () {\n    if (document.visibilityState === 'hidden') {\n      // The element is blurred due to \"visibilityState\" set to \"hidden\".\n      // 100ms is referenced from the WICG polyfill.\n      // eslint-disable-next-line no-magic-numbers\n      if (Date.now() - blurSinceRef.current < 100) {\n        hadKeyboardEventRef.current = true;\n      }\n\n      eventSubscription.resume();\n    }\n  }, [blurSinceRef, eventSubscription, hadKeyboardEventRef]);\n  (0, _react.useEffect)(function () {\n    document.addEventListener('keydown', handleKeyDown, true);\n    document.addEventListener('mousedown', handlePointerDown, true);\n    document.addEventListener('pointerdown', handlePointerDown, true);\n    document.addEventListener('touchstart', handlePointerDown, true);\n    document.addEventListener('visibilitychange', handleVisibilityChange, true);\n    return function () {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('mousedown', handlePointerDown);\n      document.removeEventListener('pointerdown', handlePointerDown);\n      document.removeEventListener('touchstart', handlePointerDown);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [handleKeyDown, handlePointerDown, handleVisibilityChange]);\n  (0, _react.useEffect)(function () {\n    var target = targetRef.current;\n    target.addEventListener('blur', handleBlur, true);\n    target.addEventListener('focus', handleFocus, true);\n    return function () {\n      target.removeEventListener('blur', handleBlur);\n      target.removeEventListener('focus', handleFocus);\n    }; // We specifically add \"targetRef.current\" here.\n    // If the target element changed, we should reattach our event listeners.\n  }, [handleBlur, handleFocus, targetRef]);\n  (0, _react.useEffect)(function () {\n    eventSubscription.resume();\n    return function () {\n      return eventSubscription.pause();\n    };\n  }, [eventSubscription]);\n}\n\nfunction useObserveFocusVisibleForModernBrowsers(targetRef, onFocusVisibleRef) {\n  var handleFocus = (0, _react.useCallback)(function () {\n    if (targetRef.current.matches(':focus-visible')) {\n      onFocusVisibleRef === null || onFocusVisibleRef === void 0 ? void 0 : onFocusVisibleRef.current();\n    }\n  }, [onFocusVisibleRef, targetRef]);\n  (0, _react.useEffect)(function () {\n    var target = targetRef.current;\n    target.addEventListener('focus', handleFocus);\n    return function () {\n      return target.removeEventListener('focus', handleFocus);\n    }; // We specifically add \"targetRef.current\" here.\n    // If the target element changed, we should reattach our event listeners.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [handleFocus, targetRef, targetRef.current]);\n}\n\nfunction useObserveFocusVisible(targetRef, onFocusVisible) {\n  var _useNonce = (0, _useNonce3.default)(),\n      _useNonce2 = _slicedToArray(_useNonce, 1),\n      nonce = _useNonce2[0];\n\n  var onFocusVisibleRef = (0, _useValueRef.default)(onFocusVisible); // The nonce is use for browser capabilities. Just in case the \"nonce\" had changed unexpectedly, the capabilities of the browser should never change.\n  // Thus, we are using an initial version of \"nonce\". In case web devs changed the \"nonce\" to an invalid value, we won't break rules of hooks (as stated below).\n\n  var nonceRef = (0, _react.useRef)(nonce); // \":focus-visible\" selector is supported from Chrome/Edge 86+ and not supported in IE11 or Safari.\n  // Doing a capability check on pseudo classes requires injecting a stylesheet, thus nonce is needed.\n\n  var supportFocusVisible = (0, _react.useMemo)(function () {\n    return (0, _supportPseudoClass.default)(':focus-visible', nonceRef.current);\n  }, [nonceRef]); // Since \"supportPseudoClass\" is a browser capability, the result should be constant during the page lifetime.\n  // Thus, running hooks conditionally is okay here.\n\n  if (supportFocusVisible) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useObserveFocusVisibleForModernBrowsers(targetRef, onFocusVisibleRef);\n  } else {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useObserveFocusVisibleForLegacyBrowsers(targetRef, onFocusVisibleRef);\n  }\n}","map":{"version":3,"mappings":"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","names":["INPUT_TYPES_ALLOW_LIST","focusTriggersKeyboardModality","el","isContentEditable","readOnly","tagName","type","includes","createEventSubscription","target","types","handler","subscribed","subscribe","forEach","addEventListener","unsubscribe","removeEventListener","undefined","pause","resume","useObserveFocusVisibleForLegacyBrowsers","targetRef","onFocusVisibleRef","blurSinceRef","hadKeyboardEventRef","hasFocusVisibleRef","eventSubscription","document","event","nodeName","toLowerCase","current","setHasFocusVisible","nextHasFocusVisible","handleKeyDown","altKey","ctrlKey","metaKey","handlePointerDown","handleFocus","handleBlur","Date","now","handleVisibilityChange","visibilityState","useObserveFocusVisibleForModernBrowsers","matches","useObserveFocusVisible","onFocusVisible","nonce","nonceRef","supportFocusVisible"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-component/lib/src/hooks/internal/useObserveFocusVisible.ts"],"sourcesContent":["import { MutableRefObject, RefObject, useCallback, useEffect, useMemo, useRef } from 'react';\n\nimport supportPseudoClass from '../../Utils/supportPseudoClass';\nimport useNonce from './useNonce';\nimport useValueRef from './useValueRef';\n\nconst INPUT_TYPES_ALLOW_LIST = [\n  'date',\n  'datetime-local',\n  'datetime',\n  'email',\n  'month',\n  'number',\n  'password',\n  'search',\n  'tel',\n  'text',\n  'time',\n  'url',\n  'week'\n];\n\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} el\n * @return {boolean}\n */\nfunction focusTriggersKeyboardModality(el: HTMLInputElement | HTMLTextAreaElement): boolean {\n  const { isContentEditable, readOnly, tagName, type } = el;\n\n  return (\n    (tagName === 'INPUT' && INPUT_TYPES_ALLOW_LIST.includes(type) && !readOnly) ||\n    (tagName === 'TEXTAREA' && !readOnly) ||\n    isContentEditable\n  );\n}\n\nfunction createEventSubscription(\n  target: Element | Node,\n  types: string[],\n  handler: (event: Event) => void\n): {\n  pause: () => void;\n  resume: () => void;\n} {\n  let subscribed: true;\n\n  const subscribe = () => {\n    if (!subscribed) {\n      types.forEach(type => target.addEventListener(type, handler));\n      subscribed = true;\n    }\n  };\n\n  const unsubscribe = () => {\n    if (subscribed) {\n      types.forEach(type => target.removeEventListener(type, handler));\n      subscribed = undefined;\n    }\n  };\n\n  return {\n    pause: unsubscribe,\n    resume: subscribe\n  };\n}\n\n// TODO: Add tests\n//       1. Focus via keyboard vs. mouse\n//       2. Focus via keyboard, switch app, switch back (expect to get another focusVisible after switch back)\n//       3. Focus via mouse, switch app, switch back (do NOT expect to get another focusVisible after switch back)\nfunction useObserveFocusVisibleForLegacyBrowsers(\n  targetRef: RefObject<HTMLElement>,\n  onFocusVisibleRef: MutableRefObject<() => void>\n) {\n  // This polyfill algorithm is adopted from https://github.com/WICG/focus-visible.\n  const blurSinceRef = useRef(0);\n  const hadKeyboardEventRef = useRef(true);\n  const hasFocusVisibleRef = useRef(false);\n\n  const eventSubscription = useMemo(\n    () =>\n      createEventSubscription(\n        document,\n        [\n          'mousemove',\n          'mousedown',\n          'mouseup',\n          'pointermove',\n          'pointerdown',\n          'pointerup',\n          'touchmove',\n          'touchstart',\n          'touchend'\n        ],\n        event => {\n          if ((event.target as HTMLElement).nodeName?.toLowerCase() !== 'html') {\n            hadKeyboardEventRef.current = false;\n            eventSubscription.pause();\n          }\n        }\n      ),\n    [hadKeyboardEventRef]\n  );\n\n  const setHasFocusVisible = useCallback(\n    nextHasFocusVisible => {\n      if (hasFocusVisibleRef.current !== nextHasFocusVisible) {\n        hasFocusVisibleRef.current = nextHasFocusVisible;\n        nextHasFocusVisible && onFocusVisibleRef?.current();\n      }\n    },\n    [hasFocusVisibleRef, onFocusVisibleRef]\n  );\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (event.altKey || event.ctrlKey || event.metaKey) {\n        return;\n      }\n\n      if (event.target === targetRef.current) {\n        setHasFocusVisible(true);\n      }\n\n      hadKeyboardEventRef.current = true;\n    },\n    [hadKeyboardEventRef, setHasFocusVisible, targetRef]\n  );\n\n  const handlePointerDown = useCallback(() => {\n    hadKeyboardEventRef.current = false;\n  }, [hadKeyboardEventRef]);\n\n  const handleFocus = useCallback(\n    ({ target }: Event) => {\n      target === targetRef.current &&\n        (hadKeyboardEventRef.current || focusTriggersKeyboardModality(target as HTMLInputElement)) &&\n        setHasFocusVisible(true);\n    },\n    [hadKeyboardEventRef, setHasFocusVisible, targetRef]\n  );\n\n  const handleBlur = useCallback(\n    (event: Event) => {\n      if (event.target === targetRef.current && hasFocusVisibleRef.current) {\n        blurSinceRef.current = Date.now();\n\n        setHasFocusVisible(false);\n      }\n    },\n    [blurSinceRef, hasFocusVisibleRef, setHasFocusVisible, targetRef]\n  );\n\n  const handleVisibilityChange = useCallback(() => {\n    if (document.visibilityState === 'hidden') {\n      // The element is blurred due to \"visibilityState\" set to \"hidden\".\n      // 100ms is referenced from the WICG polyfill.\n      // eslint-disable-next-line no-magic-numbers\n      if (Date.now() - blurSinceRef.current < 100) {\n        hadKeyboardEventRef.current = true;\n      }\n\n      eventSubscription.resume();\n    }\n  }, [blurSinceRef, eventSubscription, hadKeyboardEventRef]);\n\n  useEffect(() => {\n    document.addEventListener('keydown', handleKeyDown, true);\n    document.addEventListener('mousedown', handlePointerDown, true);\n    document.addEventListener('pointerdown', handlePointerDown, true);\n    document.addEventListener('touchstart', handlePointerDown, true);\n    document.addEventListener('visibilitychange', handleVisibilityChange, true);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('mousedown', handlePointerDown);\n      document.removeEventListener('pointerdown', handlePointerDown);\n      document.removeEventListener('touchstart', handlePointerDown);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [handleKeyDown, handlePointerDown, handleVisibilityChange]);\n\n  useEffect(() => {\n    const { current: target } = targetRef;\n\n    target.addEventListener('blur', handleBlur, true);\n    target.addEventListener('focus', handleFocus, true);\n\n    return () => {\n      target.removeEventListener('blur', handleBlur);\n      target.removeEventListener('focus', handleFocus);\n    };\n\n    // We specifically add \"targetRef.current\" here.\n    // If the target element changed, we should reattach our event listeners.\n  }, [handleBlur, handleFocus, targetRef]);\n\n  useEffect(() => {\n    eventSubscription.resume();\n\n    return () => eventSubscription.pause();\n  }, [eventSubscription]);\n}\n\nfunction useObserveFocusVisibleForModernBrowsers(\n  targetRef: RefObject<HTMLElement>,\n  onFocusVisibleRef: MutableRefObject<() => void>\n) {\n  const handleFocus = useCallback(() => {\n    if (targetRef.current.matches(':focus-visible')) {\n      onFocusVisibleRef?.current();\n    }\n  }, [onFocusVisibleRef, targetRef]);\n\n  useEffect(() => {\n    const { current: target } = targetRef;\n\n    target.addEventListener('focus', handleFocus);\n\n    return () => target.removeEventListener('focus', handleFocus);\n\n    // We specifically add \"targetRef.current\" here.\n    // If the target element changed, we should reattach our event listeners.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [handleFocus, targetRef, targetRef.current]);\n}\n\nexport default function useObserveFocusVisible(targetRef: RefObject<HTMLElement>, onFocusVisible: () => void) {\n  const [nonce] = useNonce();\n  const onFocusVisibleRef = useValueRef(onFocusVisible);\n\n  // The nonce is use for browser capabilities. Just in case the \"nonce\" had changed unexpectedly, the capabilities of the browser should never change.\n  // Thus, we are using an initial version of \"nonce\". In case web devs changed the \"nonce\" to an invalid value, we won't break rules of hooks (as stated below).\n  const nonceRef = useRef(nonce);\n\n  // \":focus-visible\" selector is supported from Chrome/Edge 86+ and not supported in IE11 or Safari.\n  // Doing a capability check on pseudo classes requires injecting a stylesheet, thus nonce is needed.\n  const supportFocusVisible = useMemo(() => supportPseudoClass(':focus-visible', nonceRef.current), [nonceRef]);\n\n  // Since \"supportPseudoClass\" is a browser capability, the result should be constant during the page lifetime.\n  // Thus, running hooks conditionally is okay here.\n  if (supportFocusVisible) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useObserveFocusVisibleForModernBrowsers(targetRef, onFocusVisibleRef);\n  } else {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useObserveFocusVisibleForLegacyBrowsers(targetRef, onFocusVisibleRef);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}