{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RequestSession = void 0;\n\nvar Exports_1 = require(\"../common/Exports\");\n\nvar RecognitionEvents_1 = require(\"./RecognitionEvents\");\n\nvar ServiceTelemetryListener_Internal_1 = require(\"./ServiceTelemetryListener.Internal\");\n\nvar RequestSession =\n/** @class */\nfunction () {\n  function RequestSession(audioSourceId) {\n    var _this = this;\n\n    this.privIsDisposed = false;\n    this.privDetachables = new Array();\n    this.privIsAudioNodeDetached = false;\n    this.privIsRecognizing = false;\n    this.privIsSpeechEnded = false;\n    this.privTurnStartAudioOffset = 0;\n    this.privLastRecoOffset = 0;\n    this.privHypothesisReceived = false;\n    this.privBytesSent = 0;\n    this.privRecogNumber = 0;\n    this.privInTurn = false;\n    this.privConnectionAttempts = 0;\n\n    this.onPreConnectionStart = function (authFetchEventId, connectionId) {\n      _this.privAuthFetchEventId = authFetchEventId;\n      _this.privSessionId = connectionId;\n\n      _this.onEvent(new RecognitionEvents_1.ConnectingToServiceEvent(_this.privRequestId, _this.privAuthFetchEventId, _this.privSessionId));\n    };\n\n    this.onServiceTurnStartResponse = function () {\n      if (!!_this.privTurnDeferral && !!_this.privInTurn) {\n        // What? How are we starting a turn with another not done?\n        _this.privTurnDeferral.reject(\"Another turn started before current completed.\"); // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n\n        /* tslint:disable:no-empty */\n\n\n        _this.privTurnDeferral.promise.then().catch(function () {});\n      }\n\n      _this.privInTurn = true;\n      _this.privTurnDeferral = new Exports_1.Deferred();\n    };\n\n    this.getTelemetry = function () {\n      if (_this.privServiceTelemetryListener.hasTelemetry) {\n        return _this.privServiceTelemetryListener.getTelemetry();\n      } else {\n        return null;\n      }\n    };\n\n    this.onEvent = function (event) {\n      if (!!_this.privServiceTelemetryListener) {\n        _this.privServiceTelemetryListener.onEvent(event);\n      }\n\n      Exports_1.Events.instance.onEvent(event);\n    };\n\n    this.privAudioSourceId = audioSourceId;\n    this.privRequestId = Exports_1.createNoDashGuid();\n    this.privAudioNodeId = Exports_1.createNoDashGuid();\n    this.privTurnDeferral = new Exports_1.Deferred(); // We're not in a turn, so resolve.\n\n    this.privTurnDeferral.resolve();\n  }\n\n  Object.defineProperty(RequestSession.prototype, \"sessionId\", {\n    get: function () {\n      return this.privSessionId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"requestId\", {\n    get: function () {\n      return this.privRequestId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"audioNodeId\", {\n    get: function () {\n      return this.privAudioNodeId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"turnCompletionPromise\", {\n    get: function () {\n      return this.privTurnDeferral.promise;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"isSpeechEnded\", {\n    get: function () {\n      return this.privIsSpeechEnded;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"isRecognizing\", {\n    get: function () {\n      return this.privIsRecognizing;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"currentTurnAudioOffset\", {\n    get: function () {\n      return this.privTurnStartAudioOffset;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"recogNumber\", {\n    get: function () {\n      return this.privRecogNumber;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"numConnectionAttempts\", {\n    get: function () {\n      return this.privConnectionAttempts;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(RequestSession.prototype, \"bytesSent\", {\n    // The number of bytes sent for the current connection.\n    // Counter is reset to 0 each time a connection is established.\n    get: function () {\n      return this.privBytesSent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  RequestSession.prototype.listenForServiceTelemetry = function (eventSource) {\n    if (!!this.privServiceTelemetryListener) {\n      this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\n    }\n  };\n\n  RequestSession.prototype.startNewRecognition = function () {\n    this.privIsSpeechEnded = false;\n    this.privIsRecognizing = true;\n    this.privTurnStartAudioOffset = 0;\n    this.privLastRecoOffset = 0;\n    this.privRequestId = Exports_1.createNoDashGuid();\n    this.privRecogNumber++;\n    this.privServiceTelemetryListener = new ServiceTelemetryListener_Internal_1.ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\n    this.onEvent(new RecognitionEvents_1.RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n  };\n\n  RequestSession.prototype.onAudioSourceAttachCompleted = function (audioNode, isError, error) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.privAudioNode = audioNode;\n            this.privIsAudioNodeDetached = false;\n            if (!isError) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.onComplete()];\n\n          case 1:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            this.onEvent(new RecognitionEvents_1.ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  RequestSession.prototype.onAuthCompleted = function (isError, error) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!isError) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.onComplete()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  RequestSession.prototype.onConnectionEstablishCompleted = function (statusCode, reason) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(statusCode === 200)) return [3\n            /*break*/\n            , 1];\n            this.onEvent(new RecognitionEvents_1.RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));\n\n            if (!!this.privAudioNode) {\n              this.privAudioNode.replay();\n            }\n\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\n            this.privBytesSent = 0;\n            return [2\n            /*return*/\n            ];\n\n          case 1:\n            if (!(statusCode === 403)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.onComplete()];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  RequestSession.prototype.onServiceTurnEndResponse = function (continuousRecognition) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.privTurnDeferral.resolve();\n            if (!(!continuousRecognition || this.isSpeechEnded)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.onComplete()];\n\n          case 1:\n            _a.sent();\n\n            this.privInTurn = false;\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            // Start a new request set.\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\n            this.privRequestId = Exports_1.createNoDashGuid();\n            this.privAudioNode.replay();\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  RequestSession.prototype.onHypothesis = function (offset) {\n    if (!this.privHypothesisReceived) {\n      this.privHypothesisReceived = true;\n      this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\n    }\n  };\n\n  RequestSession.prototype.onPhraseRecognized = function (offset) {\n    this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\n    this.onServiceRecognized(offset);\n  };\n\n  RequestSession.prototype.onServiceRecognized = function (offset) {\n    this.privLastRecoOffset = offset;\n    this.privHypothesisReceived = false;\n    this.privAudioNode.shrinkBuffers(offset);\n    this.privConnectionAttempts = 0;\n  };\n\n  RequestSession.prototype.onAudioSent = function (bytesSent) {\n    this.privBytesSent += bytesSent;\n  };\n\n  RequestSession.prototype.onRetryConnection = function () {\n    this.privConnectionAttempts++;\n  };\n\n  RequestSession.prototype.dispose = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _i, _a, detachable;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!!this.privIsDisposed) return [3\n            /*break*/\n            , 5]; // we should have completed by now. If we did not its an unknown error.\n\n            this.privIsDisposed = true;\n            _i = 0, _a = this.privDetachables;\n            _b.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3\n            /*break*/\n            , 4];\n            detachable = _a[_i];\n            return [4\n            /*yield*/\n            , detachable.detach()];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            _i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            this.privServiceTelemetryListener.dispose();\n            this.privIsRecognizing = false;\n            _b.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  RequestSession.prototype.onStopRecognizing = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.onComplete()];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // Should be called with the audioNode for this session has indicated that it is out of speech.\n\n\n  RequestSession.prototype.onSpeechEnded = function () {\n    this.privIsSpeechEnded = true;\n  };\n\n  RequestSession.prototype.onComplete = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!!this.privIsRecognizing) return [3\n            /*break*/\n            , 2];\n            this.privIsRecognizing = false;\n            return [4\n            /*yield*/\n            , this.detachAudioNode()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  RequestSession.prototype.detachAudioNode = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!this.privIsAudioNodeDetached) return [3\n            /*break*/\n            , 2];\n            this.privIsAudioNodeDetached = true;\n            if (!this.privAudioNode) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.privAudioNode.detach()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return RequestSession;\n}();\n\nexports.RequestSession = RequestSession;","map":{"version":3,"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;AAQA;;AAOA;;AAEA;AAAA;AAAA;AAsBI,0BAAYA,aAAZ,EAAiC;AAAjC;;AArBQ,0BAA0B,KAA1B;AAEA,2BAAiC,IAAIC,KAAJ,EAAjC;AAMA,mCAAmC,KAAnC;AACA,6BAA6B,KAA7B;AACA,6BAA6B,KAA7B;AACA,oCAAmC,CAAnC;AACA,8BAA6B,CAA7B;AACA,kCAAkC,KAAlC;AACA,yBAAwB,CAAxB;AACA,2BAA0B,CAA1B;AAGA,sBAAsB,KAAtB;AACA,kCAAiC,CAAjC;;AAiFD,gCAAuB,UAACC,gBAAD,EAA2BC,YAA3B,EAA+C;AACzEC,WAAI,CAACC,oBAAL,GAA4BH,gBAA5B;AACAE,WAAI,CAACE,aAAL,GAAqBH,YAArB;;AACAC,WAAI,CAACG,OAAL,CAAa,IAAIC,4CAAJ,CAA6BJ,KAAI,CAACK,aAAlC,EAAiDL,KAAI,CAACC,oBAAtD,EAA4ED,KAAI,CAACE,aAAjF,CAAb;AACH,KAJM;;AAwCA,sCAA6B;AAChC,UAAI,CAAC,CAACF,KAAI,CAACM,gBAAP,IAA2B,CAAC,CAACN,KAAI,CAACO,UAAtC,EAAkD;AAC9C;AACAP,aAAI,CAACM,gBAAL,CAAsBE,MAAtB,CAA6B,gDAA7B,EAF8C,CAG9C;;AACA;;;AACAR,aAAI,CAACM,gBAAL,CAAsBG,OAAtB,CAA8BC,IAA9B,GAAqCC,KAArC,CAA2C,aAAS,CAApD;AACH;;AACDX,WAAI,CAACO,UAAL,GAAkB,IAAlB;AACAP,WAAI,CAACM,gBAAL,GAAwB,IAAIM,kBAAJ,EAAxB;AACH,KAVM;;AAoDA,wBAAe;AAClB,UAAIZ,KAAI,CAACa,4BAAL,CAAkCC,YAAtC,EAAoD;AAChD,eAAOd,KAAI,CAACa,4BAAL,CAAkCE,YAAlC,EAAP;AACH,OAFD,MAEO;AACH,eAAO,IAAP;AACH;AACJ,KANM;;AAiBG,mBAAU,UAACC,KAAD,EAA8B;AAC9C,UAAI,CAAC,CAAChB,KAAI,CAACa,4BAAX,EAAyC;AACrCb,aAAI,CAACa,4BAAL,CAAkCV,OAAlC,CAA0Ca,KAA1C;AACH;;AACDJ,uBAAOK,QAAP,CAAgBd,OAAhB,CAAwBa,KAAxB;AACH,KALS;;AA3LN,SAAKE,iBAAL,GAAyBtB,aAAzB;AACA,SAAKS,aAAL,GAAqBO,4BAArB;AACA,SAAKO,eAAL,GAAuBP,4BAAvB;AACA,SAAKN,gBAAL,GAAwB,IAAIM,kBAAJ,EAAxB,CAJ6B,CAM7B;;AACA,SAAKN,gBAAL,CAAsBc,OAAtB;AACH;;AAEDC,wBAAWC,wBAAX,EAAW,WAAX,EAAoB;SAApB;AACI,aAAO,KAAKpB,aAAZ;AACH,KAFmB;qBAAA;;AAAA,GAApB;AAIAmB,wBAAWC,wBAAX,EAAW,WAAX,EAAoB;SAApB;AACI,aAAO,KAAKjB,aAAZ;AACH,KAFmB;qBAAA;;AAAA,GAApB;AAIAgB,wBAAWC,wBAAX,EAAW,aAAX,EAAsB;SAAtB;AACI,aAAO,KAAKH,eAAZ;AACH,KAFqB;qBAAA;;AAAA,GAAtB;AAIAE,wBAAWC,wBAAX,EAAW,uBAAX,EAAgC;SAAhC;AACI,aAAO,KAAKhB,gBAAL,CAAsBG,OAA7B;AACH,KAF+B;qBAAA;;AAAA,GAAhC;AAIAY,wBAAWC,wBAAX,EAAW,eAAX,EAAwB;SAAxB;AACI,aAAO,KAAKC,iBAAZ;AACH,KAFuB;qBAAA;;AAAA,GAAxB;AAIAF,wBAAWC,wBAAX,EAAW,eAAX,EAAwB;SAAxB;AACI,aAAO,KAAKE,iBAAZ;AACH,KAFuB;qBAAA;;AAAA,GAAxB;AAIAH,wBAAWC,wBAAX,EAAW,wBAAX,EAAiC;SAAjC;AACI,aAAO,KAAKG,wBAAZ;AACH,KAFgC;qBAAA;;AAAA,GAAjC;AAIAJ,wBAAWC,wBAAX,EAAW,aAAX,EAAsB;SAAtB;AACI,aAAO,KAAKI,eAAZ;AACH,KAFqB;qBAAA;;AAAA,GAAtB;AAIAL,wBAAWC,wBAAX,EAAW,uBAAX,EAAgC;SAAhC;AACI,aAAO,KAAKK,sBAAZ;AACH,KAF+B;qBAAA;;AAAA,GAAhC;AAMAN,wBAAWC,wBAAX,EAAW,WAAX,EAAoB;AAFpB;AACA;SACA;AACI,aAAO,KAAKM,aAAZ;AACH,KAFmB;qBAAA;;AAAA,GAApB;;AAGON,uDAAP,UAAiCO,WAAjC,EAAyE;AACrE,QAAI,CAAC,CAAC,KAAKhB,4BAAX,EAAyC;AACrC,WAAKiB,eAAL,CAAqBC,IAArB,CAA0BF,WAAW,CAACG,cAAZ,CAA2B,KAAKnB,4BAAhC,CAA1B;AACH;AACJ,GAJM;;AAMAS,iDAAP;AACI,SAAKC,iBAAL,GAAyB,KAAzB;AACA,SAAKC,iBAAL,GAAyB,IAAzB;AACA,SAAKC,wBAAL,GAAgC,CAAhC;AACA,SAAKQ,kBAAL,GAA0B,CAA1B;AACA,SAAK5B,aAAL,GAAqBO,4BAArB;AACA,SAAKc,eAAL;AACA,SAAKb,4BAAL,GAAoC,IAAIqB,4DAAJ,CAA6B,KAAK7B,aAAlC,EAAiD,KAAKa,iBAAtD,EAAyE,KAAKC,eAA9E,CAApC;AACA,SAAKhB,OAAL,CAAa,IAAIC,6CAAJ,CAA8B,KAAK+B,SAAnC,EAA8C,KAAKjC,aAAnD,EAAkE,KAAKgB,iBAAvE,EAA0F,KAAKC,eAA/F,CAAb;AACH,GATM;;AAWMG,0DAAb,UAA0Cc,SAA1C,EAA0EC,OAA1E,EAA4FC,KAA5F,EAA0G;;;;;AACtG,iBAAKC,aAAL,GAAqBH,SAArB;AACA,iBAAKI,uBAAL,GAA+B,KAA/B;iBAEIH;AAAA;AAAA;AACA;AAAA;AAAA,cAAM,KAAKI,UAAL,EAAN;;;AAAAC;;;;;;;AAEA,iBAAKvC,OAAL,CAAa,IAAIC,yCAAJ,CAA0B,KAAKC,aAA/B,EAA8C,KAAKH,aAAnD,EAAkE,KAAKgB,iBAAvE,EAA0F,KAAKC,eAA/F,CAAb;;;;;;;;;;AAEP,GATY;;AAiBAG,6CAAb,UAA6Be,OAA7B,EAA+CC,KAA/C,EAA6D;;;;;iBACrDD;AAAA;AAAA;AACA;AAAA;AAAA,cAAM,KAAKI,UAAL,EAAN;;;AAAAC;;;;;;;;;;;AAEP,GAJY;;AAMApB,4DAAb,UAA4CqB,UAA5C,EAAgEC,MAAhE,EAA+E;;;;;kBACvED,UAAU,KAAK,MAAf;AAAA;AAAA;AACA,iBAAKxC,OAAL,CAAa,IAAIC,2CAAJ,CAA4B,KAAK+B,SAAjC,EAA4C,KAAKjB,iBAAjD,EAAoE,KAAKC,eAAzE,EAA0F,KAAKlB,oBAA/F,EAAqH,KAAKC,aAA1H,CAAb;;AACA,gBAAI,CAAC,CAAC,KAAKqC,aAAX,EAA0B;AACtB,mBAAKA,aAAL,CAAmBM,MAAnB;AACH;;AACD,iBAAKpB,wBAAL,GAAgC,KAAKQ,kBAArC;AACA,iBAAKL,aAAL,GAAqB,CAArB;AACA;AAAA;AAAA;;;kBACOe,UAAU,KAAK,MAAf;AAAA;AAAA;AACP;AAAA;AAAA,cAAM,KAAKF,UAAL,EAAN;;;AAAAC;;;;;;;;;;;AAEP,GAZY;;AAcApB,sDAAb,UAAsCwB,qBAAtC,EAAoE;;;;;AAChE,iBAAKxC,gBAAL,CAAsBc,OAAtB;kBAEI,CAAC0B,qBAAD,IAA0B,KAAKC,gBAA/B;AAAA;AAAA;AACA;AAAA;AAAA,cAAM,KAAKN,UAAL,EAAN;;;AAAAC;;AACA,iBAAKnC,UAAL,GAAkB,KAAlB;;;;;;AAEA;AACA,iBAAKkB,wBAAL,GAAgC,KAAKQ,kBAArC;AACA,iBAAK5B,aAAL,GAAqBO,4BAArB;AACA,iBAAK2B,aAAL,CAAmBM,MAAnB;;;;;;;;;;AAEP,GAZY;;AA0BNvB,0CAAP,UAAoB0B,MAApB,EAAkC;AAC9B,QAAI,CAAC,KAAKC,sBAAV,EAAkC;AAC9B,WAAKA,sBAAL,GAA8B,IAA9B;AACA,WAAKpC,4BAAL,CAAkCqC,kBAAlC,CAAqD,KAAKX,aAAL,CAAmBY,gBAAnB,CAAoCH,MAApC,CAArD;AACH;AACJ,GALM;;AAOA1B,gDAAP,UAA0B0B,MAA1B,EAAwC;AACpC,SAAKnC,4BAAL,CAAkCuC,cAAlC,CAAiD,KAAKb,aAAL,CAAmBY,gBAAnB,CAAoCH,MAApC,CAAjD;AACA,SAAKK,mBAAL,CAAyBL,MAAzB;AACH,GAHM;;AAKA1B,iDAAP,UAA2B0B,MAA3B,EAAyC;AACrC,SAAKf,kBAAL,GAA0Be,MAA1B;AACA,SAAKC,sBAAL,GAA8B,KAA9B;AACA,SAAKV,aAAL,CAAmBe,aAAnB,CAAiCN,MAAjC;AACA,SAAKrB,sBAAL,GAA8B,CAA9B;AACH,GALM;;AAOAL,yCAAP,UAAmBiC,SAAnB,EAAoC;AAChC,SAAK3B,aAAL,IAAsB2B,SAAtB;AACH,GAFM;;AAIAjC,+CAAP;AACI,SAAKK,sBAAL;AACH,GAFM;;AAIML,qCAAb,UAAqBgB,KAArB,EAAmC;;;;;;;iBAC3B,CAAC,KAAKkB,gBAAN;AAAA;AAAA,kBACA;;AACA,iBAAKA,cAAL,GAAsB,IAAtB;oBACyBd,UAAKZ;;;;kBAAL2B,iBAAoB;AAAA;AAAA;AAAlCC,sBAAU,SAAV;AACP;AAAA;AAAA,cAAMA,UAAU,CAACC,MAAX,EAAN;;;AAAAC;;;;;AADqBH;;;;;;AAIzB,iBAAK5C,4BAAL,CAAkCgD,OAAlC;AACA,iBAAKrC,iBAAL,GAAyB,KAAzB;;;;;;;;;;AAEP,GAXY;;AAqBAF,+CAAb;;;;;AACI;AAAA;AAAA,cAAM,KAAKmB,UAAL,EAAN;;;AAAAC;;;;;;;;AACH,GAFY,CAzMjB,CA6MI;;;AACOpB,2CAAP;AACI,SAAKC,iBAAL,GAAyB,IAAzB;AACH,GAFM;;AAWOD,wCAAd;;;;;iBACQ,CAAC,CAAC,KAAKE,mBAAP;AAAA;AAAA;AACA,iBAAKA,iBAAL,GAAyB,KAAzB;AACA;AAAA;AAAA,cAAM,KAAKsC,eAAL,EAAN;;;AAAApB;;;;;;;;;;;AAEP,GALa;;AAOApB,6CAAd;;;;;iBACQ,CAAC,KAAKkB,yBAAN;AAAA;AAAA;AACA,iBAAKA,uBAAL,GAA+B,IAA/B;iBACI,KAAKD,eAAL;AAAA;AAAA;AACA;AAAA;AAAA,cAAM,KAAKA,aAAL,CAAmBoB,MAAnB,EAAN;;;AAAAjB;;;;;;;;;;;AAGX,GAPa;;AAQlB;AAxOA;;AAAaqB","names":["audioSourceId","Array","authFetchEventId","connectionId","_this","privAuthFetchEventId","privSessionId","onEvent","RecognitionEvents_1","privRequestId","privTurnDeferral","privInTurn","reject","promise","then","catch","Exports_1","privServiceTelemetryListener","hasTelemetry","getTelemetry","event","instance","privAudioSourceId","privAudioNodeId","resolve","Object","RequestSession","privIsSpeechEnded","privIsRecognizing","privTurnStartAudioOffset","privRecogNumber","privConnectionAttempts","privBytesSent","eventSource","privDetachables","push","attachListener","privLastRecoOffset","ServiceTelemetryListener_Internal_1","requestId","audioNode","isError","error","privAudioNode","privIsAudioNodeDetached","onComplete","_a","statusCode","reason","replay","continuousRecognition","isSpeechEnded","offset","privHypothesisReceived","hypothesisReceived","findTimeAtOffset","phraseReceived","onServiceRecognized","shrinkBuffers","bytesSent","privIsDisposed","_i","detachable","detach","_b","dispose","detachAudioNode","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/src/common.speech/RequestSession.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { Z_NO_COMPRESSION } from \"zlib\";\r\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    IDetachable,\r\n    IEventSource,\r\n    PlatformEvent\r\n} from \"../common/Exports\";\r\nimport {\r\n    ConnectingToServiceEvent,\r\n    ListeningStartedEvent,\r\n    RecognitionStartedEvent,\r\n    RecognitionTriggeredEvent,\r\n    SpeechRecognitionEvent,\r\n} from \"./RecognitionEvents\";\r\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal\";\r\n\r\nexport class RequestSession {\r\n    private privIsDisposed: boolean = false;\r\n    private privServiceTelemetryListener: ServiceTelemetryListener;\r\n    private privDetachables: IDetachable[] = new Array<IDetachable>();\r\n    private privRequestId: string;\r\n    private privAudioSourceId: string;\r\n    private privAudioNodeId: string;\r\n    private privAudioNode: ReplayableAudioNode;\r\n    private privAuthFetchEventId: string;\r\n    private privIsAudioNodeDetached: boolean = false;\r\n    private privIsRecognizing: boolean = false;\r\n    private privIsSpeechEnded: boolean = false;\r\n    private privTurnStartAudioOffset: number = 0;\r\n    private privLastRecoOffset: number = 0;\r\n    private privHypothesisReceived: boolean = false;\r\n    private privBytesSent: number = 0;\r\n    private privRecogNumber: number = 0;\r\n    private privSessionId: string;\r\n    private privTurnDeferral: Deferred<void>;\r\n    private privInTurn: boolean = false;\r\n    private privConnectionAttempts: number = 0;\r\n\r\n    constructor(audioSourceId: string) {\r\n        this.privAudioSourceId = audioSourceId;\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privAudioNodeId = createNoDashGuid();\r\n        this.privTurnDeferral = new Deferred<void>();\r\n\r\n        // We're not in a turn, so resolve.\r\n        this.privTurnDeferral.resolve();\r\n    }\r\n\r\n    public get sessionId(): string {\r\n        return this.privSessionId;\r\n    }\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get audioNodeId(): string {\r\n        return this.privAudioNodeId;\r\n    }\r\n\r\n    public get turnCompletionPromise(): Promise<void> {\r\n        return this.privTurnDeferral.promise;\r\n    }\r\n\r\n    public get isSpeechEnded(): boolean {\r\n        return this.privIsSpeechEnded;\r\n    }\r\n\r\n    public get isRecognizing(): boolean {\r\n        return this.privIsRecognizing;\r\n    }\r\n\r\n    public get currentTurnAudioOffset(): number {\r\n        return this.privTurnStartAudioOffset;\r\n    }\r\n\r\n    public get recogNumber(): number {\r\n        return this.privRecogNumber;\r\n    }\r\n\r\n    public get numConnectionAttempts(): number {\r\n        return this.privConnectionAttempts;\r\n    }\r\n\r\n    // The number of bytes sent for the current connection.\r\n    // Counter is reset to 0 each time a connection is established.\r\n    public get bytesSent(): number {\r\n        return this.privBytesSent;\r\n    }\r\n    public listenForServiceTelemetry(eventSource: IEventSource<PlatformEvent>): void {\r\n        if (!!this.privServiceTelemetryListener) {\r\n            this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\r\n        }\r\n    }\r\n\r\n    public startNewRecognition(): void {\r\n        this.privIsSpeechEnded = false;\r\n        this.privIsRecognizing = true;\r\n        this.privTurnStartAudioOffset = 0;\r\n        this.privLastRecoOffset = 0;\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privRecogNumber++;\r\n        this.privServiceTelemetryListener = new ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\r\n        this.onEvent(new RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\r\n    }\r\n\r\n    public async onAudioSourceAttachCompleted(audioNode: ReplayableAudioNode, isError: boolean, error?: string): Promise<void> {\r\n        this.privAudioNode = audioNode;\r\n        this.privIsAudioNodeDetached = false;\r\n\r\n        if (isError) {\r\n            await this.onComplete();\r\n        } else {\r\n            this.onEvent(new ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\r\n        }\r\n    }\r\n\r\n    public onPreConnectionStart = (authFetchEventId: string, connectionId: string): void => {\r\n        this.privAuthFetchEventId = authFetchEventId;\r\n        this.privSessionId = connectionId;\r\n        this.onEvent(new ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));\r\n    }\r\n\r\n    public async onAuthCompleted(isError: boolean, error?: string): Promise<void> {\r\n        if (isError) {\r\n            await this.onComplete();\r\n        }\r\n    }\r\n\r\n    public async onConnectionEstablishCompleted(statusCode: number, reason?: string): Promise<void> {\r\n        if (statusCode === 200) {\r\n            this.onEvent(new RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));\r\n            if (!!this.privAudioNode) {\r\n                this.privAudioNode.replay();\r\n            }\r\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\r\n            this.privBytesSent = 0;\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            await this.onComplete();\r\n        }\r\n    }\r\n\r\n    public async onServiceTurnEndResponse(continuousRecognition: boolean): Promise<void> {\r\n        this.privTurnDeferral.resolve();\r\n\r\n        if (!continuousRecognition || this.isSpeechEnded) {\r\n            await this.onComplete();\r\n            this.privInTurn = false;\r\n        } else {\r\n            // Start a new request set.\r\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\r\n            this.privRequestId = createNoDashGuid();\r\n            this.privAudioNode.replay();\r\n        }\r\n    }\r\n\r\n    public onServiceTurnStartResponse = (): void => {\r\n        if (!!this.privTurnDeferral && !!this.privInTurn) {\r\n            // What? How are we starting a turn with another not done?\r\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\r\n            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\r\n            /* tslint:disable:no-empty */\r\n            this.privTurnDeferral.promise.then().catch(() => { });\r\n        }\r\n        this.privInTurn = true;\r\n        this.privTurnDeferral = new Deferred<void>();\r\n    }\r\n\r\n    public onHypothesis(offset: number): void {\r\n        if (!this.privHypothesisReceived) {\r\n            this.privHypothesisReceived = true;\r\n            this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\r\n        }\r\n    }\r\n\r\n    public onPhraseRecognized(offset: number): void {\r\n        this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\r\n        this.onServiceRecognized(offset);\r\n    }\r\n\r\n    public onServiceRecognized(offset: number): void {\r\n        this.privLastRecoOffset = offset;\r\n        this.privHypothesisReceived = false;\r\n        this.privAudioNode.shrinkBuffers(offset);\r\n        this.privConnectionAttempts = 0;\r\n    }\r\n\r\n    public onAudioSent(bytesSent: number): void {\r\n        this.privBytesSent += bytesSent;\r\n    }\r\n\r\n    public onRetryConnection(): void {\r\n        this.privConnectionAttempts++;\r\n    }\r\n\r\n    public async dispose(error?: string): Promise<void> {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n            for (const detachable of this.privDetachables) {\r\n                await detachable.detach();\r\n            }\r\n\r\n            this.privServiceTelemetryListener.dispose();\r\n            this.privIsRecognizing = false;\r\n        }\r\n    }\r\n\r\n    public getTelemetry = (): string => {\r\n        if (this.privServiceTelemetryListener.hasTelemetry) {\r\n            return this.privServiceTelemetryListener.getTelemetry();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public async onStopRecognizing(): Promise<void> {\r\n        await this.onComplete();\r\n    }\r\n\r\n    // Should be called with the audioNode for this session has indicated that it is out of speech.\r\n    public onSpeechEnded(): void {\r\n        this.privIsSpeechEnded = true;\r\n    }\r\n\r\n    protected onEvent = (event: SpeechRecognitionEvent): void => {\r\n        if (!!this.privServiceTelemetryListener) {\r\n            this.privServiceTelemetryListener.onEvent(event);\r\n        }\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private async onComplete(): Promise<void> {\r\n        if (!!this.privIsRecognizing) {\r\n            this.privIsRecognizing = false;\r\n            await this.detachAudioNode();\r\n        }\r\n    }\r\n\r\n    private async detachAudioNode(): Promise<void> {\r\n        if (!this.privIsAudioNodeDetached) {\r\n            this.privIsAudioNodeDetached = true;\r\n            if (this.privAudioNode) {\r\n                await this.privAudioNode.detach();\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}