{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n/* eslint no-await-in-loop: \"off\" */\n\n\nvar _default = /*#__PURE__*/function () {\n  function _default(audioContext) {\n    (0, _classCallCheck2.default)(this, _default);\n    this.audioContext = audioContext;\n  }\n\n  (0, _createClass2.default)(_default, [{\n    key: \"pause\",\n    value: function pause() {\n      this.audioContext && this.audioContext.suspend();\n      this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('pause'));\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      this.audioContext && this.audioContext.resume();\n      this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('resume'));\n    }\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(queue) {\n        var utterance;\n        return _regenerator.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(utterance = queue.shift())) {\n                  _context.next = 7;\n                  break;\n                }\n\n                this.playingUtterance = utterance;\n                _context.next = 4;\n                return utterance.play(this.audioContext);\n\n              case 4:\n                this.playingUtterance = null;\n                _context.next = 0;\n                break;\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function start(_x) {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.playingUtterance && this.playingUtterance.stop();\n\n      if (this.audioContext.state === 'suspended') {\n        // Play -> Pause -> Cancel (stop)\n        // This would generate these events: \"start\", \"pause\", \"end\"\n        // Without this code, the \"end\" event will not emit until resume() is called\n        // Cancelling an unstarted utterance will not emit any \"start\" or \"end\" event\n        this.audioContext.resume();\n      }\n    }\n  }]);\n  return _default;\n}();\n\nexports.default = _default;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;AAAA;;;;AAGE,oBAAYA,YAAZ,EAA0B;AAAA;AACxB,SAAKA,YAAL,GAAoBA,YAApB;AACD;;;;WAED,iBAAQ;AACN,WAAKA,YAAL,IAAqB,KAAKA,YAAL,CAAkBC,OAAlB,EAArB;AACA,WAAKC,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBC,aAAtB,CAAoC,IAAIC,WAAJ,CAAgB,OAAhB,CAApC,CAAzB;AACD;;;WAED,kBAAS;AACP,WAAKJ,YAAL,IAAqB,KAAKA,YAAL,CAAkBK,MAAlB,EAArB;AACA,WAAKH,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBC,aAAtB,CAAoC,IAAIC,WAAJ,CAAgB,QAAhB,CAApC,CAAzB;AACD;;;;2FAED,iBAAYE,KAAZ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAGUC,SAAS,GAAGD,KAAK,CAACE,KAANF,EAHtB;AAAAG;AAAA;AAAA;;AAII,qBAAKP,gBAAL,GAAwBK,SAAxB;AAJJE;AAAA,uBAMUF,SAAS,CAACG,IAAVH,CAAe,KAAKP,YAApBO,CANV;;AAAA;AAQI,qBAAKL,gBAAL,GAAwB,IAAxB;AARJO;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;WAYA,gBAAO;AACL,WAAKP,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBS,IAAtB,EAAzB;;AAEA,UAAI,KAAKX,YAAL,CAAkBY,KAAlB,KAA4B,WAAhC,EAA6C;AAC3C;AACA;AAEA;AACA;AACA,aAAKZ,YAAL,CAAkBK,MAAlB;AACD;AACF","names":["audioContext","suspend","playingUtterance","dispatchEvent","CustomEvent","resume","queue","utterance","shift","_context","play","stop","state"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/web-speech-cognitive-services/src/SpeechServices/TextToSpeech/AudioContextConsumer.js"],"sourcesContent":["/* eslint no-await-in-loop: \"off\" */\n\nexport default class {\n  constructor(audioContext) {\n    this.audioContext = audioContext;\n  }\n\n  pause() {\n    this.audioContext && this.audioContext.suspend();\n    this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('pause'));\n  }\n\n  resume() {\n    this.audioContext && this.audioContext.resume();\n    this.playingUtterance && this.playingUtterance.dispatchEvent(new CustomEvent('resume'));\n  }\n\n  async start(queue) {\n    let utterance;\n\n    while ((utterance = queue.shift())) {\n      this.playingUtterance = utterance;\n\n      await utterance.play(this.audioContext);\n\n      this.playingUtterance = null;\n    }\n  }\n\n  stop() {\n    this.playingUtterance && this.playingUtterance.stop();\n\n    if (this.audioContext.state === 'suspended') {\n      // Play -> Pause -> Cancel (stop)\n      // This would generate these events: \"start\", \"pause\", \"end\"\n\n      // Without this code, the \"end\" event will not emit until resume() is called\n      // Cancelling an unstarted utterance will not emit any \"start\" or \"end\" event\n      this.audioContext.resume();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}