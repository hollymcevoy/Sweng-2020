{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _Composer = _interopRequireDefault(require(\"./Composer\"));\n\nvar _createCustomEvent = _interopRequireDefault(require(\"./createCustomEvent\"));\n\nvar _createErrorEvent = _interopRequireDefault(require(\"./createErrorEvent\"));\n\nvar _migrateDeprecatedProps = _interopRequireDefault(require(\"./migrateDeprecatedProps\"));\n\nvar _useSynthesize = _interopRequireDefault(require(\"./useSynthesize\"));\n\nvar _excluded = [\"ponyfill\"];\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar SayUtterance = function SayUtterance(props) {\n  var _migrateDeprecatedPro = (0, _migrateDeprecatedProps[\"default\"])(props),\n      onEnd = _migrateDeprecatedPro.onEnd,\n      onError = _migrateDeprecatedPro.onError,\n      onStart = _migrateDeprecatedPro.onStart,\n      utterance = _migrateDeprecatedPro.utterance;\n\n  var started = (0, _react.useRef)(false);\n  var synthesize = (0, _useSynthesize[\"default\"])(); // This useEffect() is essentially converting Promise-based useSynthesize() into events.\n\n  (0, _react.useEffect)(function () {\n    // After synthesis started, if utterance has changed, the event will be fired by the wrong target.\n    // Thus, we do not allow utterance to change after synthesis started.\n    if (started.current) {\n      // Since we have already cancelled the previous utterance, we are not starting a new one.\n      // This is because if we start a new one, we could fire onStart event twice, which sound confusing to the developer.\n      return console.warn('react-say: Should not change utterance after synthesis started.');\n    }\n\n    var cancelled;\n\n    var _synthesize = synthesize(utterance, function () {\n      started.current = true;\n      !cancelled && onStart && onStart((0, _createCustomEvent[\"default\"])('start'));\n    }),\n        cancel = _synthesize.cancel,\n        promise = _synthesize.promise;\n\n    promise.then(function () {\n      return !cancelled && onEnd && onEnd((0, _createCustomEvent[\"default\"])('end'));\n    }, function (error) {\n      return !cancelled && onError && onError((0, _createErrorEvent[\"default\"])(error));\n    });\n    return function () {\n      cancelled = true;\n      cancel();\n    };\n  }, []);\n  return false;\n};\n\nSayUtterance.defaultProps = {\n  onEnd: undefined,\n  onError: undefined,\n  onStart: undefined\n};\nSayUtterance.propTypes = {\n  onEnd: _propTypes[\"default\"].func,\n  onError: _propTypes[\"default\"].func,\n  onStart: _propTypes[\"default\"].func\n};\n\nvar SayUtteranceWithContext = function SayUtteranceWithContext(_ref) {\n  var ponyfill = _ref.ponyfill,\n      props = (0, _objectWithoutProperties2[\"default\"])(_ref, _excluded);\n  return /*#__PURE__*/_react[\"default\"].createElement(_Composer[\"default\"], {\n    ponyfill: ponyfill\n  }, /*#__PURE__*/_react[\"default\"].createElement(SayUtterance, props));\n};\n\nSayUtteranceWithContext.defaultProps = _objectSpread(_objectSpread({}, SayUtterance.defaultProps), {}, {\n  ponyfill: undefined\n});\nSayUtteranceWithContext.propTypes = _objectSpread(_objectSpread({}, SayUtterance.propTypes), {}, {\n  ponyfill: _propTypes[\"default\"].shape({\n    speechSynthesis: _propTypes[\"default\"].any.isRequired,\n    SpeechSynthesisUtterance: _propTypes[\"default\"].any.isRequired\n  })\n});\nvar _default = SayUtteranceWithContext;\nexports[\"default\"] = _default;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;AAAA;;AACA;;AAEA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,YAAY,GAAG,SAAfA,YAAe,QAAS;AAC5B,8BAKI,wCAAuBC,KAAvB,CALJ;AAAA,MACEC,KADF,yBACEA,KADF;AAAA,MAEEC,OAFF,yBAEEA,OAFF;AAAA,MAGEC,OAHF,yBAGEA,OAHF;AAAA,MAIEC,SAJF,yBAIEA,SAJF;;AAOA,MAAMC,OAAO,GAAG,mBAAO,KAAP,CAAhB;AACA,MAAMC,UAAU,GAAG,gCAAnB,CAT4B,CAW5B;;AACA,wBAAU,YAAM;AACd;AACA;AACA,QAAID,OAAO,CAACE,OAAZ,EAAqB;AACnB;AACA;AAEA,aAAOC,OAAO,CAACC,IAARD,CAAa,iEAAbA,CAAP;AACD;;AAED,QAAIE,SAAJ;;AACA,sBAA4BJ,UAAU,CAACF,SAAD,EAAY,YAAM;AACtDC,aAAO,CAACE,OAARF,GAAkB,IAAlBA;AACA,OAACK,SAAD,IAAcP,OAAd,IAAyBA,OAAO,CAAC,mCAAkB,OAAlB,CAAD,CAAhC;AAFoC,MAAtC;AAAA,QAAQQ,MAAR,eAAQA,MAAR;AAAA,QAAgBC,OAAhB,eAAgBA,OAAhB;;AAKAA,WAAO,CAACC,IAARD,CACE;AAAA,aAAM,CAACF,SAAD,IAAcT,KAAd,IAAuBA,KAAK,CAAC,mCAAkB,KAAlB,CAAD,CAAlC;AADF,OAEE,iBAAK;AAAA,aAAI,CAACS,SAAD,IAAcR,OAAd,IAAyBA,OAAO,CAAC,kCAAiBY,KAAjB,CAAD,CAApC;AAFP;AAKA,WAAO,YAAM;AACXJ,eAAS,GAAG,IAAZA;AACAC,YAAM;AAFR;AArBF,KAyBG,EAzBH;AA2BA,SAAO,KAAP;AAvCF;;AA0CAZ,YAAY,CAACgB,YAAbhB,GAA4B;AAC1BE,OAAK,EAAEe,SADmB;AAE1Bd,SAAO,EAAEc,SAFiB;AAG1Bb,SAAO,EAAEa;AAHiB,CAA5BjB;AAMAA,YAAY,CAACkB,SAAblB,GAAyB;AACvBE,OAAK,EAAEiB,sBAAUC,IADM;AAEvBjB,SAAO,EAAEgB,sBAAUC,IAFI;AAGvBhB,SAAO,EAAEe,sBAAUC;AAHI,CAAzBpB;;AAMA,IAAMqB,uBAAuB,GAAG,SAA1BA,uBAA0B;AAAA,MAAGC,QAAH,QAAGA,QAAH;AAAA,MAAgBrB,KAAhB;AAAA,sBAC9BsB,gCAACC,oBAAD;AAAUF,YAAQ,EAAGA;AAArB,kBACEC,gCAACvB,YAAD,EAAmBC,KAAnB,CADF,CAD8B;AAAhC;;AAMAoB,uBAAuB,CAACL,YAAxBK,mCACKrB,YAAY,CAACgB,YADlB;AAEEM,UAAQ,EAAEL;AAFZ;AAKAI,uBAAuB,CAACH,SAAxBG,mCACKrB,YAAY,CAACkB,SADlB;AAEEI,UAAQ,EAAEH,sBAAUM,KAAVN,CAAgB;AACxBO,mBAAe,EAAEP,sBAAUQ,GAAVR,CAAcS,UADP;AAExBC,4BAAwB,EAAEV,sBAAUQ,GAAVR,CAAcS;AAFhB,GAAhBT;AAFZ;eAQeE","names":["SayUtterance","props","onEnd","onError","onStart","utterance","started","synthesize","current","console","warn","cancelled","cancel","promise","then","error","defaultProps","undefined","propTypes","PropTypes","func","SayUtteranceWithContext","ponyfill","_react","_Composer","shape","speechSynthesis","any","isRequired","SpeechSynthesisUtterance"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/react-say/src/SayUtterance.js"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React, { useEffect, useRef } from 'react';\n\nimport Composer from './Composer';\nimport createCustomEvent from './createCustomEvent';\nimport createErrorEvent from './createErrorEvent';\nimport migrateDeprecatedProps from './migrateDeprecatedProps';\nimport useSynthesize from './useSynthesize';\n\nconst SayUtterance = props => {\n  const {\n    onEnd,\n    onError,\n    onStart,\n    utterance\n  } = migrateDeprecatedProps(props);\n\n  const started = useRef(false);\n  const synthesize = useSynthesize();\n\n  // This useEffect() is essentially converting Promise-based useSynthesize() into events.\n  useEffect(() => {\n    // After synthesis started, if utterance has changed, the event will be fired by the wrong target.\n    // Thus, we do not allow utterance to change after synthesis started.\n    if (started.current) {\n      // Since we have already cancelled the previous utterance, we are not starting a new one.\n      // This is because if we start a new one, we could fire onStart event twice, which sound confusing to the developer.\n\n      return console.warn('react-say: Should not change utterance after synthesis started.');\n    }\n\n    let cancelled;\n    const { cancel, promise } = synthesize(utterance, () => {\n      started.current = true;\n      !cancelled && onStart && onStart(createCustomEvent('start'));\n    });\n\n    promise.then(\n      () => !cancelled && onEnd && onEnd(createCustomEvent('end')),\n      error => !cancelled && onError && onError(createErrorEvent(error))\n    );\n\n    return () => {\n      cancelled = true;\n      cancel();\n    };\n  }, []);\n\n  return false;\n};\n\nSayUtterance.defaultProps = {\n  onEnd: undefined,\n  onError: undefined,\n  onStart: undefined\n};\n\nSayUtterance.propTypes = {\n  onEnd: PropTypes.func,\n  onError: PropTypes.func,\n  onStart: PropTypes.func\n};\n\nconst SayUtteranceWithContext = ({ ponyfill, ...props }) => (\n  <Composer ponyfill={ ponyfill }>\n    <SayUtterance { ...props } />\n  </Composer>\n);\n\nSayUtteranceWithContext.defaultProps = {\n  ...SayUtterance.defaultProps,\n  ponyfill: undefined\n};\n\nSayUtteranceWithContext.propTypes = {\n  ...SayUtterance.propTypes,\n  ponyfill: PropTypes.shape({\n    speechSynthesis: PropTypes.any.isRequired,\n    SpeechSynthesisUtterance: PropTypes.any.isRequired\n  })\n};\n\nexport default SayUtteranceWithContext\n"]},"metadata":{},"sourceType":"script"}