{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Queue = void 0;\n\nvar Error_1 = require(\"./Error\");\n\nvar List_1 = require(\"./List\");\n\nvar Promise_1 = require(\"./Promise\");\n\nvar SubscriberType;\n\n(function (SubscriberType) {\n  SubscriberType[SubscriberType[\"Dequeue\"] = 0] = \"Dequeue\";\n  SubscriberType[SubscriberType[\"Peek\"] = 1] = \"Peek\";\n})(SubscriberType || (SubscriberType = {}));\n\nvar Queue =\n/** @class */\nfunction () {\n  function Queue(list) {\n    var _this = this;\n\n    this.privPromiseStore = new List_1.List();\n    this.privIsDrainInProgress = false;\n    this.privIsDisposing = false;\n    this.privDisposeReason = null;\n\n    this.enqueue = function (item) {\n      _this.throwIfDispose();\n\n      _this.enqueueFromPromise(new Promise(function (resolve, reject) {\n        resolve(item);\n      }));\n    };\n\n    this.enqueueFromPromise = function (promise) {\n      _this.throwIfDispose();\n\n      promise.then(function (val) {\n        _this.privList.add(val);\n        /* tslint:disable:no-empty */\n\n      }, function (error) {});\n    };\n\n    this.dequeue = function () {\n      _this.throwIfDispose();\n\n      var deferredSubscriber = new Promise_1.Deferred();\n\n      if (_this.privSubscribers) {\n        _this.privSubscribers.add({\n          deferral: deferredSubscriber,\n          type: SubscriberType.Dequeue\n        });\n\n        _this.drain();\n      }\n\n      return deferredSubscriber.promise;\n    };\n\n    this.peek = function () {\n      _this.throwIfDispose();\n\n      var deferredSubscriber = new Promise_1.Deferred();\n      var subs = _this.privSubscribers;\n\n      if (subs) {\n        _this.privSubscribers.add({\n          deferral: deferredSubscriber,\n          type: SubscriberType.Peek\n        });\n\n        _this.drain();\n      }\n\n      return deferredSubscriber.promise;\n    };\n\n    this.length = function () {\n      _this.throwIfDispose();\n\n      return _this.privList.length();\n    };\n\n    this.isDisposed = function () {\n      return _this.privSubscribers == null;\n    };\n\n    this.drain = function () {\n      if (!_this.privIsDrainInProgress && !_this.privIsDisposing) {\n        _this.privIsDrainInProgress = true;\n        var subs = _this.privSubscribers;\n        var lists = _this.privList;\n\n        if (subs && lists) {\n          while (lists.length() > 0 && subs.length() > 0 && !_this.privIsDisposing) {\n            var subscriber = subs.removeFirst();\n\n            if (subscriber.type === SubscriberType.Peek) {\n              subscriber.deferral.resolve(lists.first());\n            } else {\n              var dequeuedItem = lists.removeFirst();\n              subscriber.deferral.resolve(dequeuedItem);\n            }\n          } // note: this block assumes cooperative multitasking, i.e.,\n          // between the if-statement and the assignment there are no\n          // thread switches.\n          // Reason is that between the initial const = this.; and this\n          // point there is the derral.resolve() operation that might have\n          // caused recursive calls to the Queue, especially, calling\n          // Dispose() on the queue alredy (which would reset the var\n          // here to null!).\n          // That should generally hold true for javascript...\n\n\n          if (_this.privSubscribers === subs) {\n            _this.privSubscribers = subs;\n          } // note: this block assumes cooperative multitasking, i.e.,\n          // between the if-statement and the assignment there are no\n          // thread switches.\n          // Reason is that between the initial const = this.; and this\n          // point there is the derral.resolve() operation that might have\n          // caused recursive calls to the Queue, especially, calling\n          // Dispose() on the queue alredy (which would reset the var\n          // here to null!).\n          // That should generally hold true for javascript...\n\n\n          if (_this.privList === lists) {\n            _this.privList = lists;\n          }\n        }\n\n        _this.privIsDrainInProgress = false;\n      }\n    };\n\n    this.throwIfDispose = function () {\n      if (_this.isDisposed()) {\n        if (_this.privDisposeReason) {\n          throw new Error_1.InvalidOperationError(_this.privDisposeReason);\n        }\n\n        throw new Error_1.ObjectDisposedError(\"Queue\");\n      } else if (_this.privIsDisposing) {\n        throw new Error_1.InvalidOperationError(\"Queue disposing\");\n      }\n    };\n\n    this.privList = list ? list : new List_1.List();\n    this.privDetachables = [];\n    this.privSubscribers = new List_1.List();\n    this.privDetachables.push(this.privList.onAdded(this.drain));\n  }\n\n  Queue.prototype.drainAndDispose = function (pendingItemProcessor, reason) {\n    return __awaiter(this, void 0, void 0, function () {\n      var subs, subscriber, _i, _a, detachable, promiseArray_1;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(!this.isDisposed() && !this.privIsDisposing)) return [3\n            /*break*/\n            , 5];\n            this.privDisposeReason = reason;\n            this.privIsDisposing = true;\n            subs = this.privSubscribers;\n\n            if (subs) {\n              while (subs.length() > 0) {\n                subscriber = subs.removeFirst(); // TODO: this needs work (Resolve(null) instead?).\n\n                subscriber.deferral.resolve(undefined); // subscriber.deferral.reject(\"Disposed\");\n              } // note: this block assumes cooperative multitasking, i.e.,\n              // between the if-statement and the assignment there are no\n              // thread switches.\n              // Reason is that between the initial const = this.; and this\n              // point there is the derral.resolve() operation that might have\n              // caused recursive calls to the Queue, especially, calling\n              // Dispose() on the queue alredy (which would reset the var\n              // here to null!).\n              // That should generally hold true for javascript...\n\n\n              if (this.privSubscribers === subs) {\n                this.privSubscribers = subs;\n              }\n            }\n\n            _i = 0, _a = this.privDetachables;\n            _b.label = 1;\n\n          case 1:\n            if (!(_i < _a.length)) return [3\n            /*break*/\n            , 4];\n            detachable = _a[_i];\n            return [4\n            /*yield*/\n            , detachable.detach()];\n\n          case 2:\n            _b.sent();\n\n            _b.label = 3;\n\n          case 3:\n            _i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {\n              promiseArray_1 = [];\n              this.privPromiseStore.toArray().forEach(function (wrapper) {\n                promiseArray_1.push(wrapper);\n              });\n              return [2\n              /*return*/\n              , Promise.all(promiseArray_1).finally(function () {\n                _this.privSubscribers = null;\n\n                _this.privList.forEach(function (item, index) {\n                  pendingItemProcessor(item);\n                });\n\n                _this.privList = null;\n                return;\n              }).then()];\n            } else {\n              this.privSubscribers = null;\n              this.privList = null;\n            }\n\n            _b.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Queue.prototype.dispose = function (reason) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.drainAndDispose(null, reason)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return Queue;\n}();\n\nexports.Queue = Queue;","map":{"version":3,"mappings":"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","names":["SubscriberType","list","List_1","item","_this","throwIfDispose","enqueueFromPromise","Promise","resolve","reject","promise","then","val","privList","add","error","deferredSubscriber","Promise_1","privSubscribers","deferral","type","Dequeue","drain","subs","Peek","length","privIsDrainInProgress","privIsDisposing","lists","subscriber","removeFirst","first","dequeuedItem","isDisposed","privDisposeReason","Error_1","privDetachables","push","onAdded","Queue","pendingItemProcessor","reason","undefined","_a","_i","detachable","detach","_b","privPromiseStore","promiseArray_1","toArray","forEach","wrapper","all","finally","index","drainAndDispose","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/src/common/Queue.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError, ObjectDisposedError } from \"./Error\";\r\nimport { IDetachable } from \"./IDetachable\";\r\nimport { IDisposable } from \"./IDisposable\";\r\nimport { List } from \"./List\";\r\nimport {\r\n    Deferred,\r\n} from \"./Promise\";\r\nexport interface IQueue<TItem> extends IDisposable {\r\n    enqueue(item: TItem): void;\r\n    enqueueFromPromise(promise: Promise<TItem>): void;\r\n    dequeue(): Promise<TItem>;\r\n    peek(): Promise<TItem>;\r\n    length(): number;\r\n}\r\n\r\nenum SubscriberType {\r\n    Dequeue,\r\n    Peek,\r\n}\r\n\r\nexport class Queue<TItem> implements IQueue<TItem> {\r\n    private privPromiseStore: List<Promise<TItem>> = new List<Promise<TItem>>();\r\n    private privList: List<TItem>;\r\n    private privDetachables: IDetachable[];\r\n    private privSubscribers: List<{ type: SubscriberType, deferral: Deferred<TItem> }>;\r\n    private privIsDrainInProgress: boolean = false;\r\n    private privIsDisposing: boolean = false;\r\n    private privDisposeReason: string = null;\r\n\r\n    public constructor(list?: List<TItem>) {\r\n        this.privList = list ? list : new List<TItem>();\r\n        this.privDetachables = [];\r\n        this.privSubscribers = new List<{ type: SubscriberType, deferral: Deferred<TItem> }>();\r\n        this.privDetachables.push(this.privList.onAdded(this.drain));\r\n    }\r\n\r\n    public enqueue = (item: TItem): void => {\r\n        this.throwIfDispose();\r\n        this.enqueueFromPromise(new Promise<TItem>((resolve: (value: TItem) => void, reject: (reason: any) => void) => { resolve(item); }));\r\n    }\r\n\r\n    public enqueueFromPromise = (promise: Promise<TItem>): void => {\r\n        this.throwIfDispose();\r\n        promise.then((val: TItem): void => {\r\n            this.privList.add(val);\r\n             /* tslint:disable:no-empty */\r\n        }, (error: string): void => { });\r\n    }\r\n\r\n    public dequeue = (): Promise<TItem> => {\r\n        this.throwIfDispose();\r\n        const deferredSubscriber = new Deferred<TItem>();\r\n\r\n        if (this.privSubscribers) {\r\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Dequeue });\r\n            this.drain();\r\n        }\r\n\r\n        return deferredSubscriber.promise;\r\n    }\r\n\r\n    public peek = (): Promise<TItem> => {\r\n        this.throwIfDispose();\r\n        const deferredSubscriber = new Deferred<TItem>();\r\n\r\n        const subs = this.privSubscribers;\r\n        if (subs) {\r\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Peek });\r\n            this.drain();\r\n        }\r\n\r\n        return deferredSubscriber.promise;\r\n    }\r\n\r\n    public length = (): number => {\r\n        this.throwIfDispose();\r\n        return this.privList.length();\r\n    }\r\n\r\n    public isDisposed = (): boolean => {\r\n        return this.privSubscribers == null;\r\n    }\r\n\r\n    public async drainAndDispose(pendingItemProcessor: (pendingItemInQueue: TItem) => void, reason?: string): Promise<void> {\r\n        if (!this.isDisposed() && !this.privIsDisposing) {\r\n            this.privDisposeReason = reason;\r\n            this.privIsDisposing = true;\r\n\r\n            const subs = this.privSubscribers;\r\n            if (subs) {\r\n                while (subs.length() > 0) {\r\n                    const subscriber = subs.removeFirst();\r\n                    // TODO: this needs work (Resolve(null) instead?).\r\n                    subscriber.deferral.resolve(undefined);\r\n                    // subscriber.deferral.reject(\"Disposed\");\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privSubscribers === subs) {\r\n                    this.privSubscribers = subs;\r\n                }\r\n            }\r\n\r\n            for (const detachable of this.privDetachables) {\r\n                await detachable.detach();\r\n            }\r\n\r\n            if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {\r\n                const promiseArray: Promise<TItem>[] = [];\r\n\r\n                this.privPromiseStore.toArray().forEach((wrapper: Promise<TItem>) => {\r\n                    promiseArray.push(wrapper);\r\n                });\r\n                return Promise.all(promiseArray).finally(() => {\r\n                    this.privSubscribers = null;\r\n                    this.privList.forEach((item: TItem, index: number): void => {\r\n                        pendingItemProcessor(item);\r\n                    });\r\n                    this.privList = null;\r\n                    return;\r\n                }).then<void>();\r\n            } else {\r\n                this.privSubscribers = null;\r\n                this.privList = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        await this.drainAndDispose(null, reason);\r\n    }\r\n\r\n    private drain = (): void => {\r\n        if (!this.privIsDrainInProgress && !this.privIsDisposing) {\r\n            this.privIsDrainInProgress = true;\r\n\r\n            const subs = this.privSubscribers;\r\n            const lists = this.privList;\r\n            if (subs && lists) {\r\n                while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {\r\n                    const subscriber = subs.removeFirst();\r\n                    if (subscriber.type === SubscriberType.Peek) {\r\n                        subscriber.deferral.resolve(lists.first());\r\n                    } else {\r\n                        const dequeuedItem = lists.removeFirst();\r\n                        subscriber.deferral.resolve(dequeuedItem);\r\n                    }\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privSubscribers === subs) {\r\n                    this.privSubscribers = subs;\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privList === lists) {\r\n                    this.privList = lists;\r\n                }\r\n            }\r\n\r\n            this.privIsDrainInProgress = false;\r\n        }\r\n    }\r\n\r\n    private throwIfDispose = (): void => {\r\n        if (this.isDisposed()) {\r\n            if (this.privDisposeReason) {\r\n                throw new InvalidOperationError(this.privDisposeReason);\r\n            }\r\n\r\n            throw new ObjectDisposedError(\"Queue\");\r\n        } else if (this.privIsDisposing) {\r\n            throw new InvalidOperationError(\"Queue disposing\");\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}