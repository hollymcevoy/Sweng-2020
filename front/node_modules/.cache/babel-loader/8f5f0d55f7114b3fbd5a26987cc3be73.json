{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RestConfigBase } from \"../../common.browser/RestConfigBase\"; // Node.JS specific xmlhttprequest / browser support.\n\nimport * as XHR from \"xmlhttprequest-ts\";\n/**\n * Config settings for Conversation Translator\n */\n\n/**\n * Helpers for sending / receiving HTTPS requests / responses.\n * @param params\n */\n\nfunction queryParams() {\n  let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.keys(params).map(k => encodeURIComponent(k) + \"=\" + encodeURIComponent(params[k])).join(\"&\");\n}\n\nfunction withQuery(url) {\n  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const queryString = queryParams(params);\n  return queryString ? url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + queryString : url;\n}\n\nfunction parseXHRResult(xhr) {\n  return {\n    data: xhr.responseText,\n    headers: xhr.getAllResponseHeaders(),\n    json: () => JSON.parse(xhr.responseText),\n    ok: xhr.status >= 200 && xhr.status < 300,\n    status: xhr.status,\n    statusText: xhr.statusText\n  };\n}\n\nfunction errorResponse(xhr) {\n  let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return {\n    data: message || xhr.statusText,\n    headers: xhr.getAllResponseHeaders(),\n    json: () => JSON.parse(message || \"\\\"\" + xhr.statusText + \"\\\"\"),\n    ok: false,\n    status: xhr.status,\n    statusText: xhr.statusText\n  };\n}\n\nexport function extractHeaderValue(headerKey, headers) {\n  let headerValue = \"\";\n\n  try {\n    const arr = headers.trim().split(/[\\r\\n]+/);\n    const headerMap = {};\n    arr.forEach(line => {\n      const parts = line.split(\": \");\n      const header = parts.shift().toLowerCase();\n      const value = parts.join(\": \");\n      headerMap[header] = value;\n    });\n    headerValue = headerMap[headerKey.toLowerCase()];\n  } catch (e) {// ignore the error\n  }\n\n  return headerValue;\n}\nexport function request(method, url) {\n  let queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let body = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  let callback = arguments.length > 5 ? arguments[5] : undefined;\n  const defaultRequestOptions = RestConfigBase.requestOptions;\n  const ignoreCache = options.ignoreCache || defaultRequestOptions.ignoreCache;\n  const headers = options.headers || defaultRequestOptions.headers;\n  const timeout = options.timeout || defaultRequestOptions.timeout;\n  let xhr;\n\n  if (typeof window === \"undefined\") {\n    // Node\n    xhr = new XHR.XMLHttpRequest();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  xhr.open(method, withQuery(url, queryParams), true);\n\n  if (headers) {\n    Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\n  }\n\n  if (ignoreCache) {\n    xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\n  }\n\n  xhr.timeout = timeout;\n\n  xhr.onload = evt => {\n    callback(parseXHRResult(xhr));\n  };\n\n  xhr.onerror = evt => {\n    callback(errorResponse(xhr, \"Failed to make request.\"));\n  };\n\n  xhr.ontimeout = evt => {\n    callback(errorResponse(xhr, \"Request took longer than expected.\"));\n  };\n\n  if (method === \"post\" && body) {\n    xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n    xhr.send(JSON.stringify(body));\n  } else {\n    xhr.send();\n  }\n}\nexport function PromiseToEmptyCallback(promise, cb, err) {\n  if (!!promise) {\n    promise.then(result => {\n      try {\n        if (!!cb) {\n          cb();\n        }\n      } catch (e) {\n        if (!!err) {\n          err(`'Unhandled error on promise callback: ${e}'`);\n        }\n      }\n    }, reason => {\n      try {\n        if (!!err) {\n          err(reason);\n        }\n        /* tslint:disable:no-empty */\n\n      } catch (error) {}\n    });\n  } else {\n    if (!!err) {\n      err(\"Null promise\");\n    }\n  }\n}","map":{"version":3,"mappings":"AAAA;AACA;AAIA,SAA0BA,cAA1B,QAAgD,qCAAhD,C,CAGA;;AACA,OAAO,KAAKC,GAAZ,MAAqB,mBAArB;AAEA;;;;AAGA;;;;;AAIA,SAASC,WAAT,GAAqC;AAAA,MAAhBC,MAAgB,uEAAF,EAAE;AACjC,SAAOC,MAAM,CAACC,IAAP,CAAYF,MAAZ,EACFG,GADE,CACGC,CAAD,IAAYC,kBAAkB,CAACD,CAAD,CAAlB,GAAwB,GAAxB,GAA8BC,kBAAkB,CAACL,MAAM,CAACI,CAAD,CAAP,CAD9D,EAEFE,IAFE,CAEG,GAFH,CAAP;AAGH;;AAED,SAASC,SAAT,CAAmBC,GAAnB,EAAgD;AAAA,MAAhBR,MAAgB,uEAAF,EAAE;AAC5C,QAAMS,WAAW,GAAGV,WAAW,CAACC,MAAD,CAA/B;AACA,SAAOS,WAAW,GAAGD,GAAG,IAAIA,GAAG,CAACE,OAAJ,CAAY,GAAZ,MAAqB,CAAC,CAAtB,GAA0B,GAA1B,GAAgC,GAApC,CAAH,GAA8CD,WAAjD,GAA+DD,GAAjF;AACH;;AAED,SAASG,cAAT,CAAwBC,GAAxB,EAAgE;AAC5D,SAAO;AACHC,QAAI,EAAED,GAAG,CAACE,YADP;AAEHC,WAAO,EAAEH,GAAG,CAACI,qBAAJ,EAFN;AAGHC,QAAI,EAAE,MAASC,IAAI,CAACC,KAAL,CAAWP,GAAG,CAACE,YAAf,CAHZ;AAIHM,MAAE,EAAER,GAAG,CAACS,MAAJ,IAAc,GAAd,IAAqBT,GAAG,CAACS,MAAJ,GAAa,GAJnC;AAKHA,UAAM,EAAET,GAAG,CAACS,MALT;AAMHC,cAAU,EAAEV,GAAG,CAACU;AANb,GAAP;AAQH;;AAED,SAASC,aAAT,CAAuBX,GAAvB,EAA8F;AAAA,MAA7BY,OAA6B,uEAAJ,IAAI;AAC1F,SAAO;AACHX,QAAI,EAAEW,OAAO,IAAIZ,GAAG,CAACU,UADlB;AAEHP,WAAO,EAAEH,GAAG,CAACI,qBAAJ,EAFN;AAGHC,QAAI,EAAE,MAASC,IAAI,CAACC,KAAL,CAAWK,OAAO,IAAK,OAAOZ,GAAG,CAACU,UAAX,GAAwB,IAA/C,CAHZ;AAIHF,MAAE,EAAE,KAJD;AAKHC,UAAM,EAAET,GAAG,CAACS,MALT;AAMHC,cAAU,EAAEV,GAAG,CAACU;AANb,GAAP;AAQH;;AAED,OAAM,SAAUG,kBAAV,CAA6BC,SAA7B,EAAgDX,OAAhD,EAA+D;AAEjE,MAAIY,WAAW,GAAW,EAA1B;;AAEA,MAAI;AACA,UAAMC,GAAG,GAAGb,OAAO,CAACc,IAAR,GAAeC,KAAf,CAAqB,SAArB,CAAZ;AACA,UAAMC,SAAS,GAAQ,EAAvB;AACAH,OAAG,CAACI,OAAJ,CAAaC,IAAD,IAAc;AACtB,YAAMC,KAAK,GAAGD,IAAI,CAACH,KAAL,CAAW,IAAX,CAAd;AACA,YAAMK,MAAM,GAAGD,KAAK,CAACE,KAAN,GAAcC,WAAd,EAAf;AACA,YAAMC,KAAK,GAAGJ,KAAK,CAAC5B,IAAN,CAAW,IAAX,CAAd;AACAyB,eAAS,CAACI,MAAD,CAAT,GAAoBG,KAApB;AACH,KALD;AAOAX,eAAW,GAAGI,SAAS,CAACL,SAAS,CAACW,WAAV,EAAD,CAAvB;AACH,GAXD,CAWE,OAAOE,CAAP,EAAU,CACR;AACH;;AAED,SAAOZ,WAAP;AACH;AAED,OAAM,SAAUa,OAAV,CACFC,MADE,EAEFjC,GAFE,EAMW;AAAA,MAHbT,WAGa,uEAHM,EAGN;AAAA,MAFb2C,IAEa,uEAFD,IAEC;AAAA,MADbC,OACa,uEADc,EACd;AAAA,MAAbC,QAAa;AAEb,QAAMC,qBAAqB,GAAGhD,cAAc,CAACiD,cAA7C;AAEA,QAAMC,WAAW,GAAGJ,OAAO,CAACI,WAAR,IAAuBF,qBAAqB,CAACE,WAAjE;AACA,QAAMhC,OAAO,GAAG4B,OAAO,CAAC5B,OAAR,IAAmB8B,qBAAqB,CAAC9B,OAAzD;AACA,QAAMiC,OAAO,GAAGL,OAAO,CAACK,OAAR,IAAmBH,qBAAqB,CAACG,OAAzD;AAEA,MAAIpC,GAAJ;;AACA,MAAI,OAAOqC,MAAP,KAAkB,WAAtB,EAAmC;AAAE;AACjCrC,OAAG,GAAG,IAAId,GAAG,CAACoD,cAAR,EAAN;AAEH,GAHD,MAGO;AACHtC,OAAG,GAAG,IAAIsC,cAAJ,EAAN;AACH;;AACDtC,KAAG,CAACuC,IAAJ,CAASV,MAAT,EAAiBlC,SAAS,CAACC,GAAD,EAAMT,WAAN,CAA1B,EAA8C,IAA9C;;AAEA,MAAIgB,OAAJ,EAAa;AACTd,UAAM,CAACC,IAAP,CAAYa,OAAZ,EAAqBiB,OAArB,CAA8BoB,GAAD,IAAcxC,GAAG,CAACyC,gBAAJ,CAAqBD,GAArB,EAA0BrC,OAAO,CAACqC,GAAD,CAAjC,CAA3C;AACH;;AAED,MAAIL,WAAJ,EAAiB;AACbnC,OAAG,CAACyC,gBAAJ,CAAqB,eAArB,EAAsC,UAAtC;AACH;;AAEDzC,KAAG,CAACoC,OAAJ,GAAcA,OAAd;;AAEApC,KAAG,CAAC0C,MAAJ,GAAcC,GAAD,IAAa;AACtBX,YAAQ,CAACjC,cAAc,CAACC,GAAD,CAAf,CAAR;AACH,GAFD;;AAIAA,KAAG,CAAC4C,OAAJ,GAAeD,GAAD,IAAa;AACvBX,YAAQ,CAACrB,aAAa,CAACX,GAAD,EAAM,yBAAN,CAAd,CAAR;AACH,GAFD;;AAIAA,KAAG,CAAC6C,SAAJ,GAAiBF,GAAD,IAAa;AACzBX,YAAQ,CAACrB,aAAa,CAACX,GAAD,EAAM,oCAAN,CAAd,CAAR;AACH,GAFD;;AAIA,MAAI6B,MAAM,KAAK,MAAX,IAAqBC,IAAzB,EAA+B;AAC3B9B,OAAG,CAACyC,gBAAJ,CAAqB,cAArB,EAAqC,kBAArC;AACAzC,OAAG,CAAC8C,IAAJ,CAASxC,IAAI,CAACyC,SAAL,CAAejB,IAAf,CAAT;AACH,GAHD,MAGO;AACH9B,OAAG,CAAC8C,IAAJ;AACH;AACJ;AAED,OAAM,SAAUE,sBAAV,CAAoCC,OAApC,EAAyDC,EAAzD,EAAwEC,GAAxE,EAAsF;AACxF,MAAI,CAAC,CAACF,OAAN,EAAe;AACXA,WAAO,CAACG,IAAR,CAAcC,MAAD,IAAoB;AAC7B,UAAI;AACA,YAAI,CAAC,CAACH,EAAN,EAAU;AACNA,YAAE;AACL;AACJ,OAJD,CAIE,OAAOvB,CAAP,EAAU;AACR,YAAI,CAAC,CAACwB,GAAN,EAAW;AACPA,aAAG,CAAC,yCAAyCxB,CAAC,GAA3C,CAAH;AACH;AACJ;AACJ,KAVD,EAUI2B,MAAD,IAAgB;AACf,UAAI;AACA,YAAI,CAAC,CAACH,GAAN,EAAW;AACPA,aAAG,CAACG,MAAD,CAAH;AACH;AACD;;AACH,OALD,CAKE,OAAOC,KAAP,EAAc,CACf;AACJ,KAlBD;AAmBH,GApBD,MAoBO;AACH,QAAI,CAAC,CAACJ,GAAN,EAAW;AACPA,SAAG,CAAC,cAAD,CAAH;AACH;AACJ;AACJ","names":["RestConfigBase","XHR","queryParams","params","Object","keys","map","k","encodeURIComponent","join","withQuery","url","queryString","indexOf","parseXHRResult","xhr","data","responseText","headers","getAllResponseHeaders","json","JSON","parse","ok","status","statusText","errorResponse","message","extractHeaderValue","headerKey","headerValue","arr","trim","split","headerMap","forEach","line","parts","header","shift","toLowerCase","value","e","request","method","body","options","callback","defaultRequestOptions","requestOptions","ignoreCache","timeout","window","XMLHttpRequest","open","key","setRequestHeader","onload","evt","onerror","ontimeout","send","stringify","PromiseToEmptyCallback","promise","cb","err","then","result","reason","error"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/es2015/src/common.speech/Transcription/src/common.speech/Transcription/ConversationUtils.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { IResponse } from \"./ConversationTranslatorInterfaces\";\r\n\r\nimport { IRequestOptions, RestConfigBase } from \"../../common.browser/RestConfigBase\";\r\nimport { Callback } from \"../../sdk/Transcription/IConversation\";\r\n\r\n// Node.JS specific xmlhttprequest / browser support.\r\nimport * as XHR from \"xmlhttprequest-ts\";\r\n\r\n/**\r\n * Config settings for Conversation Translator\r\n */\r\n/**\r\n * Helpers for sending / receiving HTTPS requests / responses.\r\n * @param params\r\n */\r\nfunction queryParams(params: any = {}): any {\r\n    return Object.keys(params)\r\n        .map((k: any) => encodeURIComponent(k) + \"=\" + encodeURIComponent(params[k]))\r\n        .join(\"&\");\r\n}\r\n\r\nfunction withQuery(url: string, params: any = {}): any {\r\n    const queryString = queryParams(params);\r\n    return queryString ? url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + queryString : url;\r\n}\r\n\r\nfunction parseXHRResult(xhr: XMLHttpRequest | XHR.XMLHttpRequest): IResponse {\r\n    return {\r\n        data: xhr.responseText,\r\n        headers: xhr.getAllResponseHeaders(),\r\n        json: <T>() => JSON.parse(xhr.responseText) as T,\r\n        ok: xhr.status >= 200 && xhr.status < 300,\r\n        status: xhr.status,\r\n        statusText: xhr.statusText,\r\n    };\r\n}\r\n\r\nfunction errorResponse(xhr: XMLHttpRequest | XHR.XMLHttpRequest, message: string | null = null): IResponse {\r\n    return {\r\n        data: message || xhr.statusText,\r\n        headers: xhr.getAllResponseHeaders(),\r\n        json: <T>() => JSON.parse(message || (\"\\\"\" + xhr.statusText + \"\\\"\")) as T,\r\n        ok: false,\r\n        status: xhr.status,\r\n        statusText: xhr.statusText,\r\n    };\r\n}\r\n\r\nexport function extractHeaderValue(headerKey: string, headers: string): string {\r\n\r\n    let headerValue: string = \"\";\r\n\r\n    try {\r\n        const arr = headers.trim().split(/[\\r\\n]+/);\r\n        const headerMap: any = {};\r\n        arr.forEach((line: any) => {\r\n            const parts = line.split(\": \");\r\n            const header = parts.shift().toLowerCase();\r\n            const value = parts.join(\": \");\r\n            headerMap[header] = value;\r\n        });\r\n\r\n        headerValue = headerMap[headerKey.toLowerCase()];\r\n    } catch (e) {\r\n        // ignore the error\r\n    }\r\n\r\n    return headerValue;\r\n}\r\n\r\nexport function request(\r\n    method: \"get\" | \"post\" | \"delete\",\r\n    url: string,\r\n    queryParams: any = {},\r\n    body: any = null,\r\n    options: IRequestOptions = {},\r\n    callback: any): any {\r\n\r\n    const defaultRequestOptions = RestConfigBase.requestOptions;\r\n\r\n    const ignoreCache = options.ignoreCache || defaultRequestOptions.ignoreCache;\r\n    const headers = options.headers || defaultRequestOptions.headers;\r\n    const timeout = options.timeout || defaultRequestOptions.timeout;\r\n\r\n    let xhr: XMLHttpRequest | XHR.XMLHttpRequest;\r\n    if (typeof window === \"undefined\") { // Node\r\n        xhr = new XHR.XMLHttpRequest();\r\n\r\n    } else {\r\n        xhr = new XMLHttpRequest();\r\n    }\r\n    xhr.open(method, withQuery(url, queryParams), true);\r\n\r\n    if (headers) {\r\n        Object.keys(headers).forEach((key: any) => xhr.setRequestHeader(key, headers[key]));\r\n    }\r\n\r\n    if (ignoreCache) {\r\n        xhr.setRequestHeader(\"Cache-Control\", \"no-cache\");\r\n    }\r\n\r\n    xhr.timeout = timeout;\r\n\r\n    xhr.onload = (evt: any) => {\r\n        callback(parseXHRResult(xhr));\r\n    };\r\n\r\n    xhr.onerror = (evt: any) => {\r\n        callback(errorResponse(xhr, \"Failed to make request.\"));\r\n    };\r\n\r\n    xhr.ontimeout = (evt: any) => {\r\n        callback(errorResponse(xhr, \"Request took longer than expected.\"));\r\n    };\r\n\r\n    if (method === \"post\" && body) {\r\n        xhr.setRequestHeader(\"Content-Type\", \"application/json\");\r\n        xhr.send(JSON.stringify(body));\r\n    } else {\r\n        xhr.send();\r\n    }\r\n}\r\n\r\nexport function PromiseToEmptyCallback<T>(promise: Promise<T>, cb?: Callback, err?: Callback): void {\r\n    if (!!promise) {\r\n        promise.then((result: T): void => {\r\n            try {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            } catch (e) {\r\n                if (!!err) {\r\n                    err(`'Unhandled error on promise callback: ${e}'`);\r\n                }\r\n            }\r\n        }, (reason: any) => {\r\n            try {\r\n                if (!!err) {\r\n                    err(reason);\r\n                }\r\n                /* tslint:disable:no-empty */\r\n            } catch (error) {\r\n            }\r\n        });\r\n    } else {\r\n        if (!!err) {\r\n            err(\"Null promise\");\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}