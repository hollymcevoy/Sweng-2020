{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar Subject_1 = require('../Subject');\n\nvar Observable_1 = require('../Observable');\n\nvar Subscriber_1 = require('../Subscriber');\n\nvar Subscription_1 = require('../Subscription');\n\nvar refCount_1 = require('../operators/refCount');\n/**\n * @class ConnectableObservable<T>\n */\n\n\nvar ConnectableObservable = function (_super) {\n  __extends(ConnectableObservable, _super);\n\n  function ConnectableObservable(\n  /** @deprecated internal use only */\n  source,\n  /** @deprecated internal use only */\n  subjectFactory) {\n    _super.call(this);\n\n    this.source = source;\n    this.subjectFactory = subjectFactory;\n    /** @deprecated internal use only */\n\n    this._refCount = 0;\n    this._isComplete = false;\n  }\n  /** @deprecated internal use only */\n\n\n  ConnectableObservable.prototype._subscribe = function (subscriber) {\n    return this.getSubject().subscribe(subscriber);\n  };\n  /** @deprecated internal use only */\n\n\n  ConnectableObservable.prototype.getSubject = function () {\n    var subject = this._subject;\n\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n\n    return this._subject;\n  };\n\n  ConnectableObservable.prototype.connect = function () {\n    var connection = this._connection;\n\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription_1.Subscription();\n      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription_1.Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n\n    return connection;\n  };\n\n  ConnectableObservable.prototype.refCount = function () {\n    return refCount_1.refCount()(this);\n  };\n\n  return ConnectableObservable;\n}(Observable_1.Observable);\n\nexports.ConnectableObservable = ConnectableObservable;\nvar connectableProto = ConnectableObservable.prototype;\nexports.connectableObservableDescriptor = {\n  operator: {\n    value: null\n  },\n  _refCount: {\n    value: 0,\n    writable: true\n  },\n  _subject: {\n    value: null,\n    writable: true\n  },\n  _connection: {\n    value: null,\n    writable: true\n  },\n  _subscribe: {\n    value: connectableProto._subscribe\n  },\n  _isComplete: {\n    value: connectableProto._isComplete,\n    writable: true\n  },\n  getSubject: {\n    value: connectableProto.getSubject\n  },\n  connect: {\n    value: connectableProto.connect\n  },\n  refCount: {\n    value: connectableProto.refCount\n  }\n};\n\nvar ConnectableSubscriber = function (_super) {\n  __extends(ConnectableSubscriber, _super);\n\n  function ConnectableSubscriber(destination, connectable) {\n    _super.call(this, destination);\n\n    this.connectable = connectable;\n  }\n\n  ConnectableSubscriber.prototype._error = function (err) {\n    this._unsubscribe();\n\n    _super.prototype._error.call(this, err);\n  };\n\n  ConnectableSubscriber.prototype._complete = function () {\n    this.connectable._isComplete = true;\n\n    this._unsubscribe();\n\n    _super.prototype._complete.call(this);\n  };\n  /** @deprecated internal use only */\n\n\n  ConnectableSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (connectable) {\n      this.connectable = null;\n      var connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  };\n\n  return ConnectableSubscriber;\n}(Subject_1.SubjectSubscriber);\n\nvar RefCountOperator = function () {\n  function RefCountOperator(connectable) {\n    this.connectable = connectable;\n  }\n\n  RefCountOperator.prototype.call = function (subscriber, source) {\n    var connectable = this.connectable;\n    connectable._refCount++;\n    var refCounter = new RefCountSubscriber(subscriber, connectable);\n    var subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      refCounter.connection = connectable.connect();\n    }\n\n    return subscription;\n  };\n\n  return RefCountOperator;\n}();\n\nvar RefCountSubscriber = function (_super) {\n  __extends(RefCountSubscriber, _super);\n\n  function RefCountSubscriber(destination, connectable) {\n    _super.call(this, destination);\n\n    this.connectable = connectable;\n  }\n  /** @deprecated internal use only */\n\n\n  RefCountSubscriber.prototype._unsubscribe = function () {\n    var connectable = this.connectable;\n\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    var refCount = connectable._refCount;\n\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    connectable._refCount = refCount - 1;\n\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    } ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n\n\n    var connection = this.connection;\n    var sharedConnection = connectable._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  };\n\n  return RefCountSubscriber;\n}(Subscriber_1.Subscriber);","map":{"version":3,"mappings":"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","names":["__extends","source","subjectFactory","_super","ConnectableObservable","subscriber","getSubject","subscribe","subject","_subject","isStopped","connection","_connection","_isComplete","Subscription_1","add","ConnectableSubscriber","closed","EMPTY","refCount_1","Observable_1","exports","connectableProto","prototype","operator","value","_refCount","writable","_subscribe","connect","refCount","destination","connectable","err","_unsubscribe","_error","call","_complete","unsubscribe","Subject_1","RefCountOperator","refCounter","RefCountSubscriber","subscription","sharedConnection","Subscriber_1"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/src/observable/ConnectableObservable.ts"],"sourcesContent":["import { Subject, SubjectSubscriber } from '../Subject';\nimport { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\n\n/**\n * @class ConnectableObservable<T>\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n\n  /** @deprecated internal use only */ public _subject: Subject<T>;\n  /** @deprecated internal use only */ public _refCount: number = 0;\n  /** @deprecated internal use only */ public _connection: Subscription;\n  _isComplete = false;\n\n  constructor(/** @deprecated internal use only */ public source: Observable<T>,\n              /** @deprecated internal use only */ public subjectFactory: () => Subject<T>) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  /** @deprecated internal use only */ public getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      this._isComplete = false;\n      connection = this._connection = new Subscription();\n      connection.add(this.source\n        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      } else {\n        this._connection = connection;\n      }\n    }\n    return connection;\n  }\n\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n\nconst connectableProto = <any>ConnectableObservable.prototype;\n\nexport const connectableObservableDescriptor: PropertyDescriptorMap = {\n  operator: { value: null },\n  _refCount: { value: 0, writable: true },\n  _subject: { value: null, writable: true },\n  _connection: { value: null, writable: true },\n  _subscribe: { value: connectableProto._subscribe },\n  _isComplete: { value: connectableProto._isComplete, writable: true },\n  getSubject: { value: connectableProto.getSubject },\n  connect: { value: connectableProto.connect },\n  refCount: { value: connectableProto.refCount }\n};\n\nclass ConnectableSubscriber<T> extends SubjectSubscriber<T> {\n  constructor(destination: Subject<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n  protected _error(err: any): void {\n    this._unsubscribe();\n    super._error(err);\n  }\n  protected _complete(): void {\n    this.connectable._isComplete = true;\n    this._unsubscribe();\n    super._complete();\n  }\n  /** @deprecated internal use only */ _unsubscribe() {\n    const connectable = <any>this.connectable;\n    if (connectable) {\n      this.connectable = null;\n      const connection = connectable._connection;\n      connectable._refCount = 0;\n      connectable._subject = null;\n      connectable._connection = null;\n      if (connection) {\n        connection.unsubscribe();\n      }\n    }\n  }\n}\n\nclass RefCountOperator<T> implements Operator<T, T> {\n  constructor(private connectable: ConnectableObservable<T>) {\n  }\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n\n    const { connectable } = this;\n    (<any> connectable)._refCount++;\n\n    const refCounter = new RefCountSubscriber(subscriber, connectable);\n    const subscription = source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      (<any> refCounter).connection = connectable.connect();\n    }\n\n    return subscription;\n  }\n}\n\nclass RefCountSubscriber<T> extends Subscriber<T> {\n\n  private connection: Subscription;\n\n  constructor(destination: Subscriber<T>,\n              private connectable: ConnectableObservable<T>) {\n    super(destination);\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n\n    const { connectable } = this;\n    if (!connectable) {\n      this.connection = null;\n      return;\n    }\n\n    this.connectable = null;\n    const refCount = (<any> connectable)._refCount;\n    if (refCount <= 0) {\n      this.connection = null;\n      return;\n    }\n\n    (<any> connectable)._refCount = refCount - 1;\n    if (refCount > 1) {\n      this.connection = null;\n      return;\n    }\n\n    ///\n    // Compare the local RefCountSubscriber's connection Subscription to the\n    // connection Subscription on the shared ConnectableObservable. In cases\n    // where the ConnectableObservable source synchronously emits values, and\n    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n    // execution continues to here before the RefCountOperator has a chance to\n    // supply the RefCountSubscriber with the shared connection Subscription.\n    // For example:\n    // ```\n    // Observable.range(0, 10)\n    //   .publish()\n    //   .refCount()\n    //   .take(5)\n    //   .subscribe();\n    // ```\n    // In order to account for this case, RefCountSubscriber should only dispose\n    // the ConnectableObservable's shared connection Subscription if the\n    // connection Subscription exists, *and* either:\n    //   a. RefCountSubscriber doesn't have a reference to the shared connection\n    //      Subscription yet, or,\n    //   b. RefCountSubscriber's connection Subscription reference is identical\n    //      to the shared connection Subscription\n    ///\n    const { connection } = this;\n    const sharedConnection = (<any> connectable)._connection;\n    this.connection = null;\n\n    if (sharedConnection && (!connection || sharedConnection === connection)) {\n      sharedConnection.unsubscribe();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}