{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar ArrayObservable_1 = require('../observable/ArrayObservable');\n\nvar isArray_1 = require('../util/isArray');\n\nvar OuterSubscriber_1 = require('../OuterSubscriber');\n\nvar subscribeToResult_1 = require('../util/subscribeToResult');\n\nvar none = {};\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\n\nfunction combineLatest() {\n  var observables = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    observables[_i - 0] = arguments[_i];\n  }\n\n  var project = null;\n\n  if (typeof observables[observables.length - 1] === 'function') {\n    project = observables.pop();\n  } // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n\n\n  if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n    observables = observables[0].slice();\n  }\n\n  return function (source) {\n    return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project));\n  };\n}\n\nexports.combineLatest = combineLatest;\n\nvar CombineLatestOperator = function () {\n  function CombineLatestOperator(project) {\n    this.project = project;\n  }\n\n  CombineLatestOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n  };\n\n  return CombineLatestOperator;\n}();\n\nexports.CombineLatestOperator = CombineLatestOperator;\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\n\nvar CombineLatestSubscriber = function (_super) {\n  __extends(CombineLatestSubscriber, _super);\n\n  function CombineLatestSubscriber(destination, project) {\n    _super.call(this, destination);\n\n    this.project = project;\n    this.active = 0;\n    this.values = [];\n    this.observables = [];\n  }\n\n  CombineLatestSubscriber.prototype._next = function (observable) {\n    this.values.push(none);\n    this.observables.push(observable);\n  };\n\n  CombineLatestSubscriber.prototype._complete = function () {\n    var observables = this.observables;\n    var len = observables.length;\n\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n\n      for (var i = 0; i < len; i++) {\n        var observable = observables[i];\n        this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n      }\n    }\n  };\n\n  CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete();\n    }\n  };\n\n  CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n    var values = this.values;\n    var oldVal = values[outerIndex];\n    var toRespond = !this.toRespond ? 0 : oldVal === none ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n\n    if (toRespond === 0) {\n      if (this.project) {\n        this._tryProject(values);\n      } else {\n        this.destination.next(values.slice());\n      }\n    }\n  };\n\n  CombineLatestSubscriber.prototype._tryProject = function (values) {\n    var result;\n\n    try {\n      result = this.project.apply(this, values);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n\n    this.destination.next(result);\n  };\n\n  return CombineLatestSubscriber;\n}(OuterSubscriber_1.OuterSubscriber);\n\nexports.CombineLatestSubscriber = CombineLatestSubscriber;","map":{"version":3,"mappings":"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","names":["none","observables","project","length","pop","isArray_1","slice","source","lift","call","ArrayObservable_1","concat","CombineLatestOperator","exports","combineLatest","subscriber","subscribe","CombineLatestSubscriber","__extends","destination","_super","observable","values","push","len","complete","active","toRespond","i","add","subscribeToResult_1","unused","outerValue","innerValue","outerIndex","innerIndex","innerSub","oldVal","_tryProject","next","result","apply","err","error","OuterSubscriber_1"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/src/operators/combineLatest.ts"],"sourcesContent":["import { Observable, ObservableInput } from '../Observable';\nimport { ArrayObservable } from '../observable/ArrayObservable';\nimport { isArray } from '../util/isArray';\nimport { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\nconst none = {};\n\n/* tslint:disable:max-line-length */\nexport function combineLatest<T, R>(project: (v1: T) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, R>(v2: ObservableInput<T2>, project: (v1: T, v2: T2) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, project: (v1: T, v2: T2, v3: T3) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, project: (v1: T, v2: T2, v3: T3, v4: T4) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, T5, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => R): OperatorFunction<T, R>;\nexport function combineLatest<T, T2, T3, T4, T5, T6, R>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>, project: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5, v6: T6) => R): OperatorFunction<T, R> ;\nexport function combineLatest<T, T2>(v2: ObservableInput<T2>): OperatorFunction<T, [T, T2]>;\nexport function combineLatest<T, T2, T3>(v2: ObservableInput<T2>, v3: ObservableInput<T3>): OperatorFunction<T, [T, T2, T3]>;\nexport function combineLatest<T, T2, T3, T4>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>): OperatorFunction<T, [T, T2, T3, T4]>;\nexport function combineLatest<T, T2, T3, T4, T5>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>): OperatorFunction<T, [T, T2, T3, T4, T5]>;\nexport function combineLatest<T, T2, T3, T4, T5, T6>(v2: ObservableInput<T2>, v3: ObservableInput<T3>, v4: ObservableInput<T4>, v5: ObservableInput<T5>, v6: ObservableInput<T6>): OperatorFunction<T, [T, T2, T3, T4, T5, T6]> ;\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<T> | ((...values: Array<T>) => R)>): OperatorFunction<T, R>;\nexport function combineLatest<T, R>(array: ObservableInput<T>[]): OperatorFunction<T, Array<T>>;\nexport function combineLatest<T, TOther, R>(array: ObservableInput<TOther>[], project: (v1: T, ...values: Array<TOther>) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Combines multiple Observables to create an Observable whose values are\n * calculated from the latest values of each of its input Observables.\n *\n * <span class=\"informal\">Whenever any input Observable emits a value, it\n * computes a formula using the latest values from all the inputs, then emits\n * the output of that formula.</span>\n *\n * <img src=\"./img/combineLatest.png\" width=\"100%\">\n *\n * `combineLatest` combines the values from this Observable with values from\n * Observables passed as arguments. This is done by subscribing to each\n * Observable, in order, and collecting an array of each of the most recent\n * values any time any of the input Observables emits, then either taking that\n * array and passing it as arguments to an optional `project` function and\n * emitting the return value of that, or just emitting the array of recent\n * values directly if there is no `project` function.\n *\n * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n * bmi.subscribe(x => console.log('BMI is ' + x));\n *\n * // With output to console:\n * // BMI is 24.212293388429753\n * // BMI is 23.93948099205209\n * // BMI is 23.671253629592222\n *\n * @see {@link combineAll}\n * @see {@link merge}\n * @see {@link withLatestFrom}\n *\n * @param {ObservableInput} other An input Observable to combine with the source\n * Observable. More than one input Observables may be given as argument.\n * @param {function} [project] An optional function to project the values from\n * the combined latest values into a new value on the output Observable.\n * @return {Observable} An Observable of projected values from the most recent\n * values from each input Observable, or an array of the most recent values from\n * each input Observable.\n * @method combineLatest\n * @owner Observable\n */\nexport function combineLatest<T, R>(...observables: Array<ObservableInput<any> |\n                                                    Array<ObservableInput<any>> |\n                                                    ((...values: Array<any>) => R)>): OperatorFunction<T, R> {\n  let project: (...values: Array<any>) => R = null;\n  if (typeof observables[observables.length - 1] === 'function') {\n    project = <(...values: Array<any>) => R>observables.pop();\n  }\n\n  // if the first and only other argument besides the resultSelector is an array\n  // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n  if (observables.length === 1 && isArray(observables[0])) {\n    observables = (<any>observables[0]).slice();\n  }\n\n  return (source: Observable<T>) => source.lift.call(new ArrayObservable([source, ...observables]), new CombineLatestOperator(project));\n}\n\nexport class CombineLatestOperator<T, R> implements Operator<T, R> {\n  constructor(private project?: (...values: Array<any>) => R) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class CombineLatestSubscriber<T, R> extends OuterSubscriber<T, R> {\n  private active: number = 0;\n  private values: any[] = [];\n  private observables: any[] = [];\n  private toRespond: number;\n\n  constructor(destination: Subscriber<R>, private project?: (...values: Array<any>) => R) {\n    super(destination);\n  }\n\n  protected _next(observable: any) {\n    this.values.push(none);\n    this.observables.push(observable);\n  }\n\n  protected _complete() {\n    const observables = this.observables;\n    const len = observables.length;\n    if (len === 0) {\n      this.destination.complete();\n    } else {\n      this.active = len;\n      this.toRespond = len;\n      for (let i = 0; i < len; i++) {\n        const observable = observables[i];\n        this.add(subscribeToResult(this, observable, observable, i));\n      }\n    }\n  }\n\n  notifyComplete(unused: Subscriber<R>): void {\n    if ((this.active -= 1) === 0) {\n      this.destination.complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    const values = this.values;\n    const oldVal = values[outerIndex];\n    const toRespond = !this.toRespond\n      ? 0\n      : oldVal === none ? --this.toRespond : this.toRespond;\n    values[outerIndex] = innerValue;\n\n    if (toRespond === 0) {\n      if (this.project) {\n        this._tryProject(values);\n      } else {\n        this.destination.next(values.slice());\n      }\n    }\n  }\n\n  private _tryProject(values: any[]) {\n    let result: any;\n    try {\n      result = this.project.apply(this, values);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}