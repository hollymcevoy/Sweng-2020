{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = _callee;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _effects = require(\"redux-saga/effects\");\n\nvar _botframeworkDirectlinejs = require(\"botframework-directlinejs\");\n\nvar _jwtDecode = _interopRequireDefault(require(\"jwt-decode\"));\n\nvar _connect = require(\"../actions/connect\");\n\nvar _createPromiseQueue = _interopRequireDefault(require(\"../createPromiseQueue\"));\n\nvar _forkPut = _interopRequireDefault(require(\"./effects/forkPut\"));\n\nvar _uniqueID = _interopRequireDefault(require(\"../utils/uniqueID\"));\n\nvar _updateConnectionStatus = _interopRequireWildcard(require(\"../actions/updateConnectionStatus\"));\n\nvar _disconnect = require(\"../actions/disconnect\");\n\nvar _reconnect = require(\"../actions/reconnect\");\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar _marked = /*#__PURE__*/_regenerator[\"default\"].mark(observeAndPutConnectionStatusUpdate),\n    _marked2 = /*#__PURE__*/_regenerator[\"default\"].mark(connectSaga),\n    _marked3 = /*#__PURE__*/_regenerator[\"default\"].mark(reconnectSaga),\n    _marked4 = /*#__PURE__*/_regenerator[\"default\"].mark(runAsyncEffect),\n    _marked5 = /*#__PURE__*/_regenerator[\"default\"].mark(takeDisconnectAsError),\n    _marked6 = /*#__PURE__*/_regenerator[\"default\"].mark(_callee);\n\nvar CONNECTING = _botframeworkDirectlinejs.ConnectionStatus.Connecting,\n    ONLINE = _botframeworkDirectlinejs.ConnectionStatus.Online,\n    UNINITIALIZED = _botframeworkDirectlinejs.ConnectionStatus.Uninitialized;\n\nfunction randomUserID() {\n  return \"r_\".concat((0, _uniqueID[\"default\"])().substr(0, 10));\n}\n\nfunction observeAndPutConnectionStatusUpdate(directLine) {\n  var connectionStatusQueue, connectionStatusSubscription, connectionStatus;\n  return _regenerator[\"default\"].wrap(function observeAndPutConnectionStatusUpdate$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          connectionStatusQueue = (0, _createPromiseQueue[\"default\"])();\n          connectionStatusSubscription = directLine.connectionStatus$.subscribe({\n            next: connectionStatusQueue.push\n          });\n          _context.prev = 2;\n\n        case 3:\n          _context.next = 5;\n          return (0, _effects.call)(connectionStatusQueue.shift);\n\n        case 5:\n          connectionStatus = _context.sent;\n          _context.next = 8;\n          return (0, _effects.put)((0, _updateConnectionStatus[\"default\"])(connectionStatus));\n\n        case 8:\n          _context.next = 3;\n          break;\n\n        case 10:\n          _context.prev = 10;\n          connectionStatusSubscription.unsubscribe();\n          return _context.finish(10);\n\n        case 13:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[2,, 10, 13]]);\n} // TODO: [P2] We should move this check and rectification to DirectLineJS.\n\n\nfunction rectifyUserID(directLine, userIDFromAction) {\n  var token = directLine.token;\n  var userIDFromToken; // TODO: Add test to make sure \"jwt-decode\" work as expected.\n\n  try {\n    userIDFromToken = ((0, _jwtDecode[\"default\"])(token) || {}).user; // eslint-disable-next-line no-empty\n  } catch (err) {}\n\n  var result = {\n    fromAction: userIDFromAction,\n    fromToken: userIDFromToken\n  };\n\n  if (userIDFromToken) {\n    if (userIDFromAction && userIDFromAction !== userIDFromToken) {\n      console.warn('Web Chat: user ID is both specified in the Direct Line token and passed in, will use the user ID from the token.');\n    }\n\n    result[\"final\"] = userIDFromToken;\n  } else if (userIDFromAction) {\n    if (typeof userIDFromAction !== 'string') {\n      console.warn('Web Chat: user ID must be a string.');\n      result[\"final\"] = randomUserID();\n    } else if (/^dl_/.test(userIDFromAction)) {\n      console.warn('Web Chat: user ID prefixed with \"dl_\" is reserved and must be embedded into the Direct Line token to prevent forgery.');\n      result[\"final\"] = randomUserID();\n    } else {\n      result[\"final\"] = userIDFromAction;\n    }\n  } else {\n    result[\"final\"] = randomUserID();\n  }\n\n  return result;\n} // We could make this a Promise instead of saga (function generator) to make the code cleaner, if:\n// 1. We found a way to cancel Promise\n// 2. subscribe() are shared amongst all subscriptions, e.g. turn Observable into events\n\n\nfunction connectSaga(directLine) {\n  var activitySubscription, unsubscribeActivity, _yield$take, connectionStatus;\n\n  return _regenerator[\"default\"].wrap(function connectSaga$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          // DirectLineJS starts the connection only after the first subscriber for activity$, not connectionStatus$\n          activitySubscription = directLine.activity$.subscribe({\n            next: function next() {\n              return 0;\n            }\n          });\n          unsubscribeActivity = activitySubscription.unsubscribe.bind(activitySubscription);\n          _context2.prev = 2;\n\n        case 3:\n          _context2.next = 5;\n          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);\n\n        case 5:\n          _yield$take = _context2.sent;\n          connectionStatus = _yield$take.payload.connectionStatus;\n\n          if (!(connectionStatus === ONLINE)) {\n            _context2.next = 11;\n            break;\n          }\n\n          return _context2.abrupt(\"return\", function () {\n            unsubscribeActivity();\n            directLine.end();\n          });\n\n        case 11:\n          if (!(connectionStatus !== UNINITIALIZED && connectionStatus !== CONNECTING)) {\n            _context2.next = 13;\n            break;\n          }\n\n          throw new Error(\"Failed to connect, DirectLineJS returned \".concat(connectionStatus, \".\"));\n\n        case 13:\n          _context2.next = 3;\n          break;\n\n        case 15:\n          _context2.next = 21;\n          break;\n\n        case 17:\n          _context2.prev = 17;\n          _context2.t0 = _context2[\"catch\"](2); // We will unsubscribe if we failed to connect or got cancelled only.\n          // We should not unsubscribe in happy case, because DirectLineJS should relying on the subscription to connect/disconnect.\n\n          unsubscribeActivity();\n          throw _context2.t0;\n\n        case 21:\n          _context2.prev = 21;\n          _context2.next = 24;\n          return (0, _effects.cancelled)();\n\n        case 24:\n          if (!_context2.sent) {\n            _context2.next = 26;\n            break;\n          }\n\n          unsubscribeActivity();\n\n        case 26:\n          return _context2.finish(21);\n\n        case 27:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2, null, [[2, 17, 21, 27]]);\n}\n\nfunction reconnectSaga() {\n  var _yield$take2, connectionStatus;\n\n  return _regenerator[\"default\"].wrap(function reconnectSaga$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS);\n\n        case 2:\n          _yield$take2 = _context3.sent;\n          connectionStatus = _yield$take2.payload.connectionStatus;\n\n          if (!(connectionStatus === ONLINE)) {\n            _context3.next = 8;\n            break;\n          }\n\n          return _context3.abrupt(\"break\", 12);\n\n        case 8:\n          if (!(connectionStatus !== CONNECTING)) {\n            _context3.next = 10;\n            break;\n          }\n\n          throw new Error(\"Failed to reconnect. DirectLineJS returned \".concat(connectionStatus, \".\"));\n\n        case 10:\n          _context3.next = 0;\n          break;\n\n        case 12:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n} // This is similar to behavior of redux-promise-middleware, but using saga instead of Promise.\n// We guarantee PENDING -> FULFILLING -> FULFILLED, or PENDING -> REJECTED. This will help us simplify logic in other part of code.\n// Note that after the saga is cancelled, subsequent call to put() will be ignored silently.\n\n\nfunction runAsyncEffect(_ref, callEffectFactory) {\n  var type, meta, payload, result;\n  return _regenerator[\"default\"].wrap(function runAsyncEffect$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          type = _ref.type, meta = _ref.meta, payload = _ref.payload;\n          _context4.prev = 1;\n          _context4.next = 4;\n          return (0, _forkPut[\"default\"])({\n            type: \"\".concat(type, \"_PENDING\"),\n            meta: meta,\n            payload: payload\n          });\n\n        case 4:\n          _context4.next = 6;\n          return callEffectFactory();\n\n        case 6:\n          result = _context4.sent;\n          _context4.next = 9;\n          return (0, _forkPut[\"default\"])({\n            type: \"\".concat(type, \"_FULFILLING\"),\n            meta: meta,\n            payload: payload\n          }, {\n            type: \"\".concat(type, \"_FULFILLED\"),\n            meta: meta,\n            payload: payload\n          });\n\n        case 9:\n          return _context4.abrupt(\"return\", result);\n\n        case 12:\n          _context4.prev = 12;\n          _context4.t0 = _context4[\"catch\"](1);\n          _context4.next = 16;\n          return (0, _forkPut[\"default\"])({\n            type: \"\".concat(type, \"_REJECTED\"),\n            error: true,\n            meta: meta,\n            payload: _context4.t0\n          });\n\n        case 16:\n          throw _context4.t0;\n\n        case 17:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4, null, [[1, 12]]);\n}\n\nfunction takeDisconnectAsError() {\n  return _regenerator[\"default\"].wrap(function takeDisconnectAsError$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return (0, _effects.take)(_disconnect.DISCONNECT);\n\n        case 2:\n          throw new Error('disconnected');\n\n        case 3:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked5);\n}\n\nfunction runAsyncEffectUntilDisconnect(baseAction, callEffectFactory) {\n  // We cannot use saga cancel() here, because cancelling saga will prohibit us from sending *_REJECTED.\n  // Without REJECTED, it impacts our assumptions around PENDING/FULFILLED/REJECTED.\n  return runAsyncEffect(baseAction, /*#__PURE__*/_regenerator[\"default\"].mark(function runUntilDisconnect() {\n    var _yield$race, result;\n\n    return _regenerator[\"default\"].wrap(function runUntilDisconnect$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return (0, _effects.race)({\n              _: takeDisconnectAsError(),\n              result: callEffectFactory()\n            });\n\n          case 2:\n            _yield$race = _context6.sent;\n            result = _yield$race.result;\n            return _context6.abrupt(\"return\", result);\n\n          case 5:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, runUntilDisconnect);\n  }));\n}\n\nfunction _callee() {\n  var _loop;\n\n  return _regenerator[\"default\"].wrap(function _callee$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          _loop = /*#__PURE__*/_regenerator[\"default\"].mark(function _loop() {\n            var _yield$take3, _yield$take3$payload, directLine, userIDFromAction, username, updateConnectionStatusTask, rectifiedUserID, meta, disconnectMeta, endDirectLine, _yield$race2, _yield$race2$updateCo, _yield$race2$updateCo2, connectionStatus;\n\n            return _regenerator[\"default\"].wrap(function _loop$(_context7) {\n              while (1) {\n                switch (_context7.prev = _context7.next) {\n                  case 0:\n                    _context7.next = 2;\n                    return (0, _effects.take)(_connect.CONNECT);\n\n                  case 2:\n                    _yield$take3 = _context7.sent;\n                    _yield$take3$payload = _yield$take3.payload;\n                    directLine = _yield$take3$payload.directLine;\n                    userIDFromAction = _yield$take3$payload.userID;\n                    username = _yield$take3$payload.username;\n                    _context7.next = 9;\n                    return (0, _effects.fork)(observeAndPutConnectionStatusUpdate, directLine);\n\n                  case 9:\n                    updateConnectionStatusTask = _context7.sent;\n                    rectifiedUserID = rectifyUserID(directLine, userIDFromAction); // TODO: [P2] Checks if this attached subtask will get killed if the parent task is complete (peacefully), errored out, or cancelled.\n\n                    meta = {\n                      userID: rectifiedUserID[\"final\"],\n                      username: username\n                    }; // Send user ID to DirectLineJS if it was specified from props of <API.Composer>.\n                    // However, DirectLineJS may still prefer the user ID from token if it is burnt into the token.\n                    // To prevent DirectLineJS giving false warnings, we will only call setUserId() if it is different than the token.\n\n                    directLine.setUserId && rectifiedUserID.fromToken !== meta.userID && directLine.setUserId(meta.userID);\n                    disconnectMeta = void 0; // We will dispatch CONNECT_PENDING, wait for connect completed, errored, or cancelled (thru disconnect).\n                    // Then dispatch CONNECT_FULFILLED/CONNECT_REJECTED as needed.\n\n                    _context7.prev = 14;\n                    _context7.next = 17;\n                    return runAsyncEffectUntilDisconnect({\n                      type: _connect.CONNECT,\n                      meta: meta,\n                      payload: {\n                        directLine: directLine\n                      }\n                    }, function () {\n                      return (0, _effects.call)(connectSaga, directLine);\n                    });\n\n                  case 17:\n                    endDirectLine = _context7.sent;\n                    _context7.prev = 18;\n\n                  case 19:\n                    _context7.next = 21;\n                    return (0, _effects.race)({\n                      _: (0, _effects.take)(_disconnect.DISCONNECT),\n                      updateConnectionStatusAction: (0, _effects.take)(_updateConnectionStatus.UPDATE_CONNECTION_STATUS)\n                    });\n\n                  case 21:\n                    _yield$race2 = _context7.sent;\n                    _yield$race2$updateCo = _yield$race2.updateConnectionStatusAction;\n                    _yield$race2$updateCo = _yield$race2$updateCo === void 0 ? {} : _yield$race2$updateCo;\n                    _yield$race2$updateCo2 = _yield$race2$updateCo.payload;\n                    _yield$race2$updateCo2 = _yield$race2$updateCo2 === void 0 ? {} : _yield$race2$updateCo2;\n                    connectionStatus = _yield$race2$updateCo2.connectionStatus; // If it is not disconnect action, connectionStatus will not be undefined.\n\n                    if (!(connectionStatus === CONNECTING)) {\n                      _context7.next = 32;\n                      break;\n                    }\n\n                    _context7.next = 30;\n                    return runAsyncEffectUntilDisconnect({\n                      type: _reconnect.RECONNECT,\n                      meta: meta,\n                      payload: {\n                        directLine: directLine\n                      }\n                    }, function () {\n                      return (0, _effects.call)(reconnectSaga);\n                    });\n\n                  case 30:\n                    _context7.next = 38;\n                    break;\n\n                  case 32:\n                    if (!(connectionStatus !== ONLINE)) {\n                      _context7.next = 38;\n                      break;\n                    }\n\n                    if (!(typeof connectionStatus !== 'undefined')) {\n                      _context7.next = 37;\n                      break;\n                    }\n\n                    throw new Error(\"Connection status changed to \".concat(connectionStatus));\n\n                  case 37:\n                    return _context7.abrupt(\"break\", 40);\n\n                  case 38:\n                    _context7.next = 19;\n                    break;\n\n                  case 40:\n                    _context7.prev = 40;\n                    endDirectLine();\n                    return _context7.finish(40);\n\n                  case 43:\n                    _context7.next = 48;\n                    break;\n\n                  case 45:\n                    _context7.prev = 45;\n                    _context7.t0 = _context7[\"catch\"](14);\n                    disconnectMeta = {\n                      error: _context7.t0\n                    };\n\n                  case 48:\n                    _context7.prev = 48;\n                    _context7.next = 51;\n                    return (0, _effects.cancel)(updateConnectionStatusTask);\n\n                  case 51:\n                    _context7.next = 53;\n                    return (0, _forkPut[\"default\"])({\n                      type: _disconnect.DISCONNECT_PENDING,\n                      meta: disconnectMeta,\n                      payload: {\n                        directLine: directLine\n                      }\n                    }, {\n                      type: _disconnect.DISCONNECT_FULFILLED,\n                      meta: disconnectMeta,\n                      payload: {\n                        directLine: directLine\n                      }\n                    });\n\n                  case 53:\n                    return _context7.finish(48);\n\n                  case 54:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }\n            }, _loop, null, [[14, 45, 48, 54], [18,, 40, 43]]);\n          });\n\n        case 1:\n          return _context8.delegateYield(_loop(), \"t0\", 2);\n\n        case 2:\n          _context8.next = 1;\n          break;\n\n        case 4:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, _marked6);\n}","map":{"version":3,"mappings":"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","names":["observeAndPutConnectionStatusUpdate","connectSaga","reconnectSaga","runAsyncEffect","takeDisconnectAsError","CONNECTING","ConnectionStatus","Connecting","ONLINE","Online","UNINITIALIZED","Uninitialized","randomUserID","substr","directLine","connectionStatusQueue","connectionStatusSubscription","connectionStatus$","subscribe","next","push","_context","shift","connectionStatus","unsubscribe","rectifyUserID","userIDFromAction","token","userIDFromToken","user","err","result","fromAction","fromToken","console","warn","test","activitySubscription","activity$","unsubscribeActivity","bind","_context2","UPDATE_CONNECTION_STATUS","_yield$take","payload","end","Error","_context3","_yield$take2","callEffectFactory","type","meta","_context4","error","_context5","DISCONNECT","runAsyncEffectUntilDisconnect","baseAction","runUntilDisconnect","_context6","_","_yield$race","_loop","_context7","CONNECT","_yield$take3","_yield$take3$payload","userID","username","updateConnectionStatusTask","rectifiedUserID","setUserId","disconnectMeta","endDirectLine","updateConnectionStatusAction","_yield$race2","_yield$race2$updateCo","_yield$race2$updateCo2","RECONNECT","DISCONNECT_PENDING","DISCONNECT_FULFILLED","_context8"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-core/lib/src/sagas/connectSaga.js"],"sourcesContent":["/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 10] }] */\n\nimport { call, cancel, cancelled, fork, put, race, take } from 'redux-saga/effects';\n\nimport { ConnectionStatus } from 'botframework-directlinejs';\nimport decode from 'jwt-decode';\n\nimport { CONNECT } from '../actions/connect';\nimport createPromiseQueue from '../createPromiseQueue';\nimport forkPut from './effects/forkPut';\nimport uniqueID from '../utils/uniqueID';\nimport updateConnectionStatus, { UPDATE_CONNECTION_STATUS } from '../actions/updateConnectionStatus';\n\nimport { DISCONNECT, DISCONNECT_PENDING, DISCONNECT_FULFILLED } from '../actions/disconnect';\n\nimport { RECONNECT } from '../actions/reconnect';\n\nconst { Connecting: CONNECTING, Online: ONLINE, Uninitialized: UNINITIALIZED } = ConnectionStatus;\n\nfunction randomUserID() {\n  return `r_${uniqueID().substr(0, 10)}`;\n}\n\nfunction* observeAndPutConnectionStatusUpdate(directLine) {\n  const connectionStatusQueue = createPromiseQueue();\n  const connectionStatusSubscription = directLine.connectionStatus$.subscribe({ next: connectionStatusQueue.push });\n\n  try {\n    for (;;) {\n      const connectionStatus = yield call(connectionStatusQueue.shift);\n\n      yield put(updateConnectionStatus(connectionStatus));\n    }\n  } finally {\n    connectionStatusSubscription.unsubscribe();\n  }\n}\n\n// TODO: [P2] We should move this check and rectification to DirectLineJS.\nfunction rectifyUserID(directLine, userIDFromAction) {\n  const { token } = directLine;\n\n  let userIDFromToken;\n\n  // TODO: Add test to make sure \"jwt-decode\" work as expected.\n  try {\n    userIDFromToken = (decode(token) || {}).user;\n    // eslint-disable-next-line no-empty\n  } catch (err) {}\n\n  const result = {\n    fromAction: userIDFromAction,\n    fromToken: userIDFromToken\n  };\n\n  if (userIDFromToken) {\n    if (userIDFromAction && userIDFromAction !== userIDFromToken) {\n      console.warn(\n        'Web Chat: user ID is both specified in the Direct Line token and passed in, will use the user ID from the token.'\n      );\n    }\n\n    result.final = userIDFromToken;\n  } else if (userIDFromAction) {\n    if (typeof userIDFromAction !== 'string') {\n      console.warn('Web Chat: user ID must be a string.');\n\n      result.final = randomUserID();\n    } else if (/^dl_/u.test(userIDFromAction)) {\n      console.warn(\n        'Web Chat: user ID prefixed with \"dl_\" is reserved and must be embedded into the Direct Line token to prevent forgery.'\n      );\n\n      result.final = randomUserID();\n    } else {\n      result.final = userIDFromAction;\n    }\n  } else {\n    result.final = randomUserID();\n  }\n\n  return result;\n}\n\n// We could make this a Promise instead of saga (function generator) to make the code cleaner, if:\n// 1. We found a way to cancel Promise\n// 2. subscribe() are shared amongst all subscriptions, e.g. turn Observable into events\nfunction* connectSaga(directLine) {\n  // DirectLineJS starts the connection only after the first subscriber for activity$, not connectionStatus$\n  const activitySubscription = directLine.activity$.subscribe({ next: () => 0 });\n  const unsubscribeActivity = activitySubscription.unsubscribe.bind(activitySubscription);\n\n  try {\n    for (;;) {\n      const {\n        payload: { connectionStatus }\n      } = yield take(UPDATE_CONNECTION_STATUS);\n\n      if (connectionStatus === ONLINE) {\n        // TODO: [P2] DirectLineJS should kill the connection when we unsubscribe\n        //       But currently in v3, DirectLineJS does not have this functionality\n        //       Thus, we need to call \"end()\" explicitly\n\n        return () => {\n          unsubscribeActivity();\n          directLine.end();\n        };\n      } else if (connectionStatus !== UNINITIALIZED && connectionStatus !== CONNECTING) {\n        throw new Error(`Failed to connect, DirectLineJS returned ${connectionStatus}.`);\n      }\n    }\n  } catch (err) {\n    // We will unsubscribe if we failed to connect or got cancelled only.\n    // We should not unsubscribe in happy case, because DirectLineJS should relying on the subscription to connect/disconnect.\n    unsubscribeActivity();\n\n    throw err;\n  } finally {\n    if (yield cancelled()) {\n      unsubscribeActivity();\n    }\n  }\n}\n\nfunction* reconnectSaga() {\n  for (;;) {\n    const {\n      payload: { connectionStatus }\n    } = yield take(UPDATE_CONNECTION_STATUS);\n\n    if (connectionStatus === ONLINE) {\n      break;\n    } else if (connectionStatus !== CONNECTING) {\n      throw new Error(`Failed to reconnect. DirectLineJS returned ${connectionStatus}.`);\n    }\n  }\n}\n\n// This is similar to behavior of redux-promise-middleware, but using saga instead of Promise.\n// We guarantee PENDING -> FULFILLING -> FULFILLED, or PENDING -> REJECTED. This will help us simplify logic in other part of code.\n// Note that after the saga is cancelled, subsequent call to put() will be ignored silently.\nfunction* runAsyncEffect({ type, meta, payload }, callEffectFactory) {\n  try {\n    yield forkPut({ type: `${type}_PENDING`, meta, payload });\n\n    const result = yield callEffectFactory();\n\n    yield forkPut({ type: `${type}_FULFILLING`, meta, payload }, { type: `${type}_FULFILLED`, meta, payload });\n\n    return result;\n  } catch (payload) {\n    yield forkPut({ type: `${type}_REJECTED`, error: true, meta, payload });\n\n    throw payload;\n  }\n}\n\nfunction* takeDisconnectAsError() {\n  yield take(DISCONNECT);\n\n  throw new Error('disconnected');\n}\n\nfunction runAsyncEffectUntilDisconnect(baseAction, callEffectFactory) {\n  // We cannot use saga cancel() here, because cancelling saga will prohibit us from sending *_REJECTED.\n  // Without REJECTED, it impacts our assumptions around PENDING/FULFILLED/REJECTED.\n  return runAsyncEffect(baseAction, function* runUntilDisconnect() {\n    const { result } = yield race({\n      _: takeDisconnectAsError(),\n      result: callEffectFactory()\n    });\n\n    return result;\n  });\n}\n\nexport default function* () {\n  for (;;) {\n    const {\n      payload: { directLine, userID: userIDFromAction, username }\n    } = yield take(CONNECT);\n\n    const updateConnectionStatusTask = yield fork(observeAndPutConnectionStatusUpdate, directLine);\n    const rectifiedUserID = rectifyUserID(directLine, userIDFromAction);\n\n    // TODO: [P2] Checks if this attached subtask will get killed if the parent task is complete (peacefully), errored out, or cancelled.\n    const meta = {\n      userID: rectifiedUserID.final,\n      username\n    };\n\n    // Send user ID to DirectLineJS if it was specified from props of <API.Composer>.\n    // However, DirectLineJS may still prefer the user ID from token if it is burnt into the token.\n    // To prevent DirectLineJS giving false warnings, we will only call setUserId() if it is different than the token.\n    directLine.setUserId && rectifiedUserID.fromToken !== meta.userID && directLine.setUserId(meta.userID);\n\n    let disconnectMeta;\n\n    // We will dispatch CONNECT_PENDING, wait for connect completed, errored, or cancelled (thru disconnect).\n    // Then dispatch CONNECT_FULFILLED/CONNECT_REJECTED as needed.\n    try {\n      const endDirectLine = yield runAsyncEffectUntilDisconnect(\n        {\n          type: CONNECT,\n          meta,\n          payload: { directLine }\n        },\n        () => call(connectSaga, directLine)\n      );\n\n      try {\n        for (;;) {\n          // We are waiting for connection status change or disconnect action.\n          const { updateConnectionStatusAction: { payload: { connectionStatus } = {} } = {} } = yield race({\n            _: take(DISCONNECT),\n            updateConnectionStatusAction: take(UPDATE_CONNECTION_STATUS)\n          });\n\n          // If it is not disconnect action, connectionStatus will not be undefined.\n          if (connectionStatus === CONNECTING) {\n            // If DirectLineJS changed connectionStatus to CONNECTING, we will treat it as reconnect status.\n            yield runAsyncEffectUntilDisconnect(\n              {\n                type: RECONNECT,\n                meta,\n                payload: { directLine }\n              },\n              () => call(reconnectSaga)\n            );\n          } else if (connectionStatus !== ONLINE) {\n            if (typeof connectionStatus !== 'undefined') {\n              // We need to kill the connection because DirectLineJS want to close it.\n              throw new Error(`Connection status changed to ${connectionStatus}`);\n            } else {\n              // Someone dispatched disconnect action.\n              break;\n            }\n          }\n        }\n      } finally {\n        endDirectLine();\n      }\n    } catch (error) {\n      disconnectMeta = { error };\n    } finally {\n      yield cancel(updateConnectionStatusTask);\n\n      // Even if the connection is interrupted, we will still emit DISCONNECT_PENDING.\n      // This will makes handling logic easier. If CONNECT_FULFILLED, we guarantee DISCONNECT_PENDING.\n      yield forkPut(\n        { type: DISCONNECT_PENDING, meta: disconnectMeta, payload: { directLine } },\n        { type: DISCONNECT_FULFILLED, meta: disconnectMeta, payload: { directLine } }\n      );\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}