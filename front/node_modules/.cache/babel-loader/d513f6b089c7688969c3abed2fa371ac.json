{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseAudioPlayer = void 0;\n\nvar Error_1 = require(\"../../common/Error\");\n\nvar Promise_1 = require(\"../../common/Promise\");\n\nvar Exports_1 = require(\"../Exports\");\n\nvar AudioStreamFormat_1 = require(\"./AudioStreamFormat\");\n/**\n * Base audio player class\n * TODO: Plays only PCM for now.\n * @class\n */\n\n\nvar BaseAudioPlayer =\n/** @class */\nfunction () {\n  /**\n   * Creates and initializes an instance of this class.\n   * @constructor\n   * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.\n   */\n  function BaseAudioPlayer(audioFormat) {\n    this.audioContext = null;\n    this.gainNode = null;\n    this.autoUpdateBufferTimer = 0;\n\n    if (audioFormat === undefined) {\n      audioFormat = Exports_1.AudioStreamFormat.getDefaultInputFormat();\n    }\n\n    this.init(audioFormat);\n  }\n  /**\n   * play Audio sample\n   * @param newAudioData audio data to be played.\n   */\n\n\n  BaseAudioPlayer.prototype.playAudioSample = function (newAudioData, cb, err) {\n    var _this = this;\n\n    Promise_1.marshalPromiseToCallbacks(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var audioData, newSamplesData;\n        return __generator(this, function (_a) {\n          this.ensureInitializedContext();\n          audioData = this.formatAudioData(newAudioData);\n          newSamplesData = new Float32Array(this.samples.length + audioData.length);\n          newSamplesData.set(this.samples, 0);\n          newSamplesData.set(audioData, this.samples.length);\n          this.samples = newSamplesData;\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    }(), cb, err);\n  };\n  /**\n   * stops audio and clears the buffers\n   */\n\n\n  BaseAudioPlayer.prototype.stopAudio = function (cb, err) {\n    if (this.audioContext !== null) {\n      this.samples = new Float32Array();\n      clearInterval(this.autoUpdateBufferTimer);\n      this.audioContext.close().then(function () {\n        if (!!cb) {\n          cb();\n        }\n      }, function (error) {\n        if (!!err) {\n          err(error);\n        }\n      });\n      this.audioContext = null;\n    }\n  };\n\n  BaseAudioPlayer.prototype.init = function (audioFormat) {\n    this.audioFormat = audioFormat;\n    this.samples = new Float32Array();\n  };\n\n  BaseAudioPlayer.prototype.ensureInitializedContext = function () {\n    var _this = this;\n\n    if (this.audioContext === null) {\n      this.createAudioContext();\n      var timerPeriod = 200;\n      this.autoUpdateBufferTimer = setInterval(function () {\n        _this.updateAudioBuffer();\n      }, timerPeriod);\n    }\n  };\n\n  BaseAudioPlayer.prototype.createAudioContext = function () {\n    // new ((window as any).AudioContext || (window as any).webkitAudioContext)();\n    this.audioContext = AudioStreamFormat_1.AudioStreamFormatImpl.getAudioContext(); // TODO: Various examples shows this gain node, it does not seem to be needed unless we plan\n    // to control the volume, not likely\n\n    this.gainNode = this.audioContext.createGain();\n    this.gainNode.gain.value = 1;\n    this.gainNode.connect(this.audioContext.destination);\n    this.startTime = this.audioContext.currentTime;\n  };\n\n  BaseAudioPlayer.prototype.formatAudioData = function (audioData) {\n    switch (this.audioFormat.bitsPerSample) {\n      case 8:\n        return this.formatArrayBuffer(new Int8Array(audioData), 128);\n\n      case 16:\n        return this.formatArrayBuffer(new Int16Array(audioData), 32768);\n\n      case 32:\n        return this.formatArrayBuffer(new Int32Array(audioData), 2147483648);\n\n      default:\n        throw new Error_1.InvalidOperationError(\"Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time\");\n    }\n  };\n\n  BaseAudioPlayer.prototype.formatArrayBuffer = function (audioData, maxValue) {\n    var float32Data = new Float32Array(audioData.length);\n\n    for (var i = 0; i < audioData.length; i++) {\n      float32Data[i] = audioData[i] / maxValue;\n    }\n\n    return float32Data;\n  };\n\n  BaseAudioPlayer.prototype.updateAudioBuffer = function () {\n    if (this.samples.length === 0) {\n      return;\n    }\n\n    var channelCount = this.audioFormat.channels;\n    var bufferSource = this.audioContext.createBufferSource();\n    var frameCount = this.samples.length / channelCount;\n    var audioBuffer = this.audioContext.createBuffer(channelCount, frameCount, this.audioFormat.samplesPerSec); // TODO: Should we do the conversion in the pushAudioSample instead?\n\n    for (var channel = 0; channel < channelCount; channel++) {\n      // Fill in individual channel data\n      var channelOffset = channel;\n      var audioData = audioBuffer.getChannelData(channel);\n\n      for (var i = 0; i < this.samples.length; i++, channelOffset += channelCount) {\n        audioData[i] = this.samples[channelOffset];\n      }\n    }\n\n    if (this.startTime < this.audioContext.currentTime) {\n      this.startTime = this.audioContext.currentTime;\n    }\n\n    bufferSource.buffer = audioBuffer;\n    bufferSource.connect(this.gainNode);\n    bufferSource.start(this.startTime); // Make sure we play the next sample after the current one.\n\n    this.startTime += audioBuffer.duration; // Clear the samples for the next pushed data.\n\n    this.samples = new Float32Array();\n  };\n\n  BaseAudioPlayer.prototype.playAudio = function (audioData) {\n    return __awaiter(this, void 0, void 0, function () {\n      var source, destination;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.audioContext === null) {\n              this.createAudioContext();\n            }\n\n            source = this.audioContext.createBufferSource();\n            destination = this.audioContext.destination;\n            return [4\n            /*yield*/\n            , this.audioContext.decodeAudioData(audioData, function (newBuffer) {\n              source.buffer = newBuffer;\n              source.connect(destination);\n              source.start(0);\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return BaseAudioPlayer;\n}();\n\nexports.BaseAudioPlayer = BaseAudioPlayer;","map":{"version":3,"mappings":"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","names":["audioFormat","undefined","Exports_1","getDefaultInputFormat","init","BaseAudioPlayer","newAudioData","cb","err","Promise_1","ensureInitializedContext","audioData","formatAudioData","newSamplesData","Float32Array","samples","length","set","audioContext","clearInterval","autoUpdateBufferTimer","close","then","error","createAudioContext","timerPeriod","setInterval","_this","updateAudioBuffer","AudioStreamFormat_1","getAudioContext","gainNode","createGain","gain","value","connect","destination","startTime","currentTime","bitsPerSample","formatArrayBuffer","Int8Array","Int16Array","Int32Array","Error_1","maxValue","float32Data","i","channelCount","channels","bufferSource","createBufferSource","frameCount","audioBuffer","createBuffer","samplesPerSec","channel","channelOffset","getChannelData","buffer","start","duration","source","decodeAudioData","newBuffer","_a","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/src/sdk/Audio/BaseAudioPlayer.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError } from \"../../common/Error\";\r\nimport { marshalPromiseToCallbacks } from \"../../common/Promise\";\r\nimport { AudioStreamFormat, PullAudioInputStreamCallback } from \"../Exports\";\r\nimport { AudioStreamFormatImpl } from \"./AudioStreamFormat\";\r\n\r\ntype AudioDataTypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array;\r\n/**\r\n * Base audio player class\r\n * TODO: Plays only PCM for now.\r\n * @class\r\n */\r\nexport class BaseAudioPlayer {\r\n\r\n    private audioContext: AudioContext = null;\r\n    private gainNode: GainNode = null;\r\n    private audioFormat: AudioStreamFormatImpl;\r\n    private autoUpdateBufferTimer: any = 0;\r\n    private samples: Float32Array;\r\n    private startTime: number;\r\n\r\n    /**\r\n     * Creates and initializes an instance of this class.\r\n     * @constructor\r\n     * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.\r\n     */\r\n    public constructor(audioFormat?: AudioStreamFormat) {\r\n        if (audioFormat === undefined) {\r\n            audioFormat = AudioStreamFormat.getDefaultInputFormat();\r\n        }\r\n        this.init(audioFormat);\r\n    }\r\n\r\n    /**\r\n     * play Audio sample\r\n     * @param newAudioData audio data to be played.\r\n     */\r\n    public playAudioSample(newAudioData: ArrayBuffer, cb?: () => void, err?: (error: string) => void): void {\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n                this.ensureInitializedContext();\r\n                const audioData = this.formatAudioData(newAudioData);\r\n                const newSamplesData = new Float32Array(this.samples.length + audioData.length);\r\n                newSamplesData.set(this.samples, 0);\r\n                newSamplesData.set(audioData, this.samples.length);\r\n                this.samples = newSamplesData;\r\n        })(), cb, err);\r\n    }\r\n\r\n    /**\r\n     * stops audio and clears the buffers\r\n     */\r\n    public stopAudio(cb?: () => void, err?: (error: string) => void): void {\r\n        if (this.audioContext !== null) {\r\n            this.samples = new Float32Array();\r\n            clearInterval(this.autoUpdateBufferTimer);\r\n            this.audioContext.close().then(() => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }, (error: string) => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n            this.audioContext = null;\r\n        }\r\n    }\r\n\r\n    private init(audioFormat: AudioStreamFormat): void {\r\n        this.audioFormat = audioFormat as AudioStreamFormatImpl;\r\n        this.samples = new Float32Array();\r\n    }\r\n\r\n    private ensureInitializedContext(): void {\r\n        if (this.audioContext === null) {\r\n            this.createAudioContext();\r\n            const timerPeriod = 200;\r\n            this.autoUpdateBufferTimer = setInterval(() => {\r\n                this.updateAudioBuffer();\r\n            }, timerPeriod);\r\n        }\r\n    }\r\n\r\n    private createAudioContext(): void {\r\n        // new ((window as any).AudioContext || (window as any).webkitAudioContext)();\r\n        this.audioContext = AudioStreamFormatImpl.getAudioContext();\r\n\r\n        // TODO: Various examples shows this gain node, it does not seem to be needed unless we plan\r\n        // to control the volume, not likely\r\n        this.gainNode = this.audioContext.createGain();\r\n        this.gainNode.gain.value = 1;\r\n        this.gainNode.connect(this.audioContext.destination);\r\n        this.startTime = this.audioContext.currentTime;\r\n    }\r\n\r\n    private formatAudioData(audioData: ArrayBuffer): Float32Array {\r\n        switch (this.audioFormat.bitsPerSample) {\r\n            case 8:\r\n                return this.formatArrayBuffer(new Int8Array(audioData), 128);\r\n            case 16:\r\n                return this.formatArrayBuffer(new Int16Array(audioData), 32768);\r\n            case 32:\r\n                return this.formatArrayBuffer(new Int32Array(audioData), 2147483648);\r\n            default:\r\n                throw new InvalidOperationError(\"Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time\");\r\n        }\r\n    }\r\n\r\n    private formatArrayBuffer(audioData: AudioDataTypedArray, maxValue: number): Float32Array {\r\n        const float32Data = new Float32Array(audioData.length);\r\n        for (let i = 0; i < audioData.length; i++) {\r\n            float32Data[i] = audioData[i] / maxValue;\r\n        }\r\n        return float32Data;\r\n    }\r\n\r\n    private updateAudioBuffer(): void {\r\n        if (this.samples.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const channelCount = this.audioFormat.channels;\r\n        const bufferSource = this.audioContext.createBufferSource();\r\n        const frameCount = this.samples.length / channelCount;\r\n        const audioBuffer = this.audioContext.createBuffer(channelCount, frameCount, this.audioFormat.samplesPerSec);\r\n\r\n        // TODO: Should we do the conversion in the pushAudioSample instead?\r\n        for (let channel = 0; channel < channelCount; channel++) {\r\n            // Fill in individual channel data\r\n            let channelOffset = channel;\r\n            const audioData = audioBuffer.getChannelData(channel);\r\n            for (let i = 0; i < this.samples.length; i++, channelOffset += channelCount) {\r\n                audioData[i] = this.samples[channelOffset];\r\n            }\r\n        }\r\n\r\n        if (this.startTime < this.audioContext.currentTime) {\r\n            this.startTime = this.audioContext.currentTime;\r\n        }\r\n\r\n        bufferSource.buffer = audioBuffer;\r\n        bufferSource.connect(this.gainNode);\r\n        bufferSource.start(this.startTime);\r\n\r\n        // Make sure we play the next sample after the current one.\r\n        this.startTime += audioBuffer.duration;\r\n\r\n        // Clear the samples for the next pushed data.\r\n        this.samples = new Float32Array();\r\n    }\r\n\r\n    private async playAudio(audioData: ArrayBuffer): Promise<void> {\r\n        if (this.audioContext === null) {\r\n            this.createAudioContext();\r\n        }\r\n        const source: AudioBufferSourceNode = this.audioContext.createBufferSource();\r\n        const destination: AudioDestinationNode = this.audioContext.destination;\r\n        await this.audioContext.decodeAudioData(audioData, (newBuffer: AudioBuffer): void => {\r\n            source.buffer = newBuffer;\r\n            source.connect(destination);\r\n            source.start(0);\r\n        });\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}