{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createTaskQueue;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _pDeferEs = _interopRequireDefault(require(\"p-defer-es5\"));\n\nfunction createTaskQueue() {\n  var queueWithCurrent = [];\n  var queue = {\n    cancelAll: function cancelAll() {\n      queueWithCurrent.forEach(function (_ref) {\n        var cancel = _ref.cancel;\n        return cancel();\n      });\n    },\n    push: function push(fn) {\n      var cancelDeferred = (0, _pDeferEs.default)();\n      var resultDeferred = (0, _pDeferEs.default)();\n      var entry = {\n        promise: resultDeferred.promise\n      };\n      var abort;\n\n      var cancel = entry.cancel = function () {\n        // Override the \"fn\" so we don't call the actual \"fn\" later.\n        // In this approach, we can reuse the logic inside \"start\" to handle post-cancellation.\n        fn = function fn() {\n          return {\n            result: Promise.reject(new Error('cancelled before start'))\n          };\n        }; // Abort the task if it is currently running.\n\n\n        abort && abort();\n        cancelDeferred.reject(new Error('cancelled in the midway'));\n      };\n\n      var start = /*#__PURE__*/function () {\n        var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n          var _fn, abortFn, result;\n\n          return _regenerator.default.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _fn = fn(), abortFn = _fn.abort, result = _fn.result;\n                  abort = abortFn;\n                  _context.prev = 2;\n                  _context.t0 = resultDeferred;\n                  _context.next = 6;\n                  return Promise.race([result, cancelDeferred.promise]);\n\n                case 6:\n                  _context.t1 = _context.sent;\n\n                  _context.t0.resolve.call(_context.t0, _context.t1);\n\n                  _context.next = 13;\n                  break;\n\n                case 10:\n                  _context.prev = 10;\n                  _context.t2 = _context[\"catch\"](2);\n                  resultDeferred.reject(_context.t2);\n\n                case 13:\n                  queueWithCurrent = queueWithCurrent.filter(function (e) {\n                    return e !== entry;\n                  });\n\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[2, 10]]);\n        }));\n\n        return function start() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      var lastEntry = queueWithCurrent[queueWithCurrent.length - 1];\n      var lastPromise = lastEntry && lastEntry.promise || Promise.resolve();\n      queueWithCurrent.push(entry); // After the last promise resolved/rejected, we will start this task.\n      // We will start even if the last promise rejected.\n\n      lastPromise.then(start, start);\n      return {\n        cancel: cancel,\n        result: resultDeferred.promise\n      };\n    }\n  };\n  Object.defineProperty(queue, 'length', {\n    get: function get() {\n      return queueWithCurrent.length;\n    }\n  });\n  return queue;\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AAEe,SAASA,eAAT,GAA2B;AACxC,MAAIC,gBAAgB,GAAG,EAAvB;AAEA,MAAMC,KAAK,GAAG;AACZC,aAAS,EAAE,qBAAM;AACfF,sBAAgB,CAACG,OAAjBH,CAAyB;AAAA,YAAGI,MAAH,QAAGA,MAAH;AAAA,eAAgBA,MAAM,EAAtB;AAAzB;AAFU;AAIZC,QAAI,EAAE,kBAAM;AACV,UAAMC,cAAc,GAAG,wBAAvB;AACA,UAAMC,cAAc,GAAG,wBAAvB;AACA,UAAMC,KAAK,GAAG;AAAEC,eAAO,EAAEF,cAAc,CAACE;AAA1B,OAAd;AACA,UAAIC,KAAJ;;AAEA,UAAMN,MAAM,GAAII,KAAK,CAACJ,MAANI,GAAe,YAAM;AACnC;AACA;AACAG,UAAE,GAAG;AAAA,iBAAO;AAAEC,kBAAM,EAAEC,OAAO,CAACC,MAARD,CAAe,IAAIE,KAAJ,CAAU,wBAAV,CAAfF;AAAV,WAAP;AAAL,UAHmC,CAKnC;;;AACAH,aAAK,IAAIA,KAAK,EAAdA;AACAJ,sBAAc,CAACQ,MAAfR,CAAsB,IAAIS,KAAJ,CAAU,yBAAV,CAAtBT;AAPF;;AAUA,UAAMU,KAAK;AAAA,4FAAG;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAAC,wBACuBN,EAAE,EADzB,EACGO,OADH,OACJR,KADI,EACYE,MADZ,OACYA,MADZ;AAGZF,uBAAK,GAAGQ,OAARR;AAHYS;AAAAA,gCAOVZ,cAPU;AAAAY;AAAA,yBAOmBN,OAAO,CAACO,IAARP,CAAa,CAACD,MAAD,EAASN,cAAc,CAACG,OAAxB,CAAbI,CAPnB;;AAAA;AAAAM;;AAAAA,8BAOKE,OAPL;;AAAAF;AAAA;;AAAA;AAAAA;AAAAA;AASVZ,gCAAc,CAACO,MAAfP;;AATU;AAYZP,kCAAgB,GAAGA,gBAAgB,CAACsB,MAAjBtB,CAAwB,aAAC;AAAA,2BAAIuB,CAAC,KAAKf,KAAV;AAAzB,oBAAnBR;;AAZY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAH;;AAAA,wBAALgB,KAAK;AAAA;AAAA;AAAA,SAAX;;AAeA,UAAMQ,SAAS,GAAGxB,gBAAgB,CAACA,gBAAgB,CAACyB,MAAjBzB,GAA0B,CAA3B,CAAlC;AACA,UAAM0B,WAAW,GAAIF,SAAS,IAAIA,SAAS,CAACf,OAAvBe,IAAmCX,OAAO,CAACQ,OAARR,EAAxD;AAEAb,sBAAgB,CAACK,IAAjBL,CAAsBQ,KAAtBR,EAlCU,CAoCV;AACA;;AACA0B,iBAAW,CAACC,IAAZD,CAAiBV,KAAjBU,EAAwBV,KAAxBU;AAEA,aAAO;AACLtB,cAAM,EAANA,MADK;AAELQ,cAAM,EAAEL,cAAc,CAACE;AAFlB,OAAP;AAID;AAhDW,GAAd;AAmDAmB,QAAM,CAACC,cAAPD,CAAsB3B,KAAtB2B,EAA6B,QAA7BA,EAAuC;AAAEE,OAAG,EAAE;AAAA,aAAM9B,gBAAgB,CAACyB,MAAvB;AAAA;AAAP,GAAvCG;AAEA,SAAO3B,KAAP;AACD","names":["createTaskQueue","queueWithCurrent","queue","cancelAll","forEach","cancel","push","cancelDeferred","resultDeferred","entry","promise","abort","fn","result","Promise","reject","Error","start","_fn","abortFn","_context","race","resolve","filter","e","lastEntry","length","lastPromise","then","Object","defineProperty","get"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-directlinespeech-sdk/lib/src/createTaskQueue.js"],"sourcesContent":["import createDeferred from 'p-defer-es5';\n\nexport default function createTaskQueue() {\n  let queueWithCurrent = [];\n\n  const queue = {\n    cancelAll: () => {\n      queueWithCurrent.forEach(({ cancel }) => cancel());\n    },\n    push: fn => {\n      const cancelDeferred = createDeferred();\n      const resultDeferred = createDeferred();\n      const entry = { promise: resultDeferred.promise };\n      let abort;\n\n      const cancel = (entry.cancel = () => {\n        // Override the \"fn\" so we don't call the actual \"fn\" later.\n        // In this approach, we can reuse the logic inside \"start\" to handle post-cancellation.\n        fn = () => ({ result: Promise.reject(new Error('cancelled before start')) });\n\n        // Abort the task if it is currently running.\n        abort && abort();\n        cancelDeferred.reject(new Error('cancelled in the midway'));\n      });\n\n      const start = async () => {\n        const { abort: abortFn, result } = fn();\n\n        abort = abortFn;\n\n        try {\n          // Either wait for the actual result, or the task is being cancelled.\n          resultDeferred.resolve(await Promise.race([result, cancelDeferred.promise]));\n        } catch (error) {\n          resultDeferred.reject(error);\n        }\n\n        queueWithCurrent = queueWithCurrent.filter(e => e !== entry);\n      };\n\n      const lastEntry = queueWithCurrent[queueWithCurrent.length - 1];\n      const lastPromise = (lastEntry && lastEntry.promise) || Promise.resolve();\n\n      queueWithCurrent.push(entry);\n\n      // After the last promise resolved/rejected, we will start this task.\n      // We will start even if the last promise rejected.\n      lastPromise.then(start, start);\n\n      return {\n        cancel,\n        result: resultDeferred.promise\n      };\n    }\n  };\n\n  Object.defineProperty(queue, 'length', { get: () => queueWithCurrent.length });\n\n  return queue;\n}\n"]},"metadata":{},"sourceType":"script"}