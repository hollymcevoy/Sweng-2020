{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.connectSendTextBox = void 0;\nexports.useTextBoxSubmit = useTextBoxSubmit;\nexports.useTextBoxValue = useTextBoxValue;\n\nvar _botframeworkWebchatApi = require(\"botframework-webchat-api\");\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _detectBrowser = require(\"../Utils/detectBrowser\");\n\nvar _AccessibleInputText = _interopRequireDefault(require(\"../Utils/AccessibleInputText\"));\n\nvar _AutoResizeTextArea = _interopRequireDefault(require(\"./AutoResizeTextArea\"));\n\nvar _connectToWebChat = _interopRequireDefault(require(\"../connectToWebChat\"));\n\nvar _navigableEvent = _interopRequireDefault(require(\"../Utils/TypeFocusSink/navigableEvent\"));\n\nvar _useFocus = _interopRequireDefault(require(\"../hooks/useFocus\"));\n\nvar _useRegisterFocusSendBox = _interopRequireDefault(require(\"../hooks/internal/useRegisterFocusSendBox\"));\n\nvar _useReplaceEmoticon = _interopRequireDefault(require(\"../hooks/internal/useReplaceEmoticon\"));\n\nvar _useScrollDown = _interopRequireDefault(require(\"../hooks/useScrollDown\"));\n\nvar _useScrollToEnd = _interopRequireDefault(require(\"../hooks/useScrollToEnd\"));\n\nvar _useScrollUp = _interopRequireDefault(require(\"../hooks/useScrollUp\"));\n\nvar _useStyleSet3 = _interopRequireDefault(require(\"../hooks/useStyleSet\"));\n\nvar _useStyleToEmotionObject = _interopRequireDefault(require(\"../hooks/internal/useStyleToEmotionObject\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar useDisabled = _botframeworkWebchatApi.hooks.useDisabled,\n    useLocalizer = _botframeworkWebchatApi.hooks.useLocalizer,\n    useSendBoxValue = _botframeworkWebchatApi.hooks.useSendBoxValue,\n    useStopDictate = _botframeworkWebchatApi.hooks.useStopDictate,\n    useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions,\n    useSubmitSendBox = _botframeworkWebchatApi.hooks.useSubmitSendBox;\nvar ROOT_STYLE = {\n  '&.webchat__send-box-text-box': {\n    display: 'flex',\n    '& .webchat__send-box-text-box__input, & .webchat__send-box-text-box__text-area': {\n      flex: 1\n    }\n  }\n};\n\nvar connectSendTextBox = function connectSendTextBox() {\n  for (var _len = arguments.length, selectors = new Array(_len), _key = 0; _key < _len; _key++) {\n    selectors[_key] = arguments[_key];\n  }\n\n  return _connectToWebChat.default.apply(void 0, [function (_ref) {\n    var disabled = _ref.disabled,\n        focusSendBox = _ref.focusSendBox,\n        language = _ref.language,\n        scrollToEnd = _ref.scrollToEnd,\n        sendBoxValue = _ref.sendBoxValue,\n        setSendBox = _ref.setSendBox,\n        stopDictate = _ref.stopDictate,\n        submitSendBox = _ref.submitSendBox;\n    return {\n      disabled: disabled,\n      language: language,\n      onChange: function onChange(_ref2) {\n        var value = _ref2.target.value;\n        setSendBox(value);\n        stopDictate();\n      },\n      onKeyPress: function onKeyPress(event) {\n        var key = event.key,\n            shiftKey = event.shiftKey;\n\n        if (key === 'Enter' && !shiftKey) {\n          event.preventDefault();\n\n          if (sendBoxValue) {\n            scrollToEnd();\n            submitSendBox();\n            focusSendBox();\n          }\n        }\n      },\n      onSubmit: function onSubmit(event) {\n        event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING\n        // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box\n\n        if (sendBoxValue) {\n          scrollToEnd();\n          submitSendBox();\n        }\n      },\n      value: sendBoxValue\n    };\n  }].concat(selectors));\n};\n\nexports.connectSendTextBox = connectSendTextBox;\n\nfunction useTextBoxSubmit() {\n  var _useSendBoxValue = useSendBoxValue(),\n      _useSendBoxValue2 = _slicedToArray(_useSendBoxValue, 1),\n      sendBoxValue = _useSendBoxValue2[0];\n\n  var focus = (0, _useFocus.default)();\n  var scrollToEnd = (0, _useScrollToEnd.default)();\n  var submitSendBox = useSubmitSendBox();\n  return (0, _react.useCallback)(function (setFocus) {\n    if (sendBoxValue) {\n      scrollToEnd();\n      submitSendBox();\n\n      if (setFocus) {\n        if (setFocus === true) {\n          console.warn(\"\\\"botframework-webchat: Passing \\\"true\\\" to \\\"useTextBoxSubmit\\\" is deprecated and will be removed on or after 2022-04-23. Please pass \\\"sendBox\\\" instead.\\\"\");\n          focus('sendBox');\n        } else {\n          focus(setFocus);\n        }\n      }\n    }\n\n    return !!sendBoxValue;\n  }, [focus, scrollToEnd, sendBoxValue, submitSendBox]);\n}\n\nfunction useTextBoxValue() {\n  var _useSendBoxValue3 = useSendBoxValue(),\n      _useSendBoxValue4 = _slicedToArray(_useSendBoxValue3, 2),\n      value = _useSendBoxValue4[0],\n      setValue = _useSendBoxValue4[1];\n\n  var replaceEmoticon = (0, _useReplaceEmoticon.default)();\n  var stopDictate = useStopDictate();\n  var setter = (0, _react.useCallback)(function (nextValue) {\n    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        selectionEnd = _ref3.selectionEnd,\n        selectionStart = _ref3.selectionStart;\n\n    if (typeof nextValue !== 'string') {\n      throw new Error('botframework-webchat: First argument passed to useTextBoxValue() must be a string.');\n    } // Currently, we cannot detect whether the change is due to clipboard paste or pressing a key on the keyboard.\n    // We should not change to emoji when the user is pasting text.\n    // We would assume, for a single character addition, the user must be pressing a key.\n\n\n    if (nextValue.length === value.length + 1) {\n      var _replaceEmoticon = replaceEmoticon({\n        selectionEnd: selectionEnd,\n        selectionStart: selectionStart,\n        value: nextValue\n      }),\n          nextSelectionEnd = _replaceEmoticon.selectionEnd,\n          nextSelectionStart = _replaceEmoticon.selectionStart,\n          nextValueWithEmoji = _replaceEmoticon.value;\n\n      selectionEnd = nextSelectionEnd;\n      selectionStart = nextSelectionStart;\n      nextValue = nextValueWithEmoji;\n    }\n\n    setValue(nextValue);\n    stopDictate();\n    return {\n      selectionEnd: selectionEnd,\n      selectionStart: selectionStart,\n      value: nextValue\n    };\n  }, [replaceEmoticon, setValue, stopDictate, value]);\n  return [value, setter];\n}\n\nvar PREVENT_DEFAULT_HANDLER = function PREVENT_DEFAULT_HANDLER(event) {\n  return event.preventDefault();\n};\n\nvar TextBox = function TextBox(_ref4) {\n  var className = _ref4.className;\n\n  var _useSendBoxValue5 = useSendBoxValue(),\n      _useSendBoxValue6 = _slicedToArray(_useSendBoxValue5, 2),\n      setSendBox = _useSendBoxValue6[1];\n\n  var _useStyleSet = (0, _useStyleSet3.default)(),\n      _useStyleSet2 = _slicedToArray(_useStyleSet, 1),\n      sendBoxTextBoxStyleSet = _useStyleSet2[0].sendBoxTextBox;\n\n  var _useStyleOptions = useStyleOptions(),\n      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),\n      sendBoxTextWrap = _useStyleOptions2[0].sendBoxTextWrap;\n\n  var _useDisabled = useDisabled(),\n      _useDisabled2 = _slicedToArray(_useDisabled, 1),\n      disabled = _useDisabled2[0];\n\n  var _useTextBoxValue = useTextBoxValue(),\n      _useTextBoxValue2 = _slicedToArray(_useTextBoxValue, 2),\n      textBoxValue = _useTextBoxValue2[0],\n      setTextBoxValue = _useTextBoxValue2[1];\n\n  var inputElementRef = (0, _react.useRef)();\n  var localize = useLocalizer();\n  var placeCheckpointOnChangeRef = (0, _react.useRef)(false);\n  var prevInputStateRef = (0, _react.useRef)();\n  var rootClassName = (0, _useStyleToEmotionObject.default)()(ROOT_STYLE) + '';\n  var scrollDown = (0, _useScrollDown.default)();\n  var scrollUp = (0, _useScrollUp.default)();\n  var submitTextBox = useTextBoxSubmit();\n  var undoStackRef = (0, _react.useRef)([]);\n  var sendBoxString = localize('TEXT_INPUT_ALT');\n  var typeYourMessageString = localize('TEXT_INPUT_PLACEHOLDER');\n  var rememberInputState = (0, _react.useCallback)(function () {\n    var _inputElementRef$curr = inputElementRef.current,\n        selectionEnd = _inputElementRef$curr.selectionEnd,\n        selectionStart = _inputElementRef$curr.selectionStart,\n        value = _inputElementRef$curr.value;\n    prevInputStateRef.current = {\n      selectionEnd: selectionEnd,\n      selectionStart: selectionStart,\n      value: value\n    };\n  }, [inputElementRef, prevInputStateRef]); // This is for TypeFocusSink. When the focus in on the script, then starting press \"a\", without this line, it would cause errors.\n  // We call rememberInputState() when \"onFocus\" event is fired, but since this is from TypeFocusSink, we are not able to receive \"onFocus\" event before it happen.\n\n  (0, _react.useEffect)(rememberInputState, [rememberInputState]); // This is for moving the selection while setting the send box value.\n  // If we only use setSendBox, we will need to wait for the next render cycle to get the value in, before we can set selectionEnd/Start.\n\n  var setSelectionRangeAndValue = (0, _react.useCallback)(function (_ref5) {\n    var selectionEnd = _ref5.selectionEnd,\n        selectionStart = _ref5.selectionStart,\n        value = _ref5.value;\n\n    if (inputElementRef.current) {\n      // We need to set the value, before selectionStart/selectionEnd.\n      inputElementRef.current.value = value;\n      inputElementRef.current.selectionStart = selectionStart;\n      inputElementRef.current.selectionEnd = selectionEnd;\n    }\n\n    setSendBox(value);\n  }, [inputElementRef, setSendBox]);\n  var handleChange = (0, _react.useCallback)(function (event) {\n    var _event$target = event.target,\n        selectionEnd = _event$target.selectionEnd,\n        selectionStart = _event$target.selectionStart,\n        value = _event$target.value;\n\n    if (placeCheckpointOnChangeRef.current) {\n      undoStackRef.current.push(_objectSpread({}, prevInputStateRef.current));\n      placeCheckpointOnChangeRef.current = false;\n    }\n\n    var nextInputState = setTextBoxValue(value, {\n      selectionEnd: selectionEnd,\n      selectionStart: selectionStart\n    }); // If an emoticon is converted to emoji, place another checkpoint.\n\n    if (nextInputState.value !== value) {\n      undoStackRef.current.push({\n        selectionEnd: selectionEnd,\n        selectionStart: selectionStart,\n        value: value\n      });\n      placeCheckpointOnChangeRef.current = true;\n      setSelectionRangeAndValue(nextInputState);\n    }\n  }, [placeCheckpointOnChangeRef, prevInputStateRef, setSelectionRangeAndValue, setTextBoxValue, undoStackRef]);\n  var handleFocus = (0, _react.useCallback)(function () {\n    rememberInputState();\n    placeCheckpointOnChangeRef.current = true;\n  }, [placeCheckpointOnChangeRef, rememberInputState]);\n  var handleKeyDown = (0, _react.useCallback)(function (event) {\n    var ctrlKey = event.ctrlKey,\n        key = event.key,\n        metaKey = event.metaKey;\n\n    if ((ctrlKey || metaKey) && (key === 'Z' || key === 'z')) {\n      event.preventDefault();\n      var poppedInputState = undoStackRef.current.pop();\n\n      if (poppedInputState) {\n        prevInputStateRef.current = _objectSpread({}, poppedInputState);\n      } else {\n        prevInputStateRef.current = {\n          selectionEnd: 0,\n          selectionStart: 0,\n          value: ''\n        };\n      }\n\n      setSelectionRangeAndValue(prevInputStateRef.current);\n    }\n  }, [prevInputStateRef, setSelectionRangeAndValue, undoStackRef]);\n  var handleKeyPress = (0, _react.useCallback)(function (event) {\n    var key = event.key,\n        shiftKey = event.shiftKey;\n\n    if (key === 'Enter' && !shiftKey) {\n      event.preventDefault(); // If text box is submitted, focus on the send box\n\n      submitTextBox('sendBox'); // After submit, we will clear the undo stack.\n\n      undoStackRef.current = [];\n    }\n  }, [submitTextBox, undoStackRef]);\n  var handleSelect = (0, _react.useCallback)(function (_ref6) {\n    var _ref6$target = _ref6.target,\n        selectionEnd = _ref6$target.selectionEnd,\n        selectionStart = _ref6$target.selectionStart,\n        value = _ref6$target.value;\n\n    if (value === prevInputStateRef.current.value) {\n      // When caret move, we should push to undo stack on change.\n      placeCheckpointOnChangeRef.current = true;\n    }\n\n    prevInputStateRef.current = {\n      selectionEnd: selectionEnd,\n      selectionStart: selectionStart,\n      value: value\n    };\n  }, [placeCheckpointOnChangeRef, prevInputStateRef]);\n  var handleSubmit = (0, _react.useCallback)(function (event) {\n    event.preventDefault(); // Consider clearing the send box only after we received POST_ACTIVITY_PENDING\n    // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box\n\n    submitTextBox(); // After submit, we will clear the undo stack.\n\n    undoStackRef.current = [];\n  }, [submitTextBox, undoStackRef]);\n  var handleKeyDownCapture = (0, _react.useCallback)(function (event) {\n    var ctrlKey = event.ctrlKey,\n        metaKey = event.metaKey,\n        shiftKey = event.shiftKey;\n\n    if (ctrlKey || metaKey || shiftKey) {\n      return;\n    } // Navigable event means the end-user is focusing on an inputtable element, but it is okay to capture the arrow keys.\n\n\n    if ((0, _navigableEvent.default)(event)) {\n      var handled = true;\n\n      switch (event.key) {\n        case 'End':\n          scrollDown({\n            displacement: Infinity\n          });\n          break;\n\n        case 'Home':\n          scrollUp({\n            displacement: Infinity\n          });\n          break;\n\n        case 'PageDown':\n          scrollDown();\n          break;\n\n        case 'PageUp':\n          scrollUp();\n          break;\n\n        default:\n          handled = false;\n          break;\n      }\n\n      if (handled) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n  }, [scrollDown, scrollUp]);\n  var focusCallback = (0, _react.useCallback)(function () {\n    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        noKeyboard = _ref7.noKeyboard;\n\n    var current = inputElementRef.current;\n\n    if (current) {\n      // The \"disable soft keyboard on mobile devices\" logic will not work on IE11. It will cause the <input> to become read-only until next focus.\n      // Thus, no mobile devices carry IE11 so we don't need to explicitly disable soft keyboard on IE11.\n      // See #3757 for repro and details.\n      if (noKeyboard && !_detectBrowser.ie11) {\n        // To not activate the virtual keyboard while changing focus to an input, we will temporarily set it as read-only and flip it back.\n        // https://stackoverflow.com/questions/7610758/prevent-iphone-default-keyboard-when-focusing-an-input/7610923\n        var readOnly = current.getAttribute('readonly');\n        current.setAttribute('readonly', 'readonly');\n        setTimeout(function () {\n          var current = inputElementRef.current;\n\n          if (current) {\n            current.focus();\n            readOnly ? current.setAttribute('readonly', readOnly) : current.removeAttribute('readonly');\n          }\n        }, 0);\n      } else {\n        current.focus();\n      }\n    }\n  }, [inputElementRef]);\n  (0, _useRegisterFocusSendBox.default)(focusCallback);\n  return /*#__PURE__*/_react.default.createElement(\"form\", {\n    \"aria-disabled\": disabled,\n    className: (0, _classnames.default)('webchat__send-box-text-box', rootClassName, sendBoxTextBoxStyleSet + '', (className || '') + ''),\n    onSubmit: disabled ? PREVENT_DEFAULT_HANDLER : handleSubmit\n  }, !sendBoxTextWrap ? /*#__PURE__*/_react.default.createElement(_AccessibleInputText.default, {\n    \"aria-label\": sendBoxString,\n    className: \"webchat__send-box-text-box__input\",\n    \"data-id\": \"webchat-sendbox-input\",\n    disabled: disabled,\n    enterKeyHint: \"send\",\n    inputMode: \"text\",\n    onChange: disabled ? undefined : handleChange,\n    onFocus: disabled ? undefined : handleFocus,\n    onKeyDown: disabled ? undefined : handleKeyDown,\n    onKeyDownCapture: disabled ? undefined : handleKeyDownCapture,\n    onKeyPress: disabled ? undefined : handleKeyPress,\n    onSelect: disabled ? undefined : handleSelect,\n    placeholder: typeYourMessageString,\n    readOnly: disabled,\n    ref: inputElementRef,\n    type: \"text\",\n    value: textBoxValue\n  }) : /*#__PURE__*/_react.default.createElement(_AutoResizeTextArea.default, {\n    \"aria-label\": sendBoxString,\n    className: \"webchat__send-box-text-box__text-area\",\n    \"data-id\": \"webchat-sendbox-input\",\n    disabled: disabled,\n    enterKeyHint: \"send\",\n    inputMode: \"text\",\n    onChange: disabled ? undefined : handleChange,\n    onFocus: disabled ? undefined : handleFocus,\n    onKeyDown: disabled ? undefined : handleKeyDown,\n    onKeyDownCapture: disabled ? undefined : handleKeyDownCapture,\n    onKeyPress: disabled ? undefined : handleKeyPress,\n    onSelect: disabled ? undefined : handleSelect,\n    placeholder: typeYourMessageString,\n    readOnly: disabled,\n    ref: inputElementRef,\n    rows: 1,\n    textAreaClassName: \"webchat__send-box-text-box__html-text-area\",\n    value: textBoxValue\n  }), disabled && /*#__PURE__*/_react.default.createElement(\"div\", {\n    className: \"webchat__send-box-text-box__glass\"\n  }));\n};\n\nTextBox.defaultProps = {\n  className: ''\n};\nTextBox.propTypes = {\n  className: _propTypes.default.string\n};\nvar _default = TextBox;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["useDisabled","hooks","useLocalizer","useSendBoxValue","useStopDictate","useStyleOptions","useSubmitSendBox","ROOT_STYLE","display","flex","connectSendTextBox","selectors","arguments","connectToWebChat","disabled","focusSendBox","language","scrollToEnd","sendBoxValue","setSendBox","stopDictate","submitSendBox","onChange","value","target","onKeyPress","key","event","shiftKey","preventDefault","onSubmit","useTextBoxSubmit","focus","setFocus","console","warn","useTextBoxValue","setValue","replaceEmoticon","setter","nextValue","selectionEnd","selectionStart","Error","length","nextSelectionEnd","nextSelectionStart","nextValueWithEmoji","PREVENT_DEFAULT_HANDLER","TextBox","className","sendBoxTextBoxStyleSet","sendBoxTextBox","sendBoxTextWrap","textBoxValue","setTextBoxValue","inputElementRef","localize","placeCheckpointOnChangeRef","prevInputStateRef","rootClassName","scrollDown","scrollUp","submitTextBox","undoStackRef","sendBoxString","typeYourMessageString","rememberInputState","current","setSelectionRangeAndValue","handleChange","push","nextInputState","handleFocus","handleKeyDown","ctrlKey","metaKey","poppedInputState","pop","handleKeyPress","handleSelect","handleSubmit","handleKeyDownCapture","handled","displacement","Infinity","stopPropagation","focusCallback","noKeyboard","ie11","readOnly","getAttribute","setAttribute","setTimeout","removeAttribute","_react","_AccessibleInputText","enterKeyHint","inputMode","undefined","onFocus","onKeyDown","onKeyDownCapture","onSelect","placeholder","ref","type","_AutoResizeTextArea","rows","textAreaClassName","defaultProps","propTypes","PropTypes","string"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-component/lib/src/SendBox/TextBox.tsx"],"sourcesContent":["import { hooks } from 'botframework-webchat-api';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport React, { MutableRefObject, useCallback, useEffect, useRef } from 'react';\n\nimport { ie11 } from '../Utils/detectBrowser';\nimport AccessibleInputText from '../Utils/AccessibleInputText';\nimport AutoResizeTextArea from './AutoResizeTextArea';\nimport connectToWebChat from '../connectToWebChat';\nimport navigableEvent from '../Utils/TypeFocusSink/navigableEvent';\nimport useFocus from '../hooks/useFocus';\nimport useRegisterFocusSendBox from '../hooks/internal/useRegisterFocusSendBox';\nimport useReplaceEmoticon from '../hooks/internal/useReplaceEmoticon';\nimport useScrollDown from '../hooks/useScrollDown';\nimport useScrollToEnd from '../hooks/useScrollToEnd';\nimport useScrollUp from '../hooks/useScrollUp';\nimport useStyleSet from '../hooks/useStyleSet';\nimport useStyleToEmotionObject from '../hooks/internal/useStyleToEmotionObject';\n\nconst { useDisabled, useLocalizer, useSendBoxValue, useStopDictate, useStyleOptions, useSubmitSendBox } = hooks;\n\nconst ROOT_STYLE = {\n  '&.webchat__send-box-text-box': {\n    display: 'flex',\n\n    '& .webchat__send-box-text-box__input, & .webchat__send-box-text-box__text-area': {\n      flex: 1\n    }\n  }\n};\n\nconst connectSendTextBox = (...selectors) =>\n  connectToWebChat(\n    ({ disabled, focusSendBox, language, scrollToEnd, sendBoxValue, setSendBox, stopDictate, submitSendBox }) => ({\n      disabled,\n      language,\n      onChange: ({ target: { value } }) => {\n        setSendBox(value);\n        stopDictate();\n      },\n      onKeyPress: event => {\n        const { key, shiftKey } = event;\n\n        if (key === 'Enter' && !shiftKey) {\n          event.preventDefault();\n\n          if (sendBoxValue) {\n            scrollToEnd();\n            submitSendBox();\n            focusSendBox();\n          }\n        }\n      },\n      onSubmit: event => {\n        event.preventDefault();\n\n        // Consider clearing the send box only after we received POST_ACTIVITY_PENDING\n        // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box\n\n        if (sendBoxValue) {\n          scrollToEnd();\n          submitSendBox();\n        }\n      },\n      value: sendBoxValue\n    }),\n    ...selectors\n  );\n\nfunction useTextBoxSubmit(): (setFocus?: boolean | 'sendBox') => void {\n  const [sendBoxValue] = useSendBoxValue();\n  const focus = useFocus();\n  const scrollToEnd = useScrollToEnd();\n  const submitSendBox = useSubmitSendBox();\n\n  return useCallback(\n    setFocus => {\n      if (sendBoxValue) {\n        scrollToEnd();\n        submitSendBox();\n\n        if (setFocus) {\n          if (setFocus === true) {\n            console.warn(\n              `\"botframework-webchat: Passing \"true\" to \"useTextBoxSubmit\" is deprecated and will be removed on or after 2022-04-23. Please pass \"sendBox\" instead.\"`\n            );\n\n            focus('sendBox');\n          } else {\n            focus(setFocus);\n          }\n        }\n      }\n\n      return !!sendBoxValue;\n    },\n    [focus, scrollToEnd, sendBoxValue, submitSendBox]\n  );\n}\n\nfunction useTextBoxValue(): [\n  string,\n  (\n    textBoxValue: string,\n    options: { selectionEnd: number; selectionStart: number }\n  ) => { selectionEnd: number; selectionStart: number; value: string }\n] {\n  const [value, setValue] = useSendBoxValue();\n  const replaceEmoticon = useReplaceEmoticon();\n  const stopDictate = useStopDictate();\n\n  const setter = useCallback(\n    (nextValue, { selectionEnd, selectionStart } = {}) => {\n      if (typeof nextValue !== 'string') {\n        throw new Error('botframework-webchat: First argument passed to useTextBoxValue() must be a string.');\n      }\n\n      // Currently, we cannot detect whether the change is due to clipboard paste or pressing a key on the keyboard.\n      // We should not change to emoji when the user is pasting text.\n      // We would assume, for a single character addition, the user must be pressing a key.\n      if (nextValue.length === value.length + 1) {\n        const {\n          selectionEnd: nextSelectionEnd,\n          selectionStart: nextSelectionStart,\n          value: nextValueWithEmoji\n        } = replaceEmoticon({ selectionEnd, selectionStart, value: nextValue });\n\n        selectionEnd = nextSelectionEnd;\n        selectionStart = nextSelectionStart;\n        nextValue = nextValueWithEmoji;\n      }\n\n      setValue(nextValue);\n      stopDictate();\n\n      return {\n        selectionEnd,\n        selectionStart,\n        value: nextValue\n      };\n    },\n    [replaceEmoticon, setValue, stopDictate, value]\n  );\n\n  return [value, setter];\n}\n\nconst PREVENT_DEFAULT_HANDLER = event => event.preventDefault();\n\nconst TextBox = ({ className }) => {\n  const [, setSendBox] = useSendBoxValue();\n  const [{ sendBoxTextBox: sendBoxTextBoxStyleSet }] = useStyleSet();\n  const [{ sendBoxTextWrap }] = useStyleOptions();\n  const [disabled] = useDisabled();\n  const [textBoxValue, setTextBoxValue] = useTextBoxValue();\n  const inputElementRef: MutableRefObject<HTMLInputElement & HTMLTextAreaElement> = useRef();\n  const localize = useLocalizer();\n  const placeCheckpointOnChangeRef = useRef(false);\n  const prevInputStateRef: MutableRefObject<{\n    selectionEnd: number;\n    selectionStart: number;\n    value: string;\n  }> = useRef();\n  const rootClassName = useStyleToEmotionObject()(ROOT_STYLE) + '';\n  const scrollDown = useScrollDown();\n  const scrollUp = useScrollUp();\n  const submitTextBox = useTextBoxSubmit();\n  const undoStackRef = useRef([]);\n\n  const sendBoxString = localize('TEXT_INPUT_ALT');\n  const typeYourMessageString = localize('TEXT_INPUT_PLACEHOLDER');\n\n  const rememberInputState = useCallback(() => {\n    const {\n      current: { selectionEnd, selectionStart, value }\n    } = inputElementRef;\n\n    prevInputStateRef.current = { selectionEnd, selectionStart, value };\n  }, [inputElementRef, prevInputStateRef]);\n\n  // This is for TypeFocusSink. When the focus in on the script, then starting press \"a\", without this line, it would cause errors.\n  // We call rememberInputState() when \"onFocus\" event is fired, but since this is from TypeFocusSink, we are not able to receive \"onFocus\" event before it happen.\n  useEffect(rememberInputState, [rememberInputState]);\n\n  // This is for moving the selection while setting the send box value.\n  // If we only use setSendBox, we will need to wait for the next render cycle to get the value in, before we can set selectionEnd/Start.\n  const setSelectionRangeAndValue = useCallback(\n    ({ selectionEnd, selectionStart, value }) => {\n      if (inputElementRef.current) {\n        // We need to set the value, before selectionStart/selectionEnd.\n        inputElementRef.current.value = value;\n\n        inputElementRef.current.selectionStart = selectionStart;\n        inputElementRef.current.selectionEnd = selectionEnd;\n      }\n\n      setSendBox(value);\n    },\n    [inputElementRef, setSendBox]\n  );\n\n  const handleChange = useCallback(\n    event => {\n      const {\n        target: { selectionEnd, selectionStart, value }\n      } = event;\n\n      if (placeCheckpointOnChangeRef.current) {\n        undoStackRef.current.push({ ...prevInputStateRef.current });\n\n        placeCheckpointOnChangeRef.current = false;\n      }\n\n      const nextInputState = setTextBoxValue(value, { selectionEnd, selectionStart });\n\n      // If an emoticon is converted to emoji, place another checkpoint.\n      if (nextInputState.value !== value) {\n        undoStackRef.current.push({ selectionEnd, selectionStart, value });\n\n        placeCheckpointOnChangeRef.current = true;\n\n        setSelectionRangeAndValue(nextInputState);\n      }\n    },\n    [placeCheckpointOnChangeRef, prevInputStateRef, setSelectionRangeAndValue, setTextBoxValue, undoStackRef]\n  );\n\n  const handleFocus = useCallback(() => {\n    rememberInputState();\n\n    placeCheckpointOnChangeRef.current = true;\n  }, [placeCheckpointOnChangeRef, rememberInputState]);\n\n  const handleKeyDown = useCallback(\n    event => {\n      const { ctrlKey, key, metaKey } = event;\n\n      if ((ctrlKey || metaKey) && (key === 'Z' || key === 'z')) {\n        event.preventDefault();\n\n        const poppedInputState = undoStackRef.current.pop();\n\n        if (poppedInputState) {\n          prevInputStateRef.current = { ...poppedInputState };\n        } else {\n          prevInputStateRef.current = { selectionEnd: 0, selectionStart: 0, value: '' };\n        }\n\n        setSelectionRangeAndValue(prevInputStateRef.current);\n      }\n    },\n    [prevInputStateRef, setSelectionRangeAndValue, undoStackRef]\n  );\n\n  const handleKeyPress = useCallback(\n    event => {\n      const { key, shiftKey } = event;\n\n      if (key === 'Enter' && !shiftKey) {\n        event.preventDefault();\n\n        // If text box is submitted, focus on the send box\n        submitTextBox('sendBox');\n\n        // After submit, we will clear the undo stack.\n        undoStackRef.current = [];\n      }\n    },\n    [submitTextBox, undoStackRef]\n  );\n\n  const handleSelect = useCallback(\n    ({ target: { selectionEnd, selectionStart, value } }) => {\n      if (value === prevInputStateRef.current.value) {\n        // When caret move, we should push to undo stack on change.\n        placeCheckpointOnChangeRef.current = true;\n      }\n\n      prevInputStateRef.current = { selectionEnd, selectionStart, value };\n    },\n    [placeCheckpointOnChangeRef, prevInputStateRef]\n  );\n\n  const handleSubmit = useCallback(\n    event => {\n      event.preventDefault();\n\n      // Consider clearing the send box only after we received POST_ACTIVITY_PENDING\n      // E.g. if the connection is bad, sending the message essentially do nothing but just clearing the send box\n      submitTextBox();\n\n      // After submit, we will clear the undo stack.\n      undoStackRef.current = [];\n    },\n    [submitTextBox, undoStackRef]\n  );\n\n  const handleKeyDownCapture = useCallback(\n    event => {\n      const { ctrlKey, metaKey, shiftKey } = event;\n\n      if (ctrlKey || metaKey || shiftKey) {\n        return;\n      }\n\n      // Navigable event means the end-user is focusing on an inputtable element, but it is okay to capture the arrow keys.\n      if (navigableEvent(event)) {\n        let handled = true;\n\n        switch (event.key) {\n          case 'End':\n            scrollDown({ displacement: Infinity });\n            break;\n\n          case 'Home':\n            scrollUp({ displacement: Infinity });\n            break;\n\n          case 'PageDown':\n            scrollDown();\n            break;\n\n          case 'PageUp':\n            scrollUp();\n            break;\n\n          default:\n            handled = false;\n            break;\n        }\n\n        if (handled) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      }\n    },\n    [scrollDown, scrollUp]\n  );\n\n  const focusCallback = useCallback(\n    ({ noKeyboard } = {}) => {\n      const { current } = inputElementRef;\n\n      if (current) {\n        // The \"disable soft keyboard on mobile devices\" logic will not work on IE11. It will cause the <input> to become read-only until next focus.\n        // Thus, no mobile devices carry IE11 so we don't need to explicitly disable soft keyboard on IE11.\n        // See #3757 for repro and details.\n        if (noKeyboard && !ie11) {\n          // To not activate the virtual keyboard while changing focus to an input, we will temporarily set it as read-only and flip it back.\n          // https://stackoverflow.com/questions/7610758/prevent-iphone-default-keyboard-when-focusing-an-input/7610923\n          const readOnly = current.getAttribute('readonly');\n\n          current.setAttribute('readonly', 'readonly');\n\n          setTimeout(() => {\n            const { current } = inputElementRef;\n\n            if (current) {\n              current.focus();\n              readOnly ? current.setAttribute('readonly', readOnly) : current.removeAttribute('readonly');\n            }\n          }, 0);\n        } else {\n          current.focus();\n        }\n      }\n    },\n    [inputElementRef]\n  );\n\n  useRegisterFocusSendBox(focusCallback);\n\n  return (\n    <form\n      aria-disabled={disabled}\n      className={classNames(\n        'webchat__send-box-text-box',\n        rootClassName,\n        sendBoxTextBoxStyleSet + '',\n        (className || '') + ''\n      )}\n      onSubmit={disabled ? PREVENT_DEFAULT_HANDLER : handleSubmit}\n    >\n      {!sendBoxTextWrap ? (\n        <AccessibleInputText\n          aria-label={sendBoxString}\n          className=\"webchat__send-box-text-box__input\"\n          data-id=\"webchat-sendbox-input\"\n          disabled={disabled}\n          enterKeyHint=\"send\"\n          inputMode=\"text\"\n          onChange={disabled ? undefined : handleChange}\n          onFocus={disabled ? undefined : handleFocus}\n          onKeyDown={disabled ? undefined : handleKeyDown}\n          onKeyDownCapture={disabled ? undefined : handleKeyDownCapture}\n          onKeyPress={disabled ? undefined : handleKeyPress}\n          onSelect={disabled ? undefined : handleSelect}\n          placeholder={typeYourMessageString}\n          readOnly={disabled}\n          ref={inputElementRef}\n          type=\"text\"\n          value={textBoxValue}\n        />\n      ) : (\n        <AutoResizeTextArea\n          aria-label={sendBoxString}\n          className=\"webchat__send-box-text-box__text-area\"\n          data-id=\"webchat-sendbox-input\"\n          disabled={disabled}\n          enterKeyHint=\"send\"\n          inputMode=\"text\"\n          onChange={disabled ? undefined : handleChange}\n          onFocus={disabled ? undefined : handleFocus}\n          onKeyDown={disabled ? undefined : handleKeyDown}\n          onKeyDownCapture={disabled ? undefined : handleKeyDownCapture}\n          onKeyPress={disabled ? undefined : handleKeyPress}\n          onSelect={disabled ? undefined : handleSelect}\n          placeholder={typeYourMessageString}\n          readOnly={disabled}\n          ref={inputElementRef}\n          rows={1}\n          textAreaClassName=\"webchat__send-box-text-box__html-text-area\"\n          value={textBoxValue}\n        />\n      )}\n      {disabled && <div className=\"webchat__send-box-text-box__glass\" />}\n    </form>\n  );\n};\n\nTextBox.defaultProps = {\n  className: ''\n};\n\nTextBox.propTypes = {\n  className: PropTypes.string\n};\n\nexport default TextBox;\n\nexport { connectSendTextBox, useTextBoxSubmit, useTextBoxValue };\n"]},"metadata":{},"sourceType":"script"}