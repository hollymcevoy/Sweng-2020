{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConversationTranslator = exports.SpeechState = void 0;\n\nvar Exports_1 = require(\"../../common.speech/Exports\");\n\nvar Exports_2 = require(\"../../common/Exports\");\n\nvar Contracts_1 = require(\"../Contracts\");\n\nvar Exports_3 = require(\"../Exports\");\n\nvar Conversation_1 = require(\"./Conversation\");\n\nvar Exports_4 = require(\"./Exports\");\n\nvar SpeechState;\n\n(function (SpeechState) {\n  SpeechState[SpeechState[\"Inactive\"] = 0] = \"Inactive\";\n  SpeechState[SpeechState[\"Connecting\"] = 1] = \"Connecting\";\n  SpeechState[SpeechState[\"Connected\"] = 2] = \"Connected\";\n})(SpeechState = exports.SpeechState || (exports.SpeechState = {})); // tslint:disable:max-classes-per-file\n// child class of TranslationRecognizer meant only for use with ConversationTranslator\n\n\nvar ConversationTranslationRecognizer =\n/** @class */\nfunction (_super) {\n  __extends(ConversationTranslationRecognizer, _super);\n\n  function ConversationTranslationRecognizer(speechConfig, audioConfig, translator) {\n    var _this = _super.call(this, speechConfig, audioConfig) || this;\n\n    _this.privSpeechState = SpeechState.Inactive;\n\n    if (!!translator) {\n      _this.privTranslator = translator;\n\n      _this.sessionStarted = function () {\n        _this.privSpeechState = SpeechState.Connected;\n      };\n\n      _this.sessionStopped = function () {\n        _this.privSpeechState = SpeechState.Inactive;\n      };\n\n      _this.recognized = function (tr, e) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var _a;\n\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                if (!((_a = e.result) === null || _a === void 0 ? void 0 : _a.errorDetails)) return [3\n                /*break*/\n                , 2];\n                return [4\n                /*yield*/\n                , this.cancelSpeech()];\n\n              case 1:\n                _b.sent(); // TODO: format the error message contained in 'errorDetails'\n\n\n                this.fireCancelEvent(e.result.errorDetails);\n                _b.label = 2;\n\n              case 2:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      };\n\n      _this.canceled = function (r, e) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var error_1;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!(this.privSpeechState !== SpeechState.Inactive)) return [3\n                /*break*/\n                , 4];\n                _a.label = 1;\n\n              case 1:\n                _a.trys.push([1, 3,, 4]);\n\n                return [4\n                /*yield*/\n                , this.cancelSpeech()];\n\n              case 2:\n                _a.sent();\n\n                return [3\n                /*break*/\n                , 4];\n\n              case 3:\n                error_1 = _a.sent();\n                this.privSpeechState = SpeechState.Inactive;\n                return [3\n                /*break*/\n                , 4];\n\n              case 4:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      };\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(ConversationTranslationRecognizer.prototype, \"state\", {\n    get: function () {\n      return this.privSpeechState;\n    },\n    set: function (newState) {\n      this.privSpeechState = newState;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ConversationTranslationRecognizer.prototype.onConnection = function () {\n    this.privSpeechState = SpeechState.Connected;\n  };\n\n  ConversationTranslationRecognizer.prototype.onDisconnection = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.privSpeechState = SpeechState.Inactive;\n            return [4\n            /*yield*/\n            , this.cancelSpeech()];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Fire a cancel event\n   * @param error\n   */\n\n\n  ConversationTranslationRecognizer.prototype.fireCancelEvent = function (error) {\n    var _a, _b, _c;\n\n    try {\n      if (!!this.privTranslator.canceled) {\n        var cancelEvent = new Exports_4.ConversationTranslationCanceledEventArgs((_a = error === null || error === void 0 ? void 0 : error.reason) !== null && _a !== void 0 ? _a : Exports_3.CancellationReason.Error, (_b = error === null || error === void 0 ? void 0 : error.errorDetails) !== null && _b !== void 0 ? _b : error, (_c = error === null || error === void 0 ? void 0 : error.errorCode) !== null && _c !== void 0 ? _c : Exports_3.CancellationErrorCode.RuntimeError, undefined, error === null || error === void 0 ? void 0 : error.sessionId);\n        this.privTranslator.canceled(this.privTranslator, cancelEvent);\n      }\n    } catch (e) {//\n    }\n  };\n\n  ConversationTranslationRecognizer.prototype.cancelSpeech = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _b.trys.push([0, 2,, 3]);\n\n            this.stopContinuousRecognitionAsync();\n            return [4\n            /*yield*/\n            , (_a = this.privReco) === null || _a === void 0 ? void 0 : _a.disconnect()];\n\n          case 1:\n            _b.sent();\n\n            this.privSpeechState = SpeechState.Inactive;\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            e_1 = _b.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return ConversationTranslationRecognizer;\n}(Exports_3.TranslationRecognizer);\n/***\n * Join, leave or connect to a conversation.\n */\n\n\nvar ConversationTranslator =\n/** @class */\nfunction (_super) {\n  __extends(ConversationTranslator, _super);\n\n  function ConversationTranslator(audioConfig) {\n    var _this = _super.call(this, audioConfig) || this;\n\n    _this.privIsDisposed = false;\n    _this.privIsSpeaking = false;\n    _this.privErrors = Exports_1.ConversationConnectionConfig.restErrors;\n    _this.privPlaceholderKey = \"abcdefghijklmnopqrstuvwxyz012345\";\n    _this.privPlaceholderRegion = \"westus\";\n    _this.privProperties = new Exports_3.PropertyCollection();\n    return _this;\n  }\n\n  Object.defineProperty(ConversationTranslator.prototype, \"properties\", {\n    get: function () {\n      return this.privProperties;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ConversationTranslator.prototype, \"speechRecognitionLanguage\", {\n    get: function () {\n      return this.privSpeechRecognitionLanguage;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(ConversationTranslator.prototype, \"participants\", {\n    get: function () {\n      var _a;\n\n      return (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.participants;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ConversationTranslator.prototype.joinConversationAsync = function (conversation, nickname, param1, param2, param3) {\n    var _this = this;\n\n    try {\n      if (typeof conversation === \"string\") {\n        Contracts_1.Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n        Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n\n        if (!!this.privConversation) {\n          this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);\n        }\n\n        var lang = param1;\n\n        if (lang === undefined || lang === null || lang === \"\") {\n          lang = Exports_1.ConversationConnectionConfig.defaultLanguageCode;\n        } // create a placeholder config\n\n\n        this.privSpeechTranslationConfig = Exports_3.SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion);\n        this.privSpeechTranslationConfig.setProfanity(Exports_3.ProfanityOption.Masked);\n        this.privSpeechTranslationConfig.addTargetLanguage(lang);\n        this.privSpeechTranslationConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage], lang);\n        this.privSpeechTranslationConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.ConversationTranslator_Name], nickname);\n        var endpoint = this.privProperties.getProperty(Exports_3.PropertyId.ConversationTranslator_Host);\n\n        if (endpoint) {\n          this.privSpeechTranslationConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.ConversationTranslator_Host], endpoint);\n        }\n\n        var speechEndpointHost = this.privProperties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_Host);\n\n        if (speechEndpointHost) {\n          this.privSpeechTranslationConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_Host], speechEndpointHost);\n        } // join the conversation\n\n\n        this.privConversation = new Conversation_1.ConversationImpl(this.privSpeechTranslationConfig);\n        this.privConversation.conversationTranslator = this;\n        this.privConversation.joinConversationAsync(conversation, nickname, lang, function (result) {\n          if (!result) {\n            _this.handleError(new Error(_this.privErrors.permissionDeniedConnect), param3);\n          }\n\n          _this.privSpeechTranslationConfig.authorizationToken = result; // connect to the ws\n\n          _this.privConversation.startConversationAsync(function () {\n            _this.handleCallback(param2, param3);\n          }, function (error) {\n            _this.handleError(error, param3);\n          });\n        }, function (error) {\n          _this.handleError(error, param3);\n        });\n      } else if (typeof conversation === \"object\") {\n        Contracts_1.Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n        Contracts_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\")); // save the nickname\n\n        this.privProperties.setProperty(Exports_3.PropertyId.ConversationTranslator_Name, nickname); // ref the conversation object\n\n        this.privConversation = conversation; // ref the conversation translator object\n\n        this.privConversation.conversationTranslator = this;\n        Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);\n        Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n        this.privSpeechTranslationConfig = conversation.config;\n        this.handleCallback(param1, param2);\n      } else {\n        this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"invalid conversation type\")), param2);\n      }\n    } catch (error) {\n      this.handleError(error, typeof param1 === \"string\" ? param3 : param2);\n    }\n  };\n  /**\n   * Leave the conversation\n   * @param cb\n   * @param err\n   */\n\n\n  ConversationTranslator.prototype.leaveConversationAsync = function (cb, err) {\n    var _this = this;\n\n    Exports_2.marshalPromiseToCallbacks(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              // stop the speech websocket\n              return [4\n              /*yield*/\n              , this.cancelSpeech()];\n\n            case 1:\n              // stop the speech websocket\n              _a.sent(); // stop the websocket\n\n\n              return [4\n              /*yield*/\n              , this.privConversation.endConversationImplAsync()];\n\n            case 2:\n              // stop the websocket\n              _a.sent(); // https delete request\n\n\n              return [4\n              /*yield*/\n              , this.privConversation.deleteConversationImplAsync()];\n\n            case 3:\n              // https delete request\n              _a.sent();\n\n              this.dispose();\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }(), cb, err);\n  };\n  /**\n   * Send a text message\n   * @param message\n   * @param cb\n   * @param err\n   */\n\n\n  ConversationTranslator.prototype.sendTextMessageAsync = function (message, cb, err) {\n    var _a;\n\n    try {\n      Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n      Contracts_1.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", message));\n      (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.sendTextMessageAsync(message, cb, err);\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  };\n  /**\n   * Start speaking\n   * @param cb\n   * @param err\n   */\n\n\n  ConversationTranslator.prototype.startTranscribingAsync = function (cb, err) {\n    var _this = this;\n\n    Exports_2.marshalPromiseToCallbacks(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var error_2;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 4,, 6]);\n\n              Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n              Contracts_1.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n              if (!(this.privCTRecognizer === undefined)) return [3\n              /*break*/\n              , 2];\n              return [4\n              /*yield*/\n              , this.connectTranslatorRecognizer()];\n\n            case 1:\n              _a.sent();\n\n              _a.label = 2;\n\n            case 2:\n              Contracts_1.Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);\n\n              if (!this.canSpeak) {\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n              }\n\n              return [4\n              /*yield*/\n              , this.startContinuousRecognition()];\n\n            case 3:\n              _a.sent();\n\n              this.privIsSpeaking = true;\n              return [3\n              /*break*/\n              , 6];\n\n            case 4:\n              error_2 = _a.sent();\n              this.privIsSpeaking = false;\n              return [4\n              /*yield*/\n              , this.cancelSpeech()];\n\n            case 5:\n              _a.sent();\n\n              throw error_2;\n\n            case 6:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }(), cb, err);\n  };\n  /**\n   * Stop speaking\n   * @param cb\n   * @param err\n   */\n\n\n  ConversationTranslator.prototype.stopTranscribingAsync = function (cb, err) {\n    var _this = this;\n\n    Exports_2.marshalPromiseToCallbacks(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var error_3;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 4,, 6]);\n\n              if (!!this.privIsSpeaking) return [3\n              /*break*/\n              , 2]; // stop speech\n\n              return [4\n              /*yield*/\n              , this.cancelSpeech()];\n\n            case 1:\n              // stop speech\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n\n            case 2:\n              // stop the recognition but leave the websocket open\n              this.privIsSpeaking = false;\n              return [4\n              /*yield*/\n              , new Promise(function (resolve, reject) {\n                var _a;\n\n                (_a = _this.privCTRecognizer) === null || _a === void 0 ? void 0 : _a.stopContinuousRecognitionAsync(resolve, reject);\n              })];\n\n            case 3:\n              _a.sent();\n\n              return [3\n              /*break*/\n              , 6];\n\n            case 4:\n              error_3 = _a.sent();\n              return [4\n              /*yield*/\n              , this.cancelSpeech()];\n\n            case 5:\n              _a.sent();\n\n              return [3\n              /*break*/\n              , 6];\n\n            case 6:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }(), cb, err);\n  };\n\n  ConversationTranslator.prototype.isDisposed = function () {\n    return this.privIsDisposed;\n  };\n\n  ConversationTranslator.prototype.dispose = function (reason, success, err) {\n    var _this = this;\n\n    Exports_2.marshalPromiseToCallbacks(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, _b;\n\n        return __generator(this, function (_c) {\n          switch (_c.label) {\n            case 0:\n              if (this.isDisposed && !this.privIsSpeaking) {\n                return [2\n                /*return*/\n                ];\n              }\n\n              return [4\n              /*yield*/\n              , this.cancelSpeech()];\n\n            case 1:\n              _c.sent();\n\n              this.privIsDisposed = true;\n              (_a = this.privSpeechTranslationConfig) === null || _a === void 0 ? void 0 : _a.close();\n              this.privSpeechRecognitionLanguage = undefined;\n              this.privProperties = undefined;\n              this.privAudioConfig = undefined;\n              this.privSpeechTranslationConfig = undefined;\n              (_b = this.privConversation) === null || _b === void 0 ? void 0 : _b.dispose();\n              this.privConversation = undefined;\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }(), success, err);\n  };\n  /**\n   * Cancel the speech websocket\n   */\n\n\n  ConversationTranslator.prototype.cancelSpeech = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var e_2;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _b.trys.push([0, 2,, 3]);\n\n            this.privIsSpeaking = false;\n            return [4\n            /*yield*/\n            , (_a = this.privCTRecognizer) === null || _a === void 0 ? void 0 : _a.onDisconnection()];\n\n          case 1:\n            _b.sent();\n\n            this.privCTRecognizer = undefined;\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            e_2 = _b.sent();\n            return [3\n            /*break*/\n            , 3];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Connect to the speech translation recognizer.\n   * Currently there is no language validation performed before sending the SpeechLanguage code to the service.\n   * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'\n   * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'\n   * @param cb\n   * @param err\n   */\n\n\n  ConversationTranslator.prototype.connectTranslatorRecognizer = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var token, endpointHost, url, error_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 1,, 3]);\n\n            if (this.privAudioConfig === undefined) {\n              this.privAudioConfig = Exports_3.AudioConfig.fromDefaultMicrophoneInput();\n            } // clear the temp subscription key if it's a participant joining\n\n\n            if (this.privSpeechTranslationConfig.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey) {\n              this.privSpeechTranslationConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_Key], \"\");\n            }\n\n            token = encodeURIComponent(this.privConversation.room.token);\n            endpointHost = this.privSpeechTranslationConfig.getProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_Host], Exports_1.ConversationConnectionConfig.speechHost);\n            endpointHost = endpointHost.replace(\"{region}\", this.privConversation.room.cognitiveSpeechRegion);\n            url = \"wss://\" + endpointHost + Exports_1.ConversationConnectionConfig.speechPath + \"?\" + Exports_1.ConversationConnectionConfig.configParams.token + \"=\" + token;\n            this.privSpeechTranslationConfig.setProperty(Exports_3.PropertyId[Exports_3.PropertyId.SpeechServiceConnection_Endpoint], url);\n            this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this);\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            error_4 = _a.sent();\n            return [4\n            /*yield*/\n            , this.cancelSpeech()];\n\n          case 2:\n            _a.sent();\n\n            throw error_4;\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Handle the start speaking request\n   * @param cb\n   * @param err\n   */\n\n\n  ConversationTranslator.prototype.startContinuousRecognition = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      _this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);\n    });\n  };\n\n  Object.defineProperty(ConversationTranslator.prototype, \"canSpeak\", {\n    get: function () {\n      // is there a Conversation websocket available and has the Recognizer been set up\n      if (!this.privConversation.isConnected || !this.privCTRecognizer) {\n        return false;\n      } // is the user already speaking\n\n\n      if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) {\n        return false;\n      } // is the user muted\n\n\n      if (this.privConversation.isMutedByHost) {\n        return false;\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return ConversationTranslator;\n}(Exports_4.ConversationCommon);\n\nexports.ConversationTranslator = ConversationTranslator;","map":{"version":3,"mappings":"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","names":["SpeechState","exports","__extends","speechConfig","audioConfig","translator","_super","_this","privSpeechState","Inactive","privTranslator","sessionStarted","Connected","sessionStopped","recognized","tr","e","result","errorDetails","cancelSpeech","_b","fireCancelEvent","canceled","r","_a","Object","ConversationTranslationRecognizer","newState","error","cancelEvent","Exports_4","reason","Exports_3","Error","errorCode","_c","RuntimeError","undefined","sessionId","stopContinuousRecognitionAsync","privReco","disconnect","Exports_1","restErrors","privProperties","ConversationTranslator","privSpeechRecognitionLanguage","privConversation","participants","conversation","nickname","param1","param2","param3","Contracts_1","throwIfNullOrUndefined","privErrors","invalidArgs","replace","throwIfNullOrWhitespace","handleError","permissionDeniedStart","lang","defaultLanguageCode","privSpeechTranslationConfig","fromSubscription","privPlaceholderKey","privPlaceholderRegion","setProfanity","Masked","addTargetLanguage","setProperty","SpeechServiceConnection_RecoLanguage","ConversationTranslator_Name","endpoint","getProperty","ConversationTranslator_Host","speechEndpointHost","SpeechServiceConnection_Host","Conversation_1","conversationTranslator","joinConversationAsync","permissionDeniedConnect","authorizationToken","startConversationAsync","handleCallback","room","token","config","cb","err","Exports_2","endConversationImplAsync","deleteConversationImplAsync","dispose","message","permissionDeniedSend","sendTextMessageAsync","privCTRecognizer","connectTranslatorRecognizer","canSpeak","startContinuousRecognition","privIsSpeaking","error_2","Promise","resolve","reject","privIsDisposed","success","isDisposed","close","privAudioConfig","onDisconnection","fromDefaultMicrophoneInput","SpeechServiceConnection_Key","encodeURIComponent","endpointHost","speechHost","cognitiveSpeechRegion","url","speechPath","configParams","SpeechServiceConnection_Endpoint","error_4","startContinuousRecognitionAsync","isConnected","state","Connecting","isMutedByHost"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/src/sdk/Transcription/ConversationTranslator.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n// Multi-device Conversation is a Preview feature.\r\n\r\nimport { ConversationConnectionConfig } from \"../../common.speech/Exports\";\r\nimport {\r\n    IDisposable,\r\n    IErrorMessages,\r\n    marshalPromiseToCallbacks\r\n} from \"../../common/Exports\";\r\nimport { Contracts } from \"../Contracts\";\r\nimport {\r\n    AudioConfig,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ProfanityOption,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    SessionEventArgs,\r\n    SpeechTranslationConfig,\r\n    TranslationRecognitionCanceledEventArgs,\r\n    TranslationRecognitionEventArgs,\r\n    TranslationRecognizer\r\n} from \"../Exports\";\r\nimport { ConversationImpl } from \"./Conversation\";\r\nimport {\r\n    ConversationCommon,\r\n    ConversationExpirationEventArgs,\r\n    ConversationHandler,\r\n    ConversationParticipantsChangedEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationEventArgs,\r\n    IConversationTranslator,\r\n    Participant,\r\n} from \"./Exports\";\r\nimport { Callback, IConversation } from \"./IConversation\";\r\n\r\nexport enum SpeechState {\r\n    Inactive, Connecting, Connected\r\n}\r\n\r\n// tslint:disable:max-classes-per-file\r\n\r\n// child class of TranslationRecognizer meant only for use with ConversationTranslator\r\nclass ConversationTranslationRecognizer extends TranslationRecognizer {\r\n    private privTranslator: ConversationTranslator;\r\n    private privSpeechState: SpeechState;\r\n    public constructor(speechConfig: SpeechTranslationConfig, audioConfig?: AudioConfig, translator?: ConversationTranslator) {\r\n        super(speechConfig, audioConfig);\r\n        this.privSpeechState = SpeechState.Inactive;\r\n        if (!!translator) {\r\n            this.privTranslator = translator;\r\n            this.sessionStarted = () => {\r\n                this.privSpeechState = SpeechState.Connected;\r\n            };\r\n\r\n            this.sessionStopped = () => {\r\n                this.privSpeechState = SpeechState.Inactive;\r\n            };\r\n\r\n            this.recognized = async (tr: TranslationRecognizer, e: TranslationRecognitionEventArgs) => {\r\n                // TODO: add support for getting recognitions from here if own speech\r\n\r\n                // if there is an error connecting to the conversation service from the speech service the error will be returned in the ErrorDetails field.\r\n                if (e.result?.errorDetails) {\r\n                    await this.cancelSpeech();\r\n                    // TODO: format the error message contained in 'errorDetails'\r\n                    this.fireCancelEvent(e.result.errorDetails);\r\n                }\r\n            };\r\n\r\n            this.canceled = async (r: TranslationRecognizer, e: TranslationRecognitionCanceledEventArgs) => {\r\n                if (this.privSpeechState !== SpeechState.Inactive) {\r\n                    try {\r\n                        await this.cancelSpeech();\r\n                    } catch (error) {\r\n                        this.privSpeechState = SpeechState.Inactive;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    }\r\n    public get state(): SpeechState {\r\n        return this.privSpeechState;\r\n    }\r\n\r\n    public set state(newState: SpeechState) {\r\n        this.privSpeechState = newState;\r\n    }\r\n\r\n    public onConnection(): void {\r\n        this.privSpeechState = SpeechState.Connected;\r\n    }\r\n\r\n    public async onDisconnection(): Promise<void> {\r\n        this.privSpeechState = SpeechState.Inactive;\r\n        await this.cancelSpeech();\r\n    }\r\n\r\n    /**\r\n     * Fire a cancel event\r\n     * @param error\r\n     */\r\n    private fireCancelEvent(error: any): void {\r\n        try {\r\n            if (!!this.privTranslator.canceled) {\r\n                const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n                    error?.reason ?? CancellationReason.Error,\r\n                    error?.errorDetails ?? error,\r\n                    error?.errorCode ?? CancellationErrorCode.RuntimeError,\r\n                    undefined,\r\n                    error?.sessionId);\r\n\r\n                this.privTranslator.canceled(this.privTranslator, cancelEvent);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private async cancelSpeech(): Promise<void> {\r\n        try {\r\n            this.stopContinuousRecognitionAsync();\r\n            await this.privReco?.disconnect();\r\n            this.privSpeechState = SpeechState.Inactive;\r\n        } catch (e) {\r\n            // ignore the error\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/***\r\n * Join, leave or connect to a conversation.\r\n */\r\nexport class ConversationTranslator extends ConversationCommon implements IConversationTranslator, IDisposable {\r\n\r\n    private privSpeechRecognitionLanguage: string;\r\n    private privProperties: PropertyCollection;\r\n    private privIsDisposed: boolean = false;\r\n    private privCTRecognizer: ConversationTranslationRecognizer;\r\n    private privIsSpeaking: boolean = false;\r\n    private privConversation: ConversationImpl;\r\n    private privErrors: IErrorMessages = ConversationConnectionConfig.restErrors;\r\n    private privPlaceholderKey: string = \"abcdefghijklmnopqrstuvwxyz012345\";\r\n    private privPlaceholderRegion: string = \"westus\";\r\n\r\n    public constructor(audioConfig?: AudioConfig) {\r\n        super(audioConfig);\r\n        this.privProperties = new PropertyCollection();\r\n    }\r\n\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    public get speechRecognitionLanguage(): string {\r\n        return this.privSpeechRecognitionLanguage;\r\n    }\r\n\r\n    public get participants(): Participant[] {\r\n        return this.privConversation?.participants;\r\n    }\r\n\r\n    public canceled: (sender: ConversationHandler, event: ConversationTranslationCanceledEventArgs) => void;\r\n    public conversationExpiration: (sender: IConversationTranslator, event: ConversationExpirationEventArgs) => void;\r\n    public participantsChanged: (sender: IConversationTranslator, event: ConversationParticipantsChangedEventArgs) => void;\r\n    public sessionStarted: (sender: ConversationHandler, event: SessionEventArgs) => void;\r\n    public sessionStopped: (sender: ConversationHandler, event: SessionEventArgs) => void;\r\n    public textMessageReceived: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n    public transcribed: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n    public transcribing: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n\r\n    /**\r\n     * Join a conversation. If this is the host, pass in the previously created Conversation object.\r\n     * @param conversation\r\n     * @param nickname\r\n     * @param lang\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public joinConversationAsync(conversation: IConversation, nickname: string, cb?: Callback, err?: Callback): void;\r\n    public joinConversationAsync(conversationId: string, nickname: string, lang: string, cb?: Callback, err?: Callback): void;\r\n    public joinConversationAsync(conversation: any, nickname: string, param1?: string | Callback, param2?: Callback, param3?: Callback): void {\r\n\r\n        try {\r\n\r\n            if (typeof conversation === \"string\") {\r\n\r\n                Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\r\n                Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n\r\n                if (!!this.privConversation) {\r\n                    this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);\r\n                }\r\n\r\n                let lang: string = param1 as string;\r\n                if (lang === undefined || lang === null || lang === \"\") { lang = ConversationConnectionConfig.defaultLanguageCode; }\r\n\r\n                // create a placeholder config\r\n                this.privSpeechTranslationConfig = SpeechTranslationConfig.fromSubscription(\r\n                    this.privPlaceholderKey,\r\n                    this.privPlaceholderRegion);\r\n                this.privSpeechTranslationConfig.setProfanity(ProfanityOption.Masked);\r\n                this.privSpeechTranslationConfig.addTargetLanguage(lang);\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], lang);\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], nickname);\r\n\r\n                const endpoint: string = this.privProperties.getProperty(PropertyId.ConversationTranslator_Host);\r\n                if (endpoint) {\r\n                    this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Host], endpoint);\r\n                }\r\n                const speechEndpointHost: string = this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Host);\r\n                if (speechEndpointHost) {\r\n                    this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Host], speechEndpointHost);\r\n                }\r\n\r\n                // join the conversation\r\n                this.privConversation = new ConversationImpl(this.privSpeechTranslationConfig);\r\n                this.privConversation.conversationTranslator = this;\r\n\r\n                this.privConversation.joinConversationAsync(\r\n                    conversation,\r\n                    nickname,\r\n                    lang,\r\n                    ((result: string) => {\r\n\r\n                        if (!result) {\r\n                            this.handleError(new Error(this.privErrors.permissionDeniedConnect), param3);\r\n                        }\r\n\r\n                        this.privSpeechTranslationConfig.authorizationToken = result;\r\n\r\n                        // connect to the ws\r\n                        this.privConversation.startConversationAsync(\r\n                            (() => {\r\n                                this.handleCallback(param2, param3);\r\n                            }),\r\n                            ((error: any) => {\r\n                                this.handleError(error, param3);\r\n                            }));\r\n\r\n                    }),\r\n                    ((error: any) => {\r\n                        this.handleError(error, param3);\r\n                    }));\r\n\r\n            } else if (typeof conversation === \"object\") {\r\n\r\n                Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\r\n                Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n\r\n                // save the nickname\r\n                this.privProperties.setProperty(PropertyId.ConversationTranslator_Name, nickname);\r\n                // ref the conversation object\r\n                this.privConversation = conversation as ConversationImpl;\r\n                // ref the conversation translator object\r\n                this.privConversation.conversationTranslator = this;\r\n\r\n                Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);\r\n                Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\r\n\r\n                this.privSpeechTranslationConfig = conversation.config;\r\n\r\n                this.handleCallback(param1 as Callback, param2);\r\n            } else {\r\n                this.handleError(\r\n                    new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"invalid conversation type\")),\r\n                    param2);\r\n            }\r\n\r\n        } catch (error) {\r\n            this.handleError(error, typeof param1 === \"string\" ? param3 : param2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Leave the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public leaveConversationAsync(cb?: Callback, err?: Callback): void {\r\n\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n\r\n            // stop the speech websocket\r\n            await this.cancelSpeech();\r\n            // stop the websocket\r\n            await this.privConversation.endConversationImplAsync();\r\n            // https delete request\r\n            await this.privConversation.deleteConversationImplAsync();\r\n            this.dispose();\r\n\r\n        })(), cb, err);\r\n    }\r\n\r\n    /**\r\n     * Send a text message\r\n     * @param message\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public sendTextMessageAsync(message: string, cb?: Callback, err?: Callback): void {\r\n\r\n        try {\r\n            Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\r\n            Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", message));\r\n\r\n            this.privConversation?.sendTextMessageAsync(message, cb, err);\r\n        } catch (error) {\r\n\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start speaking\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public startTranscribingAsync(cb?: Callback, err?: Callback): void {\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n            try {\r\n                Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\r\n                Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\r\n\r\n                if (this.privCTRecognizer === undefined) {\r\n                    await this.connectTranslatorRecognizer();\r\n                }\r\n                Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);\r\n\r\n                if (!this.canSpeak) {\r\n                    this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n                }\r\n\r\n                await this.startContinuousRecognition();\r\n\r\n                this.privIsSpeaking = true;\r\n            } catch (error) {\r\n                this.privIsSpeaking = false;\r\n                await this.cancelSpeech();\r\n                throw error;\r\n            }\r\n        })(), cb, err);\r\n    }\r\n\r\n    /**\r\n     * Stop speaking\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public stopTranscribingAsync(cb?: Callback, err?: Callback): void {\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n            try {\r\n                if (!this.privIsSpeaking) {\r\n                    // stop speech\r\n                    await this.cancelSpeech();\r\n                    return;\r\n                }\r\n\r\n                // stop the recognition but leave the websocket open\r\n                this.privIsSpeaking = false;\r\n                await new Promise((resolve: () => void, reject: (error: string) => void): void => {\r\n                    this.privCTRecognizer?.stopContinuousRecognitionAsync(resolve, reject);\r\n                });\r\n\r\n            } catch (error) {\r\n                await this.cancelSpeech();\r\n            }\r\n        })(), cb, err);\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string, success?: () => void, err?: (error: string) => void): void {\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n            if (this.isDisposed && !this.privIsSpeaking) {\r\n                return;\r\n            }\r\n            await this.cancelSpeech();\r\n            this.privIsDisposed = true;\r\n            this.privSpeechTranslationConfig?.close();\r\n            this.privSpeechRecognitionLanguage = undefined;\r\n            this.privProperties = undefined;\r\n            this.privAudioConfig = undefined;\r\n            this.privSpeechTranslationConfig = undefined;\r\n            this.privConversation?.dispose();\r\n            this.privConversation = undefined;\r\n        })(), success, err);\r\n    }\r\n\r\n    /**\r\n     * Cancel the speech websocket\r\n     */\r\n    private async cancelSpeech(): Promise<void> {\r\n        try {\r\n            this.privIsSpeaking = false;\r\n            await this.privCTRecognizer?.onDisconnection();\r\n            this.privCTRecognizer = undefined;\r\n        } catch (e) {\r\n            // ignore the error\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect to the speech translation recognizer.\r\n     * Currently there is no language validation performed before sending the SpeechLanguage code to the service.\r\n     * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'\r\n     * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    private async connectTranslatorRecognizer(): Promise<void> {\r\n        try {\r\n\r\n            if (this.privAudioConfig === undefined) {\r\n                this.privAudioConfig = AudioConfig.fromDefaultMicrophoneInput();\r\n            }\r\n\r\n            // clear the temp subscription key if it's a participant joining\r\n            if (this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key])\r\n                === this.privPlaceholderKey) {\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Key], \"\");\r\n            }\r\n\r\n            // TODO\r\n            const token: string = encodeURIComponent(this.privConversation.room.token);\r\n\r\n            let endpointHost: string = this.privSpeechTranslationConfig.getProperty(\r\n                PropertyId[PropertyId.SpeechServiceConnection_Host], ConversationConnectionConfig.speechHost);\r\n            endpointHost = endpointHost.replace(\"{region}\", this.privConversation.room.cognitiveSpeechRegion);\r\n\r\n            const url: string = `wss://${endpointHost}${ConversationConnectionConfig.speechPath}?${ConversationConnectionConfig.configParams.token}=${token}`;\r\n\r\n            this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Endpoint], url);\r\n\r\n            this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this);\r\n        } catch (error) {\r\n            await this.cancelSpeech();\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the start speaking request\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    private startContinuousRecognition(): Promise<void> {\r\n        return new Promise((resolve: () => void, reject: (error: string) => void): void => {\r\n            this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);\r\n        });\r\n    }\r\n\r\n    private get canSpeak(): boolean {\r\n\r\n        // is there a Conversation websocket available and has the Recognizer been set up\r\n        if (!this.privConversation.isConnected || !this.privCTRecognizer) {\r\n            return false;\r\n        }\r\n\r\n        // is the user already speaking\r\n        if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) {\r\n            return false;\r\n        }\r\n\r\n        // is the user muted\r\n        if (this.privConversation.isMutedByHost) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"script"}