{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PcmRecorder = void 0;\n\nvar Exports_1 = require(\"../common/Exports\");\n\nvar PcmRecorder =\n/** @class */\nfunction () {\n  function PcmRecorder() {\n    var _this = this;\n\n    this.record = function (context, mediaStream, outputStream) {\n      var desiredSampleRate = 16000;\n\n      var scriptNode = function () {\n        var bufferSize = 0;\n\n        try {\n          return context.createScriptProcessor(bufferSize, 1, 1);\n        } catch (error) {\n          // Webkit (<= version 31) requires a valid bufferSize.\n          bufferSize = 2048;\n          var audioSampleRate = context.sampleRate;\n\n          while (bufferSize < 16384 && audioSampleRate >= 2 * desiredSampleRate) {\n            bufferSize <<= 1;\n            audioSampleRate >>= 1;\n          }\n\n          return context.createScriptProcessor(bufferSize, 1, 1);\n        }\n      }();\n\n      var waveStreamEncoder = new Exports_1.RiffPcmEncoder(context.sampleRate, desiredSampleRate);\n      var needHeader = true;\n      var that = _this;\n\n      scriptNode.onaudioprocess = function (event) {\n        var inputFrame = event.inputBuffer.getChannelData(0);\n\n        if (outputStream && !outputStream.isClosed) {\n          var waveFrame = waveStreamEncoder.encode(inputFrame);\n\n          if (!!waveFrame) {\n            outputStream.writeStreamChunk({\n              buffer: waveFrame,\n              isEnd: false,\n              timeReceived: Date.now()\n            });\n            needHeader = false;\n          }\n        }\n      };\n\n      var micInput = context.createMediaStreamSource(mediaStream); // https://webaudio.github.io/web-audio-api/#audioworklet\n      // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\n\n      if (!!_this.privSpeechProcessorScript && !!context.audioWorklet) {\n        context.audioWorklet.addModule(_this.privSpeechProcessorScript).then(function () {\n          var workletNode = new AudioWorkletNode(context, \"speech-processor\");\n\n          workletNode.port.onmessage = function (ev) {\n            var inputFrame = ev.data;\n\n            if (outputStream && !outputStream.isClosed) {\n              var waveFrame = waveStreamEncoder.encode(inputFrame);\n\n              if (!!waveFrame) {\n                outputStream.writeStreamChunk({\n                  buffer: waveFrame,\n                  isEnd: false,\n                  timeReceived: Date.now()\n                });\n                needHeader = false;\n              }\n            }\n          };\n\n          micInput.connect(workletNode);\n          workletNode.connect(context.destination);\n          _this.privMediaResources = {\n            scriptProcessorNode: workletNode,\n            source: micInput,\n            stream: mediaStream\n          };\n        }).catch(function () {\n          micInput.connect(scriptNode);\n          scriptNode.connect(context.destination);\n          _this.privMediaResources = {\n            scriptProcessorNode: scriptNode,\n            source: micInput,\n            stream: mediaStream\n          };\n        });\n      } else {\n        micInput.connect(scriptNode);\n        scriptNode.connect(context.destination);\n        _this.privMediaResources = {\n          scriptProcessorNode: scriptNode,\n          source: micInput,\n          stream: mediaStream\n        };\n      }\n    };\n\n    this.releaseMediaResources = function (context) {\n      if (_this.privMediaResources) {\n        if (_this.privMediaResources.scriptProcessorNode) {\n          _this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\n\n          _this.privMediaResources.scriptProcessorNode = null;\n        }\n\n        if (_this.privMediaResources.source) {\n          _this.privMediaResources.source.disconnect();\n\n          _this.privMediaResources.stream.getTracks().forEach(function (track) {\n            return track.stop();\n          });\n\n          _this.privMediaResources.source = null;\n        }\n      }\n    };\n  }\n\n  PcmRecorder.prototype.setWorkletUrl = function (url) {\n    this.privSpeechProcessorScript = url;\n  };\n\n  return PcmRecorder;\n}();\n\nexports.PcmRecorder = PcmRecorder;","map":{"version":3,"mappings":"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","names":["context","mediaStream","outputStream","desiredSampleRate","scriptNode","bufferSize","createScriptProcessor","error","audioSampleRate","sampleRate","waveStreamEncoder","Exports_1","needHeader","that","_this","onaudioprocess","event","inputFrame","inputBuffer","getChannelData","isClosed","waveFrame","encode","writeStreamChunk","buffer","isEnd","timeReceived","Date","now","micInput","createMediaStreamSource","privSpeechProcessorScript","audioWorklet","addModule","then","workletNode","AudioWorkletNode","port","onmessage","ev","data","connect","destination","privMediaResources","scriptProcessorNode","source","stream","catch","disconnect","getTracks","forEach","track","stop","PcmRecorder","url","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/src/common.browser/PCMRecorder.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { RiffPcmEncoder, Stream } from \"../common/Exports\";\r\nimport { IRecorder } from \"./IRecorder\";\r\n\r\nexport class PcmRecorder implements IRecorder {\r\n    private privMediaResources: IMediaResources;\r\n    private privSpeechProcessorScript: string; // speech-processor.js Url\r\n\r\n    public record = (context: AudioContext, mediaStream: MediaStream, outputStream: Stream<ArrayBuffer>): void => {\r\n        const desiredSampleRate = 16000;\r\n\r\n        const scriptNode = (() => {\r\n            let bufferSize = 0;\r\n            try {\r\n                return context.createScriptProcessor(bufferSize, 1, 1);\r\n            } catch (error) {\r\n                // Webkit (<= version 31) requires a valid bufferSize.\r\n                bufferSize = 2048;\r\n                let audioSampleRate = context.sampleRate;\r\n                while (bufferSize < 16384 && audioSampleRate >= (2 * desiredSampleRate)) {\r\n                    bufferSize <<= 1;\r\n                    audioSampleRate >>= 1;\r\n                }\r\n                return context.createScriptProcessor(bufferSize, 1, 1);\r\n            }\r\n        })();\r\n\r\n        const waveStreamEncoder = new RiffPcmEncoder(context.sampleRate, desiredSampleRate);\r\n        let needHeader: boolean = true;\r\n        const that = this;\r\n        scriptNode.onaudioprocess = (event: AudioProcessingEvent) => {\r\n            const inputFrame = event.inputBuffer.getChannelData(0);\r\n\r\n            if (outputStream && !outputStream.isClosed) {\r\n                const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                if (!!waveFrame) {\r\n                    outputStream.writeStreamChunk({\r\n                        buffer: waveFrame,\r\n                        isEnd: false,\r\n                        timeReceived: Date.now(),\r\n                    });\r\n                    needHeader = false;\r\n                }\r\n            }\r\n        };\r\n\r\n        const micInput = context.createMediaStreamSource(mediaStream);\r\n\r\n        // https://webaudio.github.io/web-audio-api/#audioworklet\r\n        // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\r\n\r\n        if (!!this.privSpeechProcessorScript && !!context.audioWorklet) {\r\n            context.audioWorklet\r\n                .addModule(this.privSpeechProcessorScript)\r\n                .then(() => {\r\n                    const workletNode = new AudioWorkletNode(context, \"speech-processor\");\r\n                    workletNode.port.onmessage = (ev: MessageEvent) => {\r\n                        const inputFrame: Float32Array = ev.data as Float32Array;\r\n\r\n                        if (outputStream && !outputStream.isClosed) {\r\n                            const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                            if (!!waveFrame) {\r\n                                outputStream.writeStreamChunk({\r\n                                    buffer: waveFrame,\r\n                                    isEnd: false,\r\n                                    timeReceived: Date.now(),\r\n                                });\r\n                                needHeader = false;\r\n                            }\r\n                        }\r\n                    };\r\n                    micInput.connect(workletNode);\r\n                    workletNode.connect(context.destination);\r\n                    this.privMediaResources = {\r\n                        scriptProcessorNode: workletNode,\r\n                        source: micInput,\r\n                        stream: mediaStream,\r\n                    };\r\n                })\r\n                .catch(() => {\r\n                    micInput.connect(scriptNode);\r\n                    scriptNode.connect(context.destination);\r\n                    this.privMediaResources = {\r\n                        scriptProcessorNode: scriptNode,\r\n                        source: micInput,\r\n                        stream: mediaStream,\r\n                    };\r\n                });\r\n        } else {\r\n            micInput.connect(scriptNode);\r\n            scriptNode.connect(context.destination);\r\n            this.privMediaResources = {\r\n                scriptProcessorNode: scriptNode,\r\n                source: micInput,\r\n                stream: mediaStream,\r\n            };\r\n        }\r\n    }\r\n\r\n    public releaseMediaResources = (context: AudioContext): void => {\r\n        if (this.privMediaResources) {\r\n            if (this.privMediaResources.scriptProcessorNode) {\r\n                this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\r\n                this.privMediaResources.scriptProcessorNode = null;\r\n            }\r\n            if (this.privMediaResources.source) {\r\n                this.privMediaResources.source.disconnect();\r\n                this.privMediaResources.stream.getTracks().forEach((track: any) => track.stop());\r\n                this.privMediaResources.source = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public setWorkletUrl(url: string): void {\r\n        this.privSpeechProcessorScript = url;\r\n    }\r\n}\r\n\r\ninterface IMediaResources {\r\n    source: MediaStreamAudioSourceNode;\r\n    scriptProcessorNode: ScriptProcessorNode | AudioWorkletNode;\r\n    stream: MediaStream;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}