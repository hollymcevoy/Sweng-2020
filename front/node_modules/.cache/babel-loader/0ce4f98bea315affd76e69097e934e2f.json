{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = fetchVoices;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _SpeechSynthesisVoice = _interopRequireDefault(require(\"./SpeechSynthesisVoice\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction fetchVoices(_x) {\n  return _fetchVoices.apply(this, arguments);\n}\n\nfunction _fetchVoices() {\n  _fetchVoices = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref) {\n    var authorizationToken, region, speechSynthesisHostname, subscriptionKey, hostname, res, voices;\n    return _regenerator.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            authorizationToken = _ref.authorizationToken, region = _ref.region, speechSynthesisHostname = _ref.speechSynthesisHostname, subscriptionKey = _ref.subscriptionKey; // Although encodeURI on a hostname doesn't work as expected for hostname, at least, it will fail peacefully.\n\n            hostname = speechSynthesisHostname || \"\".concat(encodeURI(region), \".tts.speech.microsoft.com\");\n            _context.next = 4;\n            return fetch(\"https://\".concat(hostname, \"/cognitiveservices/voices/list\"), {\n              headers: _objectSpread({\n                'content-type': 'application/json'\n              }, authorizationToken ? {\n                authorization: \"Bearer \".concat(authorizationToken)\n              } : {\n                'Ocp-Apim-Subscription-Key': subscriptionKey\n              })\n            });\n\n          case 4:\n            res = _context.sent;\n\n            if (res.ok) {\n              _context.next = 7;\n              break;\n            }\n\n            throw new Error('Failed to fetch voices');\n\n          case 7:\n            _context.next = 9;\n            return res.json();\n\n          case 9:\n            voices = _context.sent;\n            return _context.abrupt(\"return\", voices.map(function (_ref2) {\n              var gender = _ref2.Gender,\n                  lang = _ref2.Locale,\n                  voiceURI = _ref2.Name;\n              return new _SpeechSynthesisVoice.default({\n                gender: gender,\n                lang: lang,\n                voiceURI: voiceURI\n              });\n            }).sort(function (_ref3, _ref4) {\n              var x = _ref3.name;\n              var y = _ref4.name;\n              return x > y ? 1 : x < y ? -1 : 0;\n            }));\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _fetchVoices.apply(this, arguments);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAE8BA,Y;;;;;yFAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6BC,8BAA7B,QAA6BA,oBAAoBC,MAAjD,QAAiDA,MAApBD,EAA4BE,uBAAzD,QAAyDA,uBAA5BF,EAAqDG,eAAlF,QAAkFA,eAArDH,CAA7B,CACb;;AACMI,oBAFO,GAEIF,uBAAuB,cAAQG,SAAS,CAACJ,MAAD,CAAjB,8BAAlCG;AAFOE;AAAA,mBAGKC,KAAK,mBAAaH,QAAb,qCAAwD;AAC7EI,qBAAO;AACL,gCAAgB;AADX,iBAEDR,kBAAkB,GAClB;AACES,6BAAa,mBAAaT,kBAAb;AADf,eADkB,GAIlB;AACE,6CAA6BG;AAD/B,eANC;AADsE,aAAxD,CAHV;;AAAA;AAGPO,eAHO,gBAGPA;;AAHO,gBAgBRA,GAAG,CAACC,EAhBI;AAAAL;AAAA;AAAA;;AAAA,kBAiBL,IAAIM,KAAJ,CAAU,wBAAV,CAjBK;;AAAA;AAAAN;AAAA,mBAoBQI,GAAG,CAACG,IAAJH,EApBR;;AAAA;AAoBPI,kBApBO,gBAoBPA;AApBO,6CAsBNA,MAAM,CACVC,GADID,CACA;AAAA,kBAAWE,MAAX,SAAGC,MAAH;AAAA,kBAA2BC,IAA3B,SAAmBC,MAAnB;AAAA,kBAAuCC,QAAvC,SAAiCC,IAAjC;AAAA,qBAAsD,IAAIC,6BAAJ,CAAyB;AAAEN,sBAAM,EAANA,MAAF;AAAUE,oBAAI,EAAJA,IAAV;AAAgBE,wBAAQ,EAARA;AAAhB,eAAzB,CAAtD;AADA,eAEJG,IAFIT,CAEC;AAAA,kBAASU,CAAT,SAAGC,IAAH;AAAA,kBAAsBC,CAAtB,SAAgBD,IAAhB;AAAA,qBAA+BD,CAAC,GAAGE,CAAJF,GAAQ,CAARA,GAAYA,CAAC,GAAGE,CAAJF,GAAQ,CAAC,CAATA,GAAa,CAAxD;AAFD,cAtBM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","names":["fetchVoices","authorizationToken","region","speechSynthesisHostname","subscriptionKey","hostname","encodeURI","_context","fetch","headers","authorization","res","ok","Error","json","voices","map","gender","Gender","lang","Locale","voiceURI","Name","SpeechSynthesisVoice","sort","x","name","y"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/web-speech-cognitive-services/src/SpeechServices/TextToSpeech/fetchVoices.js"],"sourcesContent":["/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, -1] }] */\n\nimport SpeechSynthesisVoice from './SpeechSynthesisVoice';\n\nexport default async function fetchVoices({ authorizationToken, region, speechSynthesisHostname, subscriptionKey }) {\n  // Although encodeURI on a hostname doesn't work as expected for hostname, at least, it will fail peacefully.\n  const hostname = speechSynthesisHostname || `${ encodeURI(region) }.tts.speech.microsoft.com`;\n  const res = await fetch(`https://${ hostname }/cognitiveservices/voices/list`, {\n    headers: {\n      'content-type': 'application/json',\n      ...(authorizationToken\n        ? {\n            authorization: `Bearer ${ authorizationToken }`\n          }\n        : {\n            'Ocp-Apim-Subscription-Key': subscriptionKey\n          })\n    }\n  });\n\n  if (!res.ok) {\n    throw new Error('Failed to fetch voices');\n  }\n\n  const voices = await res.json();\n\n  return voices\n    .map(({ Gender: gender, Locale: lang, Name: voiceURI }) => new SpeechSynthesisVoice({ gender, lang, voiceURI }))\n    .sort(({ name: x }, { name: y }) => (x > y ? 1 : x < y ? -1 : 0));\n}\n"]},"metadata":{},"sourceType":"script"}