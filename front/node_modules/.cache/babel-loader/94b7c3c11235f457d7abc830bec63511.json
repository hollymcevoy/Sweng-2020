{"ast":null,"code":"import _slicedToArray from \"@babel/runtime-corejs3/helpers/slicedToArray\";\nimport _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";\nimport _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";\nimport _Object$entries from \"@babel/runtime-corejs3/core-js-stable/object/entries\";\n/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, 2, 3] }] */\n\nimport PropTypes from 'prop-types';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport Context from './Context';\nimport usePrevious from './usePrevious';\nimport useRefFrom from './useRefFrom';\nimport vendorPrefix from './vendorPrefix';\n\nfunction applyAll() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function () {\n    var _arguments = arguments,\n        _this = this; // eslint-disable-next-line no-invalid-this, prefer-rest-params\n\n\n    _forEachInstanceProperty(fns).call(fns, function (fn) {\n      return fn.apply(_this, _arguments);\n    });\n  };\n}\n\nfunction recognitionAbortable(recognition) {\n  return !!(recognition && typeof recognition.abort === 'function');\n}\n\nvar Composer = function Composer(_ref) {\n  var children = _ref.children,\n      extra = _ref.extra,\n      grammar = _ref.grammar,\n      lang = _ref.lang,\n      onDictate = _ref.onDictate,\n      onError = _ref.onError,\n      onProgress = _ref.onProgress,\n      onRawEvent = _ref.onRawEvent,\n      speechGrammarList = _ref.speechGrammarList,\n      speechRecognition = _ref.speechRecognition,\n      started = _ref.started;\n\n  var _useState = useState(0),\n      _useState2 = _slicedToArray(_useState, 2),\n      readyState = _useState2[0],\n      setReadyState = _useState2[1];\n\n  var emitDictateOnEndRef = useRef(false);\n  var extraRef = useRefFrom(extra);\n  var grammarRef = useRefFrom(grammar);\n  var langRef = useRefFrom(lang);\n  var notAllowedRef = useRef(false);\n  var onDictateRef = useRefFrom(onDictate);\n  var onErrorRef = useRefFrom(onError);\n  var onProgressRef = useRefFrom(onProgress);\n  var onRawEventRef = useRefFrom(onRawEvent);\n  var prevSpeechRecognition = usePrevious(speechRecognition);\n  var recognitionRef = useRef();\n  var speechGrammarListRef = useRefFrom(speechGrammarList);\n  var speechRecognitionRef = useRefFrom(speechRecognition); // If \"speechRecognition\" ponyfill changed, reset the \"notAllowed\" flag.\n\n  if (prevSpeechRecognition !== speechRecognition) {\n    notAllowedRef.current = false;\n  }\n\n  var handleAudioEnd = useCallback(function (_ref2) {\n    var target = _ref2.target;\n    return target === recognitionRef.current && setReadyState(3);\n  }, [recognitionRef, setReadyState]);\n  var handleAudioStart = useCallback(function (_ref3) {\n    var target = _ref3.target;\n\n    if (target !== recognitionRef.current) {\n      return;\n    }\n\n    setReadyState(2); // Web Speech API does not emit \"result\" when nothing is heard, and Chrome does not emit \"nomatch\" event.\n    // Because we emitted onProgress, we should emit \"dictate\" if not error, so they works in pair.\n\n    emitDictateOnEndRef.current = true;\n    onProgressRef.current && onProgressRef.current({\n      abortable: recognitionAbortable(target),\n      type: 'progress'\n    });\n  }, [emitDictateOnEndRef, onProgressRef, recognitionRef, setReadyState]);\n  var handleEnd = useCallback(function (_ref4) {\n    var target = _ref4.target;\n\n    if (target !== recognitionRef.current) {\n      return;\n    }\n\n    recognitionRef.current = undefined;\n    setReadyState(0);\n\n    if (emitDictateOnEndRef.current) {\n      onDictateRef.current && onDictateRef.current({\n        type: 'dictate'\n      });\n      emitDictateOnEndRef.current = false;\n    }\n  }, [emitDictateOnEndRef, onDictateRef, recognitionRef, setReadyState]);\n  var handleError = useCallback(function (event) {\n    if (event.target !== recognitionRef.current) {\n      return;\n    } // Error out, no need to emit \"dictate\"\n\n\n    emitDictateOnEndRef.current = false;\n    recognitionRef.current = undefined;\n\n    if (event.error === 'not-allowed') {\n      notAllowedRef.current = true;\n    }\n\n    setReadyState(0);\n    onErrorRef.current && onErrorRef.current(event);\n  }, [emitDictateOnEndRef, onErrorRef, notAllowedRef, recognitionRef, setReadyState]);\n  var handleRawEvent = useCallback(function (event) {\n    if (event.target !== recognitionRef.current) {\n      return;\n    }\n\n    onRawEventRef.current && onRawEventRef.current(event);\n  }, [onRawEventRef, recognitionRef]);\n  var handleResult = useCallback(function (_ref5) {\n    var rawResults = _ref5.results,\n        target = _ref5.target;\n\n    if (target !== recognitionRef.current) {\n      return;\n    }\n\n    if (rawResults.length) {\n      var results = _mapInstanceProperty([]).call(rawResults, function (alts) {\n        // Destructuring breaks Angular due to a bug in Zone.js.\n        // eslint-disable-next-line prefer-destructuring\n        var firstAlt = alts[0];\n        return {\n          confidence: firstAlt.confidence,\n          transcript: firstAlt.transcript\n        };\n      }); // Destructuring breaks Angular due to a bug in Zone.js.\n      // eslint-disable-next-line prefer-destructuring\n\n\n      var first = rawResults[0];\n\n      if (first.isFinal) {\n        // After \"onDictate\" callback, the caller should be able to set \"started\" to false on an unabortable recognition.\n        // TODO: Add test for fortification.\n        recognitionRef.current = undefined;\n        setReadyState(0);\n        onDictateRef.current && onDictateRef.current({\n          result: results[0],\n          type: 'dictate'\n        });\n      } else {\n        onProgressRef.current && onProgressRef.current({\n          abortable: recognitionAbortable(target),\n          results: results,\n          type: 'progress'\n        });\n      }\n    }\n  }, [onDictateRef, onProgressRef, recognitionRef, setReadyState]);\n  var handleStart = useCallback(function (_ref6) {\n    var target = _ref6.target;\n    return target === recognitionRef.current && setReadyState(1);\n  }, [recognitionRef, setReadyState]);\n  useEffect(function () {\n    if (started) {\n      var _context;\n\n      if (!speechRecognitionRef.current || notAllowedRef.current) {\n        throw new Error('Speech recognition is not supported');\n      }\n\n      var grammars = speechGrammarListRef.current && grammarRef.current && new speechGrammarListRef.current();\n      var recognition = recognitionRef.current = new speechRecognitionRef.current();\n\n      if (grammars) {\n        grammars.addFromString(grammarRef.current, 1);\n        recognition.grammars = grammars;\n      }\n\n      recognition.lang = langRef.current;\n      recognition.interimResults = true;\n      recognition.onaudioend = applyAll(handleAudioEnd, handleRawEvent);\n      recognition.onaudiostart = applyAll(handleAudioStart, handleRawEvent);\n      recognition.onend = applyAll(handleEnd, handleRawEvent);\n      recognition.onerror = applyAll(handleError, handleRawEvent);\n      recognition.onnomatch = handleRawEvent;\n      recognition.onresult = applyAll(handleResult, handleRawEvent);\n      recognition.onsoundend = handleRawEvent;\n      recognition.onsoundstart = handleRawEvent;\n      recognition.onspeechend = handleRawEvent;\n      recognition.onspeechstart = handleRawEvent;\n      recognition.onstart = applyAll(handleStart, handleRawEvent);\n      var _extra = extraRef.current;\n      _extra && _forEachInstanceProperty(_context = _Object$entries(_extra)).call(_context, function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            key = _ref8[0],\n            value = _ref8[1];\n\n        if (key !== 'constructor' && key !== 'prototype' && key !== '__proto__') {\n          recognition[key] = value;\n        }\n      });\n      recognition.start();\n    }\n\n    return function () {\n      var recognition = recognitionRef.current;\n\n      if (recognition) {\n        if (recognitionAbortable(recognition)) {\n          recognition.abort();\n        } else {\n          throw new Error('Failed to stop recognition while the current one is ongoing and is not abortable.');\n        }\n      }\n    };\n  }, [extraRef, grammarRef, handleAudioEnd, handleAudioStart, handleEnd, handleError, handleRawEvent, handleResult, handleStart, langRef, notAllowedRef, recognitionRef, speechGrammarListRef, speechRecognitionRef, started]);\n  var abortable = recognitionAbortable(recognitionRef.current) && readyState === 2;\n  var supported = !!speechRecognition && !notAllowedRef.current;\n  var context = useMemo(function () {\n    return {\n      abortable: abortable,\n      readyState: readyState,\n      supported: supported\n    };\n  }, [abortable, readyState, supported]);\n  return /*#__PURE__*/React.createElement(Context.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(Context.Consumer, null, function (context) {\n    return typeof children === 'function' ? children(context) : children;\n  }));\n};\n\nComposer.defaultProps = {\n  children: undefined,\n  extra: undefined,\n  grammar: undefined,\n  lang: undefined,\n  onDictate: undefined,\n  onError: undefined,\n  onProgress: undefined,\n  onRawEvent: undefined,\n  speechGrammarList: navigator.mediaDevices && navigator.mediaDevices.getUserMedia && vendorPrefix('SpeechGrammarList'),\n  speechRecognition: navigator.mediaDevices && navigator.mediaDevices.getUserMedia && vendorPrefix('SpeechRecognition'),\n  started: undefined\n};\nComposer.propTypes = {\n  children: PropTypes.any,\n  extra: PropTypes.any,\n  grammar: PropTypes.string,\n  lang: PropTypes.string,\n  onDictate: PropTypes.func,\n  onError: PropTypes.func,\n  onProgress: PropTypes.func,\n  onRawEvent: PropTypes.func,\n  speechGrammarList: PropTypes.any,\n  speechRecognition: PropTypes.any,\n  started: PropTypes.any\n};\nexport default Composer;","map":{"version":3,"mappings":"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","names":["PropTypes","React","useCallback","useEffect","useMemo","useRef","useState","Context","usePrevious","useRefFrom","vendorPrefix","applyAll","fns","arguments","_forEachInstanceProperty","call","fn","apply","_this","recognitionAbortable","recognition","abort","Composer","children","extra","grammar","lang","onDictate","onError","onProgress","onRawEvent","speechGrammarList","speechRecognition","started","readyState","setReadyState","emitDictateOnEndRef","extraRef","grammarRef","langRef","notAllowedRef","onDictateRef","onErrorRef","onProgressRef","onRawEventRef","prevSpeechRecognition","recognitionRef","speechGrammarListRef","speechRecognitionRef","current","handleAudioEnd","target","handleAudioStart","abortable","type","handleEnd","undefined","handleError","event","error","handleRawEvent","handleResult","rawResults","results","length","_mapInstanceProperty","firstAlt","alts","confidence","transcript","first","isFinal","result","handleStart","Error","grammars","addFromString","interimResults","onaudioend","onaudiostart","onend","onerror","onnomatch","onresult","onsoundend","onsoundstart","onspeechend","onspeechstart","onstart","key","value","start","supported","context","Provider","Consumer","defaultProps","navigator","mediaDevices","getUserMedia","propTypes","any","string","func"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/react-dictate-button/src/Composer.js"],"sourcesContent":["/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, 2, 3] }] */\n\nimport PropTypes from 'prop-types';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport Context from './Context';\nimport usePrevious from './usePrevious';\nimport useRefFrom from './useRefFrom';\nimport vendorPrefix from './vendorPrefix';\n\nfunction applyAll(...fns) {\n  return function () {\n    // eslint-disable-next-line no-invalid-this, prefer-rest-params\n    fns.forEach(fn => fn.apply(this, arguments));\n  };\n}\n\nfunction recognitionAbortable(recognition) {\n  return !!(recognition && typeof recognition.abort === 'function');\n}\n\nconst Composer = ({\n  children,\n  extra,\n  grammar,\n  lang,\n  onDictate,\n  onError,\n  onProgress,\n  onRawEvent,\n  speechGrammarList,\n  speechRecognition,\n  started\n}) => {\n  const [readyState, setReadyState] = useState(0);\n  const emitDictateOnEndRef = useRef(false);\n  const extraRef = useRefFrom(extra);\n  const grammarRef = useRefFrom(grammar);\n  const langRef = useRefFrom(lang);\n  const notAllowedRef = useRef(false);\n  const onDictateRef = useRefFrom(onDictate);\n  const onErrorRef = useRefFrom(onError);\n  const onProgressRef = useRefFrom(onProgress);\n  const onRawEventRef = useRefFrom(onRawEvent);\n  const prevSpeechRecognition = usePrevious(speechRecognition);\n  const recognitionRef = useRef();\n  const speechGrammarListRef = useRefFrom(speechGrammarList);\n  const speechRecognitionRef = useRefFrom(speechRecognition);\n\n  // If \"speechRecognition\" ponyfill changed, reset the \"notAllowed\" flag.\n  if (prevSpeechRecognition !== speechRecognition) {\n    notAllowedRef.current = false;\n  }\n\n  const handleAudioEnd = useCallback(\n    ({ target }) => target === recognitionRef.current && setReadyState(3),\n    [recognitionRef, setReadyState]\n  );\n\n  const handleAudioStart = useCallback(\n    ({ target }) => {\n      if (target !== recognitionRef.current) {\n        return;\n      }\n\n      setReadyState(2);\n\n      // Web Speech API does not emit \"result\" when nothing is heard, and Chrome does not emit \"nomatch\" event.\n      // Because we emitted onProgress, we should emit \"dictate\" if not error, so they works in pair.\n      emitDictateOnEndRef.current = true;\n      onProgressRef.current && onProgressRef.current({ abortable: recognitionAbortable(target), type: 'progress' });\n    },\n    [emitDictateOnEndRef, onProgressRef, recognitionRef, setReadyState]\n  );\n\n  const handleEnd = useCallback(\n    ({ target }) => {\n      if (target !== recognitionRef.current) {\n        return;\n      }\n\n      recognitionRef.current = undefined;\n      setReadyState(0);\n\n      if (emitDictateOnEndRef.current) {\n        onDictateRef.current && onDictateRef.current({ type: 'dictate' });\n        emitDictateOnEndRef.current = false;\n      }\n    },\n    [emitDictateOnEndRef, onDictateRef, recognitionRef, setReadyState]\n  );\n\n  const handleError = useCallback(\n    event => {\n      if (event.target !== recognitionRef.current) {\n        return;\n      }\n\n      // Error out, no need to emit \"dictate\"\n      emitDictateOnEndRef.current = false;\n      recognitionRef.current = undefined;\n\n      if (event.error === 'not-allowed') {\n        notAllowedRef.current = true;\n      }\n\n      setReadyState(0);\n\n      onErrorRef.current && onErrorRef.current(event);\n    },\n    [emitDictateOnEndRef, onErrorRef, notAllowedRef, recognitionRef, setReadyState]\n  );\n\n  const handleRawEvent = useCallback(\n    event => {\n      if (event.target !== recognitionRef.current) {\n        return;\n      }\n\n      onRawEventRef.current && onRawEventRef.current(event);\n    },\n    [onRawEventRef, recognitionRef]\n  );\n\n  const handleResult = useCallback(\n    ({ results: rawResults, target }) => {\n      if (target !== recognitionRef.current) {\n        return;\n      }\n\n      if (rawResults.length) {\n        const results = [].map.call(rawResults, alts => {\n          // Destructuring breaks Angular due to a bug in Zone.js.\n          // eslint-disable-next-line prefer-destructuring\n          const firstAlt = alts[0];\n\n          return {\n            confidence: firstAlt.confidence,\n            transcript: firstAlt.transcript\n          };\n        });\n\n        // Destructuring breaks Angular due to a bug in Zone.js.\n        // eslint-disable-next-line prefer-destructuring\n        const first = rawResults[0];\n\n        if (first.isFinal) {\n          // After \"onDictate\" callback, the caller should be able to set \"started\" to false on an unabortable recognition.\n          // TODO: Add test for fortification.\n          recognitionRef.current = undefined;\n          setReadyState(0);\n\n          onDictateRef.current && onDictateRef.current({ result: results[0], type: 'dictate' });\n        } else {\n          onProgressRef.current &&\n            onProgressRef.current({ abortable: recognitionAbortable(target), results, type: 'progress' });\n        }\n      }\n    },\n    [onDictateRef, onProgressRef, recognitionRef, setReadyState]\n  );\n\n  const handleStart = useCallback(\n    ({ target }) => target === recognitionRef.current && setReadyState(1),\n    [recognitionRef, setReadyState]\n  );\n\n  useEffect(() => {\n    if (started) {\n      if (!speechRecognitionRef.current || notAllowedRef.current) {\n        throw new Error('Speech recognition is not supported');\n      }\n\n      const grammars = speechGrammarListRef.current && grammarRef.current && new speechGrammarListRef.current();\n      const recognition = (recognitionRef.current = new speechRecognitionRef.current());\n\n      if (grammars) {\n        grammars.addFromString(grammarRef.current, 1);\n\n        recognition.grammars = grammars;\n      }\n\n      recognition.lang = langRef.current;\n      recognition.interimResults = true;\n      recognition.onaudioend = applyAll(handleAudioEnd, handleRawEvent);\n      recognition.onaudiostart = applyAll(handleAudioStart, handleRawEvent);\n      recognition.onend = applyAll(handleEnd, handleRawEvent);\n      recognition.onerror = applyAll(handleError, handleRawEvent);\n      recognition.onnomatch = handleRawEvent;\n      recognition.onresult = applyAll(handleResult, handleRawEvent);\n      recognition.onsoundend = handleRawEvent;\n      recognition.onsoundstart = handleRawEvent;\n      recognition.onspeechend = handleRawEvent;\n      recognition.onspeechstart = handleRawEvent;\n      recognition.onstart = applyAll(handleStart, handleRawEvent);\n\n      const { current: extra } = extraRef;\n\n      extra &&\n        Object.entries(extra).forEach(([key, value]) => {\n          if (key !== 'constructor' && key !== 'prototype' && key !== '__proto__') {\n            recognition[key] = value;\n          }\n        });\n\n      recognition.start();\n    }\n\n    return () => {\n      const { current: recognition } = recognitionRef;\n\n      if (recognition) {\n        if (recognitionAbortable(recognition)) {\n          recognition.abort();\n        } else {\n          throw new Error('Failed to stop recognition while the current one is ongoing and is not abortable.');\n        }\n      }\n    };\n  }, [\n    extraRef,\n    grammarRef,\n    handleAudioEnd,\n    handleAudioStart,\n    handleEnd,\n    handleError,\n    handleRawEvent,\n    handleResult,\n    handleStart,\n    langRef,\n    notAllowedRef,\n    recognitionRef,\n    speechGrammarListRef,\n    speechRecognitionRef,\n    started\n  ]);\n\n  const abortable = recognitionAbortable(recognitionRef.current) && readyState === 2;\n  const supported = !!speechRecognition && !notAllowedRef.current;\n\n  const context = useMemo(\n    () => ({\n      abortable,\n      readyState,\n      supported\n    }),\n    [abortable, readyState, supported]\n  );\n\n  return (\n    <Context.Provider value={context}>\n      <Context.Consumer>{context => (typeof children === 'function' ? children(context) : children)}</Context.Consumer>\n    </Context.Provider>\n  );\n};\n\nComposer.defaultProps = {\n  children: undefined,\n  extra: undefined,\n  grammar: undefined,\n  lang: undefined,\n  onDictate: undefined,\n  onError: undefined,\n  onProgress: undefined,\n  onRawEvent: undefined,\n  speechGrammarList: navigator.mediaDevices && navigator.mediaDevices.getUserMedia && vendorPrefix('SpeechGrammarList'),\n  speechRecognition: navigator.mediaDevices && navigator.mediaDevices.getUserMedia && vendorPrefix('SpeechRecognition'),\n  started: undefined\n};\n\nComposer.propTypes = {\n  children: PropTypes.any,\n  extra: PropTypes.any,\n  grammar: PropTypes.string,\n  lang: PropTypes.string,\n  onDictate: PropTypes.func,\n  onError: PropTypes.func,\n  onProgress: PropTypes.func,\n  onRawEvent: PropTypes.func,\n  speechGrammarList: PropTypes.any,\n  speechRecognition: PropTypes.any,\n  started: PropTypes.any\n};\n\nexport default Composer;\n"]},"metadata":{},"sourceType":"module"}