{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useReplaceEmoticon;\n\nvar _botframeworkWebchatApi = require(\"botframework-webchat-api\");\n\nvar _react = require(\"react\");\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar useStyleOptions = _botframeworkWebchatApi.hooks.useStyleOptions;\n\nfunction useReplaceEmoticon() {\n  var _useStyleOptions = useStyleOptions(),\n      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),\n      emojiSet = _useStyleOptions2[0].emojiSet;\n\n  return (0, _react.useCallback)( // We need to know where (in offset) the change is, then we can decide which emoticon to update.\n  // We need to distinguish in this case, string change from \"abc:)xyz\" to \"abc:))xyz\".\n  // If the caret position is after the first parenthesis, we will change it to \"abcðŸ˜Š)xyz\".\n  // But if the caret position is after the second parenthesis, we will not change it but leave it as \"abc:))xyz\".\n  // This is because the user already decided to undo the emoji and just added a parenthesis after the emoticon. It should not affect the emoticon.\n  function (_ref) {\n    var selectionEnd = _ref.selectionEnd,\n        selectionStart = _ref.selectionStart,\n        value = _ref.value;\n\n    if (typeof selectionEnd !== 'number') {\n      console.warn('botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"selectionEnd\" of type number, indicating the caret position.');\n    } else if (typeof selectionStart !== 'number') {\n      console.warn('botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"selectionStart\" of type number, indicating the caret position.');\n    } else if (typeof value !== 'string') {\n      console.warn('botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"value\" of type string.');\n    } // We only change when the user is not selecting anything.\n\n\n    selectionEnd === selectionStart && Object.entries(emojiSet).every(function (_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n          emoticon = _ref3[0],\n          emoji = _ref3[1];\n\n      var length = emoticon.length;\n\n      if (value.slice(selectionStart - length, selectionStart) === emoticon) {\n        value = \"\".concat(value.slice(0, selectionStart - length)).concat(emoji).concat(value.slice(selectionStart));\n        selectionEnd = selectionStart += emoji.length - length;\n        return false;\n      }\n\n      return true;\n    });\n    return {\n      selectionEnd: selectionEnd,\n      selectionStart: selectionStart,\n      value: value\n    };\n  }, [emojiSet]);\n}","map":{"version":3,"mappings":";;;;;;;AAEA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAQA,eAAR,GAA4BC,8BAApBD,eAAR;;AAEe,SAASE,kBAAT,GAA8B;AAC3C,yBAAuBF,eAAe,EAAtC;AAAA;AAAA,MAASG,QAAT,wBAASA,QAAT;;AAEA,SAAO,yBACL;AACA;AACA;AACA;AACA;AACA,kBAA6C;AAAA,QAA1CC,YAA0C,QAA1CA,YAA0C;AAAA,QAA5BC,cAA4B,QAA5BA,cAA4B;AAAA,QAAZC,KAAY,QAAZA,KAAY;;AAC3C,QAAI,OAAOF,YAAP,KAAwB,QAA5B,EAAsC;AACpCG,aAAO,CAACC,IAARD,CACE,qJADFA;AADF,WAIO,IAAI,OAAOF,cAAP,KAA0B,QAA9B,EAAwC;AAC7CE,aAAO,CAACC,IAARD,CACE,uJADFA;AADK,WAIA,IAAI,OAAOD,KAAP,KAAiB,QAArB,EAA+B;AACpCC,aAAO,CAACC,IAARD,CACE,+GADFA;AAVyC,MAe3C;;;AACAH,gBAAY,KAAKC,cAAjBD,IACEK,MAAM,CAACC,OAAPD,CAAeN,QAAfM,EAAyBE,KAAzBF,CAA+B,iBAAuB;AAAA;AAAA,UAArBG,QAAqB;AAAA,UAAXC,KAAW;;AACpD,UAAQC,MAAR,GAAmBF,QAAnB,CAAQE,MAAR;;AAEA,UAAIR,KAAK,CAACS,KAANT,CAAYD,cAAc,GAAGS,MAA7BR,EAAqCD,cAArCC,MAAyDM,QAA7D,EAAuE;AACrEN,aAAK,aAAMA,KAAK,CAACS,KAANT,CAAY,CAAZA,EAAeD,cAAc,GAAGS,MAAhCR,CAAN,SAAgDO,KAAhD,SAAwDP,KAAK,CAACS,KAANT,CAAYD,cAAZC,CAAxD,CAALA;AACAF,oBAAY,GAAGC,cAAc,IAAIQ,KAAK,CAACC,MAAND,GAAeC,MAAhDV;AAEA,eAAO,KAAP;AACD;;AAED,aAAO,IAAP;AAVF,MADFA;AAcA,WAAO;AAAEA,kBAAY,EAAZA,YAAF;AAAgBC,oBAAc,EAAdA,cAAhB;AAAgCC,WAAK,EAALA;AAAhC,KAAP;AApCG,KAsCL,CAACH,QAAD,CAtCK,CAAP;AAwCD","names":["useStyleOptions","hooks","useReplaceEmoticon","emojiSet","selectionEnd","selectionStart","value","console","warn","Object","entries","every","emoticon","emoji","length","slice"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-component/lib/src/hooks/internal/useReplaceEmoticon.js"],"sourcesContent":["/*eslint require-unicode-regexp: \"off\" */\n\nimport { hooks } from 'botframework-webchat-api';\nimport { useCallback } from 'react';\n\nconst { useStyleOptions } = hooks;\n\nexport default function useReplaceEmoticon() {\n  const [{ emojiSet }] = useStyleOptions();\n\n  return useCallback(\n    // We need to know where (in offset) the change is, then we can decide which emoticon to update.\n    // We need to distinguish in this case, string change from \"abc:)xyz\" to \"abc:))xyz\".\n    // If the caret position is after the first parenthesis, we will change it to \"abcðŸ˜Š)xyz\".\n    // But if the caret position is after the second parenthesis, we will not change it but leave it as \"abc:))xyz\".\n    // This is because the user already decided to undo the emoji and just added a parenthesis after the emoticon. It should not affect the emoticon.\n    ({ selectionEnd, selectionStart, value }) => {\n      if (typeof selectionEnd !== 'number') {\n        console.warn(\n          'botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"selectionEnd\" of type number, indicating the caret position.'\n        );\n      } else if (typeof selectionStart !== 'number') {\n        console.warn(\n          'botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"selectionStart\" of type number, indicating the caret position.'\n        );\n      } else if (typeof value !== 'string') {\n        console.warn(\n          'botframework-webchat: The first argument passed to \"useReplaceEmoticon\" must contains \"value\" of type string.'\n        );\n      }\n\n      // We only change when the user is not selecting anything.\n      selectionEnd === selectionStart &&\n        Object.entries(emojiSet).every(([emoticon, emoji]) => {\n          const { length } = emoticon;\n\n          if (value.slice(selectionStart - length, selectionStart) === emoticon) {\n            value = `${value.slice(0, selectionStart - length)}${emoji}${value.slice(selectionStart)}`;\n            selectionEnd = selectionStart += emoji.length - length;\n\n            return false;\n          }\n\n          return true;\n        });\n\n      return { selectionEnd, selectionStart, value };\n    },\n    [emojiSet]\n  );\n}\n"]},"metadata":{},"sourceType":"script"}