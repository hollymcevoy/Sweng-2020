{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/esnext.promise.try.js\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"DirectLineStreaming\", {\n  enumerable: true,\n  get: function get() {\n    return _directLineStreaming.DirectLineStreaming;\n  }\n});\nexports.DirectLine = exports.ConnectionStatus = void 0;\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nrequire(\"url-search-params-polyfill\");\n\nvar _BehaviorSubject = require(\"rxjs/BehaviorSubject\");\n\nvar _Observable = require(\"rxjs/Observable\");\n\nvar _async = require(\"rxjs/scheduler/async\");\n\nvar _jwtDecode = _interopRequireWildcard(require(\"jwt-decode\"));\n\nrequire(\"rxjs/add/operator/catch\");\n\nrequire(\"rxjs/add/operator/combineLatest\");\n\nrequire(\"rxjs/add/operator/count\");\n\nrequire(\"rxjs/add/operator/delay\");\n\nrequire(\"rxjs/add/operator/do\");\n\nrequire(\"rxjs/add/operator/filter\");\n\nrequire(\"rxjs/add/operator/map\");\n\nrequire(\"rxjs/add/operator/mergeMap\");\n\nrequire(\"rxjs/add/operator/concatMap\");\n\nrequire(\"rxjs/add/operator/retryWhen\");\n\nrequire(\"rxjs/add/operator/share\");\n\nrequire(\"rxjs/add/operator/take\");\n\nrequire(\"rxjs/add/observable/dom/ajax\");\n\nrequire(\"rxjs/add/observable/empty\");\n\nrequire(\"rxjs/add/observable/from\");\n\nrequire(\"rxjs/add/observable/interval\");\n\nrequire(\"rxjs/add/observable/of\");\n\nrequire(\"rxjs/add/observable/throw\");\n\nvar _dedupeFilenames = _interopRequireDefault(require(\"./dedupeFilenames\"));\n\nvar _directLineStreaming = require(\"./directLineStreaming\");\n\nvar _excluded = [\"contentUrl\"];\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar DIRECT_LINE_VERSION = 'DirectLine/3.0'; // These types are specific to this client library, not to Direct Line 3.0\n\nvar ConnectionStatus;\nexports.ConnectionStatus = ConnectionStatus;\n\n(function (ConnectionStatus) {\n  ConnectionStatus[ConnectionStatus[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  ConnectionStatus[ConnectionStatus[\"Connecting\"] = 1] = \"Connecting\";\n  ConnectionStatus[ConnectionStatus[\"Online\"] = 2] = \"Online\";\n  ConnectionStatus[ConnectionStatus[\"ExpiredToken\"] = 3] = \"ExpiredToken\";\n  ConnectionStatus[ConnectionStatus[\"FailedToConnect\"] = 4] = \"FailedToConnect\";\n  ConnectionStatus[ConnectionStatus[\"Ended\"] = 5] = \"Ended\";\n})(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));\n\nvar wrapAjaxWithRetry = function wrapAjaxWithRetry(source, scheduler) {\n  var notImplemented = function notImplemented() {\n    throw new Error('not implemented');\n  };\n\n  var inner = function inner(response$) {\n    return response$[\"catch\"](function (err) {\n      if (err.status === 429) {\n        var retryAfterValue = err.xhr.getResponseHeader('Retry-After');\n        var retryAfter = Number(retryAfterValue);\n\n        if (!isNaN(retryAfter)) {\n          return _Observable.Observable.timer(retryAfter, scheduler).flatMap(function (_) {\n            return _Observable.Observable[\"throw\"](err, scheduler);\n          });\n        }\n      }\n\n      return _Observable.Observable[\"throw\"](err, scheduler);\n    });\n  };\n\n  var outer = function outer(urlOrRequest) {\n    return inner(source(urlOrRequest));\n  };\n\n  return Object.assign(outer, {\n    get: function get(url, headers) {\n      return notImplemented();\n    },\n    post: function post(url, body, headers) {\n      return notImplemented();\n    },\n    put: function put(url, body, headers) {\n      return notImplemented();\n    },\n    patch: function patch(url, body, headers) {\n      return notImplemented();\n    },\n    \"delete\": function _delete(url, headers) {\n      return notImplemented();\n    },\n    getJSON: function getJSON(url, headers) {\n      return notImplemented();\n    }\n  });\n};\n\nvar makeServices = function makeServices(services) {\n  var scheduler = services.scheduler || _async.async;\n  return {\n    scheduler: scheduler,\n    ajax: wrapAjaxWithRetry(services.ajax || _Observable.Observable.ajax, scheduler),\n    WebSocket: services.WebSocket || WebSocket,\n    random: services.random || Math.random\n  };\n};\n\nvar lifetimeRefreshToken = 30 * 60 * 1000;\nvar intervalRefreshToken = lifetimeRefreshToken / 2;\nvar POLLING_INTERVAL_LOWER_BOUND = 200; //ms\n\nvar errorExpiredToken = new Error(\"expired token\");\nvar errorConversationEnded = new Error(\"conversation ended\");\nvar errorFailedToConnect = new Error(\"failed to connect\");\nvar konsole = {\n  log: function log(message) {\n    var _console;\n\n    for (var _len = arguments.length, optionalParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      optionalParams[_key - 1] = arguments[_key];\n    }\n\n    if (typeof window !== 'undefined' && window[\"botchatDebug\"] && message) (_console = console).log.apply(_console, [message].concat(optionalParams));\n  }\n};\n\nvar DirectLine = /*#__PURE__*/function () {\n  function DirectLine(options) {\n    (0, _classCallCheck2[\"default\"])(this, DirectLine);\n    (0, _defineProperty2[\"default\"])(this, \"connectionStatus$\", new _BehaviorSubject.BehaviorSubject(ConnectionStatus.Uninitialized));\n    (0, _defineProperty2[\"default\"])(this, \"domain\", \"https://directline.botframework.com/v3/directline\");\n    (0, _defineProperty2[\"default\"])(this, \"watermark\", '');\n    (0, _defineProperty2[\"default\"])(this, \"_botAgent\", '');\n    (0, _defineProperty2[\"default\"])(this, \"timeout\", 20 * 1000);\n    (0, _defineProperty2[\"default\"])(this, \"pollingInterval\", 1000);\n    this.secret = options.secret;\n    this.token = options.secret || options.token;\n    this.webSocket = (options.webSocket === undefined ? true : options.webSocket) && typeof WebSocket !== 'undefined' && WebSocket !== undefined;\n\n    if (options.conversationStartProperties && options.conversationStartProperties.locale) {\n      if (Object.prototype.toString.call(options.conversationStartProperties.locale) === '[object String]') {\n        this.localeOnStartConversation = options.conversationStartProperties.locale;\n      } else {\n        console.warn('DirectLineJS: conversationStartProperties.locale was ignored: the locale name may be a BCP 47 language tag');\n      }\n    }\n\n    if (options.domain) {\n      this.domain = options.domain;\n    }\n\n    if (options.conversationId) {\n      this.conversationId = options.conversationId;\n    }\n\n    if (options.watermark) {\n      this.watermark = options.watermark;\n    }\n\n    if (options.streamUrl) {\n      if (options.token && options.conversationId) {\n        this.streamUrl = options.streamUrl;\n      } else {\n        console.warn('DirectLineJS: streamUrl was ignored: you need to provide a token and a conversationid');\n      }\n    }\n\n    if (options.timeout !== undefined) {\n      this.timeout = options.timeout;\n    }\n\n    this.retries = (lifetimeRefreshToken - intervalRefreshToken) / this.timeout;\n    this._botAgent = this.getBotAgent(options.botAgent);\n    this.services = makeServices(options);\n    var parsedPollingInterval = ~~options.pollingInterval;\n\n    if (parsedPollingInterval < POLLING_INTERVAL_LOWER_BOUND) {\n      if (typeof options.pollingInterval !== 'undefined') {\n        console.warn(\"DirectLineJS: provided pollingInterval (\".concat(options.pollingInterval, \") is under lower bound (200ms), using default of 1000ms\"));\n      }\n    } else {\n      this.pollingInterval = parsedPollingInterval;\n    }\n\n    this.expiredTokenExhaustion = this.setConnectionStatusFallback(ConnectionStatus.ExpiredToken, ConnectionStatus.FailedToConnect, 5);\n    this.activity$ = (this.webSocket ? this.webSocketActivity$() : this.pollingGetActivity$()).share();\n  } // Every time we're about to make a Direct Line REST call, we call this first to see check the current connection status.\n  // Either throws an error (indicating an error state) or emits a null, indicating a (presumably) healthy connection\n\n\n  (0, _createClass2[\"default\"])(DirectLine, [{\n    key: \"checkConnection\",\n    value: function checkConnection() {\n      var _this = this;\n\n      var once = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var obs = this.connectionStatus$.flatMap(function (connectionStatus) {\n        if (connectionStatus === ConnectionStatus.Uninitialized) {\n          _this.connectionStatus$.next(ConnectionStatus.Connecting); //if token and streamUrl are defined it means reconnect has already been done. Skipping it.\n\n\n          if (_this.token && _this.streamUrl) {\n            _this.connectionStatus$.next(ConnectionStatus.Online);\n\n            return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n          } else {\n            return _this.startConversation()[\"do\"](function (conversation) {\n              _this.conversationId = conversation.conversationId;\n              _this.token = _this.secret || conversation.token;\n              _this.streamUrl = conversation.streamUrl;\n              _this.referenceGrammarId = conversation.referenceGrammarId;\n              if (!_this.secret) _this.refreshTokenLoop();\n\n              _this.connectionStatus$.next(ConnectionStatus.Online);\n            }, function (error) {\n              _this.connectionStatus$.next(ConnectionStatus.FailedToConnect);\n            }).map(function (_) {\n              return connectionStatus;\n            });\n          }\n        } else {\n          return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n        }\n      }).filter(function (connectionStatus) {\n        return connectionStatus != ConnectionStatus.Uninitialized && connectionStatus != ConnectionStatus.Connecting;\n      }).flatMap(function (connectionStatus) {\n        switch (connectionStatus) {\n          case ConnectionStatus.Ended:\n            return _Observable.Observable[\"throw\"](errorConversationEnded, _this.services.scheduler);\n\n          case ConnectionStatus.FailedToConnect:\n            return _Observable.Observable[\"throw\"](errorFailedToConnect, _this.services.scheduler);\n\n          case ConnectionStatus.ExpiredToken:\n            return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n\n          default:\n            return _Observable.Observable.of(connectionStatus, _this.services.scheduler);\n        }\n      });\n      return once ? obs.take(1) : obs;\n    }\n  }, {\n    key: \"setConnectionStatusFallback\",\n    value: function setConnectionStatusFallback(connectionStatusFrom, connectionStatusTo) {\n      var maxAttempts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n      maxAttempts--;\n      var attempts = 0;\n      var currStatus = null;\n      return function (status) {\n        if (status === connectionStatusFrom && currStatus === status && attempts >= maxAttempts) {\n          attempts = 0;\n          return connectionStatusTo;\n        }\n\n        attempts++;\n        currStatus = status;\n        return status;\n      };\n    }\n  }, {\n    key: \"expiredToken\",\n    value: function expiredToken() {\n      var connectionStatus = this.connectionStatus$.getValue();\n      if (connectionStatus != ConnectionStatus.Ended && connectionStatus != ConnectionStatus.FailedToConnect) this.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n      var protectedConnectionStatus = this.expiredTokenExhaustion(this.connectionStatus$.getValue());\n      this.connectionStatus$.next(protectedConnectionStatus);\n    }\n  }, {\n    key: \"startConversation\",\n    value: function startConversation() {\n      var _this2 = this; //if conversationid is set here, it means we need to call the reconnect api, else it is a new conversation\n\n\n      var url = this.conversationId ? \"\".concat(this.domain, \"/conversations/\").concat(this.conversationId, \"?watermark=\").concat(this.watermark) : \"\".concat(this.domain, \"/conversations\");\n      var method = this.conversationId ? \"GET\" : \"POST\";\n      var body = this.conversationId ? undefined : {\n        user: {\n          id: this.userIdOnStartConversation\n        },\n        locale: this.localeOnStartConversation\n      };\n      return this.services.ajax({\n        method: method,\n        url: url,\n        body: body,\n        timeout: this.timeout,\n        headers: _objectSpread({\n          \"Accept\": \"application/json\",\n          \"Content-Type\": \"application/json\"\n        }, this.commonHeaders())\n      }) //      .do(ajaxResponse => konsole.log(\"conversation ajaxResponse\", ajaxResponse.response))\n      .map(function (ajaxResponse) {\n        return ajaxResponse.response;\n      }).retryWhen(function (error$) {\n        return (// for now we deem 4xx and 5xx errors as unrecoverable\n          // for everything else (timeouts), retry for a while\n          error$.mergeMap(function (error) {\n            return error.status >= 400 && error.status < 600 ? _Observable.Observable[\"throw\"](error, _this2.services.scheduler) : _Observable.Observable.of(error, _this2.services.scheduler);\n          }).delay(_this2.timeout, _this2.services.scheduler).take(_this2.retries)\n        );\n      });\n    }\n  }, {\n    key: \"refreshTokenLoop\",\n    value: function refreshTokenLoop() {\n      var _this3 = this;\n\n      this.tokenRefreshSubscription = _Observable.Observable.interval(intervalRefreshToken, this.services.scheduler).flatMap(function (_) {\n        return _this3.refreshToken();\n      }).subscribe(function (token) {\n        konsole.log(\"refreshing token\", token, \"at\", new Date());\n        _this3.token = token;\n      });\n    }\n  }, {\n    key: \"refreshToken\",\n    value: function refreshToken() {\n      var _this4 = this;\n\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this4.services.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this4.domain, \"/tokens/refresh\"),\n          timeout: _this4.timeout,\n          headers: _objectSpread({}, _this4.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.token;\n        }).retryWhen(function (error$) {\n          return error$.mergeMap(function (error) {\n            if (error.status === 403) {\n              // if the token is expired there's no reason to keep trying\n              _this4.expiredToken();\n\n              return _Observable.Observable[\"throw\"](error, _this4.services.scheduler);\n            } else if (error.status === 404) {\n              // If the bot is gone, we should stop retrying\n              return _Observable.Observable[\"throw\"](error, _this4.services.scheduler);\n            }\n\n            return _Observable.Observable.of(error, _this4.services.scheduler);\n          }).delay(_this4.timeout, _this4.services.scheduler).take(_this4.retries);\n        });\n      });\n    }\n  }, {\n    key: \"reconnect\",\n    value: function reconnect(conversation) {\n      this.token = conversation.token;\n      this.streamUrl = conversation.streamUrl;\n      if (this.connectionStatus$.getValue() === ConnectionStatus.ExpiredToken) this.connectionStatus$.next(ConnectionStatus.Online);\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this.tokenRefreshSubscription) this.tokenRefreshSubscription.unsubscribe();\n\n      try {\n        this.connectionStatus$.next(ConnectionStatus.Ended);\n      } catch (e) {\n        if (e === errorConversationEnded) return;\n        throw e;\n      }\n    }\n  }, {\n    key: \"getSessionId\",\n    value: function getSessionId() {\n      var _this5 = this; // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n\n\n      konsole.log(\"getSessionId\");\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this5.services.ajax({\n          method: \"GET\",\n          url: \"\".concat(_this5.domain, \"/session/getsessionid\"),\n          withCredentials: true,\n          timeout: _this5.timeout,\n          headers: _objectSpread({\n            \"Content-Type\": \"application/json\"\n          }, _this5.commonHeaders())\n        }).map(function (ajaxResponse) {\n          if (ajaxResponse && ajaxResponse.response && ajaxResponse.response.sessionId) {\n            konsole.log(\"getSessionId response: \" + ajaxResponse.response.sessionId);\n            return ajaxResponse.response.sessionId;\n          }\n\n          return '';\n        })[\"catch\"](function (error) {\n          konsole.log(\"getSessionId error: \" + error.status);\n          return _Observable.Observable.of('', _this5.services.scheduler);\n        });\n      })[\"catch\"](function (error) {\n        return _this5.catchExpiredToken(error);\n      });\n    }\n  }, {\n    key: \"postActivity\",\n    value: function postActivity(activity) {\n      var _this6 = this; // If user id is set, check if it match activity.from.id and always override it in activity\n\n\n      if (this.userIdOnStartConversation && activity.from && activity.from.id !== this.userIdOnStartConversation) {\n        console.warn('DirectLineJS: Activity.from.id does not match with user id, ignoring activity.from.id');\n        activity.from.id = this.userIdOnStartConversation;\n      } // Use postMessageWithAttachments for messages with attachments that are local files (e.g. an image to upload)\n      // Technically we could use it for *all* activities, but postActivity is much lighter weight\n      // So, since WebChat is partially a reference implementation of Direct Line, we implement both.\n\n\n      if (activity.type === \"message\" && activity.attachments && activity.attachments.length > 0) return this.postMessageWithAttachments(activity); // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n\n      konsole.log(\"postActivity\", activity);\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this6.services.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this6.domain, \"/conversations/\").concat(_this6.conversationId, \"/activities\"),\n          body: activity,\n          timeout: _this6.timeout,\n          headers: _objectSpread({\n            \"Content-Type\": \"application/json\"\n          }, _this6.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.id;\n        })[\"catch\"](function (error) {\n          return _this6.catchPostError(error);\n        });\n      })[\"catch\"](function (error) {\n        return _this6.catchExpiredToken(error);\n      });\n    }\n  }, {\n    key: \"postMessageWithAttachments\",\n    value: function postMessageWithAttachments(message) {\n      var _this7 = this;\n\n      var attachments = message.attachments; // We clean the attachments but making sure every attachment has unique name.\n      // If the file do not have a name, Chrome will assign \"blob\" when it is appended to FormData.\n\n      var attachmentNames = (0, _dedupeFilenames[\"default\"])(attachments.map(function (media) {\n        return media.name || 'blob';\n      }));\n      var cleansedAttachments = attachments.map(function (attachment, index) {\n        return _objectSpread(_objectSpread({}, attachment), {}, {\n          name: attachmentNames[index]\n        });\n      });\n      var formData; // If we're not connected to the bot, get connected\n      // Will throw an error if we are not connected\n\n      return this.checkConnection(true).flatMap(function (_) {\n        // To send this message to DirectLine we need to deconstruct it into a \"template\" activity\n        // and one blob for each attachment.\n        formData = new FormData();\n        formData.append('activity', new Blob([JSON.stringify(_objectSpread(_objectSpread({}, message), {}, {\n          // Removing contentUrl from attachment, we will send it via multipart\n          attachments: cleansedAttachments.map(function (_ref) {\n            var string = _ref.contentUrl,\n                others = (0, _objectWithoutProperties2[\"default\"])(_ref, _excluded);\n            return _objectSpread({}, others);\n          })\n        }))], {\n          type: 'application/vnd.microsoft.activity'\n        }));\n        return _Observable.Observable.from(cleansedAttachments, _this7.services.scheduler).flatMap(function (media) {\n          return _this7.services.ajax({\n            method: \"GET\",\n            url: media.contentUrl,\n            responseType: 'arraybuffer'\n          })[\"do\"](function (ajaxResponse) {\n            return formData.append('file', new Blob([ajaxResponse.response], {\n              type: media.contentType\n            }), media.name);\n          });\n        }).count();\n      }).flatMap(function (_) {\n        return _this7.services.ajax({\n          method: \"POST\",\n          url: \"\".concat(_this7.domain, \"/conversations/\").concat(_this7.conversationId, \"/upload?userId=\").concat(message.from.id),\n          body: formData,\n          timeout: _this7.timeout,\n          headers: _objectSpread({}, _this7.commonHeaders())\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response.id;\n        })[\"catch\"](function (error) {\n          return _this7.catchPostError(error);\n        });\n      })[\"catch\"](function (error) {\n        return _this7.catchPostError(error);\n      });\n    }\n  }, {\n    key: \"catchPostError\",\n    value: function catchPostError(error) {\n      if (error.status === 403) // token has expired (will fall through to return \"retry\")\n        this.expiredToken();else if (error.status >= 400 && error.status < 500) // more unrecoverable errors\n        return _Observable.Observable[\"throw\"](error, this.services.scheduler);\n      return _Observable.Observable.of(\"retry\", this.services.scheduler);\n    }\n  }, {\n    key: \"catchExpiredToken\",\n    value: function catchExpiredToken(error) {\n      return error === errorExpiredToken ? _Observable.Observable.of(\"retry\", this.services.scheduler) : _Observable.Observable[\"throw\"](error, this.services.scheduler);\n    }\n  }, {\n    key: \"pollingGetActivity$\",\n    value: function pollingGetActivity$() {\n      var _this8 = this;\n\n      var poller$ = _Observable.Observable.create(function (subscriber) {\n        // A BehaviorSubject to trigger polling. Since it is a BehaviorSubject\n        // the first event is produced immediately.\n        var trigger$ = new _BehaviorSubject.BehaviorSubject({}); // TODO: remove Date.now, use reactive interval to space out every request\n\n        trigger$.subscribe(function () {\n          if (_this8.connectionStatus$.getValue() === ConnectionStatus.Online) {\n            var startTimestamp = Date.now();\n\n            _this8.services.ajax({\n              headers: _objectSpread({\n                Accept: 'application/json'\n              }, _this8.commonHeaders()),\n              method: 'GET',\n              url: \"\".concat(_this8.domain, \"/conversations/\").concat(_this8.conversationId, \"/activities?watermark=\").concat(_this8.watermark),\n              timeout: _this8.timeout\n            }).subscribe(function (result) {\n              subscriber.next(result);\n              setTimeout(function () {\n                return trigger$.next(null);\n              }, Math.max(0, _this8.pollingInterval - Date.now() + startTimestamp));\n            }, function (error) {\n              switch (error.status) {\n                case 403:\n                  _this8.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n\n                  setTimeout(function () {\n                    return trigger$.next(null);\n                  }, _this8.pollingInterval);\n                  break;\n\n                case 404:\n                  _this8.connectionStatus$.next(ConnectionStatus.Ended);\n\n                  break;\n\n                default:\n                  // propagate the error\n                  subscriber.error(error);\n                  break;\n              }\n            });\n          }\n        });\n      });\n\n      return this.checkConnection().flatMap(function (_) {\n        return poller$[\"catch\"](function () {\n          return _Observable.Observable.empty();\n        }).map(function (ajaxResponse) {\n          return ajaxResponse.response;\n        }).flatMap(function (activityGroup) {\n          return _this8.observableFromActivityGroup(activityGroup);\n        });\n      });\n    }\n  }, {\n    key: \"observableFromActivityGroup\",\n    value: function observableFromActivityGroup(activityGroup) {\n      if (activityGroup.watermark) this.watermark = activityGroup.watermark;\n      return _Observable.Observable.from(activityGroup.activities, this.services.scheduler);\n    }\n  }, {\n    key: \"webSocketActivity$\",\n    value: function webSocketActivity$() {\n      var _this9 = this;\n\n      return this.checkConnection().flatMap(function (_) {\n        return _this9.observableWebSocket() // WebSockets can be closed by the server or the browser. In the former case we need to\n        // retrieve a new streamUrl. In the latter case we could first retry with the current streamUrl,\n        // but it's simpler just to always fetch a new one.\n        .retryWhen(function (error$) {\n          return error$.delay(_this9.getRetryDelay(), _this9.services.scheduler).mergeMap(function (error) {\n            return _this9.reconnectToConversation();\n          });\n        });\n      }).flatMap(function (activityGroup) {\n        return _this9.observableFromActivityGroup(activityGroup);\n      });\n    } // Returns the delay duration in milliseconds\n\n  }, {\n    key: \"getRetryDelay\",\n    value: function getRetryDelay() {\n      return Math.floor(3000 + this.services.random() * 12000);\n    } // Originally we used Observable.webSocket, but it's fairly opinionated and I ended up writing\n    // a lot of code to work around their implementation details. Since WebChat is meant to be a reference\n    // implementation, I decided roll the below, where the logic is more purposeful. - @billba\n\n  }, {\n    key: \"observableWebSocket\",\n    value: function observableWebSocket() {\n      var _this10 = this;\n\n      return _Observable.Observable.create(function (subscriber) {\n        konsole.log(\"creating WebSocket\", _this10.streamUrl);\n        var ws = new _this10.services.WebSocket(_this10.streamUrl);\n        var sub;\n        var closed;\n\n        ws.onopen = function (open) {\n          konsole.log(\"WebSocket open\", open); // Chrome is pretty bad at noticing when a WebSocket connection is broken.\n          // If we periodically ping the server with empty messages, it helps Chrome\n          // realize when connection breaks, and close the socket. We then throw an\n          // error, and that give us the opportunity to attempt to reconnect.\n\n          sub = _Observable.Observable.interval(_this10.timeout, _this10.services.scheduler).subscribe(function (_) {\n            try {\n              ws.send(\"\");\n            } catch (e) {\n              konsole.log(\"Ping error\", e);\n            }\n          });\n        };\n\n        ws.onclose = function (close) {\n          konsole.log(\"WebSocket close\", close);\n          if (sub) sub.unsubscribe(); // RxJS.retryWhen has a bug that would cause \"error\" signal to be sent after the observable is completed/errored.\n          // We need to guard against extraneous \"error\" signal to workaround the bug.\n\n          closed || subscriber.error(close);\n          closed = true;\n        };\n\n        ws.onerror = function (error) {\n          konsole.log(\"WebSocket error\", error);\n          if (sub) sub.unsubscribe(); // RxJS.retryWhen has a bug that would cause \"error\" signal to be sent after the observable is completed/errored.\n          // We need to guard against extraneous \"error\" signal to workaround the bug.\n\n          closed || subscriber.error(error);\n          closed = true;\n        };\n\n        ws.onmessage = function (message) {\n          return message.data && subscriber.next(JSON.parse(message.data));\n        }; // This is the 'unsubscribe' method, which is called when this observable is disposed.\n        // When the WebSocket closes itself, we throw an error, and this function is eventually called.\n        // When the observable is closed first (e.g. when tearing down a WebChat instance) then\n        // we need to manually close the WebSocket.\n\n\n        return function () {\n          if (ws.readyState === 0 || ws.readyState === 1) ws.close();\n        };\n      });\n    }\n  }, {\n    key: \"reconnectToConversation\",\n    value: function reconnectToConversation() {\n      var _this11 = this;\n\n      return this.checkConnection(true).flatMap(function (_) {\n        return _this11.services.ajax({\n          method: \"GET\",\n          url: \"\".concat(_this11.domain, \"/conversations/\").concat(_this11.conversationId, \"?watermark=\").concat(_this11.watermark),\n          timeout: _this11.timeout,\n          headers: _objectSpread({\n            \"Accept\": \"application/json\"\n          }, _this11.commonHeaders())\n        })[\"do\"](function (result) {\n          if (!_this11.secret) _this11.token = result.response.token;\n          _this11.streamUrl = result.response.streamUrl;\n        }).map(function (_) {\n          return null;\n        }).retryWhen(function (error$) {\n          return error$.mergeMap(function (error) {\n            if (error.status === 403) {\n              // token has expired. We can't recover from this here, but the embedding\n              // website might eventually call reconnect() with a new token and streamUrl.\n              _this11.expiredToken();\n            } else if (error.status === 404) {\n              return _Observable.Observable[\"throw\"](errorConversationEnded, _this11.services.scheduler);\n            }\n\n            return _Observable.Observable.of(error, _this11.services.scheduler);\n          }).delay(_this11.timeout, _this11.services.scheduler).take(_this11.retries);\n        });\n      });\n    }\n  }, {\n    key: \"commonHeaders\",\n    value: function commonHeaders() {\n      return {\n        \"Authorization\": \"Bearer \".concat(this.token),\n        \"x-ms-bot-agent\": this._botAgent\n      };\n    }\n  }, {\n    key: \"getBotAgent\",\n    value: function getBotAgent() {\n      var customAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var clientAgent = 'directlinejs';\n\n      if (customAgent) {\n        clientAgent += \"; \".concat(customAgent);\n      }\n\n      return \"\".concat(DIRECT_LINE_VERSION, \" (\").concat(clientAgent, \" \").concat(\"0.15.1\", \")\");\n    }\n  }, {\n    key: \"setUserId\",\n    value: function setUserId(userId) {\n      if (this.connectionStatus$.getValue() === ConnectionStatus.Online) {\n        throw new Error('DirectLineJS: It is connected, we cannot set user id.');\n      }\n\n      var userIdFromToken = this.parseToken(this.token);\n\n      if (userIdFromToken) {\n        return console.warn('DirectLineJS: user id is already set in token, will ignore this user id.');\n      }\n\n      if (/^dl_/.test(userId)) {\n        return console.warn('DirectLineJS: user id prefixed with \"dl_\" is reserved and must be embedded into the Direct Line token to prevent forgery.');\n      }\n\n      this.userIdOnStartConversation = userId;\n    }\n  }, {\n    key: \"parseToken\",\n    value: function parseToken(token) {\n      try {\n        var _ref2 = (0, _jwtDecode[\"default\"])(token),\n            user = _ref2.user;\n\n        return user;\n      } catch (e) {\n        if (e instanceof _jwtDecode.InvalidTokenError) {\n          return undefined;\n        }\n      }\n    }\n  }]);\n  return DirectLine;\n}();\n\nexports.DirectLine = DirectLine;","map":{"version":3,"mappings":"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","names":["require","DIRECT_LINE_VERSION","ConnectionStatus","wrapAjaxWithRetry","source","scheduler","notImplemented","Error","inner","response$","err","status","retryAfterValue","xhr","getResponseHeader","retryAfter","Number","isNaN","Observable","timer","flatMap","outer","urlOrRequest","Object","assign","get","url","headers","post","body","put","patch","getJSON","makeServices","services","AsyncScheduler","ajax","WebSocket","random","Math","lifetimeRefreshToken","intervalRefreshToken","POLLING_INTERVAL_LOWER_BOUND","errorExpiredToken","errorConversationEnded","errorFailedToConnect","konsole","log","message","optionalParams","arguments","window","DirectLine","options","BehaviorSubject","Uninitialized","secret","token","webSocket","undefined","conversationStartProperties","locale","prototype","toString","call","localeOnStartConversation","console","warn","domain","conversationId","watermark","streamUrl","timeout","retries","_botAgent","getBotAgent","botAgent","parsedPollingInterval","pollingInterval","expiredTokenExhaustion","setConnectionStatusFallback","ExpiredToken","FailedToConnect","activity$","webSocketActivity$","pollingGetActivity$","share","once","obs","connectionStatus$","connectionStatus","_this","next","Connecting","Online","of","startConversation","conversation","referenceGrammarId","refreshTokenLoop","map","filter","Ended","take","connectionStatusFrom","connectionStatusTo","maxAttempts","attempts","currStatus","getValue","protectedConnectionStatus","method","user","id","userIdOnStartConversation","commonHeaders","ajaxResponse","response","retryWhen","error$","mergeMap","error","_this2","delay","tokenRefreshSubscription","interval","_this3","refreshToken","subscribe","Date","checkConnection","_this4","expiredToken","unsubscribe","e","_this5","withCredentials","sessionId","catchExpiredToken","activity","from","type","attachments","length","postMessageWithAttachments","_this6","catchPostError","attachmentNames","media","name","cleansedAttachments","attachment","index","formData","FormData","append","Blob","JSON","stringify","string","contentUrl","others","_this7","responseType","contentType","count","poller$","create","subscriber","trigger$","_this8","startTimestamp","now","Accept","result","setTimeout","max","empty","observableFromActivityGroup","activityGroup","activities","_this9","observableWebSocket","getRetryDelay","reconnectToConversation","floor","_this10","ws","sub","closed","onopen","open","send","onclose","close","onerror","onmessage","data","parse","readyState","_this11","customAgent","clientAgent","userId","userIdFromToken","parseToken","test","InvalidTokenError"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-directlinejs/src/directLine.ts"],"sourcesContent":["// In order to keep file size down, only import the parts of rxjs that we use\n\nimport 'core-js/features/promise';\nimport 'url-search-params-polyfill';\nimport { AjaxResponse, AjaxCreationMethod, AjaxRequest, AjaxError } from 'rxjs/observable/dom/AjaxObservable';\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Observable } from 'rxjs/Observable';\nimport { IScheduler } from 'rxjs/Scheduler';\nimport { Subscriber } from 'rxjs/Subscriber';\nimport { Subscription } from 'rxjs/Subscription';\nimport { async as AsyncScheduler } from 'rxjs/scheduler/async';\nimport jwtDecode, { JwtPayload, InvalidTokenError } from 'jwt-decode';\n\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/combineLatest';\nimport 'rxjs/add/operator/count';\nimport 'rxjs/add/operator/delay';\nimport 'rxjs/add/operator/do';\nimport 'rxjs/add/operator/filter';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/mergeMap';\nimport 'rxjs/add/operator/concatMap';\nimport 'rxjs/add/operator/retryWhen';\nimport 'rxjs/add/operator/share';\nimport 'rxjs/add/operator/take';\n\nimport 'rxjs/add/observable/dom/ajax';\nimport 'rxjs/add/observable/empty';\nimport 'rxjs/add/observable/from';\nimport 'rxjs/add/observable/interval';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/observable/throw';\n\nimport dedupeFilenames from './dedupeFilenames';\nimport { objectExpression } from '@babel/types';\n\nimport { DirectLineStreaming } from './directLineStreaming';\nexport { DirectLineStreaming };\n\nconst DIRECT_LINE_VERSION = 'DirectLine/3.0';\n\ndeclare var process: {\n    arch: string;\n    env: {\n        VERSION: string;\n        npm_package_version: string;\n    };\n    platform: string;\n    release: string;\n    version: string;\n};\n\n// Direct Line 3.0 types\n\nexport interface Conversation {\n    conversationId: string,\n    token: string,\n    eTag?: string,\n    streamUrl?: string,\n    referenceGrammarId?: string\n}\n\nexport type MediaType = \"image/png\" | \"image/jpg\" | \"image/jpeg\" | \"image/gif\" | \"image/svg+xml\" | \"audio/mpeg\" | \"audio/mp4\" | \"video/mp4\";\n\nexport interface Media {\n    contentType: MediaType,\n    contentUrl: string,\n    name?: string,\n    thumbnailUrl?: string\n}\n\nexport interface UnknownMedia{\n    contentType: string,\n    contentUrl: string,\n    name?: string,\n    thumbnailUrl?: string\n}\n\nexport type CardActionTypes = \"call\" | \"downloadFile\"| \"imBack\" | \"messageBack\" | \"openUrl\" | \"playAudio\" | \"playVideo\" | \"postBack\" | \"signin\" | \"showImage\";\n\nexport type CardAction = CallCardAction | DownloadFileCardAction | IMBackCardAction | MessageBackCardAction | OpenURLCardAction | PlayAudioCardAction | PlayVideoCardAction | PostBackCardAction | SignInCardAction | ShowImageCardAction;\n\nexport interface CallCardAction {\n    image?: string,\n    title: string,\n    type: \"call\",\n    value: any\n}\n\nexport interface DownloadFileCardAction {\n    image?: string,\n    title: string,\n    type: \"downloadFile\",\n    value: any\n}\n\nexport interface IMBackCardAction {\n    image?: string,\n    title?: string,\n    type: \"imBack\",\n    value: string\n}\n\nexport type MessageBackCardAction = MessageBackWithImage | MessageBackWithTitle\n\nexport interface MessageBackWithImage {\n    displayText?: string,\n    image: string,\n    text?: string,\n    title?: string,\n    type: \"messageBack\",\n    value?: any\n}\n\nexport interface MessageBackWithTitle {\n    displayText?: string,\n    image?: string,\n    text?: string,\n    title: string,\n    type: \"messageBack\",\n    value?: any\n}\n\nexport interface OpenURLCardAction {\n    image?: string,\n    title: string,\n    type: \"openUrl\",\n    value: any\n}\n\nexport interface PlayAudioCardAction {\n    image?: string,\n    title: string,\n    type: \"playAudio\",\n    value: any\n}\n\nexport interface PlayVideoCardAction {\n    image?: string,\n    title: string,\n    type: \"playVideo\",\n    value: any\n}\n\nexport interface PostBackCardAction {\n    image?: string,\n    title?: string,\n    type: \"postBack\",\n    value: any\n}\n\nexport interface ShowImageCardAction {\n    image?: string,\n    title: string,\n    type: \"showImage\",\n    value: any\n}\n\nexport interface SignInCardAction {\n    image?: string,\n    title: string,\n    type: \"signin\",\n    value: any\n}\n\nexport interface CardImage {\n    alt?: string,\n    url: string,\n    tap?: CardAction\n}\n\nexport interface HeroCard {\n    contentType: \"application/vnd.microsoft.card.hero\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        images?: CardImage[],\n        buttons?: CardAction[],\n        tap?: CardAction\n    }\n}\n\nexport interface Thumbnail {\n    contentType: \"application/vnd.microsoft.card.thumbnail\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        images?: CardImage[],\n        buttons?: CardAction[],\n        tap?: CardAction\n    }\n}\n\nexport interface Signin {\n    contentType: \"application/vnd.microsoft.card.signin\",\n    content: {\n        text?: string,\n        buttons?: CardAction[]\n    }\n}\n\nexport interface OAuth {\n    contentType: \"application/vnd.microsoft.card.oauth\",\n    content: {\n        text?: string,\n        connectionname: string,\n        buttons?: CardAction[]\n    }\n}\n\nexport interface ReceiptItem {\n    title?: string,\n    subtitle?: string,\n    text?: string,\n    image?: CardImage,\n    price?: string,\n    quantity?: string,\n    tap?: CardAction\n}\n\nexport interface Receipt {\n    contentType: \"application/vnd.microsoft.card.receipt\",\n    content: {\n        title?: string,\n        facts?: { key: string, value: string }[],\n        items?: ReceiptItem[],\n        tap?: CardAction,\n        tax?: string,\n        vat?: string,\n        total?: string,\n        buttons?: CardAction[]\n    }\n}\n\n// Deprecated format for Skype channels. For testing legacy bots in Emulator only.\nexport interface FlexCard {\n    contentType: \"application/vnd.microsoft.card.flex\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        images?: CardImage[],\n        buttons?: CardAction[],\n        aspect?: string\n    }\n}\n\nexport interface AudioCard {\n    contentType: \"application/vnd.microsoft.card.audio\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        media?: { url: string, profile?: string }[],\n        buttons?: CardAction[],\n        autoloop?: boolean,\n        autostart?: boolean\n    }\n}\n\nexport interface VideoCard {\n    contentType: \"application/vnd.microsoft.card.video\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        media?: { url: string, profile?: string }[],\n        buttons?: CardAction[],\n        image?: { url: string, alt?: string },\n        autoloop?: boolean,\n        autostart?: boolean\n    }\n}\n\nexport interface AdaptiveCard {\n    contentType: \"application/vnd.microsoft.card.adaptive\",\n    content: any;\n}\n\nexport interface AnimationCard {\n    contentType: \"application/vnd.microsoft.card.animation\",\n    content: {\n        title?: string,\n        subtitle?: string,\n        text?: string,\n        media?: { url: string, profile?: string }[],\n        buttons?: CardAction[],\n        image?: { url: string, alt?: string },\n        autoloop?: boolean,\n        autostart?: boolean\n    }\n}\n\nexport type KnownMedia = Media | HeroCard | Thumbnail | Signin | OAuth | Receipt | AudioCard | VideoCard | AnimationCard | FlexCard | AdaptiveCard;\nexport type Attachment = KnownMedia | UnknownMedia;\n\nexport type UserRole = \"bot\" | \"channel\" | \"user\";\n\nexport interface User {\n    id: string,\n    name?: string,\n    iconUrl?: string,\n    role?: UserRole\n}\n\nexport interface IActivity {\n    type: string,\n    channelData?: any,\n    channelId?: string,\n    conversation?: { id: string },\n    eTag?: string,\n    from: User,\n    id?: string,\n    timestamp?: string\n}\n\nexport type AttachmentLayout = \"list\" | \"carousel\";\n\nexport interface Message extends IActivity {\n    type: \"message\",\n    text?: string,\n    locale?: string,\n    textFormat?: \"plain\" | \"markdown\" | \"xml\",\n    attachmentLayout?: AttachmentLayout,\n    attachments?: Attachment[],\n    entities?: any[],\n    suggestedActions?: { actions: CardAction[], to?: string[] },\n    speak?: string,\n    inputHint?: string,\n    value?: object\n}\n\nexport interface Typing extends IActivity {\n    type: \"typing\"\n}\n\nexport interface EventActivity extends IActivity {\n    type: \"event\",\n    name: string,\n    value: any\n}\n\nexport type Activity = Message | Typing | EventActivity;\n\nexport interface ActivityGroup {\n    activities: Activity[],\n    watermark: string\n}\n\n// These types are specific to this client library, not to Direct Line 3.0\n\nexport enum ConnectionStatus {\n    Uninitialized,              // the status when the DirectLine object is first created/constructed\n    Connecting,                 // currently trying to connect to the conversation\n    Online,                     // successfully connected to the conversation. Connection is healthy so far as we know.\n    ExpiredToken,               // last operation errored out with an expired token. Possibly waiting for someone to supply a new one.\n    FailedToConnect,            // the initial attempt to connect to the conversation failed. No recovery possible.\n    Ended                       // the bot ended the conversation\n}\n\nexport interface DirectLineOptions {\n    secret?: string,\n    token?: string,\n    conversationId?: string,\n    watermark?: string,\n    domain?: string,\n    webSocket?: boolean,\n    pollingInterval?: number,\n    streamUrl?: string,\n    timeout?: number,\n    // Attached to all requests to identify requesting agent.\n    botAgent?: string,\n    conversationStartProperties?: any\n}\n\nexport interface Services {\n    scheduler: IScheduler;\n    WebSocket: typeof WebSocket;\n    ajax: AjaxCreationMethod;\n    random: () => number;\n}\n\nconst wrapAjaxWithRetry = (source: AjaxCreationMethod, scheduler: IScheduler): AjaxCreationMethod =>{\n\n    const notImplemented = (): never => { throw new Error('not implemented'); };\n\n    const inner = (response$ : Observable<AjaxResponse>) => {\n        return response$\n        .catch<AjaxResponse, AjaxResponse>((err) => {\n            if(err.status === 429){\n                const retryAfterValue = err.xhr.getResponseHeader('Retry-After');\n                const retryAfter = Number(retryAfterValue);\n                if(!isNaN(retryAfter)){\n                    return Observable.timer(retryAfter, scheduler)\n                    .flatMap(_ => Observable.throw(err, scheduler));\n                }\n            }\n\n            return Observable.throw(err, scheduler);\n        });\n    };\n\n    const outer = (urlOrRequest: string| AjaxRequest) => {\n        return inner(source(urlOrRequest));\n    };\n\n    return Object.assign(outer, {\n        get: (url: string, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        post: (url: string, body?: any, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        put: (url: string, body?: any, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        patch: (url: string, body?: any, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        delete: (url: string, headers?: Object): Observable<AjaxResponse> => notImplemented(),\n        getJSON: <T>(url: string, headers?: Object): Observable<T> => notImplemented()\n    });\n}\n\nconst makeServices = (services: Partial<Services>): Services => {\n    const scheduler = services.scheduler || AsyncScheduler;\n    return {\n        scheduler,\n        ajax: wrapAjaxWithRetry(services.ajax || Observable.ajax, scheduler),\n        WebSocket: services.WebSocket || WebSocket,\n        random: services.random || Math.random,\n    }\n}\n\nconst lifetimeRefreshToken = 30 * 60 * 1000;\nconst intervalRefreshToken = lifetimeRefreshToken / 2;\n\nconst POLLING_INTERVAL_LOWER_BOUND: number = 200; //ms\n\nconst errorExpiredToken = new Error(\"expired token\");\nconst errorConversationEnded = new Error(\"conversation ended\");\nconst errorFailedToConnect = new Error(\"failed to connect\");\n\nconst konsole = {\n    log: (message?: any, ... optionalParams: any[]) => {\n        if (typeof window !== 'undefined' && (window as any)[\"botchatDebug\"] && message)\n            console.log(message, ... optionalParams);\n    }\n}\n\nexport interface IBotConnection {\n    connectionStatus$: BehaviorSubject<ConnectionStatus>,\n    activity$: Observable<Activity>,\n    end(): void,\n    referenceGrammarId?: string,\n    postActivity(activity: Activity): Observable<string>,\n    getSessionId? : () => Observable<string>\n}\n\nexport class DirectLine implements IBotConnection {\n    public connectionStatus$ = new BehaviorSubject(ConnectionStatus.Uninitialized);\n    public activity$: Observable<Activity>;\n\n    private domain = \"https://directline.botframework.com/v3/directline\";\n    private webSocket: boolean;\n\n    private conversationId: string;\n    private expiredTokenExhaustion: Function;\n    private secret: string;\n    private token: string;\n    private watermark = '';\n    private streamUrl: string;\n    private _botAgent = '';\n    private services: Services;\n    private _userAgent: string;\n    public referenceGrammarId: string;\n    private timeout = 20 * 1000;\n    private retries: number;\n\n    private localeOnStartConversation: string;\n    private userIdOnStartConversation: string;\n\n    private pollingInterval: number = 1000; //ms\n\n    private tokenRefreshSubscription: Subscription;\n\n    constructor(options: DirectLineOptions & Partial<Services>) {\n        this.secret = options.secret;\n        this.token = options.secret || options.token;\n        this.webSocket = (options.webSocket === undefined ? true : options.webSocket) && typeof WebSocket !== 'undefined' && WebSocket !== undefined;\n\n        if (options.conversationStartProperties && options.conversationStartProperties.locale) {\n            if (Object.prototype.toString.call(options.conversationStartProperties.locale) === '[object String]') {\n                this.localeOnStartConversation = options.conversationStartProperties.locale;\n            } else {\n                console.warn('DirectLineJS: conversationStartProperties.locale was ignored: the locale name may be a BCP 47 language tag');\n            }\n        }\n\n        if (options.domain) {\n            this.domain = options.domain;\n        }\n\n        if (options.conversationId) {\n            this.conversationId = options.conversationId;\n        }\n\n        if (options.watermark) {\n            this.watermark =  options.watermark;\n        }\n\n        if (options.streamUrl) {\n            if (options.token && options.conversationId) {\n                this.streamUrl = options.streamUrl;\n            } else {\n                console.warn('DirectLineJS: streamUrl was ignored: you need to provide a token and a conversationid');\n            }\n        }\n\n        if (options.timeout !== undefined) {\n            this.timeout = options.timeout;\n        }\n\n        this.retries = (lifetimeRefreshToken - intervalRefreshToken) / this.timeout;\n\n        this._botAgent = this.getBotAgent(options.botAgent);\n\n        this.services = makeServices(options);\n\n        const parsedPollingInterval = ~~options.pollingInterval;\n\n        if (parsedPollingInterval < POLLING_INTERVAL_LOWER_BOUND) {\n            if (typeof options.pollingInterval !== 'undefined') {\n                console.warn(`DirectLineJS: provided pollingInterval (${ options.pollingInterval }) is under lower bound (200ms), using default of 1000ms`);\n            }\n        } else {\n            this.pollingInterval = parsedPollingInterval;\n        }\n\n        this.expiredTokenExhaustion = this.setConnectionStatusFallback(\n            ConnectionStatus.ExpiredToken,\n            ConnectionStatus.FailedToConnect,\n            5\n        );\n\n        this.activity$ = (this.webSocket\n            ? this.webSocketActivity$()\n            : this.pollingGetActivity$()\n        ).share();\n    }\n\n    // Every time we're about to make a Direct Line REST call, we call this first to see check the current connection status.\n    // Either throws an error (indicating an error state) or emits a null, indicating a (presumably) healthy connection\n    private checkConnection(once = false) {\n        let obs =  this.connectionStatus$\n        .flatMap(connectionStatus => {\n            if (connectionStatus === ConnectionStatus.Uninitialized) {\n                this.connectionStatus$.next(ConnectionStatus.Connecting);\n\n                //if token and streamUrl are defined it means reconnect has already been done. Skipping it.\n                if (this.token && this.streamUrl) {\n                    this.connectionStatus$.next(ConnectionStatus.Online);\n                    return Observable.of(connectionStatus, this.services.scheduler);\n                } else {\n                    return this.startConversation().do(conversation => {\n                        this.conversationId = conversation.conversationId;\n                        this.token = this.secret || conversation.token;\n                        this.streamUrl = conversation.streamUrl;\n                        this.referenceGrammarId = conversation.referenceGrammarId;\n                        if (!this.secret)\n                            this.refreshTokenLoop();\n\n                        this.connectionStatus$.next(ConnectionStatus.Online);\n                    }, error => {\n                        this.connectionStatus$.next(ConnectionStatus.FailedToConnect);\n                    })\n                    .map(_ => connectionStatus);\n                }\n            }\n            else {\n                return Observable.of(connectionStatus, this.services.scheduler);\n            }\n        })\n        .filter(connectionStatus => connectionStatus != ConnectionStatus.Uninitialized && connectionStatus != ConnectionStatus.Connecting)\n        .flatMap(connectionStatus => {\n            switch (connectionStatus) {\n                case ConnectionStatus.Ended:\n                    return Observable.throw(errorConversationEnded, this.services.scheduler);\n\n                case ConnectionStatus.FailedToConnect:\n                    return Observable.throw(errorFailedToConnect, this.services.scheduler);\n\n                case ConnectionStatus.ExpiredToken:\n                    return Observable.of(connectionStatus, this.services.scheduler);\n\n                default:\n                    return Observable.of(connectionStatus, this.services.scheduler);\n            }\n        })\n\n        return once ? obs.take(1) : obs;\n    }\n\n    setConnectionStatusFallback(\n        connectionStatusFrom: ConnectionStatus,\n        connectionStatusTo: ConnectionStatus,\n        maxAttempts = 5\n    ) {\n        maxAttempts--;\n        let attempts = 0;\n        let currStatus = null;\n        return (status: ConnectionStatus): ConnectionStatus => {\n            if (status === connectionStatusFrom && currStatus === status && attempts >= maxAttempts) {\n                attempts = 0\n                return connectionStatusTo;\n            }\n            attempts++;\n            currStatus = status;\n            return status;\n        };\n    }\n\n    private expiredToken() {\n        const connectionStatus = this.connectionStatus$.getValue();\n        if (connectionStatus != ConnectionStatus.Ended && connectionStatus != ConnectionStatus.FailedToConnect)\n            this.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n\n        const protectedConnectionStatus = this.expiredTokenExhaustion(this.connectionStatus$.getValue());\n        this.connectionStatus$.next(protectedConnectionStatus);\n    }\n\n    private startConversation() {\n        //if conversationid is set here, it means we need to call the reconnect api, else it is a new conversation\n        const url = this.conversationId\n            ? `${this.domain}/conversations/${this.conversationId}?watermark=${this.watermark}`\n            : `${this.domain}/conversations`;\n        const method = this.conversationId ? \"GET\" : \"POST\";\n        const body = this.conversationId\n            ? undefined\n            : {\n                user: {\n                    id: this.userIdOnStartConversation\n                },\n                locale: this.localeOnStartConversation\n              };\n        return this.services.ajax({\n            method,\n            url,\n            body,\n            timeout: this.timeout,\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/json\",\n                ...this.commonHeaders()\n            }\n        })\n//      .do(ajaxResponse => konsole.log(\"conversation ajaxResponse\", ajaxResponse.response))\n        .map(ajaxResponse => ajaxResponse.response as Conversation)\n        .retryWhen(error$ =>\n            // for now we deem 4xx and 5xx errors as unrecoverable\n            // for everything else (timeouts), retry for a while\n            error$.mergeMap((error) => {\n                return error.status >= 400 && error.status < 600\n                ? Observable.throw(error, this.services.scheduler)\n                : Observable.of(error, this.services.scheduler)\n            })\n            .delay(this.timeout, this.services.scheduler)\n            .take(this.retries)\n        )\n    }\n\n    private refreshTokenLoop() {\n        this.tokenRefreshSubscription = Observable.interval(intervalRefreshToken, this.services.scheduler)\n        .flatMap(_ => this.refreshToken())\n        .subscribe(token => {\n            konsole.log(\"refreshing token\", token, \"at\", new Date());\n            this.token = token;\n        });\n    }\n\n    private refreshToken() {\n        return this.checkConnection(true)\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"POST\",\n                url: `${this.domain}/tokens/refresh`,\n                timeout: this.timeout,\n                headers: {\n                    ...this.commonHeaders()\n                }\n            })\n            .map(ajaxResponse => ajaxResponse.response.token as string)\n            .retryWhen(error$ => error$\n                .mergeMap(error => {\n                    if (error.status === 403) {\n                        // if the token is expired there's no reason to keep trying\n                        this.expiredToken();\n                        return Observable.throw(error, this.services.scheduler);\n                    } else if (error.status === 404) {\n                        // If the bot is gone, we should stop retrying\n                        return Observable.throw(error, this.services.scheduler);\n                    }\n\n                    return Observable.of(error, this.services.scheduler);\n                })\n                .delay(this.timeout, this.services.scheduler)\n                .take(this.retries)\n            )\n        )\n    }\n\n    public reconnect(conversation: Conversation) {\n        this.token = conversation.token;\n        this.streamUrl = conversation.streamUrl;\n        if (this.connectionStatus$.getValue() === ConnectionStatus.ExpiredToken)\n            this.connectionStatus$.next(ConnectionStatus.Online);\n    }\n\n    end() {\n        if (this.tokenRefreshSubscription)\n            this.tokenRefreshSubscription.unsubscribe();\n        try {\n            this.connectionStatus$.next(ConnectionStatus.Ended);\n        } catch (e) {\n            if (e === errorConversationEnded)\n                return;\n            throw(e);\n        }\n    }\n\n    getSessionId(): Observable<string> {\n        // If we're not connected to the bot, get connected\n        // Will throw an error if we are not connected\n        konsole.log(\"getSessionId\");\n        return this.checkConnection(true)\n            .flatMap(_ =>\n                this.services.ajax({\n                    method: \"GET\",\n                    url: `${this.domain}/session/getsessionid`,\n                    withCredentials: true,\n                    timeout: this.timeout,\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        ...this.commonHeaders()\n                    }\n                })\n                .map(ajaxResponse => {\n                    if (ajaxResponse && ajaxResponse.response && ajaxResponse.response.sessionId) {\n                        konsole.log(\"getSessionId response: \" + ajaxResponse.response.sessionId);\n                        return ajaxResponse.response.sessionId as string;\n                    }\n                    return '';\n                })\n                .catch(error => {\n                    konsole.log(\"getSessionId error: \" + error.status);\n                    return Observable.of('', this.services.scheduler);\n                })\n            )\n            .catch(error => this.catchExpiredToken(error));\n    }\n\n    postActivity(activity: Activity) {\n        // If user id is set, check if it match activity.from.id and always override it in activity\n        if (this.userIdOnStartConversation && activity.from && activity.from.id !== this.userIdOnStartConversation) {\n            console.warn('DirectLineJS: Activity.from.id does not match with user id, ignoring activity.from.id');\n            activity.from.id = this.userIdOnStartConversation;\n        }\n        // Use postMessageWithAttachments for messages with attachments that are local files (e.g. an image to upload)\n        // Technically we could use it for *all* activities, but postActivity is much lighter weight\n        // So, since WebChat is partially a reference implementation of Direct Line, we implement both.\n        if (activity.type === \"message\" && activity.attachments && activity.attachments.length > 0)\n            return this.postMessageWithAttachments(activity);\n\n        // If we're not connected to the bot, get connected\n        // Will throw an error if we are not connected\n        konsole.log(\"postActivity\", activity);\n        return this.checkConnection(true)\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"POST\",\n                url: `${this.domain}/conversations/${this.conversationId}/activities`,\n                body: activity,\n                timeout: this.timeout,\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...this.commonHeaders()\n                },\n            })\n            .map(ajaxResponse => ajaxResponse.response.id as string)\n            .catch(error => this.catchPostError(error))\n        )\n        .catch(error => this.catchExpiredToken(error));\n    }\n\n    private postMessageWithAttachments(message: Message) {\n        const { attachments } = message;\n        // We clean the attachments but making sure every attachment has unique name.\n        // If the file do not have a name, Chrome will assign \"blob\" when it is appended to FormData.\n        const attachmentNames: string[] = dedupeFilenames(attachments.map((media: Media) => media.name || 'blob'));\n        const cleansedAttachments = attachments.map((attachment: Media, index: number) => ({\n            ...attachment,\n            name: attachmentNames[index]\n        }));\n        let formData: FormData;\n\n        // If we're not connected to the bot, get connected\n        // Will throw an error if we are not connected\n        return this.checkConnection(true)\n        .flatMap(_ => {\n            // To send this message to DirectLine we need to deconstruct it into a \"template\" activity\n            // and one blob for each attachment.\n            formData = new FormData();\n            formData.append('activity', new Blob([JSON.stringify({\n                ...message,\n                // Removing contentUrl from attachment, we will send it via multipart\n                attachments: cleansedAttachments.map(({ contentUrl: string, ...others }) => ({ ...others }))\n            })], { type: 'application/vnd.microsoft.activity' }));\n\n            return Observable.from(cleansedAttachments, this.services.scheduler)\n            .flatMap((media: Media) =>\n                this.services.ajax({\n                    method: \"GET\",\n                    url: media.contentUrl,\n                    responseType: 'arraybuffer'\n                })\n                .do(ajaxResponse =>\n                    formData.append('file', new Blob([ajaxResponse.response], { type: media.contentType }), media.name)\n                )\n            )\n            .count()\n        })\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"POST\",\n                url: `${this.domain}/conversations/${this.conversationId}/upload?userId=${message.from.id}`,\n                body: formData,\n                timeout: this.timeout,\n                headers: {\n                    ...this.commonHeaders()\n                }\n            })\n            .map(ajaxResponse => ajaxResponse.response.id as string)\n            .catch(error => this.catchPostError(error))\n        )\n        .catch(error => this.catchPostError(error));\n    }\n\n    private catchPostError(error: any) {\n        if (error.status === 403)\n            // token has expired (will fall through to return \"retry\")\n            this.expiredToken();\n        else if (error.status >= 400 && error.status < 500)\n            // more unrecoverable errors\n            return Observable.throw(error, this.services.scheduler);\n        return Observable.of(\"retry\", this.services.scheduler);\n    }\n\n    private catchExpiredToken(error: any) {\n        return error === errorExpiredToken\n        ? Observable.of(\"retry\", this.services.scheduler)\n        : Observable.throw(error, this.services.scheduler);\n    }\n\n    private pollingGetActivity$() {\n        const poller$: Observable<AjaxResponse> = Observable.create((subscriber: Subscriber<any>) => {\n            // A BehaviorSubject to trigger polling. Since it is a BehaviorSubject\n            // the first event is produced immediately.\n            const trigger$ = new BehaviorSubject<any>({});\n\n            // TODO: remove Date.now, use reactive interval to space out every request\n\n            trigger$.subscribe(() => {\n                if (this.connectionStatus$.getValue() === ConnectionStatus.Online) {\n                    const startTimestamp = Date.now();\n\n                    this.services.ajax({\n                        headers: {\n                            Accept: 'application/json',\n                            ...this.commonHeaders()\n                        },\n                        method: 'GET',\n                        url: `${ this.domain }/conversations/${ this.conversationId }/activities?watermark=${ this.watermark }`,\n                        timeout: this.timeout\n                    }).subscribe(\n                        (result: AjaxResponse) => {\n                            subscriber.next(result);\n                            setTimeout(() => trigger$.next(null), Math.max(0, this.pollingInterval - Date.now() + startTimestamp));\n                        },\n                        (error: any) => {\n                            switch (error.status) {\n                                case 403:\n                                    this.connectionStatus$.next(ConnectionStatus.ExpiredToken);\n                                    setTimeout(() => trigger$.next(null), this.pollingInterval);\n                                    break;\n\n                                case 404:\n                                    this.connectionStatus$.next(ConnectionStatus.Ended);\n                                    break;\n\n                                default:\n                                    // propagate the error\n                                    subscriber.error(error);\n                                    break;\n                            }\n                        }\n                    );\n                }\n            });\n        });\n\n        return this.checkConnection()\n        .flatMap(_ => poller$\n            .catch(() => Observable.empty<AjaxResponse>())\n            .map(ajaxResponse => ajaxResponse.response as ActivityGroup)\n            .flatMap(activityGroup => this.observableFromActivityGroup(activityGroup)));\n    }\n\n    private observableFromActivityGroup(activityGroup: ActivityGroup) {\n        if (activityGroup.watermark)\n            this.watermark = activityGroup.watermark;\n        return Observable.from(activityGroup.activities, this.services.scheduler);\n    }\n\n    private webSocketActivity$(): Observable<Activity> {\n        return this.checkConnection()\n        .flatMap(_ =>\n            this.observableWebSocket<ActivityGroup>()\n            // WebSockets can be closed by the server or the browser. In the former case we need to\n            // retrieve a new streamUrl. In the latter case we could first retry with the current streamUrl,\n            // but it's simpler just to always fetch a new one.\n            .retryWhen(error$ => error$.delay(this.getRetryDelay(), this.services.scheduler).mergeMap(error => this.reconnectToConversation()))\n        )\n        .flatMap(activityGroup => this.observableFromActivityGroup(activityGroup))\n    }\n\n    // Returns the delay duration in milliseconds\n    private getRetryDelay() {\n        return Math.floor(3000 + this.services.random() * 12000);\n    }\n\n    // Originally we used Observable.webSocket, but it's fairly opinionated and I ended up writing\n    // a lot of code to work around their implementation details. Since WebChat is meant to be a reference\n    // implementation, I decided roll the below, where the logic is more purposeful. - @billba\n    private observableWebSocket<T>() {\n        return Observable.create((subscriber: Subscriber<T>) => {\n            konsole.log(\"creating WebSocket\", this.streamUrl);\n            const ws = new this.services.WebSocket(this.streamUrl);\n            let sub: Subscription;\n            let closed: boolean;\n\n            ws.onopen = open => {\n                konsole.log(\"WebSocket open\", open);\n                // Chrome is pretty bad at noticing when a WebSocket connection is broken.\n                // If we periodically ping the server with empty messages, it helps Chrome\n                // realize when connection breaks, and close the socket. We then throw an\n                // error, and that give us the opportunity to attempt to reconnect.\n                sub = Observable.interval(this.timeout, this.services.scheduler).subscribe(_ => {\n                    try {\n                        ws.send(\"\")\n                    } catch(e) {\n                        konsole.log(\"Ping error\", e);\n                    }\n                });\n            }\n\n            ws.onclose = close => {\n                konsole.log(\"WebSocket close\", close);\n                if (sub) sub.unsubscribe();\n\n                // RxJS.retryWhen has a bug that would cause \"error\" signal to be sent after the observable is completed/errored.\n                // We need to guard against extraneous \"error\" signal to workaround the bug.\n                closed || subscriber.error(close);\n                closed = true;\n            }\n\n            ws.onerror = error => {\n                konsole.log(\"WebSocket error\", error);\n                if (sub) sub.unsubscribe();\n\n                // RxJS.retryWhen has a bug that would cause \"error\" signal to be sent after the observable is completed/errored.\n                // We need to guard against extraneous \"error\" signal to workaround the bug.\n                closed || subscriber.error(error);\n                closed = true;\n            }\n\n            ws.onmessage = message => message.data && subscriber.next(JSON.parse(message.data));\n\n            // This is the 'unsubscribe' method, which is called when this observable is disposed.\n            // When the WebSocket closes itself, we throw an error, and this function is eventually called.\n            // When the observable is closed first (e.g. when tearing down a WebChat instance) then\n            // we need to manually close the WebSocket.\n            return () => {\n                if (ws.readyState === 0 || ws.readyState === 1) ws.close();\n            }\n        }) as Observable<T>\n    }\n\n    private reconnectToConversation() {\n        return this.checkConnection(true)\n        .flatMap(_ =>\n            this.services.ajax({\n                method: \"GET\",\n                url: `${this.domain}/conversations/${this.conversationId}?watermark=${this.watermark}`,\n                timeout: this.timeout,\n                headers: {\n                    \"Accept\": \"application/json\",\n                    ...this.commonHeaders()\n                }\n            })\n            .do(result => {\n                if (!this.secret)\n                    this.token = result.response.token;\n                this.streamUrl = result.response.streamUrl;\n            })\n            .map(_ => null)\n            .retryWhen(error$ => error$\n                .mergeMap(error => {\n                    if (error.status === 403) {\n                        // token has expired. We can't recover from this here, but the embedding\n                        // website might eventually call reconnect() with a new token and streamUrl.\n                        this.expiredToken();\n                    } else if (error.status === 404) {\n                        return Observable.throw(errorConversationEnded, this.services.scheduler);\n                    }\n\n                    return Observable.of(error, this.services.scheduler);\n                })\n                .delay(this.timeout, this.services.scheduler)\n                .take(this.retries)\n            )\n        )\n    }\n\n    private commonHeaders() {\n        return {\n            \"Authorization\": `Bearer ${this.token}`,\n            \"x-ms-bot-agent\": this._botAgent\n        };\n    }\n\n    private getBotAgent(customAgent: string = ''): string {\n        let clientAgent = 'directlinejs'\n\n        if (customAgent) {\n            clientAgent += `; ${customAgent}`\n        }\n\n        return `${DIRECT_LINE_VERSION} (${clientAgent} ${process.env.npm_package_version})`;\n    }\n\n    setUserId(userId: string) {\n        if (this.connectionStatus$.getValue() === ConnectionStatus.Online) {\n            throw new Error('DirectLineJS: It is connected, we cannot set user id.');\n        }\n\n        const userIdFromToken = this.parseToken(this.token);\n        if (userIdFromToken) {\n            return console.warn('DirectLineJS: user id is already set in token, will ignore this user id.');\n        }\n\n        if (/^dl_/u.test(userId)) {\n            return console.warn('DirectLineJS: user id prefixed with \"dl_\" is reserved and must be embedded into the Direct Line token to prevent forgery.');\n        }\n\n        this.userIdOnStartConversation = userId;\n    }\n\n    private parseToken(token: string) {\n        try {\n            const { user } = jwtDecode<JwtPayload>(token) as { [key: string]: any; };\n            return user;\n        } catch (e) {\n            if (e instanceof InvalidTokenError) {\n                return undefined;\n            }\n        }\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}