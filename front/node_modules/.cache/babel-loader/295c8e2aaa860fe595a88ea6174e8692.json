{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _arrayToMap = _interopRequireDefault(require(\"../../Util/arrayToMap\"));\n\nvar _SpeechSDK = _interopRequireDefault(require(\"../SpeechSDK\"));\n\nvar _SpeechSDK$ResultReas = _SpeechSDK.default.ResultReason,\n    RecognizingSpeech = _SpeechSDK$ResultReas.RecognizingSpeech,\n    RecognizedSpeech = _SpeechSDK$ResultReas.RecognizedSpeech;\n\nfunction _default(result) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$maxAlternatives = _ref.maxAlternatives,\n      maxAlternatives = _ref$maxAlternatives === void 0 ? Infinity : _ref$maxAlternatives,\n      _ref$textNormalizatio = _ref.textNormalization,\n      textNormalization = _ref$textNormalizatio === void 0 ? 'display' : _ref$textNormalizatio;\n\n  if (result.reason === RecognizingSpeech || result.reason === RecognizedSpeech && !result.json.NBest) {\n    var resultList = [{\n      confidence: 0.5,\n      transcript: result.text\n    }];\n\n    if (result.reason === RecognizedSpeech) {\n      resultList.isFinal = true;\n    }\n\n    return resultList;\n  } else if (result.reason === RecognizedSpeech) {\n    var _resultList = (0, _arrayToMap.default)((result.json.NBest || []).slice(0, maxAlternatives).map(function (_ref2) {\n      var confidence = _ref2.Confidence,\n          display = _ref2.Display,\n          itn = _ref2.ITN,\n          lexical = _ref2.Lexical,\n          maskedITN = _ref2.MaskedITN;\n      return {\n        confidence: confidence,\n        transcript: textNormalization === 'itn' ? itn : textNormalization === 'lexical' ? lexical : textNormalization === 'maskeditn' ? maskedITN : display\n      };\n    }), {\n      isFinal: true\n    });\n\n    return _resultList;\n  }\n\n  return [];\n}","map":{"version":3,"mappings":";;;;;;;;;AAAA;;AACA;;AAEA,4BAEIA,mBADFC,YADF;AAAA,IACkBC,iBADlB,yBACkBA,iBADlB;AAAA,IACqCC,gBADrC,yBACqCA,gBADrC;;AAIe,kBAASC,MAAT,EAAqF;AAAA,iFAAJ,EAAI;AAAA,kCAAlEC,eAAkE;AAAA,MAAlEA,eAAkE,qCAAhDC,QAAgD;AAAA,mCAAtCC,iBAAsC;AAAA,MAAtCA,iBAAsC,sCAAlB,SAAkB;;AAClG,MAAIH,MAAM,CAACI,MAAPJ,KAAkBF,iBAAlBE,IAAwCA,MAAM,CAACI,MAAPJ,KAAkBD,gBAAlBC,IAAsC,CAACA,MAAM,CAACK,IAAPL,CAAYM,KAA/F,EAAuG;AACrG,QAAMC,UAAU,GAAG,CACjB;AACEC,gBAAU,EAAE,GADd;AAEEC,gBAAU,EAAET,MAAM,CAACU;AAFrB,KADiB,CAAnB;;AAOA,QAAIV,MAAM,CAACI,MAAPJ,KAAkBD,gBAAtB,EAAwC;AACtCQ,gBAAU,CAACI,OAAXJ,GAAqB,IAArBA;AACD;;AAED,WAAOA,UAAP;AAZF,SAaO,IAAIP,MAAM,CAACI,MAAPJ,KAAkBD,gBAAtB,EAAwC;AAC7C,QAAMQ,WAAU,GAAG,yBACjB,CAACP,MAAM,CAACK,IAAPL,CAAYM,KAAZN,IAAqB,EAAtB,EACGY,KADH,CACS,CADT,EACYX,eADZ,EAEGY,GAFH,CAEO;AAAA,UAAeL,UAAf,SAAGM,UAAH;AAAA,UAAoCC,OAApC,SAA2BC,OAA3B;AAAA,UAAkDC,GAAlD,SAA6CC,GAA7C;AAAA,UAAgEC,OAAhE,SAAuDC,OAAvD;AAAA,UAAoFC,SAApF,SAAyEC,SAAzE;AAAA,aAAqG;AACxGd,kBAAU,EAAVA,UADwG;AAExGC,kBAAU,EACRN,iBAAiB,KAAK,KAAtBA,GACIc,GADJd,GAEIA,iBAAiB,KAAK,SAAtBA,GACAgB,OADAhB,GAEAA,iBAAiB,KAAK,WAAtBA,GACAkB,SADAlB,GAEAY;AATkG,OAArG;AAFP,MADiB,EAcjB;AAAEJ,aAAO,EAAE;AAAX,KAdiB,CAAnB;;AAiBA,WAAOJ,WAAP;AACD;;AAED,SAAO,EAAP;AACD","names":["SpeechSDK","ResultReason","RecognizingSpeech","RecognizedSpeech","result","maxAlternatives","Infinity","textNormalization","reason","json","NBest","resultList","confidence","transcript","text","isFinal","slice","map","Confidence","display","Display","itn","ITN","lexical","Lexical","maskedITN","MaskedITN"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/web-speech-cognitive-services/src/SpeechServices/SpeechToText/cognitiveServiceEventResultToWebSpeechRecognitionResultList.js"],"sourcesContent":["import arrayToMap from '../../Util/arrayToMap';\nimport SpeechSDK from '../SpeechSDK';\n\nconst {\n  ResultReason: { RecognizingSpeech, RecognizedSpeech }\n} = SpeechSDK;\n\nexport default function(result, { maxAlternatives = Infinity, textNormalization = 'display' } = {}) {\n  if (result.reason === RecognizingSpeech || (result.reason === RecognizedSpeech && !result.json.NBest)) {\n    const resultList = [\n      {\n        confidence: 0.5,\n        transcript: result.text\n      }\n    ];\n\n    if (result.reason === RecognizedSpeech) {\n      resultList.isFinal = true;\n    }\n\n    return resultList;\n  } else if (result.reason === RecognizedSpeech) {\n    const resultList = arrayToMap(\n      (result.json.NBest || [])\n        .slice(0, maxAlternatives)\n        .map(({ Confidence: confidence, Display: display, ITN: itn, Lexical: lexical, MaskedITN: maskedITN }) => ({\n          confidence,\n          transcript:\n            textNormalization === 'itn'\n              ? itn\n              : textNormalization === 'lexical'\n              ? lexical\n              : textNormalization === 'maskeditn'\n              ? maskedITN\n              : display\n        })),\n      { isFinal: true }\n    );\n\n    return resultList;\n  }\n\n  return [];\n}\n"]},"metadata":{},"sourceType":"script"}