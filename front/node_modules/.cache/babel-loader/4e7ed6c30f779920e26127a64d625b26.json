{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/dylanmurray/Sweng-2022/front/node_modules/@babel/runtime/regenerator/index.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkSupport = checkSupport;\nexports.default = downscaleImageToDataURLUsingWorker;\n\nvar _blobToArrayBuffer = _interopRequireDefault(require(\"./blobToArrayBuffer\"));\n\nvar _downscaleImageToDataURLUsingWorker = _interopRequireDefault(require(\"./downscaleImageToDataURLUsingWorker.worker\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction createWorker(fn) {\n  var blob = new Blob([\"(\".concat(fn, \")()\")], {\n    type: 'text/javascript'\n  });\n  var url = window.URL.createObjectURL(blob);\n  return new Promise(function (resolve, reject) {\n    var worker = new Worker(url);\n\n    worker.onerror = function (_ref) {\n      var error = _ref.error,\n          message = _ref.message;\n      return reject(error || new Error(message));\n    };\n\n    worker.onmessage = function (_ref2) {\n      var data = _ref2.data;\n      return data === 'ready' && resolve(worker);\n    };\n  }).finally(function () {\n    window.URL.revokeObjectURL(url);\n  });\n}\n\nvar workerPromise;\n\nfunction getWorker() {\n  return _getWorker.apply(this, arguments);\n} // We are using a lazy-check because:\n// 1. OffscreenCanvas.getContext has a toll\n// 2. Developers could bring polyfills\n\n\nfunction _getWorker() {\n  _getWorker = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var worker;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!workerPromise) {\n              _context3.next = 6;\n              break;\n            }\n\n            _context3.next = 3;\n            return workerPromise;\n\n          case 3:\n            worker = _context3.sent;\n            _context3.next = 11;\n            break;\n\n          case 6:\n            workerPromise = createWorker(_downscaleImageToDataURLUsingWorker.default);\n            _context3.next = 9;\n            return workerPromise;\n\n          case 9:\n            worker = _context3.sent;\n            worker.addEventListener('error', function () {\n              // Current worker errored out, will create a new worker next time.\n              workerPromise = null;\n              worker.terminate();\n            });\n\n          case 11:\n            return _context3.abrupt(\"return\", worker);\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getWorker.apply(this, arguments);\n}\n\nvar checkSupportOffscreenCanvas = function checkSupportOffscreenCanvas() {\n  var hasOffscreenCanvas = typeof window.OffscreenCanvas !== 'undefined' && (typeof window.OffscreenCanvas.prototype.convertToBlob !== 'undefined' || typeof window.OffscreenCanvas.prototype.toBlob !== 'undefined');\n  var isOffscreenCanvasSupportGetContext2D;\n\n  if (hasOffscreenCanvas) {\n    try {\n      new OffscreenCanvas(1, 1).getContext('2d');\n      isOffscreenCanvasSupportGetContext2D = true;\n    } catch (err) {\n      isOffscreenCanvasSupportGetContext2D = false;\n    }\n  }\n\n  return typeof window.createImageBitmap !== 'undefined' && hasOffscreenCanvas && isOffscreenCanvasSupportGetContext2D;\n};\n\nvar checkSupportWebWorkerPromise;\n\nfunction checkSupportWebWorker() {\n  return checkSupportWebWorkerPromise || (checkSupportWebWorkerPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var worker;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(typeof window.MessageChannel === 'undefined' || typeof window.Worker === 'undefined')) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\", false);\n\n          case 2:\n            _context.prev = 2;\n            _context.next = 5;\n            return createWorker('function(){postMessage(\"ready\")}');\n\n          case 5:\n            worker = _context.sent;\n            _context.next = 11;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](2);\n            return _context.abrupt(\"return\", false);\n\n          case 11:\n            worker.terminate();\n            return _context.abrupt(\"return\", true);\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[2, 8]]);\n  }))());\n}\n\nvar checkSupportPromise;\n\nfunction checkSupport() {\n  return checkSupportPromise || (checkSupportPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var results;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return Promise.all([checkSupportOffscreenCanvas(), checkSupportWebWorker()]);\n\n          case 3:\n            results = _context2.sent;\n            return _context2.abrupt(\"return\", results.every(function (result) {\n              return result;\n            }));\n\n          case 7:\n            _context2.prev = 7;\n            _context2.t0 = _context2[\"catch\"](0);\n            return _context2.abrupt(\"return\", false);\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 7]]);\n  }))());\n}\n\nfunction downscaleImageToDataURLUsingWorker(blob, maxWidth, maxHeight, type, quality) {\n  return new Promise(function (resolve, reject) {\n    var _MessageChannel = new MessageChannel(),\n        port1 = _MessageChannel.port1,\n        port2 = _MessageChannel.port2;\n\n    port1.onmessage = function (_ref5) {\n      var _ref5$data = _ref5.data,\n          error = _ref5$data.error,\n          result = _ref5$data.result;\n\n      if (error) {\n        var err = new Error(error.message);\n        err.stack = error.stack;\n        reject(err);\n      } else {\n        resolve(result);\n      }\n\n      port1.close();\n      port2.close();\n    };\n\n    Promise.all([(0, _blobToArrayBuffer.default)(blob), getWorker()]).then(function (_ref6) {\n      var _ref7 = _slicedToArray(_ref6, 2),\n          arrayBuffer = _ref7[0],\n          worker = _ref7[1];\n\n      return worker.postMessage({\n        arrayBuffer: arrayBuffer,\n        maxHeight: maxHeight,\n        maxWidth: maxWidth,\n        quality: quality,\n        type: type\n      }, [arrayBuffer, port2]);\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["createWorker","fn","blob","Blob","type","url","window","URL","createObjectURL","Promise","resolve","reject","worker","Worker","onerror","error","message","Error","onmessage","data","finally","revokeObjectURL","workerPromise","getWorker","_context3","workerFunction","addEventListener","terminate","checkSupportOffscreenCanvas","hasOffscreenCanvas","OffscreenCanvas","prototype","convertToBlob","toBlob","isOffscreenCanvasSupportGetContext2D","getContext","err","createImageBitmap","checkSupportWebWorkerPromise","checkSupportWebWorker","_asyncToGenerator","MessageChannel","_context","checkSupportPromise","checkSupport","_context2","all","results","every","result","downscaleImageToDataURLUsingWorker","maxWidth","maxHeight","quality","port1","port2","stack","close","then","arrayBuffer","postMessage"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-component/lib/src/Utils/downscaleImageToDataURL/downscaleImageToDataURLUsingWorker.js"],"sourcesContent":["import blobToArrayBuffer from './blobToArrayBuffer';\nimport workerFunction from './downscaleImageToDataURLUsingWorker.worker';\n\nfunction createWorker(fn) {\n  const blob = new Blob([`(${fn})()`], { type: 'text/javascript' });\n  const url = window.URL.createObjectURL(blob);\n\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(url);\n\n    worker.onerror = ({ error, message }) => reject(error || new Error(message));\n    worker.onmessage = ({ data }) => data === 'ready' && resolve(worker);\n  }).finally(() => {\n    window.URL.revokeObjectURL(url);\n  });\n}\n\nlet workerPromise;\n\nasync function getWorker() {\n  let worker;\n\n  if (workerPromise) {\n    worker = await workerPromise;\n  } else {\n    workerPromise = createWorker(workerFunction);\n\n    worker = await workerPromise;\n    worker.addEventListener('error', () => {\n      // Current worker errored out, will create a new worker next time.\n      workerPromise = null;\n      worker.terminate();\n    });\n  }\n\n  return worker;\n}\n\n// We are using a lazy-check because:\n// 1. OffscreenCanvas.getContext has a toll\n// 2. Developers could bring polyfills\n\nconst checkSupportOffscreenCanvas = () => {\n  const hasOffscreenCanvas =\n    typeof window.OffscreenCanvas !== 'undefined' &&\n    (typeof window.OffscreenCanvas.prototype.convertToBlob !== 'undefined' ||\n      typeof window.OffscreenCanvas.prototype.toBlob !== 'undefined');\n  let isOffscreenCanvasSupportGetContext2D;\n\n  if (hasOffscreenCanvas) {\n    try {\n      new OffscreenCanvas(1, 1).getContext('2d');\n      isOffscreenCanvasSupportGetContext2D = true;\n    } catch (err) {\n      isOffscreenCanvasSupportGetContext2D = false;\n    }\n  }\n\n  return typeof window.createImageBitmap !== 'undefined' && hasOffscreenCanvas && isOffscreenCanvasSupportGetContext2D;\n};\n\nlet checkSupportWebWorkerPromise;\n\nfunction checkSupportWebWorker() {\n  return (\n    checkSupportWebWorkerPromise ||\n    (checkSupportWebWorkerPromise = (async () => {\n      if (typeof window.MessageChannel === 'undefined' || typeof window.Worker === 'undefined') {\n        return false;\n      }\n\n      let worker;\n\n      try {\n        worker = await createWorker('function(){postMessage(\"ready\")}');\n      } catch (err) {\n        return false;\n      }\n\n      worker.terminate();\n\n      return true;\n    })())\n  );\n}\n\nlet checkSupportPromise;\n\nfunction checkSupport() {\n  return (\n    checkSupportPromise ||\n    (checkSupportPromise = (async () => {\n      try {\n        const results = await Promise.all([checkSupportOffscreenCanvas(), checkSupportWebWorker()]);\n\n        return results.every(result => result);\n      } catch (err) {\n        return false;\n      }\n    })())\n  );\n}\n\nexport default function downscaleImageToDataURLUsingWorker(blob, maxWidth, maxHeight, type, quality) {\n  return new Promise((resolve, reject) => {\n    const { port1, port2 } = new MessageChannel();\n\n    port1.onmessage = ({ data: { error, result } }) => {\n      if (error) {\n        const err = new Error(error.message);\n\n        err.stack = error.stack;\n\n        reject(err);\n      } else {\n        resolve(result);\n      }\n\n      port1.close();\n      port2.close();\n    };\n\n    Promise.all([blobToArrayBuffer(blob), getWorker()]).then(([arrayBuffer, worker]) =>\n      worker.postMessage({ arrayBuffer, maxHeight, maxWidth, quality, type }, [arrayBuffer, port2])\n    );\n  });\n}\n\nexport { checkSupport };\n"]},"metadata":{},"sourceType":"script"}