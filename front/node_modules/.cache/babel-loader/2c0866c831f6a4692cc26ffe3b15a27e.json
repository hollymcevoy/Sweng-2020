{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReplayableAudioNode = void 0;\n\nvar ReplayableAudioNode =\n/** @class */\nfunction () {\n  function ReplayableAudioNode(audioSource, bytesPerSecond) {\n    var _this = this;\n\n    this.privBuffers = [];\n    this.privReplayOffset = 0;\n    this.privLastShrinkOffset = 0;\n    this.privBufferStartOffset = 0;\n    this.privBufferSerial = 0;\n    this.privBufferedBytes = 0;\n    this.privReplay = false;\n    this.privLastChunkAcquiredTime = 0;\n\n    this.id = function () {\n      return _this.privAudioNode.id();\n    };\n\n    this.privAudioNode = audioSource;\n    this.privBytesPerSecond = bytesPerSecond;\n  } // Reads and returns the next chunk of audio buffer.\n  // If replay of existing buffers are needed, read() will first seek and replay\n  // existing content, and upoin completion it will read new content from the underlying\n  // audio node, saving that content into the replayable buffers.\n\n\n  ReplayableAudioNode.prototype.read = function () {\n    var _this = this; // if there is a replay request to honor.\n\n\n    if (!!this.privReplay && this.privBuffers.length !== 0) {\n      // Find the start point in the buffers.\n      // Offsets are in 100ns increments.\n      // So how many bytes do we need to seek to get the right offset?\n      var offsetToSeek = this.privReplayOffset - this.privBufferStartOffset;\n      var bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\n\n      if (0 !== bytesToSeek % 2) {\n        bytesToSeek++;\n      }\n\n      var i = 0;\n\n      while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\n        bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\n      }\n\n      if (i < this.privBuffers.length) {\n        var retVal = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);\n        this.privReplayOffset += retVal.byteLength / this.privBytesPerSecond * 1e+7; // If we've reached the end of the buffers, stop replaying.\n\n        if (i === this.privBuffers.length - 1) {\n          this.privReplay = false;\n        }\n\n        return Promise.resolve({\n          buffer: retVal,\n          isEnd: false,\n          timeReceived: this.privBuffers[i].chunk.timeReceived\n        });\n      }\n    }\n\n    return this.privAudioNode.read().then(function (result) {\n      if (result && result.buffer) {\n        _this.privBuffers.push(new BufferEntry(result, _this.privBufferSerial++, _this.privBufferedBytes));\n\n        _this.privBufferedBytes += result.buffer.byteLength;\n      }\n\n      return result;\n    });\n  };\n\n  ReplayableAudioNode.prototype.detach = function () {\n    this.privBuffers = undefined;\n    return this.privAudioNode.detach();\n  };\n\n  ReplayableAudioNode.prototype.replay = function () {\n    if (this.privBuffers && 0 !== this.privBuffers.length) {\n      this.privReplay = true;\n      this.privReplayOffset = this.privLastShrinkOffset;\n    }\n  }; // Shrinks the existing audio buffers to start at the new offset, or at the\n  // beginning of the buffer closest to the requested offset.\n  // A replay request will start from the last shrink point.\n\n\n  ReplayableAudioNode.prototype.shrinkBuffers = function (offset) {\n    if (this.privBuffers === undefined || this.privBuffers.length === 0) {\n      return;\n    }\n\n    this.privLastShrinkOffset = offset; // Find the start point in the buffers.\n    // Offsets are in 100ns increments.\n    // So how many bytes do we need to seek to get the right offset?\n\n    var offsetToSeek = offset - this.privBufferStartOffset;\n    var bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\n    var i = 0;\n\n    while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\n      bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\n    }\n\n    this.privBufferStartOffset = Math.round(offset - bytesToSeek / this.privBytesPerSecond * 1e+7);\n    this.privBuffers = this.privBuffers.slice(i);\n  }; // Finds the time a buffer of audio was first seen by offset.\n\n\n  ReplayableAudioNode.prototype.findTimeAtOffset = function (offset) {\n    if (offset < this.privBufferStartOffset || this.privBuffers === undefined) {\n      return 0;\n    }\n\n    for (var _i = 0, _a = this.privBuffers; _i < _a.length; _i++) {\n      var value = _a[_i];\n      var startOffset = value.byteOffset / this.privBytesPerSecond * 1e7;\n      var endOffset = startOffset + value.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;\n\n      if (offset >= startOffset && offset <= endOffset) {\n        return value.chunk.timeReceived;\n      }\n    }\n\n    return 0;\n  };\n\n  return ReplayableAudioNode;\n}();\n\nexports.ReplayableAudioNode = ReplayableAudioNode; // Primary use of this class is to help debugging problems with the replay\n// code. If the memory cost of alloc / dealloc gets too much, drop it and just use\n// the ArrayBuffer directly.\n// tslint:disable-next-line:max-classes-per-file\n\nvar BufferEntry =\n/** @class */\nfunction () {\n  function BufferEntry(chunk, serial, byteOffset) {\n    this.chunk = chunk;\n    this.serial = serial;\n    this.byteOffset = byteOffset;\n  }\n\n  return BufferEntry;\n}();","map":{"version":3,"mappings":"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","names":["audioSource","bytesPerSecond","_this","privAudioNode","id","privBytesPerSecond","ReplayableAudioNode","privReplay","privBuffers","length","offsetToSeek","privReplayOffset","privBufferStartOffset","bytesToSeek","Math","round","i","chunk","buffer","byteLength","retVal","slice","Promise","resolve","isEnd","timeReceived","read","then","result","push","BufferEntry","privBufferSerial","privBufferedBytes","undefined","detach","privLastShrinkOffset","offset","_i","value","startOffset","byteOffset","endOffset","exports","serial"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/src/common.browser/ReplayableAudioNode.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { AudioStreamFormatImpl } from \"../../src/sdk/Audio/AudioStreamFormat\";\r\nimport {\r\n    IAudioStreamNode,\r\n    IStreamChunk,\r\n} from \"../common/Exports\";\r\n\r\nexport class ReplayableAudioNode implements IAudioStreamNode {\r\n    private privAudioNode: IAudioStreamNode;\r\n    private privBytesPerSecond: number;\r\n    private privBuffers: BufferEntry[] = [];\r\n    private privReplayOffset: number = 0;\r\n    private privLastShrinkOffset: number = 0;\r\n    private privBufferStartOffset: number = 0;\r\n    private privBufferSerial: number = 0;\r\n    private privBufferedBytes: number = 0;\r\n    private privReplay: boolean = false;\r\n    private privLastChunkAcquiredTime: number = 0;\r\n\r\n    public constructor(audioSource: IAudioStreamNode, bytesPerSecond: number) {\r\n        this.privAudioNode = audioSource;\r\n        this.privBytesPerSecond = bytesPerSecond;\r\n    }\r\n\r\n    public id = (): string => {\r\n        return this.privAudioNode.id();\r\n    }\r\n\r\n    // Reads and returns the next chunk of audio buffer.\r\n    // If replay of existing buffers are needed, read() will first seek and replay\r\n    // existing content, and upoin completion it will read new content from the underlying\r\n    // audio node, saving that content into the replayable buffers.\r\n    public read(): Promise<IStreamChunk<ArrayBuffer>> {\r\n        // if there is a replay request to honor.\r\n        if (!!this.privReplay && this.privBuffers.length !== 0) {\r\n            // Find the start point in the buffers.\r\n            // Offsets are in 100ns increments.\r\n            // So how many bytes do we need to seek to get the right offset?\r\n            const offsetToSeek: number = this.privReplayOffset - this.privBufferStartOffset;\r\n\r\n            let bytesToSeek: number = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\r\n            if (0 !== (bytesToSeek % 2)) {\r\n                bytesToSeek++;\r\n            }\r\n\r\n            let i: number = 0;\r\n\r\n            while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\r\n                bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\r\n            }\r\n\r\n            if (i < this.privBuffers.length) {\r\n                const retVal: ArrayBuffer = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);\r\n\r\n                this.privReplayOffset += (retVal.byteLength / this.privBytesPerSecond) * 1e+7;\r\n\r\n                // If we've reached the end of the buffers, stop replaying.\r\n                if (i === this.privBuffers.length - 1) {\r\n                    this.privReplay = false;\r\n                }\r\n\r\n                return Promise.resolve<IStreamChunk<ArrayBuffer>>({\r\n                    buffer: retVal,\r\n                    isEnd: false,\r\n                    timeReceived: this.privBuffers[i].chunk.timeReceived,\r\n                });\r\n            }\r\n        }\r\n\r\n        return this.privAudioNode.read()\r\n            .then((result: IStreamChunk<ArrayBuffer>) => {\r\n                if (result && result.buffer) {\r\n                    this.privBuffers.push(new BufferEntry(result, this.privBufferSerial++, this.privBufferedBytes));\r\n                    this.privBufferedBytes += result.buffer.byteLength;\r\n                }\r\n                return result;\r\n            });\r\n    }\r\n\r\n    public detach(): Promise<void> {\r\n        this.privBuffers = undefined;\r\n        return this.privAudioNode.detach();\r\n    }\r\n\r\n    public replay(): void {\r\n        if (this.privBuffers && 0 !== this.privBuffers.length) {\r\n            this.privReplay = true;\r\n            this.privReplayOffset = this.privLastShrinkOffset;\r\n        }\r\n    }\r\n\r\n    // Shrinks the existing audio buffers to start at the new offset, or at the\r\n    // beginning of the buffer closest to the requested offset.\r\n    // A replay request will start from the last shrink point.\r\n    public shrinkBuffers(offset: number): void {\r\n        if (this.privBuffers === undefined || this.privBuffers.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this.privLastShrinkOffset = offset;\r\n\r\n        // Find the start point in the buffers.\r\n        // Offsets are in 100ns increments.\r\n        // So how many bytes do we need to seek to get the right offset?\r\n        const offsetToSeek: number = offset - this.privBufferStartOffset;\r\n\r\n        let bytesToSeek: number = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);\r\n\r\n        let i: number = 0;\r\n\r\n        while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {\r\n            bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;\r\n        }\r\n        this.privBufferStartOffset = Math.round(offset - ((bytesToSeek / this.privBytesPerSecond) * 1e+7));\r\n        this.privBuffers = this.privBuffers.slice(i);\r\n    }\r\n\r\n    // Finds the time a buffer of audio was first seen by offset.\r\n    public findTimeAtOffset(offset: number): number {\r\n        if (offset < this.privBufferStartOffset || this.privBuffers === undefined) {\r\n            return 0;\r\n        }\r\n\r\n        for (const value of this.privBuffers) {\r\n            const startOffset: number = (value.byteOffset / this.privBytesPerSecond) * 1e7;\r\n            const endOffset: number = startOffset + ((value.chunk.buffer.byteLength / this.privBytesPerSecond) * 1e7);\r\n\r\n            if (offset >= startOffset && offset <= endOffset) {\r\n                return value.chunk.timeReceived;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    }\r\n}\r\n\r\n// Primary use of this class is to help debugging problems with the replay\r\n// code. If the memory cost of alloc / dealloc gets too much, drop it and just use\r\n// the ArrayBuffer directly.\r\n// tslint:disable-next-line:max-classes-per-file\r\nclass BufferEntry {\r\n    public chunk: IStreamChunk<ArrayBuffer>;\r\n    public serial: number;\r\n    public byteOffset: number;\r\n\r\n    public constructor(chunk: IStreamChunk<ArrayBuffer>, serial: number, byteOffset: number) {\r\n        this.chunk = chunk;\r\n        this.serial = serial;\r\n        this.byteOffset = byteOffset;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}