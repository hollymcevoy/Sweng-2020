{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function (d, b) {\n  for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n\nvar root_1 = require('../util/root');\n\nvar Observable_1 = require('../Observable');\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\n\n\nvar PromiseObservable = function (_super) {\n  __extends(PromiseObservable, _super);\n\n  function PromiseObservable(promise, scheduler) {\n    _super.call(this);\n\n    this.promise = promise;\n    this.scheduler = scheduler;\n  }\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n\n\n  PromiseObservable.create = function (promise, scheduler) {\n    return new PromiseObservable(promise, scheduler);\n  };\n  /** @deprecated internal use only */\n\n\n  PromiseObservable.prototype._subscribe = function (subscriber) {\n    var _this = this;\n\n    var promise = this.promise;\n    var scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(function (value) {\n          _this.value = value;\n          _this._isScalar = true;\n\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        }, function (err) {\n          if (!subscriber.closed) {\n            subscriber.error(err);\n          }\n        }).then(null, function (err) {\n          // escape the promise trap, throw unhandled errors\n          root_1.root.setTimeout(function () {\n            throw err;\n          });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, {\n            value: this.value,\n            subscriber: subscriber\n          });\n        }\n      } else {\n        promise.then(function (value) {\n          _this.value = value;\n          _this._isScalar = true;\n\n          if (!subscriber.closed) {\n            subscriber.add(scheduler.schedule(dispatchNext, 0, {\n              value: value,\n              subscriber: subscriber\n            }));\n          }\n        }, function (err) {\n          if (!subscriber.closed) {\n            subscriber.add(scheduler.schedule(dispatchError, 0, {\n              err: err,\n              subscriber: subscriber\n            }));\n          }\n        }).then(null, function (err) {\n          // escape the promise trap, throw unhandled errors\n          root_1.root.setTimeout(function () {\n            throw err;\n          });\n        });\n      }\n    }\n  };\n\n  return PromiseObservable;\n}(Observable_1.Observable);\n\nexports.PromiseObservable = PromiseObservable;\n\nfunction dispatchNext(arg) {\n  var value = arg.value,\n      subscriber = arg.subscriber;\n\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\n\nfunction dispatchError(arg) {\n  var err = arg.err,\n      subscriber = arg.subscriber;\n\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n}","map":{"version":3,"mappings":"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","names":["__extends","promise","scheduler","_super","PromiseObservable","subscriber","_isScalar","closed","next","value","complete","then","_this","err","error","root_1","setTimeout","schedule","dispatchNext","add","dispatchError","Observable_1","exports","arg"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/src/observable/PromiseObservable.ts"],"sourcesContent":["import { root } from '../util/root';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class PromiseObservable<T> extends Observable<T> {\n\n  public value: T;\n\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n  static create<T>(promise: PromiseLike<T>, scheduler?: IScheduler): Observable<T> {\n    return new PromiseObservable(promise, scheduler);\n  }\n\n  constructor(private promise: PromiseLike<T>, private scheduler?: IScheduler) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const promise = this.promise;\n    const scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.next(value);\n              subscriber.complete();\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.error(err);\n            }\n          }\n        )\n        .then(null, err => {\n          // escape the promise trap, throw unhandled errors\n          root.setTimeout(() => { throw err; });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber });\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchNext, 0, { value, subscriber }));\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchError, 0, { err, subscriber }));\n            }\n          })\n          .then(null, (err) => {\n            // escape the promise trap, throw unhandled errors\n            root.setTimeout(() => { throw err; });\n          });\n      }\n    }\n  }\n}\n\ninterface DispatchNextArg<T> {\n  subscriber: Subscriber<T>;\n  value: T;\n}\nfunction dispatchNext<T>(arg: DispatchNextArg<T>) {\n  const { value, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\n\ninterface DispatchErrorArg<T> {\n  subscriber: Subscriber<T>;\n  err: any;\n}\nfunction dispatchError<T>(arg: DispatchErrorArg<T>) {\n  const { err, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}