{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectLineStreaming = void 0;\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _BehaviorSubject = require(\"rxjs/BehaviorSubject\");\n\nvar _buffer = require(\"buffer\");\n\nvar _Observable = require(\"rxjs/Observable\");\n\nvar BFSE = _interopRequireWildcard(require(\"botframework-streaming\"));\n\nvar _crossFetch = _interopRequireDefault(require(\"cross-fetch\"));\n\nvar _directLine = require(\"./directLine\");\n\nvar _excluded = [\"attachments\"];\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar DIRECT_LINE_VERSION = 'DirectLine/3.0';\nvar MAX_RETRY_COUNT = 3;\nvar refreshTokenLifetime = 30 * 60 * 1000; //const refreshTokenLifetime = 5000;\n\nvar timeout = 20 * 1000;\nvar refreshTokenInterval = refreshTokenLifetime / 2;\n\nvar StreamHandler = /*#__PURE__*/function () {\n  function StreamHandler(s, c$, sq) {\n    (0, _classCallCheck2[\"default\"])(this, StreamHandler);\n    (0, _defineProperty2[\"default\"])(this, \"activityQueue\", []);\n    this.subscriber = s;\n    this.connectionStatus$ = c$;\n    this.shouldQueue = sq;\n  }\n\n  (0, _createClass2[\"default\"])(StreamHandler, [{\n    key: \"setSubscriber\",\n    value: function setSubscriber(s) {\n      this.subscriber = s;\n    }\n  }, {\n    key: \"processRequest\",\n    value: function () {\n      var _processRequest = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(request, logger) {\n        var streams, stream0, activitySetJson, activitySet, activity, attachments, stream, attachment, dataUri;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                streams = (0, _toConsumableArray2[\"default\"])(request.streams);\n                stream0 = streams.shift();\n                _context.next = 4;\n                return stream0.readAsString();\n\n              case 4:\n                activitySetJson = _context.sent;\n                activitySet = JSON.parse(activitySetJson);\n\n                if (!(activitySet.activities.length !== 1)) {\n                  _context.next = 9;\n                  break;\n                } // Only one activity is expected in a set in streaming\n\n\n                this.subscriber.error(new Error('there should be exactly one activity'));\n                return _context.abrupt(\"return\", BFSE.StreamingResponse.create(500));\n\n              case 9:\n                activity = activitySet.activities[0];\n\n                if (!(streams.length > 0)) {\n                  _context.next = 21;\n                  break;\n                }\n\n                attachments = (0, _toConsumableArray2[\"default\"])(activity.attachments);\n\n              case 12:\n                if (!(stream = streams.shift())) {\n                  _context.next = 20;\n                  break;\n                }\n\n                _context.next = 15;\n                return stream.readAsString();\n\n              case 15:\n                attachment = _context.sent;\n                dataUri = \"data:text/plain;base64,\" + attachment;\n                attachments.push({\n                  contentType: stream.contentType,\n                  contentUrl: dataUri\n                });\n                _context.next = 12;\n                break;\n\n              case 20:\n                activity.attachments = attachments;\n\n              case 21:\n                if (this.shouldQueue()) {\n                  this.activityQueue.push(activity);\n                } else {\n                  this.subscriber.next(activity);\n                }\n\n                return _context.abrupt(\"return\", BFSE.StreamingResponse.create(200));\n\n              case 23:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function processRequest(_x, _x2) {\n        return _processRequest.apply(this, arguments);\n      }\n\n      return processRequest;\n    }()\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var _this = this;\n\n      this.connectionStatus$.subscribe(function (cs) {});\n      this.activityQueue.forEach(function (a) {\n        return _this.subscriber.next(a);\n      });\n      this.activityQueue = [];\n    }\n  }]);\n  return StreamHandler;\n}();\n\nvar DirectLineStreaming = /*#__PURE__*/function () {\n  function DirectLineStreaming(options) {\n    var _this2 = this;\n\n    (0, _classCallCheck2[\"default\"])(this, DirectLineStreaming);\n    (0, _defineProperty2[\"default\"])(this, \"connectionStatus$\", new _BehaviorSubject.BehaviorSubject(_directLine.ConnectionStatus.Uninitialized));\n    (0, _defineProperty2[\"default\"])(this, \"_botAgent\", '');\n    this.token = options.token;\n    this.refreshToken();\n    this.domain = options.domain;\n\n    if (options.conversationId) {\n      this.conversationId = options.conversationId;\n    }\n\n    this._botAgent = this.getBotAgent(options.botAgent);\n    this.queueActivities = true;\n    this.activity$ = _Observable.Observable.create( /*#__PURE__*/function () {\n      var _ref = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(subscriber) {\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _this2.activitySubscriber = subscriber;\n                _this2.theStreamHandler = new StreamHandler(subscriber, _this2.connectionStatus$, function () {\n                  return _this2.queueActivities;\n                });\n\n                _this2.connectWithRetryAsync();\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x3) {\n        return _ref.apply(this, arguments);\n      };\n    }()).share();\n  }\n\n  (0, _createClass2[\"default\"])(DirectLineStreaming, [{\n    key: \"reconnect\",\n    value: function reconnect(_ref2) {\n      var conversationId = _ref2.conversationId,\n          token = _ref2.token;\n      this.conversationId = conversationId;\n      this.token = token;\n      this.connectAsync();\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      this.connectionStatus$.next(_directLine.ConnectionStatus.Ended);\n      this.streamConnection.disconnect();\n    }\n  }, {\n    key: \"commonHeaders\",\n    value: function commonHeaders() {\n      return {\n        \"Authorization\": \"Bearer \".concat(this.token),\n        \"x-ms-bot-agent\": this._botAgent\n      };\n    }\n  }, {\n    key: \"getBotAgent\",\n    value: function getBotAgent() {\n      var customAgent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var clientAgent = 'directlineStreaming';\n\n      if (customAgent) {\n        clientAgent += \"; \".concat(customAgent);\n      }\n\n      return \"\".concat(DIRECT_LINE_VERSION, \" (\").concat(clientAgent, \")\");\n    }\n  }, {\n    key: \"refreshToken\",\n    value: function () {\n      var _refreshToken = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3() {\n        var firstCall,\n            retryCount,\n            numberOfAttempts,\n            res,\n            _yield$res$json,\n            token,\n            _args3 = arguments;\n\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                firstCall = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : true;\n                retryCount = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 0;\n                _context3.next = 4;\n                return this.waitUntilOnline();\n\n              case 4:\n                numberOfAttempts = 0;\n\n              case 5:\n                if (!(numberOfAttempts < MAX_RETRY_COUNT)) {\n                  _context3.next = 30;\n                  break;\n                }\n\n                numberOfAttempts++;\n                _context3.next = 9;\n                return new Promise(function (r) {\n                  return setTimeout(r, refreshTokenInterval);\n                });\n\n              case 9:\n                _context3.prev = 9;\n                _context3.next = 12;\n                return (0, _crossFetch[\"default\"])(\"\".concat(this.domain, \"/tokens/refresh\"), {\n                  method: \"POST\",\n                  headers: this.commonHeaders()\n                });\n\n              case 12:\n                res = _context3.sent;\n\n                if (!res.ok) {\n                  _context3.next = 22;\n                  break;\n                }\n\n                numberOfAttempts = 0;\n                _context3.next = 17;\n                return res.json();\n\n              case 17:\n                _yield$res$json = _context3.sent;\n                token = _yield$res$json.token;\n                this.token = token;\n                _context3.next = 23;\n                break;\n\n              case 22:\n                if (res.status === 403 || res.status === 403) {\n                  console.error(\"Fatal error while refreshing the token: \".concat(res.status, \" \").concat(res.statusText));\n                  this.streamConnection.disconnect();\n                } else {\n                  console.warn(\"Refresh attempt #\".concat(numberOfAttempts, \" failed: \").concat(res.status, \" \").concat(res.statusText));\n                }\n\n              case 23:\n                _context3.next = 28;\n                break;\n\n              case 25:\n                _context3.prev = 25;\n                _context3.t0 = _context3[\"catch\"](9);\n                console.warn(\"Refresh attempt #\".concat(numberOfAttempts, \" threw an exception: \").concat(_context3.t0));\n\n              case 28:\n                _context3.next = 5;\n                break;\n\n              case 30:\n                console.error(\"Retries exhausted\");\n                this.streamConnection.disconnect();\n\n              case 32:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[9, 25]]);\n      }));\n\n      function refreshToken() {\n        return _refreshToken.apply(this, arguments);\n      }\n\n      return refreshToken;\n    }()\n  }, {\n    key: \"postActivity\",\n    value: function postActivity(activity) {\n      var _this3 = this;\n\n      if (activity.type === \"message\" && activity.attachments && activity.attachments.length > 0) {\n        return this.postMessageWithAttachments(activity);\n      }\n\n      var resp$ = _Observable.Observable.create( /*#__PURE__*/function () {\n        var _ref3 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4(subscriber) {\n          var request, resp, numberOfStreams, idString, _JSON$parse, id;\n\n          return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  request = BFSE.StreamingRequest.create('POST', '/v3/directline/conversations/' + _this3.conversationId + '/activities');\n                  request.setBody(JSON.stringify(activity));\n                  _context4.next = 4;\n                  return _this3.streamConnection.send(request);\n\n                case 4:\n                  resp = _context4.sent;\n                  _context4.prev = 5;\n\n                  if (!(resp.statusCode !== 200)) {\n                    _context4.next = 8;\n                    break;\n                  }\n\n                  throw new Error(\"PostActivity returned \" + resp.statusCode);\n\n                case 8:\n                  numberOfStreams = resp.streams.length;\n\n                  if (!(numberOfStreams !== 1)) {\n                    _context4.next = 11;\n                    break;\n                  }\n\n                  throw new Error(\"Expected one stream but got \" + numberOfStreams);\n\n                case 11:\n                  _context4.next = 13;\n                  return resp.streams[0].readAsString();\n\n                case 13:\n                  idString = _context4.sent;\n                  _JSON$parse = JSON.parse(idString), id = _JSON$parse.Id;\n                  return _context4.abrupt(\"return\", subscriber.next(id));\n\n                case 18:\n                  _context4.prev = 18;\n                  _context4.t0 = _context4[\"catch\"](5); // If there is a network issue then its handled by\n                  // the disconnectionHandler. Everything else can\n                  // be retried\n\n                  console.warn(_context4.t0);\n\n                  _this3.streamConnection.disconnect();\n\n                  return _context4.abrupt(\"return\", subscriber.error(_context4.t0));\n\n                case 23:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, null, [[5, 18]]);\n        }));\n\n        return function (_x4) {\n          return _ref3.apply(this, arguments);\n        };\n      }());\n\n      return resp$;\n    }\n  }, {\n    key: \"postMessageWithAttachments\",\n    value: function postMessageWithAttachments(message) {\n      var _this4 = this;\n\n      var attachments = message.attachments,\n          messageWithoutAttachments = (0, _objectWithoutProperties2[\"default\"])(message, _excluded);\n      return _Observable.Observable.create(function (subscriber) {\n        var httpContentList = [];\n        (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee6() {\n          var arrayBuffers, url, request, activityStream, resp, _yield$resp$streams$, id;\n\n          return _regenerator[\"default\"].wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  _context6.prev = 0;\n                  _context6.next = 3;\n                  return Promise.all(attachments.map( /*#__PURE__*/function () {\n                    var _ref5 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee5(attachment) {\n                      var media, res;\n                      return _regenerator[\"default\"].wrap(function _callee5$(_context5) {\n                        while (1) {\n                          switch (_context5.prev = _context5.next) {\n                            case 0:\n                              media = attachment;\n                              _context5.next = 3;\n                              return (0, _crossFetch[\"default\"])(media.contentUrl);\n\n                            case 3:\n                              res = _context5.sent;\n\n                              if (!res.ok) {\n                                _context5.next = 12;\n                                break;\n                              }\n\n                              _context5.next = 7;\n                              return res.arrayBuffer();\n\n                            case 7:\n                              _context5.t0 = _context5.sent;\n                              _context5.t1 = media;\n                              return _context5.abrupt(\"return\", {\n                                arrayBuffer: _context5.t0,\n                                media: _context5.t1\n                              });\n\n                            case 12:\n                              throw new Error('...');\n\n                            case 13:\n                            case \"end\":\n                              return _context5.stop();\n                          }\n                        }\n                      }, _callee5);\n                    }));\n\n                    return function (_x5) {\n                      return _ref5.apply(this, arguments);\n                    };\n                  }()));\n\n                case 3:\n                  arrayBuffers = _context6.sent;\n                  arrayBuffers.forEach(function (_ref6) {\n                    var arrayBuffer = _ref6.arrayBuffer,\n                        media = _ref6.media;\n\n                    var buffer = _buffer.Buffer.from(arrayBuffer);\n\n                    console.log(buffer);\n                    var stream = new BFSE.SubscribableStream();\n                    stream.write(buffer);\n                    var httpContent = new BFSE.HttpContent({\n                      type: media.contentType,\n                      contentLength: buffer.length\n                    }, stream);\n                    httpContentList.push(httpContent);\n                  });\n                  url = \"/v3/directline/conversations/\".concat(_this4.conversationId, \"/users/\").concat(messageWithoutAttachments.from.id, \"/upload\");\n                  request = BFSE.StreamingRequest.create('PUT', url);\n                  activityStream = new BFSE.SubscribableStream();\n                  activityStream.write(JSON.stringify(messageWithoutAttachments), 'utf-8');\n                  request.addStream(new BFSE.HttpContent({\n                    type: \"application/vnd.microsoft.activity\",\n                    contentLength: activityStream.length\n                  }, activityStream));\n                  httpContentList.forEach(function (e) {\n                    return request.addStream(e);\n                  });\n                  _context6.next = 13;\n                  return _this4.streamConnection.send(request);\n\n                case 13:\n                  resp = _context6.sent;\n\n                  if (!(resp.streams && resp.streams.length !== 1)) {\n                    _context6.next = 18;\n                    break;\n                  }\n\n                  subscriber.error(new Error(\"Invalid stream count \".concat(resp.streams.length)));\n                  _context6.next = 23;\n                  break;\n\n                case 18:\n                  _context6.next = 20;\n                  return resp.streams[0].readAsJson();\n\n                case 20:\n                  _yield$resp$streams$ = _context6.sent;\n                  id = _yield$resp$streams$.Id;\n                  subscriber.next(id);\n\n                case 23:\n                  _context6.next = 28;\n                  break;\n\n                case 25:\n                  _context6.prev = 25;\n                  _context6.t0 = _context6[\"catch\"](0);\n                  subscriber.error(_context6.t0);\n\n                case 28:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, null, [[0, 25]]);\n        }))();\n      });\n    }\n  }, {\n    key: \"waitUntilOnline\",\n    value: function () {\n      var _waitUntilOnline = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee7() {\n        var _this5 = this;\n\n        return _regenerator[\"default\"].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                return _context7.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this5.connectionStatus$.subscribe(function (cs) {\n                    if (cs === _directLine.ConnectionStatus.Online) return resolve();\n                  }, function (e) {\n                    return reject(e);\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function waitUntilOnline() {\n        return _waitUntilOnline.apply(this, arguments);\n      }\n\n      return waitUntilOnline;\n    }()\n  }, {\n    key: \"connectAsync\",\n    value: function () {\n      var _connectAsync = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee9() {\n        var _this6 = this;\n\n        var re, params, urlSearchParams, wsUrl;\n        return _regenerator[\"default\"].wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                re = new RegExp('^http(s?)');\n\n                if (re.test(this.domain)) {\n                  _context9.next = 3;\n                  break;\n                }\n\n                throw \"Domain must begin with http or https\";\n\n              case 3:\n                params = {\n                  token: this.token\n                };\n                if (this.conversationId) params['conversationId'] = this.conversationId;\n                urlSearchParams = new URLSearchParams(params).toString();\n                wsUrl = \"\".concat(this.domain.replace(re, 'ws$1'), \"/conversations/connect?\").concat(urlSearchParams);\n                return _context9.abrupt(\"return\", new Promise( /*#__PURE__*/function () {\n                  var _ref7 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee8(resolve, reject) {\n                    var request, response, responseString, conversation;\n                    return _regenerator[\"default\"].wrap(function _callee8$(_context8) {\n                      while (1) {\n                        switch (_context8.prev = _context8.next) {\n                          case 0:\n                            _context8.prev = 0;\n                            _this6.streamConnection = new BFSE.WebSocketClient({\n                              url: wsUrl,\n                              requestHandler: _this6.theStreamHandler,\n                              disconnectionHandler: function disconnectionHandler(e) {\n                                return resolve(e);\n                              }\n                            });\n                            _this6.queueActivities = true;\n                            _context8.next = 5;\n                            return _this6.streamConnection.connect();\n\n                          case 5:\n                            request = BFSE.StreamingRequest.create('POST', '/v3/directline/conversations');\n                            _context8.next = 8;\n                            return _this6.streamConnection.send(request);\n\n                          case 8:\n                            response = _context8.sent;\n\n                            if (!(response.statusCode !== 200)) {\n                              _context8.next = 11;\n                              break;\n                            }\n\n                            throw new Error(\"Connection response code \" + response.statusCode);\n\n                          case 11:\n                            if (!(response.streams.length !== 1)) {\n                              _context8.next = 13;\n                              break;\n                            }\n\n                            throw new Error(\"Expected 1 stream but got \" + response.streams.length);\n\n                          case 13:\n                            _context8.next = 15;\n                            return response.streams[0].readAsString();\n\n                          case 15:\n                            responseString = _context8.sent;\n                            conversation = JSON.parse(responseString);\n                            _this6.conversationId = conversation.conversationId;\n\n                            _this6.connectionStatus$.next(_directLine.ConnectionStatus.Online); // Wait until DL consumers have had a chance to be notified\n                            // of the connection status change.\n\n\n                            _context8.next = 21;\n                            return _this6.waitUntilOnline();\n\n                          case 21:\n                            _this6.theStreamHandler.flush();\n\n                            _this6.queueActivities = false;\n                            _context8.next = 28;\n                            break;\n\n                          case 25:\n                            _context8.prev = 25;\n                            _context8.t0 = _context8[\"catch\"](0);\n                            reject(_context8.t0);\n\n                          case 28:\n                          case \"end\":\n                            return _context8.stop();\n                        }\n                      }\n                    }, _callee8, null, [[0, 25]]);\n                  }));\n\n                  return function (_x6, _x7) {\n                    return _ref7.apply(this, arguments);\n                  };\n                }()));\n\n              case 8:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function connectAsync() {\n        return _connectAsync.apply(this, arguments);\n      }\n\n      return connectAsync;\n    }()\n  }, {\n    key: \"connectWithRetryAsync\",\n    value: function () {\n      var _connectWithRetryAsync = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee10() {\n        var _this7 = this;\n\n        var numRetries, start, res;\n        return _regenerator[\"default\"].wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                numRetries = MAX_RETRY_COUNT;\n\n              case 1:\n                if (!(numRetries > 0)) {\n                  _context10.next = 23;\n                  break;\n                }\n\n                numRetries--;\n                start = Date.now();\n                _context10.prev = 4;\n                this.connectionStatus$.next(_directLine.ConnectionStatus.Connecting);\n                _context10.next = 8;\n                return this.connectAsync();\n\n              case 8:\n                res = _context10.sent;\n                console.warn(\"Retrying connection \".concat(res));\n\n                if (!(60000 < Date.now() - start)) {\n                  _context10.next = 13;\n                  break;\n                } // reset the retry counter and retry immediately\n                // if the connection lasted for more than a minute\n\n\n                numRetries = MAX_RETRY_COUNT;\n                return _context10.abrupt(\"continue\", 1);\n\n              case 13:\n                _context10.next = 19;\n                break;\n\n              case 15:\n                _context10.prev = 15;\n                _context10.t0 = _context10[\"catch\"](4);\n                console.error(\"Failed to connect \".concat(_context10.t0));\n                throw _context10.t0;\n\n              case 19:\n                _context10.next = 21;\n                return new Promise(function (r) {\n                  return setTimeout(r, _this7.getRetryDelay());\n                });\n\n              case 21:\n                _context10.next = 1;\n                break;\n\n              case 23:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[4, 15]]);\n      }));\n\n      function connectWithRetryAsync() {\n        return _connectWithRetryAsync.apply(this, arguments);\n      }\n\n      return connectWithRetryAsync;\n    }() // Returns the delay duration in milliseconds\n\n  }, {\n    key: \"getRetryDelay\",\n    value: function getRetryDelay() {\n      return Math.floor(3000 + Math.random() * 12000);\n    }\n  }]);\n  return DirectLineStreaming;\n}();\n\nexports.DirectLineStreaming = DirectLineStreaming;","map":{"version":3,"mappings":"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","names":["DIRECT_LINE_VERSION","MAX_RETRY_COUNT","refreshTokenLifetime","timeout","refreshTokenInterval","StreamHandler","s","c$","sq","subscriber","connectionStatus$","shouldQueue","request","logger","streams","stream0","shift","_context","readAsString","activitySetJson","activitySet","JSON","parse","activities","length","error","Error","BFSE","StreamingResponse","create","activity","attachments","stream","attachment","dataUri","push","contentType","contentUrl","activityQueue","next","subscribe","forEach","a","_this","DirectLineStreaming","options","BehaviorSubject","ConnectionStatus","Uninitialized","token","refreshToken","domain","conversationId","_botAgent","getBotAgent","botAgent","queueActivities","activity$","Observable","_this2","activitySubscriber","theStreamHandler","connectWithRetryAsync","share","connectAsync","Ended","streamConnection","disconnect","customAgent","clientAgent","firstCall","retryCount","_context3","waitUntilOnline","numberOfAttempts","Promise","setTimeout","r","method","headers","commonHeaders","res","ok","json","_yield$res$json","status","console","statusText","warn","type","postMessageWithAttachments","resp$","StreamingRequest","_this3","setBody","stringify","_context4","send","resp","statusCode","numberOfStreams","idString","_JSON$parse","id","Id","message","messageWithoutAttachments","httpContentList","_context6","all","map","media","_context5","arrayBuffer","arrayBuffers","buffer","Buffer","from","log","SubscribableStream","write","httpContent","HttpContent","contentLength","url","_this4","activityStream","addStream","e","readAsJson","_yield$resp$streams$","resolve","reject","_this5","cs","Online","re","RegExp","test","_context9","params","urlSearchParams","URLSearchParams","toString","wsUrl","replace","_context8","_this6","WebSocketClient","requestHandler","disconnectionHandler","connect","response","responseString","conversation","flush","numRetries","_context10","start","Date","now","Connecting","_this7","getRetryDelay","Math","floor","random"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-directlinejs/src/directLineStreaming.ts"],"sourcesContent":["// In order to keep file size down, only import the parts of rxjs that we use\n\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\nimport { Buffer } from 'buffer';\nimport { Observable } from 'rxjs/Observable';\nimport { Subscriber } from 'rxjs/Subscriber';\nimport * as BFSE from 'botframework-streaming';\nimport fetch from 'cross-fetch';\n\nimport {\n  Activity,\n  ConnectionStatus,\n  Conversation,\n  IBotConnection,\n  Media,\n  Message\n} from './directLine';\n\nconst DIRECT_LINE_VERSION = 'DirectLine/3.0';\nconst MAX_RETRY_COUNT = 3;\nconst refreshTokenLifetime = 30 * 60 * 1000;\n//const refreshTokenLifetime = 5000;\nconst timeout = 20 * 1000;\nconst refreshTokenInterval = refreshTokenLifetime / 2;\n\ninterface DirectLineStreamingOptions {\n  token: string,\n  conversationId?: string,\n  domain: string,\n  // Attached to all requests to identify requesting agent.\n  botAgent?: string\n}\n\nclass StreamHandler implements BFSE.RequestHandler {\n  private connectionStatus$;\n  private subscriber: Subscriber<Activity>;\n  private shouldQueue: () => boolean;\n  private activityQueue: Array<Activity> = [];\n\n  constructor(s: Subscriber<Activity>, c$: Observable<ConnectionStatus>, sq: () => boolean) {\n    this.subscriber = s;\n    this.connectionStatus$ = c$;\n    this.shouldQueue = sq;\n  }\n\n  public setSubscriber(s: Subscriber<Activity>) {\n    this.subscriber = s;\n  }\n\n  async processRequest(request: BFSE.IReceiveRequest, logger?: any): Promise<BFSE.StreamingResponse> {\n    const streams = [...request.streams];\n    const stream0 = streams.shift();\n    const activitySetJson = await stream0.readAsString();\n    const activitySet = JSON.parse(activitySetJson);\n\n    if (activitySet.activities.length !== 1) {\n      // Only one activity is expected in a set in streaming\n      this.subscriber.error(new Error('there should be exactly one activity'));\n      return BFSE.StreamingResponse.create(500);\n    }\n\n    const activity = activitySet.activities[0];\n\n    if (streams.length > 0) {\n      const attachments = [...activity.attachments];\n\n      let stream: BFSE.ContentStream;\n      while (stream = streams.shift()) {\n        const attachment = await stream.readAsString();\n        const dataUri = \"data:text/plain;base64,\" + attachment;\n        attachments.push({ contentType: stream.contentType, contentUrl: dataUri });\n      }\n\n      activity.attachments = attachments;\n    }\n\n    if (this.shouldQueue()) {\n      this.activityQueue.push(activity);\n    } else {\n      this.subscriber.next(activity);\n    }\n\n    return BFSE.StreamingResponse.create(200);\n  }\n\n  public flush() {\n    this.connectionStatus$.subscribe(cs => { })\n    this.activityQueue.forEach((a) => this.subscriber.next(a));\n    this.activityQueue = [];\n  }\n}\n\nexport class DirectLineStreaming implements IBotConnection {\n  public connectionStatus$ = new BehaviorSubject(ConnectionStatus.Uninitialized);\n  public activity$: Observable<Activity>;\n\n  private activitySubscriber: Subscriber<Activity>;\n  private theStreamHandler: StreamHandler;\n\n  private domain: string;\n\n  private conversationId: string;\n  private token: string;\n  private streamConnection: BFSE.WebSocketClient;\n  private queueActivities: boolean;\n\n  private _botAgent = '';\n\n  constructor(options: DirectLineStreamingOptions) {\n    this.token = options.token;\n\n    this.refreshToken();\n\n    this.domain = options.domain;\n\n    if (options.conversationId) {\n      this.conversationId = options.conversationId;\n    }\n\n    this._botAgent = this.getBotAgent(options.botAgent);\n\n    this.queueActivities = true;\n    this.activity$ = Observable.create(async (subscriber: Subscriber<Activity>) => {\n      this.activitySubscriber = subscriber;\n      this.theStreamHandler = new StreamHandler(subscriber, this.connectionStatus$, () => this.queueActivities);\n      this.connectWithRetryAsync();\n    }).share();\n  }\n\n  public reconnect({ conversationId, token } : Conversation) {\n    this.conversationId = conversationId;\n    this.token = token;\n    this.connectAsync();\n  }\n\n  end() {\n    this.connectionStatus$.next(ConnectionStatus.Ended);\n    this.streamConnection.disconnect();\n  }\n\n  private commonHeaders() {\n    return {\n      \"Authorization\": `Bearer ${this.token}`,\n      \"x-ms-bot-agent\": this._botAgent\n    };\n  }\n\n  private getBotAgent(customAgent: string = ''): string {\n    let clientAgent = 'directlineStreaming'\n\n    if (customAgent) {\n      clientAgent += `; ${customAgent}`\n    }\n\n    return `${DIRECT_LINE_VERSION} (${clientAgent})`;\n  }\n\n  private async refreshToken(firstCall = true, retryCount = 0) {\n    await this.waitUntilOnline();\n\n    let numberOfAttempts = 0;\n    while(numberOfAttempts < MAX_RETRY_COUNT) {\n      numberOfAttempts++;\n      await new Promise(r => setTimeout(r, refreshTokenInterval));\n      try {\n        const res = await fetch(`${this.domain}/tokens/refresh`, {method: \"POST\", headers: this.commonHeaders()});\n        if (res.ok) {\n          numberOfAttempts = 0;\n          const {token} = await res.json();\n          this.token = token;\n        } else {\n          if (res.status === 403 || res.status === 403) {\n            console.error(`Fatal error while refreshing the token: ${res.status} ${res.statusText}`);\n            this.streamConnection.disconnect();\n          } else {\n            console.warn(`Refresh attempt #${numberOfAttempts} failed: ${res.status} ${res.statusText}`);\n          }\n        }\n      } catch(e) {\n        console.warn(`Refresh attempt #${numberOfAttempts} threw an exception: ${e}`);\n      }\n    }\n\n    console.error(\"Retries exhausted\");\n    this.streamConnection.disconnect();\n  }\n\n  postActivity(activity: Activity) {\n    if (activity.type === \"message\" && activity.attachments && activity.attachments.length > 0) {\n      return this.postMessageWithAttachments(activity);\n    }\n\n    const resp$ = Observable.create(async subscriber => {\n      const request = BFSE.StreamingRequest.create('POST', '/v3/directline/conversations/' + this.conversationId + '/activities');\n      request.setBody(JSON.stringify(activity));\n      const resp = await this.streamConnection.send(request);\n\n      try {\n        if (resp.statusCode !== 200) throw new Error(\"PostActivity returned \" + resp.statusCode);\n        const numberOfStreams = resp.streams.length;\n        if (numberOfStreams !== 1) throw new Error(\"Expected one stream but got \" + numberOfStreams)\n        const idString = await resp.streams[0].readAsString();\n        const {Id : id} = JSON.parse(idString);\n        return subscriber.next(id);\n      } catch(e) {\n          // If there is a network issue then its handled by\n          // the disconnectionHandler. Everything else can\n          // be retried\n          console.warn(e);\n          this.streamConnection.disconnect();\n          return subscriber.error(e);\n      }\n    });\n    return resp$;\n  }\n\n  private postMessageWithAttachments(message: Message) {\n    const { attachments, ...messageWithoutAttachments } = message;\n\n    return Observable.create( subscriber => {\n      const httpContentList = [];\n      (async () => {\n        try {\n          const arrayBuffers = await Promise.all(attachments.map(async attachment => {\n            const media = attachment as Media;\n            const res = await fetch(media.contentUrl);\n            if (res.ok) {\n              return { arrayBuffer: await res.arrayBuffer(), media };\n            } else {\n              throw new Error('...');\n            }\n          }));\n\n          arrayBuffers.forEach(({ arrayBuffer, media }) => {\n            const buffer = Buffer.from(arrayBuffer);\n            console.log(buffer);\n            const stream = new BFSE.SubscribableStream();\n            stream.write(buffer);\n            const httpContent = new BFSE.HttpContent({ type: media.contentType, contentLength: buffer.length }, stream);\n            httpContentList.push(httpContent);\n          });\n\n          const url = `/v3/directline/conversations/${this.conversationId}/users/${messageWithoutAttachments.from.id}/upload`;\n          const request = BFSE.StreamingRequest.create('PUT', url);\n          const activityStream = new BFSE.SubscribableStream();\n          activityStream.write(JSON.stringify(messageWithoutAttachments), 'utf-8');\n          request.addStream(new BFSE.HttpContent({ type: \"application/vnd.microsoft.activity\", contentLength: activityStream.length }, activityStream));\n          httpContentList.forEach(e => request.addStream(e));\n\n          const resp = await this.streamConnection.send(request);\n          if (resp.streams && resp.streams.length !== 1) {\n            subscriber.error(new Error(`Invalid stream count ${resp.streams.length}`));\n          } else {\n            const {Id: id} = await resp.streams[0].readAsJson();\n            subscriber.next(id);\n          }\n        } catch(e) {\n          subscriber.error(e);\n        }\n      })();\n    });\n  }\n\n  private async waitUntilOnline() {\n    return new Promise<void>((resolve, reject) => {\n      this.connectionStatus$.subscribe((cs) => {\n        if (cs === ConnectionStatus.Online) return resolve();\n      },\n        (e) => reject(e));\n    })\n  }\n\n  private async connectAsync() {\n    const re = new RegExp('^http(s?)');\n    if (!re.test(this.domain)) throw (\"Domain must begin with http or https\");\n    const params = {token: this.token};\n    if (this.conversationId) params['conversationId'] = this.conversationId;\n    const urlSearchParams = new URLSearchParams(params).toString();\n    const wsUrl = `${this.domain.replace(re, 'ws$1')}/conversations/connect?${urlSearchParams}`;\n\n    return new Promise(async (resolve, reject) => {\n      try {\n        this.streamConnection = new BFSE.WebSocketClient({\n          url: wsUrl,\n          requestHandler: this.theStreamHandler,\n          disconnectionHandler: (e) => resolve(e)\n        });\n\n        this.queueActivities = true;\n        await this.streamConnection.connect();\n        const request = BFSE.StreamingRequest.create('POST', '/v3/directline/conversations');\n        const response = await this.streamConnection.send(request);\n        if (response.statusCode !== 200) throw new Error(\"Connection response code \" + response.statusCode);\n        if (response.streams.length !== 1) throw new Error(\"Expected 1 stream but got \" + response.streams.length);\n        const responseString = await response.streams[0].readAsString();\n        const conversation = JSON.parse(responseString);\n        this.conversationId = conversation.conversationId;\n        this.connectionStatus$.next(ConnectionStatus.Online);\n\n        // Wait until DL consumers have had a chance to be notified\n        // of the connection status change.\n        await this.waitUntilOnline();\n        this.theStreamHandler.flush();\n        this.queueActivities = false;\n      } catch(e) {\n        reject(e);\n      }\n    });\n  }\n\n  private async connectWithRetryAsync() {\n    let numRetries = MAX_RETRY_COUNT;\n    while (numRetries > 0) {\n      numRetries--;\n      const start = Date.now();\n      try {\n        this.connectionStatus$.next(ConnectionStatus.Connecting);\n        const res = await this.connectAsync();\n        console.warn(`Retrying connection ${res}`);\n        if (60000 < Date.now() - start) {\n          // reset the retry counter and retry immediately\n          // if the connection lasted for more than a minute\n          numRetries = MAX_RETRY_COUNT;\n          continue;\n        }\n      } catch (err) {\n        console.error(`Failed to connect ${err}`);\n        throw(err);\n      }\n\n      await new Promise(r => setTimeout(r, this.getRetryDelay()));\n    }\n  }\n\n  // Returns the delay duration in milliseconds\n  private getRetryDelay() {\n    return Math.floor(3000 + Math.random() * 12000);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}