{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = playCognitiveServicesStream;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _createMultiBufferingPlayer = _interopRequireDefault(require(\"./createMultiBufferingPlayer\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Safari requires an audio buffer with a sample rate of 22050 Hz.\n// Using a minimum sample rate of 44100 Hz as an example, the Speech SDK's default 16000 Hz will be upsampled to 48000 Hz.\n\n\nvar MIN_SAMPLE_RATE = 44100; // The Speech SDK is hardcoded to chop packets to 4096 bytes.\n// Web Chat's multi-buffering player is set up with 3 buffers; each is 4096 bytes (2048 16-bit samples).\n// For simplicity, the multi-buffer player currently does not support progressive buffering.\n// Progressive buffering allows queuing at any sample size and will be concatenated.\n// If 1000 samples are queued, then 1048 samples are queued, they will be concatenated into a single buffer of size 2048.\n// For simplicity, data will be queued to two buffers.\n// The first buffer is 1000 samples followed by 1048 zeroes, and the second buffer is 1048 samples followed by 1000 zeroes.\n// There is no plan to support progressive buffering until the Speech SDK chops data at dynamic size.\n\nvar DEFAULT_BUFFER_SIZE = 4096;\n\nfunction average(array) {\n  return array.reduce(function (sum, value) {\n    return sum + value;\n  }, 0) / array.length;\n}\n\nfunction formatTypedBitArrayToFloatArray(audioData, maxValue) {\n  var float32Data = new Float32Array(audioData.length);\n\n  for (var i = 0; i < audioData.length; i++) {\n    float32Data[+i] = audioData[+i] / maxValue;\n  }\n\n  return float32Data;\n}\n\nfunction formatAudioDataArrayBufferToFloatArray(_ref, arrayBuffer) {\n  var bitsPerSample = _ref.bitsPerSample;\n\n  switch (bitsPerSample) {\n    case 8:\n      return formatTypedBitArrayToFloatArray(new Int8Array(arrayBuffer), 128);\n\n    case 16:\n      return formatTypedBitArrayToFloatArray(new Int16Array(arrayBuffer), 32768);\n\n    case 32:\n      return formatTypedBitArrayToFloatArray(new Int32Array(arrayBuffer), 2147483648);\n\n    default:\n      throw new Error('Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time');\n  }\n}\n\nfunction abortToReject(signal) {\n  return new Promise(function (_, reject) {\n    signal.onabort = function () {\n      return reject(new Error('aborted'));\n    };\n  });\n} // In a 2 channel audio (e.g. A/B), the data arrives as interleaved, like \"ABABABABAB\".\n// This function will take \"ABABABABAB\" and return an array [\"AAAAA\", \"BBBBB\"].\n\n\nfunction deinterleave(channelInterleavedAudioData, _ref2) {\n  var channels = _ref2.channels;\n  var multiChannelArrayBuffer = new Array(channels);\n  var frameSize = channelInterleavedAudioData.length / channels;\n\n  for (var channel = 0; channel < channels; channel++) {\n    var audioData = new Float32Array(frameSize);\n    multiChannelArrayBuffer[+channel] = audioData;\n\n    for (var offset = 0; offset < frameSize; offset++) {\n      audioData[+offset] = channelInterleavedAudioData[offset * channels + channel];\n    }\n  }\n\n  return multiChannelArrayBuffer;\n} // This function upsamples the audio data via an integer multiplier.\n// Web Chat uses simple anti-aliasing. For simplicity, the anti-aliasing does not roll over to next buffer.\n\n\nfunction multiplySampleRate(source, sampleRateMultiplier) {\n  if (sampleRateMultiplier === 1) {\n    return source;\n  }\n\n  var lastValues = new Array(sampleRateMultiplier).fill(source[0]);\n  var target = new Float32Array(source.length * sampleRateMultiplier);\n\n  for (var sourceOffset = 0; sourceOffset < source.length; sourceOffset++) {\n    var value = source[+sourceOffset];\n    var targetOffset = sourceOffset * sampleRateMultiplier;\n\n    for (var multiplierIndex = 0; multiplierIndex < sampleRateMultiplier; multiplierIndex++) {\n      lastValues.shift();\n      lastValues.push(value);\n      target[targetOffset + multiplierIndex] = average(lastValues);\n    }\n  }\n\n  return target;\n}\n\nfunction playCognitiveServicesStream(_x, _x2) {\n  return _playCognitiveServicesStream.apply(this, arguments);\n}\n\nfunction _playCognitiveServicesStream() {\n  _playCognitiveServicesStream = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(audioContext, stream) {\n    var _ref3,\n        _ref3$signal,\n        signal,\n        queuedBufferSourceNodes,\n        _args2 = arguments;\n\n    return _regenerator.default.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref3 = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {}, _ref3$signal = _ref3.signal, signal = _ref3$signal === void 0 ? {} : _ref3$signal;\n\n            if (audioContext) {\n              _context2.next = 5;\n              break;\n            }\n\n            throw new Error('botframework-directlinespeech-sdk: audioContext must be specified.');\n\n          case 5:\n            if (stream) {\n              _context2.next = 9;\n              break;\n            }\n\n            throw new Error('botframework-directlinespeech-sdk: stream must be specified.');\n\n          case 9:\n            if (stream.format) {\n              _context2.next = 13;\n              break;\n            }\n\n            throw new Error('botframework-directlinespeech-sdk: stream is missing format.');\n\n          case 13:\n            if (!(typeof stream.read !== 'function')) {\n              _context2.next = 15;\n              break;\n            }\n\n            throw new Error('botframework-directlinespeech-sdk: stream is missing read().');\n\n          case 15:\n            queuedBufferSourceNodes = [];\n            _context2.prev = 16;\n            return _context2.delegateYield( /*#__PURE__*/_regenerator.default.mark(function _callee() {\n              var format, abortPromise, array, read, samplesPerSec, newSamplesPerSec, sampleRateMultiplier, player, chunk, maxChunks, interleavedArray, multiChannelArray, upsampledMultiChannelArray;\n              return _regenerator.default.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      format = stream.format;\n                      abortPromise = abortToReject(signal);\n                      array = new Uint8Array(DEFAULT_BUFFER_SIZE);\n\n                      read = function read() {\n                        return Promise.race([abortPromise.catch(function () {// Abort will gracefully end the queue. We will check signal.aborted later to throw abort exception.\n                        }), stream.read(array.buffer).then(function (numBytes) {\n                          return numBytes === array.byteLength ? array : numBytes ? array.slice(0, numBytes) : undefined;\n                        })]);\n                      };\n\n                      if (!signal.aborted) {\n                        _context.next = 6;\n                        break;\n                      }\n\n                      throw new Error('aborted');\n\n                    case 6:\n                      samplesPerSec = format.samplesPerSec; // TODO: [P0] #3692 Remove the following if-condition block when the underlying bugs are resolved.\n                      //       There is a bug in Speech SDK 1.15.0 that returns 24kHz instead of 16kHz.\n                      //       Even if we explicitly specify the output audio format to 16kHz, there is another bug that ignored it.\n                      //       In short, DLSpeech service currently always streams in RIFF WAV format, instead of MP3.\n                      //       https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/313\n                      //       https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/314\n\n                      if (format.requestAudioFormatString === 'audio-24khz-48kbitrate-mono-mp3') {\n                        samplesPerSec = 16000;\n                      }\n\n                      newSamplesPerSec = samplesPerSec;\n                      sampleRateMultiplier = 1; // Safari requires a minimum sample rate of 22100 Hz.\n                      // A multiplier is calculated the the data meets the minimum sample rate.\n                      // An integer-based multiplier to simplify our upsampler.\n                      // For security, data will only be upsampled up to 96000 Hz.\n\n                      while (newSamplesPerSec < MIN_SAMPLE_RATE && newSamplesPerSec < 96000) {\n                        sampleRateMultiplier++;\n                        newSamplesPerSec = samplesPerSec * sampleRateMultiplier;\n                      } // The third parameter is the sample size in bytes.\n                      // For example, if the Speech SDK sends Web Chat 4096 bytes of 16-bit samples, there will be 2048 samples per channel.\n                      // The multi-buffering player is set up to handle 2048 samples per buffer.\n                      // If the multiplier 3x, it will handle 6144 samples per buffer.\n\n\n                      player = (0, _createMultiBufferingPlayer.default)(audioContext, _objectSpread(_objectSpread({}, format), {}, {\n                        samplesPerSec: newSamplesPerSec\n                      }), DEFAULT_BUFFER_SIZE / (format.bitsPerSample / 8) * sampleRateMultiplier); // For security, the maximum number of chunks handled will be 1000.\n\n                      _context.next = 14;\n                      return read();\n\n                    case 14:\n                      chunk = _context.sent;\n                      maxChunks = 0;\n\n                    case 16:\n                      if (!(chunk && maxChunks < 1000 && !signal.aborted)) {\n                        _context.next = 29;\n                        break;\n                      }\n\n                      if (!signal.aborted) {\n                        _context.next = 19;\n                        break;\n                      }\n\n                      return _context.abrupt(\"break\", 29);\n\n                    case 19:\n                      // Data received from Speech SDK is interleaved; 2 channels (e.g. A and B) will be sent as \"ABABABABAB\"\n                      // And each sample (A/B) will be an 8 to 32-bit number.\n                      // Convert the 8 - 32-bit number into a floating-point number, as required by Web Audio API.\n                      interleavedArray = formatAudioDataArrayBufferToFloatArray(format, chunk.buffer); // Deinterleave data back into two array buffer, e.g. \"AAAAA\" and \"BBBBB\".\n\n                      multiChannelArray = deinterleave(interleavedArray, format); // Upsample data if necessary. If the multiplier is 2x, \"AAAAA\" will be upsampled to \"AAAAAAAAAA\" (with anti-alias).\n\n                      upsampledMultiChannelArray = multiChannelArray.map(function (array) {\n                        return multiplySampleRate(array, sampleRateMultiplier);\n                      }); // Queue to the buffering player.\n\n                      player.push(upsampledMultiChannelArray);\n\n                    case 23:\n                      _context.next = 25;\n                      return read();\n\n                    case 25:\n                      chunk = _context.sent;\n                      maxChunks++;\n                      _context.next = 16;\n                      break;\n\n                    case 29:\n                      abortPromise.catch(function () {\n                        return player.cancelAll();\n                      });\n\n                      if (!signal.aborted) {\n                        _context.next = 32;\n                        break;\n                      }\n\n                      throw new Error('aborted');\n\n                    case 32:\n                      _context.next = 34;\n                      return Promise.race([abortPromise, player.flush()]);\n\n                    case 34:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            })(), \"t0\", 18);\n\n          case 18:\n            _context2.prev = 18;\n            queuedBufferSourceNodes.forEach(function (node) {\n              return node.stop();\n            });\n            return _context2.finish(18);\n\n          case 21:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[16,, 18, 21]]);\n  }));\n  return _playCognitiveServicesStream.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["MIN_SAMPLE_RATE","DEFAULT_BUFFER_SIZE","average","array","reduce","sum","value","length","formatTypedBitArrayToFloatArray","audioData","maxValue","float32Data","Float32Array","i","formatAudioDataArrayBufferToFloatArray","arrayBuffer","bitsPerSample","Int8Array","Int16Array","Int32Array","Error","abortToReject","signal","Promise","_","reject","onabort","deinterleave","channelInterleavedAudioData","channels","multiChannelArrayBuffer","Array","frameSize","channel","offset","multiplySampleRate","source","sampleRateMultiplier","lastValues","fill","target","sourceOffset","targetOffset","multiplierIndex","shift","push","playCognitiveServicesStream","audioContext","stream","_ref3","_context2","format","read","queuedBufferSourceNodes","abortPromise","Uint8Array","race","catch","buffer","then","numBytes","byteLength","slice","undefined","aborted","_context","samplesPerSec","requestAudioFormatString","newSamplesPerSec","player","chunk","maxChunks","interleavedArray","multiChannelArray","upsampledMultiChannelArray","map","cancelAll","flush","forEach","node","stop"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-directlinespeech-sdk/lib/src/playCognitiveServicesStream.js"],"sourcesContent":["/* eslint no-magic-numbers: [\"error\", { \"ignore\": [0, 1, 8, 16, 32, 128, 1000, 16000, 32768, 96000, 2147483648] }] */\n/* eslint no-await-in-loop: \"off\" */\n/* eslint prefer-destructuring: \"off\" */\n\nimport createMultiBufferingPlayer from './createMultiBufferingPlayer';\n\n// Safari requires an audio buffer with a sample rate of 22050 Hz.\n// Using a minimum sample rate of 44100 Hz as an example, the Speech SDK's default 16000 Hz will be upsampled to 48000 Hz.\nconst MIN_SAMPLE_RATE = 44100;\n\n// The Speech SDK is hardcoded to chop packets to 4096 bytes.\n// Web Chat's multi-buffering player is set up with 3 buffers; each is 4096 bytes (2048 16-bit samples).\n// For simplicity, the multi-buffer player currently does not support progressive buffering.\n\n// Progressive buffering allows queuing at any sample size and will be concatenated.\n// If 1000 samples are queued, then 1048 samples are queued, they will be concatenated into a single buffer of size 2048.\n\n// For simplicity, data will be queued to two buffers.\n// The first buffer is 1000 samples followed by 1048 zeroes, and the second buffer is 1048 samples followed by 1000 zeroes.\n\n// There is no plan to support progressive buffering until the Speech SDK chops data at dynamic size.\nconst DEFAULT_BUFFER_SIZE = 4096;\n\nfunction average(array) {\n  return array.reduce((sum, value) => sum + value, 0) / array.length;\n}\n\nfunction formatTypedBitArrayToFloatArray(audioData, maxValue) {\n  const float32Data = new Float32Array(audioData.length);\n\n  for (let i = 0; i < audioData.length; i++) {\n    float32Data[+i] = audioData[+i] / maxValue;\n  }\n\n  return float32Data;\n}\n\nfunction formatAudioDataArrayBufferToFloatArray({ bitsPerSample }, arrayBuffer) {\n  switch (bitsPerSample) {\n    case 8:\n      return formatTypedBitArrayToFloatArray(new Int8Array(arrayBuffer), 128);\n\n    case 16:\n      return formatTypedBitArrayToFloatArray(new Int16Array(arrayBuffer), 32768);\n\n    case 32:\n      return formatTypedBitArrayToFloatArray(new Int32Array(arrayBuffer), 2147483648);\n\n    default:\n      throw new Error('Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time');\n  }\n}\n\nfunction abortToReject(signal) {\n  return new Promise((_, reject) => {\n    signal.onabort = () => reject(new Error('aborted'));\n  });\n}\n\n// In a 2 channel audio (e.g. A/B), the data arrives as interleaved, like \"ABABABABAB\".\n// This function will take \"ABABABABAB\" and return an array [\"AAAAA\", \"BBBBB\"].\nfunction deinterleave(channelInterleavedAudioData, { channels }) {\n  const multiChannelArrayBuffer = new Array(channels);\n  const frameSize = channelInterleavedAudioData.length / channels;\n\n  for (let channel = 0; channel < channels; channel++) {\n    const audioData = new Float32Array(frameSize);\n\n    multiChannelArrayBuffer[+channel] = audioData;\n\n    for (let offset = 0; offset < frameSize; offset++) {\n      audioData[+offset] = channelInterleavedAudioData[offset * channels + channel];\n    }\n  }\n\n  return multiChannelArrayBuffer;\n}\n\n// This function upsamples the audio data via an integer multiplier.\n// Web Chat uses simple anti-aliasing. For simplicity, the anti-aliasing does not roll over to next buffer.\nfunction multiplySampleRate(source, sampleRateMultiplier) {\n  if (sampleRateMultiplier === 1) {\n    return source;\n  }\n\n  const lastValues = new Array(sampleRateMultiplier).fill(source[0]);\n  const target = new Float32Array(source.length * sampleRateMultiplier);\n\n  for (let sourceOffset = 0; sourceOffset < source.length; sourceOffset++) {\n    const value = source[+sourceOffset];\n    const targetOffset = sourceOffset * sampleRateMultiplier;\n\n    for (let multiplierIndex = 0; multiplierIndex < sampleRateMultiplier; multiplierIndex++) {\n      lastValues.shift();\n      lastValues.push(value);\n      target[targetOffset + multiplierIndex] = average(lastValues);\n    }\n  }\n\n  return target;\n}\n\nexport default async function playCognitiveServicesStream(audioContext, stream, { signal = {} } = {}) {\n  if (!audioContext) {\n    throw new Error('botframework-directlinespeech-sdk: audioContext must be specified.');\n  } else if (!stream) {\n    throw new Error('botframework-directlinespeech-sdk: stream must be specified.');\n  } else if (!stream.format) {\n    throw new Error('botframework-directlinespeech-sdk: stream is missing format.');\n  } else if (typeof stream.read !== 'function') {\n    throw new Error('botframework-directlinespeech-sdk: stream is missing read().');\n  }\n\n  const queuedBufferSourceNodes = [];\n\n  try {\n    const { format } = stream;\n    const abortPromise = abortToReject(signal);\n    const array = new Uint8Array(DEFAULT_BUFFER_SIZE);\n\n    const read = () =>\n      Promise.race([\n        abortPromise.catch(() => {\n          // Abort will gracefully end the queue. We will check signal.aborted later to throw abort exception.\n        }),\n        stream\n          .read(array.buffer)\n          .then(numBytes => (numBytes === array.byteLength ? array : numBytes ? array.slice(0, numBytes) : undefined))\n      ]);\n\n    if (signal.aborted) {\n      throw new Error('aborted');\n    }\n\n    let { samplesPerSec } = format;\n\n    // TODO: [P0] #3692 Remove the following if-condition block when the underlying bugs are resolved.\n    //       There is a bug in Speech SDK 1.15.0 that returns 24kHz instead of 16kHz.\n    //       Even if we explicitly specify the output audio format to 16kHz, there is another bug that ignored it.\n    //       In short, DLSpeech service currently always streams in RIFF WAV format, instead of MP3.\n    //       https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/313\n    //       https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/314\n    if (format.requestAudioFormatString === 'audio-24khz-48kbitrate-mono-mp3') {\n      samplesPerSec = 16000;\n    }\n\n    let newSamplesPerSec = samplesPerSec;\n    let sampleRateMultiplier = 1;\n\n    // Safari requires a minimum sample rate of 22100 Hz.\n    // A multiplier is calculated the the data meets the minimum sample rate.\n    // An integer-based multiplier to simplify our upsampler.\n    // For security, data will only be upsampled up to 96000 Hz.\n    while (newSamplesPerSec < MIN_SAMPLE_RATE && newSamplesPerSec < 96000) {\n      sampleRateMultiplier++;\n      newSamplesPerSec = samplesPerSec * sampleRateMultiplier;\n    }\n\n    // The third parameter is the sample size in bytes.\n    // For example, if the Speech SDK sends Web Chat 4096 bytes of 16-bit samples, there will be 2048 samples per channel.\n    // The multi-buffering player is set up to handle 2048 samples per buffer.\n    // If the multiplier 3x, it will handle 6144 samples per buffer.\n    const player = createMultiBufferingPlayer(\n      audioContext,\n      { ...format, samplesPerSec: newSamplesPerSec },\n      (DEFAULT_BUFFER_SIZE / (format.bitsPerSample / 8)) * sampleRateMultiplier\n    );\n\n    // For security, the maximum number of chunks handled will be 1000.\n    for (\n      let chunk = await read(), maxChunks = 0;\n      chunk && maxChunks < 1000 && !signal.aborted;\n      chunk = await read(), maxChunks++\n    ) {\n      if (signal.aborted) {\n        break;\n      }\n\n      // Data received from Speech SDK is interleaved; 2 channels (e.g. A and B) will be sent as \"ABABABABAB\"\n      // And each sample (A/B) will be an 8 to 32-bit number.\n\n      // Convert the 8 - 32-bit number into a floating-point number, as required by Web Audio API.\n      const interleavedArray = formatAudioDataArrayBufferToFloatArray(format, chunk.buffer);\n\n      // Deinterleave data back into two array buffer, e.g. \"AAAAA\" and \"BBBBB\".\n      const multiChannelArray = deinterleave(interleavedArray, format);\n\n      // Upsample data if necessary. If the multiplier is 2x, \"AAAAA\" will be upsampled to \"AAAAAAAAAA\" (with anti-alias).\n      const upsampledMultiChannelArray = multiChannelArray.map(array =>\n        multiplySampleRate(array, sampleRateMultiplier)\n      );\n\n      // Queue to the buffering player.\n      player.push(upsampledMultiChannelArray);\n    }\n\n    abortPromise.catch(() => player.cancelAll());\n\n    if (signal.aborted) {\n      throw new Error('aborted');\n    }\n\n    await Promise.race([abortPromise, player.flush()]);\n  } finally {\n    queuedBufferSourceNodes.forEach(node => node.stop());\n  }\n}\n"]},"metadata":{},"sourceType":"script"}