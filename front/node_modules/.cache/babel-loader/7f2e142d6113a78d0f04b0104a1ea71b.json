{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = queueIncomingActivitySaga;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _effects = require(\"redux-saga/effects\");\n\nvar _queueIncomingActivity = require(\"../actions/queueIncomingActivity\");\n\nvar _activities = _interopRequireWildcard(require(\"../selectors/activities\"));\n\nvar _activityFromBot = _interopRequireDefault(require(\"../definitions/activityFromBot\"));\n\nvar _incomingActivity = _interopRequireWildcard(require(\"../actions/incomingActivity\"));\n\nvar _setSuggestedActions = _interopRequireDefault(require(\"../actions/setSuggestedActions\"));\n\nvar _sleep = _interopRequireDefault(require(\"../utils/sleep\"));\n\nvar _whileConnected = _interopRequireDefault(require(\"./effects/whileConnected\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar _marked = /*#__PURE__*/_regenerator[\"default\"].mark(takeEveryAndSelect),\n    _marked2 = /*#__PURE__*/_regenerator[\"default\"].mark(waitForActivityId),\n    _marked3 = /*#__PURE__*/_regenerator[\"default\"].mark(queueIncomingActivity),\n    _marked4 = /*#__PURE__*/_regenerator[\"default\"].mark(queueIncomingActivitySaga); // We will hold up the replying activity if the originating activity did not arrive, up to 5 seconds.\n\n\nvar REPLY_TIMEOUT = 5000;\n\nfunction takeEveryAndSelect(actionType, selector, fn) {\n  var action, state;\n  return _regenerator[\"default\"].wrap(function takeEveryAndSelect$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return (0, _effects.cancelled)();\n\n        case 2:\n          if (_context.sent) {\n            _context.next = 13;\n            break;\n          }\n\n          _context.next = 5;\n          return (0, _effects.take)(actionType);\n\n        case 5:\n          action = _context.sent;\n          _context.next = 8;\n          return (0, _effects.select)(selector);\n\n        case 8:\n          state = _context.sent;\n          _context.next = 11;\n          return (0, _effects.fork)(fn, action, state);\n\n        case 11:\n          _context.next = 0;\n          break;\n\n        case 13:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n} // Wait for specific activity to arrive in the transcript.\n// We will use the initial set of activities to close time gaps between select() and take().\n// If another activity with the same \"replyToId\" is already rendered (in the \"activities\" array),\n// we will skip the wait as we already waited long enough for the missing activity to show up.\n\n\nfunction waitForActivityId(replyToId, initialActivities) {\n  var activities, replied, _yield$take, activity;\n\n  return _regenerator[\"default\"].wrap(function waitForActivityId$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          activities = initialActivities;\n\n        case 1:\n          replied = activities.find(function (activity) {\n            return activity.id === replyToId || activity.replyToId === replyToId;\n          });\n\n          if (!replied) {\n            _context2.next = 4;\n            break;\n          }\n\n          return _context2.abrupt(\"break\", 15);\n\n        case 4:\n          _context2.next = 6;\n          return (0, _effects.take)(_incomingActivity.INCOMING_ACTIVITY);\n\n        case 6:\n          _yield$take = _context2.sent;\n          activity = _yield$take.payload.activity;\n\n          if (!(activity.id === replyToId)) {\n            _context2.next = 10;\n            break;\n          }\n\n          return _context2.abrupt(\"break\", 15);\n\n        case 10:\n          _context2.next = 12;\n          return (0, _effects.select)(_activities[\"default\"]);\n\n        case 12:\n          activities = _context2.sent;\n\n        case 13:\n          _context2.next = 1;\n          break;\n\n        case 15:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\nfunction queueIncomingActivity(_ref) {\n  var userID;\n  return _regenerator[\"default\"].wrap(function queueIncomingActivity$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          userID = _ref.userID;\n          _context4.next = 3;\n          return takeEveryAndSelect(_queueIncomingActivity.QUEUE_INCOMING_ACTIVITY, _activities[\"default\"], /*#__PURE__*/_regenerator[\"default\"].mark(function queueIncomingActivity(_ref2, initialActivities) {\n            var activity, replyToId, initialBotActivities, result, messageActivities, lastMessageActivity, _lastMessageActivity$, actions, to;\n\n            return _regenerator[\"default\"].wrap(function queueIncomingActivity$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    activity = _ref2.payload.activity; // This is for resolving an accessibility issue.\n                    // If the incoming activity has \"replyToId\" field, hold on it until the activity replied to is in the transcript, then release this one.\n\n                    replyToId = activity.replyToId;\n                    initialBotActivities = initialActivities.filter(function (_ref3) {\n                      var role = _ref3.from.role;\n                      return role === 'bot';\n                    }); // To speed up the first activity render time, we do not delay the first activity from the bot.\n                    // Even if it is the first activity from the bot, the bot might be \"replying\" to the \"conversationUpdate\" event.\n                    // Thus, the \"replyToId\" will always be there even it is the first activity in the conversation.\n\n                    if (!(replyToId && initialBotActivities.length)) {\n                      _context3.next = 8;\n                      break;\n                    }\n\n                    _context3.next = 6;\n                    return (0, _effects.race)({\n                      _: waitForActivityId(replyToId, initialActivities),\n                      timeout: (0, _effects.call)(_sleep[\"default\"], REPLY_TIMEOUT)\n                    });\n\n                  case 6:\n                    result = _context3.sent;\n\n                    if ('timeout' in result) {\n                      console.warn(\"botframework-webchat: Timed out while waiting for activity \\\"\".concat(replyToId, \"\\\" which activity \\\"\").concat(activity.id, \"\\\" is replying to.\"), {\n                        activity: activity,\n                        replyToId: replyToId\n                      });\n                    }\n\n                  case 8:\n                    _context3.next = 10;\n                    return (0, _effects.put)((0, _incomingActivity[\"default\"])(activity));\n\n                  case 10:\n                    _context3.next = 12;\n                    return (0, _effects.select)((0, _activities.ofType)('message'));\n\n                  case 12:\n                    messageActivities = _context3.sent;\n                    lastMessageActivity = messageActivities[messageActivities.length - 1];\n\n                    if (!(0, _activityFromBot[\"default\"])(lastMessageActivity)) {\n                      _context3.next = 20;\n                      break;\n                    }\n\n                    _lastMessageActivity$ = lastMessageActivity.suggestedActions;\n                    _lastMessageActivity$ = _lastMessageActivity$ === void 0 ? {} : _lastMessageActivity$;\n                    actions = _lastMessageActivity$.actions, to = _lastMessageActivity$.to; // If suggested actions is not destined to anyone, or is destined to the user, show it.\n                    // In other words, if suggested actions is destined to someone else, don't show it.\n\n                    _context3.next = 20;\n                    return (0, _effects.put)((0, _setSuggestedActions[\"default\"])(to && to.length && !to.includes(userID) ? null : actions));\n\n                  case 20:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, queueIncomingActivity);\n          }));\n\n        case 3:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked3);\n}\n\nfunction queueIncomingActivitySaga() {\n  return _regenerator[\"default\"].wrap(function queueIncomingActivitySaga$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return (0, _whileConnected[\"default\"])(queueIncomingActivity);\n\n        case 2:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked4);\n}","map":{"version":3,"mappings":"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","names":["takeEveryAndSelect","waitForActivityId","queueIncomingActivity","queueIncomingActivitySaga","REPLY_TIMEOUT","actionType","selector","fn","_context","action","state","replyToId","initialActivities","activities","replied","find","activity","id","_context2","INCOMING_ACTIVITY","_yield$take","payload","activitiesSelector","userID","_context4","QUEUE_INCOMING_ACTIVITY","initialBotActivities","filter","role","from","length","_context3","_","timeout","sleep","result","console","warn","messageActivities","lastMessageActivity","_lastMessageActivity$","suggestedActions","actions","to","includes","_context5"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-core/lib/src/sagas/queueIncomingActivitySaga.js"],"sourcesContent":["import { call, cancelled, fork, put, race, select, take } from 'redux-saga/effects';\n\nimport { QUEUE_INCOMING_ACTIVITY } from '../actions/queueIncomingActivity';\nimport activitiesSelector, { ofType as activitiesOfType } from '../selectors/activities';\nimport activityFromBot from '../definitions/activityFromBot';\nimport incomingActivity, { INCOMING_ACTIVITY } from '../actions/incomingActivity';\nimport setSuggestedActions from '../actions/setSuggestedActions';\nimport sleep from '../utils/sleep';\nimport whileConnected from './effects/whileConnected';\n\n// We will hold up the replying activity if the originating activity did not arrive, up to 5 seconds.\nconst REPLY_TIMEOUT = 5000;\n\nfunction* takeEveryAndSelect(actionType, selector, fn) {\n  // select() will free up the code execution.\n  // If we pair up with takeEvery(), it will allow actions to slip through.\n  // Thus, we are writing one that don't use takeEvery().\n  while (!(yield cancelled())) {\n    const action = yield take(actionType);\n    const state = yield select(selector);\n\n    yield fork(fn, action, state);\n  }\n}\n\n// Wait for specific activity to arrive in the transcript.\n// We will use the initial set of activities to close time gaps between select() and take().\n// If another activity with the same \"replyToId\" is already rendered (in the \"activities\" array),\n// we will skip the wait as we already waited long enough for the missing activity to show up.\nfunction* waitForActivityId(replyToId, initialActivities) {\n  let activities = initialActivities;\n\n  for (;;) {\n    const replied = activities.find(activity => activity.id === replyToId || activity.replyToId === replyToId);\n\n    if (replied) {\n      break;\n    }\n\n    const {\n      payload: { activity }\n    } = yield take(INCOMING_ACTIVITY);\n\n    if (activity.id === replyToId) {\n      break;\n    }\n\n    activities = yield select(activitiesSelector);\n  }\n}\n\nfunction* queueIncomingActivity({ userID }) {\n  yield takeEveryAndSelect(\n    QUEUE_INCOMING_ACTIVITY,\n    activitiesSelector,\n    function* queueIncomingActivity({ payload: { activity } }, initialActivities) {\n      // This is for resolving an accessibility issue.\n      // If the incoming activity has \"replyToId\" field, hold on it until the activity replied to is in the transcript, then release this one.\n      const { replyToId } = activity;\n      const initialBotActivities = initialActivities.filter(({ from: { role } }) => role === 'bot');\n\n      // To speed up the first activity render time, we do not delay the first activity from the bot.\n      // Even if it is the first activity from the bot, the bot might be \"replying\" to the \"conversationUpdate\" event.\n      // Thus, the \"replyToId\" will always be there even it is the first activity in the conversation.\n      if (replyToId && initialBotActivities.length) {\n        // Either the activity replied to is in the transcript or after timeout.\n        const result = yield race({\n          _: waitForActivityId(replyToId, initialActivities),\n          timeout: call(sleep, REPLY_TIMEOUT)\n        });\n\n        if ('timeout' in result) {\n          console.warn(\n            `botframework-webchat: Timed out while waiting for activity \"${replyToId}\" which activity \"${activity.id}\" is replying to.`,\n            {\n              activity,\n              replyToId\n            }\n          );\n        }\n      }\n\n      yield put(incomingActivity(activity));\n\n      // Update suggested actions\n      // TODO: [P3] We could put this logic inside reducer to minimize number of actions dispatched.\n      const messageActivities = yield select(activitiesOfType('message'));\n      const lastMessageActivity = messageActivities[messageActivities.length - 1];\n\n      if (activityFromBot(lastMessageActivity)) {\n        const { suggestedActions: { actions, to } = {} } = lastMessageActivity;\n\n        // If suggested actions is not destined to anyone, or is destined to the user, show it.\n        // In other words, if suggested actions is destined to someone else, don't show it.\n        yield put(setSuggestedActions(to && to.length && !to.includes(userID) ? null : actions));\n      }\n    }\n  );\n}\n\nexport default function* queueIncomingActivitySaga() {\n  yield whileConnected(queueIncomingActivity);\n}\n"]},"metadata":{},"sourceType":"script"}