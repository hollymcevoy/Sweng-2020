{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConversationServiceAdapter = void 0;\n\nvar Exports_1 = require(\"../../common/Exports\");\n\nvar Exports_2 = require(\"../../sdk/Exports\");\n\nvar Exports_3 = require(\"../Exports\");\n\nvar ConversationConnectionMessage_1 = require(\"./ConversationConnectionMessage\");\n\nvar ConversationRequestSession_1 = require(\"./ConversationRequestSession\");\n\nvar ConversationTranslatorEventArgs_1 = require(\"./ConversationTranslatorEventArgs\");\n\nvar ConversationTranslatorInterfaces_1 = require(\"./ConversationTranslatorInterfaces\");\n\nvar Exports_4 = require(\"./ServiceMessages/Exports\");\n/***\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\n */\n\n\nvar ConversationServiceAdapter =\n/** @class */\nfunction (_super) {\n  __extends(ConversationServiceAdapter, _super);\n\n  function ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {\n    var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) || this;\n\n    _this.privLastPartialUtteranceId = \"\";\n\n    _this.noOp = function () {// operation not supported\n    };\n\n    _this.privConversationServiceConnector = conversationServiceConnector;\n    _this.privConversationAuthentication = authentication;\n    _this.receiveMessageOverride = _this.receiveConversationMessageOverride;\n    _this.recognizeOverride = _this.noOp;\n    _this.postConnectImplOverride = _this.conversationConnectImpl;\n    _this.configConnectionOverride = _this.configConnection;\n    _this.disconnectOverride = _this.privDisconnect;\n    _this.privConversationRequestSession = new ConversationRequestSession_1.ConversationRequestSession(Exports_1.createNoDashGuid());\n    _this.privConversationConnectionFactory = connectionFactory;\n    _this.privConversationIsDisposed = false;\n    return _this;\n  }\n\n  ConversationServiceAdapter.prototype.isDisposed = function () {\n    return _super.prototype.isDisposed.call(this) || this.privConversationIsDisposed;\n  };\n\n  ConversationServiceAdapter.prototype.dispose = function (reason) {\n    return __awaiter(this, void 0, void 0, function () {\n      var connection;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.privConversationIsDisposed = true;\n            if (!this.privConnectionConfigPromise) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.privConnectionConfigPromise];\n\n          case 1:\n            connection = _a.sent();\n            return [4\n            /*yield*/\n            , connection.dispose(reason)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [4\n            /*yield*/\n            , _super.prototype.dispose.call(this, reason)];\n\n          case 4:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  ConversationServiceAdapter.prototype.sendMessage = function (message) {\n    return __awaiter(this, void 0, void 0, function () {\n      var connection;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.fetchConnection()];\n\n          case 1:\n            connection = _a.sent();\n            return [2\n            /*return*/\n            , connection.send(new ConversationConnectionMessage_1.ConversationConnectionMessage(Exports_1.MessageType.Text, message))];\n        }\n      });\n    });\n  };\n\n  ConversationServiceAdapter.prototype.sendMessageAsync = function (message) {\n    return __awaiter(this, void 0, void 0, function () {\n      var sink, connection;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            sink = new Exports_1.Deferred();\n            return [4\n            /*yield*/\n            , this.fetchConnection()];\n\n          case 1:\n            connection = _a.sent();\n            return [4\n            /*yield*/\n            , connection.send(new ConversationConnectionMessage_1.ConversationConnectionMessage(Exports_1.MessageType.Text, message))];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  ConversationServiceAdapter.prototype.privDisconnect = function () {\n    if (this.terminateMessageLoop) {\n      return;\n    }\n\n    this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, Exports_2.CancellationReason.Error, Exports_2.CancellationErrorCode.NoError, \"Disconnecting\");\n    this.terminateMessageLoop = true;\n    return Promise.resolve();\n  };\n\n  ConversationServiceAdapter.prototype.processTypeSpecificMessages = function (connectionMessage, successCallback, errorCallBack) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , true];\n      });\n    });\n  }; // Cancels recognition.\n\n\n  ConversationServiceAdapter.prototype.cancelRecognition = function (sessionId, requestId, cancellationReason, errorCode, error) {\n    this.terminateMessageLoop = true;\n    var cancelEvent = new Exports_2.ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n    try {\n      if (!!this.privConversationServiceConnector.canceled) {\n        this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\n      }\n    } catch (_a) {// continue on error\n    }\n  };\n  /**\n   * Establishes a websocket connection to the end point.\n   * @param isUnAuthorized\n   */\n\n\n  ConversationServiceAdapter.prototype.conversationConnectImpl = function (connection) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        this.privConnectionLoop = this.startMessageLoop();\n        return [2\n        /*return*/\n        , connection];\n      });\n    });\n  };\n  /**\n   * Process incoming websocket messages\n   */\n\n\n  ConversationServiceAdapter.prototype.receiveConversationMessageOverride = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var communicationCustodian, connection, message, sessionId, sendFinal, commandPayload, participantsPayload, participantsResult, joinParticipantPayload, joiningParticipant, leavingParticipant, disconnectParticipant, speechPayload, speechResult, textPayload, textResult, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.isDisposed() || this.terminateMessageLoop) {\n              return [2\n              /*return*/\n              , Promise.resolve()];\n            }\n\n            communicationCustodian = new Exports_1.Deferred();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.fetchConnection()];\n\n          case 2:\n            connection = _a.sent();\n            return [4\n            /*yield*/\n            , connection.read()];\n\n          case 3:\n            message = _a.sent();\n\n            if (this.isDisposed() || this.terminateMessageLoop) {\n              // We're done.\n              communicationCustodian.resolve();\n              return [2\n              /*return*/\n              , Promise.resolve()];\n            }\n\n            if (!message) {\n              return [2\n              /*return*/\n              , this.receiveConversationMessageOverride()];\n            }\n\n            sessionId = this.privConversationRequestSession.sessionId;\n            sendFinal = false;\n\n            try {\n              switch (message.conversationMessageType.toLowerCase()) {\n                case \"info\":\n                case \"participant_command\":\n                case \"command\":\n                  commandPayload = Exports_4.CommandResponsePayload.fromJSON(message.textBody);\n\n                  switch (commandPayload.command.toLowerCase()) {\n                    /**\n                     * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\n                     * The consuming client must wait for this message to arrive\n                     * before starting to send their own data.\n                     */\n                    case \"participantlist\":\n                      participantsPayload = Exports_4.ParticipantsListPayloadResponse.fromJSON(message.textBody);\n                      participantsResult = participantsPayload.participants.map(function (p) {\n                        var participant = {\n                          avatar: p.avatar,\n                          displayName: p.nickname,\n                          id: p.participantId,\n                          isHost: p.ishost,\n                          isMuted: p.ismuted,\n                          isUsingTts: p.usetts,\n                          preferredLanguage: p.locale\n                        };\n                        return participant;\n                      });\n\n                      if (!!this.privConversationServiceConnector.participantsListReceived) {\n                        this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\n                     * This is sent at the start of the Conversation\n                     */\n\n                    case \"settranslatetolanguages\":\n                      if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\n                     * If sent by the participant the setting will effect only their own profanity level.\n                     * If sent by the host, the setting will effect all participants including the host.\n                     * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\n                     */\n\n                    case \"setprofanityfiltering\":\n                      if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetMute' is sent if the participant has been muted by the host.\n                     * Check the 'participantId' to determine if the current user has been muted.\n                     */\n\n                    case \"setmute\":\n                      if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetMuteAll' is sent if the Conversation has been muted by the host.\n                     */\n\n                    case \"setmuteall\":\n                      if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\n                        this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.MuteAllEventArgs(commandPayload.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\n                     */\n\n                    case \"roomexpirationwarning\":\n                      if (!!this.privConversationServiceConnector.conversationExpiration) {\n                        this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new Exports_2.ConversationExpirationEventArgs(commandPayload.value, this.privConversationRequestSession.sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\n                     */\n\n                    case \"setusetts\":\n                      if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetLockState' is set if the host has locked or unlocked the Conversation.\n                     */\n\n                    case \"setlockstate\":\n                      if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\n                        this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.LockRoomEventArgs(commandPayload.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'ChangeNickname' is received if a user changes their display name.\n                     * Any cached particpiants list should be updated to reflect the display name.\n                     */\n\n                    case \"changenickname\":\n                      if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.changeNickname, commandPayload.nickname, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'JoinSession' is sent when a user joins the Conversation.\n                     */\n\n                    case \"joinsession\":\n                      joinParticipantPayload = Exports_4.ParticipantPayloadResponse.fromJSON(message.textBody);\n                      joiningParticipant = {\n                        avatar: joinParticipantPayload.avatar,\n                        displayName: joinParticipantPayload.nickname,\n                        id: joinParticipantPayload.participantId,\n                        isHost: joinParticipantPayload.ishost,\n                        isMuted: joinParticipantPayload.ismuted,\n                        isUsingTts: joinParticipantPayload.usetts,\n                        preferredLanguage: joinParticipantPayload.locale\n                      };\n\n                      if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\n                        this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantEventArgs(joiningParticipant, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'LeaveSession' is sent when a user leaves the Conversation'.\n                     */\n\n                    case \"leavesession\":\n                      leavingParticipant = {\n                        id: commandPayload.participantId\n                      };\n\n                      if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\n                        this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantEventArgs(leavingParticipant, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\n                     * Check the 'ParticipantId' to check whether the message is for the current user.\n                     */\n\n                    case \"disconnectsession\":\n                      disconnectParticipant = {\n                        id: commandPayload.participantId\n                      };\n                      break;\n\n                    /**\n                     * Message not recognized.\n                     */\n\n                    default:\n                      break;\n                  }\n\n                  break;\n\n                /**\n                 * 'partial' (or 'hypothesis') represents a unfinalized speech message.\n                 */\n\n                case \"partial\":\n                /**\n                 * 'final' (or 'phrase') represents a finalized speech message.\n                 */\n\n                case \"final\":\n                  speechPayload = Exports_4.SpeechResponsePayload.fromJSON(message.textBody);\n                  speechResult = new Exports_2.ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, undefined, undefined, speechPayload.recognition, undefined, undefined, message.textBody, undefined);\n\n                  if (speechPayload.isFinal) {\n                    // check the length, sometimes empty finals are returned\n                    if (speechResult.text !== undefined && speechResult.text.length > 0) {\n                      sendFinal = true;\n                    } else if (speechPayload.id === this.privLastPartialUtteranceId) {\n                      // send final as normal. We had a non-empty partial for this same utterance\n                      // so sending the empty final is important\n                      sendFinal = true;\n                    } else {// suppress unneeded final\n                    }\n\n                    if (sendFinal) {\n                      if (!!this.privConversationServiceConnector.translationReceived) {\n                        this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.final, speechResult, sessionId));\n                      }\n                    }\n                  } else if (speechResult.text !== undefined) {\n                    this.privLastPartialUtteranceId = speechPayload.id;\n\n                    if (!!this.privConversationServiceConnector.translationReceived) {\n                      this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\n                    }\n                  }\n\n                  break;\n\n                /**\n                 * \"translated_message\" is a text message or instant message (IM).\n                 */\n\n                case \"translated_message\":\n                  textPayload = Exports_4.TextResponsePayload.fromJSON(message.textBody);\n                  textResult = new Exports_2.ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);\n\n                  if (!!this.privConversationServiceConnector.translationReceived) {\n                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\n                  }\n\n                  break;\n\n                default:\n                  // ignore any unsupported message types\n                  break;\n              }\n            } catch (e) {// continue\n            }\n\n            return [2\n            /*return*/\n            , this.receiveConversationMessageOverride()];\n\n          case 4:\n            e_1 = _a.sent();\n            this.terminateMessageLoop = true;\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [2\n            /*return*/\n            , communicationCustodian.promise];\n        }\n      });\n    });\n  };\n\n  ConversationServiceAdapter.prototype.startMessageLoop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var messageRetrievalPromise, r, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.isDisposed()) {\n              return [2\n              /*return*/\n              , Promise.resolve()];\n            }\n\n            this.terminateMessageLoop = false;\n            messageRetrievalPromise = this.receiveConversationMessageOverride();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , messageRetrievalPromise];\n\n          case 2:\n            r = _a.sent();\n            return [2\n            /*return*/\n            , r];\n\n          case 3:\n            error_1 = _a.sent();\n            this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", Exports_2.CancellationReason.Error, Exports_2.CancellationErrorCode.RuntimeError, error_1);\n            return [2\n            /*return*/\n            , null];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // Takes an established websocket connection to the endpoint\n\n\n  ConversationServiceAdapter.prototype.configConnection = function () {\n    var _this = this;\n\n    if (this.isDisposed()) {\n      return Promise.resolve(undefined);\n    }\n\n    if (this.privConnectionConfigPromise) {\n      return this.privConnectionConfigPromise.then(function (connection) {\n        if (connection.state() === Exports_1.ConnectionState.Disconnected) {\n          _this.privConnectionId = null;\n          _this.privConnectionConfigPromise = null;\n          return _this.configConnection();\n        }\n\n        return _this.privConnectionConfigPromise;\n      }, function (error) {\n        _this.privConnectionId = null;\n        _this.privConnectionConfigPromise = null;\n        return _this.configConnection();\n      });\n    }\n\n    if (this.terminateMessageLoop) {\n      return Promise.resolve(undefined);\n    }\n\n    this.privConnectionConfigPromise = this.connectImpl().then(function (connection) {\n      return connection;\n    });\n    return this.privConnectionConfigPromise;\n  };\n\n  ConversationServiceAdapter.prototype.getTranslations = function (serviceResultTranslations) {\n    var translations;\n\n    if (undefined !== serviceResultTranslations) {\n      translations = new Exports_2.Translations();\n\n      for (var _i = 0, serviceResultTranslations_1 = serviceResultTranslations; _i < serviceResultTranslations_1.length; _i++) {\n        var translation = serviceResultTranslations_1[_i];\n        translations.set(translation.lang, translation.translation);\n      }\n    }\n\n    return translations;\n  };\n\n  return ConversationServiceAdapter;\n}(Exports_3.ServiceRecognizerBase);\n\nexports.ConversationServiceAdapter = ConversationServiceAdapter;","map":{"version":3,"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;AASA;;AAQA;;AAMA;;AACA;;AACA;;AAQA;;AAMA;AAWA;;;;;AAGA;AAAA;AAAA;AAAgDA;;AAY5C,sCACIC,cADJ,EAEIC,iBAFJ,EAGIC,WAHJ,EAIIC,gBAJJ,EAKIC,4BALJ,EAKkE;AALlE,gBAOIC,kBAAML,cAAN,EAAsBC,iBAAtB,EAAyCC,WAAzC,EAAsDC,gBAAtD,EAAwEC,4BAAxE,KAAqG,IAPzG;;AAHQE,uCAAqC,EAArC;;AAmGEA,iBAAO,aACb;AACH,KAFS;;AAvFNA,SAAI,CAACC,gCAAL,GAAwCH,4BAAxC;AACAE,SAAI,CAACE,8BAAL,GAAsCR,cAAtC;AACAM,SAAI,CAACG,sBAAL,GAA8BH,KAAI,CAACI,kCAAnC;AACAJ,SAAI,CAACK,iBAAL,GAAyBL,KAAI,CAACM,IAA9B;AACAN,SAAI,CAACO,uBAAL,GAA+BP,KAAI,CAACQ,uBAApC;AACAR,SAAI,CAACS,wBAAL,GAAgCT,KAAI,CAACU,gBAArC;AACAV,SAAI,CAACW,kBAAL,GAA0BX,KAAI,CAACY,cAA/B;AACAZ,SAAI,CAACa,8BAAL,GAAsC,IAAIC,uDAAJ,CAA+BC,4BAA/B,CAAtC;AACAf,SAAI,CAACgB,iCAAL,GAAyCrB,iBAAzC;AACAK,SAAI,CAACiB,0BAAL,GAAkC,KAAlC;;AACH;;AAEMC,oDAAP;AACI,WAAOnB,iBAAMoB,UAAN,CAAgBC,IAAhB,CAAgB,IAAhB,KAAsB,KAAKH,0BAAlC;AACH,GAFM;;AAIMC,iDAAb,UAAqBG,MAArB,EAAoC;;;;;;AAChC,iBAAKJ,0BAAL,GAAkC,IAAlC;iBACI,KAAKK,6BAAL;AAAA;AAAA;AACgC;AAAA;AAAA,cAAM,KAAKA,2BAAX;;;AAA1BC,sBAAU,GAAgBC,SAA1B;AACN;AAAA;AAAA,cAAMD,UAAU,CAACE,OAAX,CAAmBJ,MAAnB,CAAN;;;AAAAG;;;;;AAEJ;AAAA;AAAA,cAAMzB,iBAAM0B,OAAN,CAAaL,IAAb,CAAa,IAAb,EAAcC,MAAd,CAAN;;;AAAAG;;;;;;;;AACH,GAPY;;AASAN,qDAAb,UAAyBQ,OAAzB,EAAwC;;;;;;AACJ;AAAA;AAAA,cAAM,KAAKC,eAAL,EAAN;;;AAA1BJ,sBAAU,GAAgBC,SAA1B;AACN;AAAA;AAAA,cAAOD,UAAU,CAACK,IAAX,CAAgB,IAAIC,6DAAJ,CACnBd,sBAAYe,IADO,EAEnBJ,OAFmB,CAAhB,CAAP;;;;AAGH,GALY;;AAOAR,0DAAb,UAA8BQ,OAA9B,EAA6C;;;;;;AACnCK,gBAAI,GAAmB,IAAIhB,kBAAJ,EAAvB;AAE0B;AAAA;AAAA,cAAM,KAAKY,eAAL,EAAN;;;AAA1BJ,sBAAU,GAAgBC,SAA1B;AAEN;AAAA;AAAA,cAAMD,UAAU,CAACK,IAAX,CAAgB,IAAIC,6DAAJ,CAAkCd,sBAAYe,IAA9C,EAAoDJ,OAApD,CAAhB,CAAN;;;AAAAF;;;;;;;;AACH,GANY;;AAQHN,wDAAV;AACI,QAAI,KAAKc,oBAAT,EAA+B;AAC3B;AACH;;AACD,SAAKC,iBAAL,CAAuB,KAAKpB,8BAAL,CAAoCqB,SAA3D,EACI,KAAKrB,8BAAL,CAAoCsB,SADxC,EAEIC,6BAAmBC,KAFvB,EAGID,gCAAsBE,OAH1B,EAII,eAJJ;AAMA,SAAKN,oBAAL,GAA4B,IAA5B;AACA,WAAOO,OAAO,CAACC,OAAR,EAAP;AACH,GAZS;;AAcMtB,qEAAhB,UACIuB,iBADJ,EAEIC,eAFJ,EAGIC,aAHJ,EAGuC;;;AACnC;AAAA;AAAA,UAAO,IAAP;;;AACH,GALe,CA3EpB,CAkFI;;;AACUzB,2DAAV,UACIgB,SADJ,EAEIC,SAFJ,EAGIS,kBAHJ,EAIIC,SAJJ,EAKIC,KALJ,EAKiB;AAEb,SAAKd,oBAAL,GAA4B,IAA5B;AAEA,QAAMe,WAAW,GAA6C,IAAIX,kDAAJ,CAC1DQ,kBAD0D,EAE1DE,KAF0D,EAG1DD,SAH0D,EAI1DG,SAJ0D,EAK1Dd,SAL0D,CAA9D;;AAOA,QAAI;AACA,UAAI,CAAC,CAAC,KAAKjC,gCAAL,CAAsCgD,QAA5C,EAAsD;AAClD,aAAKhD,gCAAL,CAAsCgD,QAAtC,CAA+C,KAAKhD,gCAApD,EAAsF8C,WAAtF;AACH;AACJ,KAJD,CAIE,WAAM,CACJ;AACH;AACJ,GAvBS;AA6BV;;;;;;AAIgB7B,iEAAhB,UAAwCK,UAAxC,EAAwE;;;AACpE,aAAK2B,kBAAL,GAA0B,KAAKC,gBAAL,EAA1B;AACA;AAAA;AAAA,UAAO5B,UAAP;;;AACH,GAHe;AAKhB;;;;;AAGcL,4EAAd;;;;;;AACI,gBAAI,KAAKC,UAAL,MAAqB,KAAKa,oBAA9B,EAAoD;AAChD;AAAA;AAAA,gBAAOO,OAAO,CAACC,OAAR,EAAP;AACH;;AAEKY,kCAAsB,GAAmB,IAAIrC,kBAAJ,EAAzC;;;;;;AAG8B;AAAA;AAAA,cAAM,KAAKY,eAAL,EAAN;;;AAA1BJ,sBAAU,GAAgBC,SAA1B;AACyC;AAAA;AAAA,cAAMD,UAAU,CAAC8B,IAAX,EAAN;;;AAAzC3B,mBAAO,GAAkCF,SAAzC;;AACN,gBAAI,KAAKL,UAAL,MAAqB,KAAKa,oBAA9B,EAAoD;AAChD;AACAoB,oCAAsB,CAACZ,OAAvB;AACA;AAAA;AAAA,gBAAOD,OAAO,CAACC,OAAR,EAAP;AACH;;AAED,gBAAI,CAACd,OAAL,EAAc;AACV;AAAA;AAAA,gBAAO,KAAKtB,kCAAL,EAAP;AACH;;AAEK8B,qBAAS,GAAW,KAAKrB,8BAAL,CAAoCqB,SAAxD;AACFoB,qBAAS,GAAY,KAArB;;AAEJ,gBAAI;AACA,sBAAQ5B,OAAO,CAAC6B,uBAAR,CAAgCC,WAAhC,EAAR;AACI,qBAAK,MAAL;AACA,qBAAK,qBAAL;AACA,qBAAK,SAAL;AACUC,gCAAc,GAA2BC,iCAAuBC,QAAvB,CAAgCjC,OAAO,CAACkC,QAAxC,CAAzC;;AACN,0BAAQH,cAAc,CAACI,OAAf,CAAuBL,WAAvB,EAAR;AAEI;;;;;AAKA,yBAAK,iBAAL;AAEUM,yCAAmB,GAAqCJ,0CAAgCC,QAAhC,CAAyCjC,OAAO,CAACkC,QAAjD,CAAxD;AAEAG,wCAAkB,GAA2BD,mBAAmB,CAACE,YAApB,CAAiCC,GAAjC,CAAqC,UAACC,CAAD,EAA+B;AACnH,4BAAMC,WAAW,GAAyB;AACtCC,gCAAM,EAAEF,CAAC,CAACE,MAD4B;AAEtCC,qCAAW,EAAEH,CAAC,CAACI,QAFuB;AAGtCC,4BAAE,EAAEL,CAAC,CAACM,aAHgC;AAItCC,gCAAM,EAAEP,CAAC,CAACQ,MAJ4B;AAKtCC,iCAAO,EAAET,CAAC,CAACU,OAL2B;AAMtCC,oCAAU,EAAEX,CAAC,CAACY,MANwB;AAOtCC,2CAAiB,EAAEb,CAAC,CAACc;AAPiB,yBAA1C;AASA,+BAAOb,WAAP;AACH,uBAXkD,CAA7C;;AAaN,0BAAI,CAAC,CAAC,KAAKlE,gCAAL,CAAsCgF,wBAA5C,EAAsE;AAClE,6BAAKhF,gCAAL,CAAsCgF,wBAAtC,CAA+D,KAAKhF,gCAApE,EACI,IAAIiF,2DAAJ,CAA8BpB,mBAAmB,CAACqB,MAAlD,EAA0DrB,mBAAmB,CAACsB,KAA9E,EACItB,mBAAmB,CAACuB,WADxB,EACqCvB,mBAAmB,CAACwB,eADzD,EAEIxB,mBAAmB,CAACyB,mBAFxB,EAE6CzB,mBAAmB,CAAC0B,UAFjE,EAGI1B,mBAAmB,CAAC2B,OAHxB,EAGiC1B,kBAHjC,EAGqD7B,SAHrD,CADJ;AAKH;;AACD;;AAEJ;;;;;AAIA,yBAAK,yBAAL;AAEI,0BAAI,CAAC,CAAC,KAAKjC,gCAAL,CAAsCyF,gCAA5C,EAA8E;AAC1E,6BAAKzF,gCAAL,CAAsCyF,gCAAtC,CAAuE,KAAKzF,gCAA5E,EACI,IAAIiF,+DAAJ,CAAkCzB,cAAc,CAACe,aAAjD,EACImB,sEAAmCC,uBADvC,EAEInC,cAAc,CAACoC,KAFnB,EAE0B3D,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;;;;;;AAMA,yBAAK,uBAAL;AAEI,0BAAI,CAAC,CAAC,KAAKjC,gCAAL,CAAsCyF,gCAA5C,EAA8E;AAC1E,6BAAKzF,gCAAL,CAAsCyF,gCAAtC,CAAuE,KAAKzF,gCAA5E,EACI,IAAIiF,+DAAJ,CAAkCzB,cAAc,CAACe,aAAjD,EACImB,sEAAmCG,qBADvC,EAEIrC,cAAc,CAACoC,KAFnB,EAE0B3D,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;;;;AAIA,yBAAK,SAAL;AAEI,0BAAI,CAAC,CAAC,KAAKjC,gCAAL,CAAsCyF,gCAA5C,EAA8E;AAC1E,6BAAKzF,gCAAL,CAAsCyF,gCAAtC,CAAuE,KAAKzF,gCAA5E,EACI,IAAIiF,+DAAJ,CAAkCzB,cAAc,CAACe,aAAjD,EACImB,sEAAmCI,OADvC,EAEItC,cAAc,CAACoC,KAFnB,EAE0B3D,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;;;AAGA,yBAAK,YAAL;AAEI,0BAAI,CAAC,CAAC,KAAKjC,gCAAL,CAAsC+F,sBAA5C,EAAoE;AAChE,6BAAK/F,gCAAL,CAAsC+F,sBAAtC,CAA6D,KAAK/F,gCAAlE,EACI,IAAIiF,kDAAJ,CAAqBzB,cAAc,CAACoC,KAApC,EAAsD3D,SAAtD,CADJ;AAEH;;AAED;;AAEJ;;;;AAGA,yBAAK,uBAAL;AAEI,0BAAI,CAAC,CAAC,KAAKjC,gCAAL,CAAsCgG,sBAA5C,EAAoE;AAChE,6BAAKhG,gCAAL,CAAsCgG,sBAAtC,CAA6D,KAAKhG,gCAAlE,EACI,IAAImC,yCAAJ,CAAoCqB,cAAc,CAACoC,KAAnD,EAAoE,KAAKhF,8BAAL,CAAoCqB,SAAxG,CADJ;AAEH;;AAED;;AAEJ;;;;AAGA,yBAAK,WAAL;AAEI,0BAAI,CAAC,CAAC,KAAKjC,gCAAL,CAAsCyF,gCAA5C,EAA8E;AAC1E,6BAAKzF,gCAAL,CAAsCyF,gCAAtC,CAAuE,KAAKzF,gCAA5E,EACI,IAAIiF,+DAAJ,CAAkCzB,cAAc,CAACe,aAAjD,EACImB,sEAAmCO,SADvC,EAEIzC,cAAc,CAACoC,KAFnB,EAE0B3D,SAF1B,CADJ;AAIH;;AAED;;AAEJ;;;;AAGA,yBAAK,cAAL;AAEI,0BAAI,CAAC,CAAC,KAAKjC,gCAAL,CAAsCkG,uBAA5C,EAAqE;AACjE,6BAAKlG,gCAAL,CAAsCkG,uBAAtC,CAA8D,KAAKlG,gCAAnE,EACI,IAAIiF,mDAAJ,CAAsBzB,cAAc,CAACoC,KAArC,EAAuD3D,SAAvD,CADJ;AAEH;;AAED;;AAEJ;;;;;AAIA,yBAAK,gBAAL;AAEI,0BAAI,CAAC,CAAC,KAAKjC,gCAAL,CAAsCyF,gCAA5C,EAA8E;AAC1E,6BAAKzF,gCAAL,CAAsCyF,gCAAtC,CAAuE,KAAKzF,gCAA5E,EACI,IAAIiF,+DAAJ,CAAkCzB,cAAc,CAACe,aAAjD,EACImB,sEAAmCS,cADvC,EAEI3C,cAAc,CAACa,QAFnB,EAE6BpC,SAF7B,CADJ;AAIH;;AAED;;AAEJ;;;;AAGA,yBAAK,aAAL;AAEUmE,4CAAsB,GAA+B3C,qCAA2BC,QAA3B,CAAoCjC,OAAO,CAACkC,QAA5C,CAArD;AAEA0C,wCAAkB,GAAyB;AAC7ClC,8BAAM,EAAEiC,sBAAsB,CAACjC,MADc;AAE7CC,mCAAW,EAAEgC,sBAAsB,CAAC/B,QAFS;AAG7CC,0BAAE,EAAE8B,sBAAsB,CAAC7B,aAHkB;AAI7CC,8BAAM,EAAE4B,sBAAsB,CAAC3B,MAJc;AAK7CC,+BAAO,EAAE0B,sBAAsB,CAACzB,OALa;AAM7CC,kCAAU,EAAEwB,sBAAsB,CAACvB,MANU;AAO7CC,yCAAiB,EAAEsB,sBAAsB,CAACrB;AAPG,uBAA3C;;AAUN,0BAAI,CAAC,CAAC,KAAK/E,gCAAL,CAAsCsG,8BAA5C,EAA4E;AACxE,6BAAKtG,gCAAL,CAAsCsG,8BAAtC,CAAqE,KAAKtG,gCAA1E,EACI,IAAIiF,sDAAJ,CACIoB,kBADJ,EAEIpE,SAFJ,CADJ;AAIH;;AAED;;AAEJ;;;;AAGA,yBAAK,cAAL;AAEUsE,wCAAkB,GAAyB;AAC7CjC,0BAAE,EAAEd,cAAc,CAACe;AAD0B,uBAA3C;;AAIN,0BAAI,CAAC,CAAC,KAAKvE,gCAAL,CAAsCwG,+BAA5C,EAA6E;AACzE,6BAAKxG,gCAAL,CAAsCwG,+BAAtC,CAAsE,KAAKxG,gCAA3E,EACI,IAAIiF,sDAAJ,CAAyBsB,kBAAzB,EAA6CtE,SAA7C,CADJ;AAEH;;AAED;;AAEJ;;;;;AAIA,yBAAK,mBAAL;AAEUwE,2CAAqB,GAAyB;AAChDnC,0BAAE,EAAEd,cAAc,CAACe;AAD6B,uBAA9C;AAIN;;AAEJ;;;;AAGA;AACI;AA3MR;;AA6MA;;AAEJ;;;;AAGA,qBAAK,SAAL;AAEA;;;;AAGA,qBAAK,OAAL;AAEUmC,+BAAa,GAA0BjD,gCAAsBC,QAAtB,CAA+BjC,OAAO,CAACkC,QAAvC,CAAvC;AAEAgD,8BAAY,GAAkC,IAAIxE,uCAAJ,CAAkCuE,aAAa,CAACnC,aAAhD,EAChD,KAAKqC,eAAL,CAAqBF,aAAa,CAACG,YAAnC,CADgD,EAEhDH,aAAa,CAACI,QAFkC,EAGhD/D,SAHgD,EAIhDA,SAJgD,EAKhD2D,aAAa,CAACK,WALkC,EAMhDhE,SANgD,EAOhDA,SAPgD,EAQhDtB,OAAO,CAACkC,QARwC,EAShDZ,SATgD,CAA9C;;AAWN,sBAAI2D,aAAa,CAACM,OAAlB,EAA2B;AACvB;AACA,wBAAIL,YAAY,CAACM,IAAb,KAAsBlE,SAAtB,IAAmC4D,YAAY,CAACM,IAAb,CAAkBC,MAAlB,GAA2B,CAAlE,EAAqE;AACjE7D,+BAAS,GAAG,IAAZ;AACH,qBAFD,MAEO,IAAIqD,aAAa,CAACpC,EAAd,KAAqB,KAAK6C,0BAA9B,EAA0D;AAC7D;AACA;AACA9D,+BAAS,GAAG,IAAZ;AACH,qBAJM,MAIA,CACH;AACH;;AAED,wBAAIA,SAAJ,EAAe;AACX,0BAAI,CAAC,CAAC,KAAKrD,gCAAL,CAAsCoH,mBAA5C,EAAiE;AAC7D,6BAAKpH,gCAAL,CAAsCoH,mBAAtC,CAA0D,KAAKpH,gCAA/D,EACI,IAAIiF,0EAAJ,CAA6CS,sEAAmC2B,KAAhF,EAAuFV,YAAvF,EAAqG1E,SAArG,CADJ;AAEH;AACJ;AACJ,mBAlBD,MAkBO,IAAI0E,YAAY,CAACM,IAAb,KAAsBlE,SAA1B,EAAqC;AACxC,yBAAKoE,0BAAL,GAAkCT,aAAa,CAACpC,EAAhD;;AACA,wBAAI,CAAC,CAAC,KAAKtE,gCAAL,CAAsCoH,mBAA5C,EAAiE;AAC7D,2BAAKpH,gCAAL,CAAsCoH,mBAAtC,CAA0D,KAAKpH,gCAA/D,EACI,IAAIiF,0EAAJ,CAA6CS,sEAAmC4B,OAAhF,EAAyFX,YAAzF,EAAuG1E,SAAvG,CADJ;AAEH;AACJ;;AAED;;AAEJ;;;;AAGA,qBAAK,oBAAL;AAEUsF,6BAAW,GAAwB9D,8BAAoBC,QAApB,CAA6BjC,OAAO,CAACkC,QAArC,CAAnC;AAEA6D,4BAAU,GAAkC,IAAIrF,uCAAJ,CAAkCoF,WAAW,CAAChD,aAA9C,EAC9C,KAAKqC,eAAL,CAAqBW,WAAW,CAACV,YAAjC,CAD8C,EAE9CU,WAAW,CAACT,QAFkC,EAG9C/D,SAH8C,EAI9CA,SAJ8C,EAK9CwE,WAAW,CAACE,YALkC,EAM9C1E,SAN8C,EAO9CA,SAP8C,EAQ9CA,SAR8C,EAS9CtB,OAAO,CAACkC,QATsC,EAU9CZ,SAV8C,CAA5C;;AAYN,sBAAI,CAAC,CAAC,KAAK/C,gCAAL,CAAsCoH,mBAA5C,EAAiE;AAC7D,yBAAKpH,gCAAL,CAAsCoH,mBAAtC,CAA0D,KAAKpH,gCAA/D,EACI,IAAIiF,0EAAJ,CAA6CS,sEAAmCgC,cAAhF,EAAgGF,UAAhG,EAA4GvF,SAA5G,CADJ;AAEH;;AACD;;AAEJ;AACI;AACA;AAlSR;AAoSH,aArSD,CAqSE,OAAO0F,CAAP,EAAU,CACR;AACH;;AACD;AAAA;AAAA,cAAO,KAAKxH,kCAAL,EAAP;;;;AAEA,iBAAK4B,oBAAL,GAA4B,IAA5B;;;;;;AAGJ;AAAA;AAAA,cAAOoB,sBAAsB,CAACyE,OAA9B;;;;AACH,GArUa;;AAuUA3G,0DAAd;;;;;;AACI,gBAAI,KAAKC,UAAL,EAAJ,EAAuB;AACnB;AAAA;AAAA,gBAAOoB,OAAO,CAACC,OAAR,EAAP;AACH;;AACD,iBAAKR,oBAAL,GAA4B,KAA5B;AAEM8F,mCAAuB,GAAG,KAAK1H,kCAAL,EAA1B;;;;;;AAGQ;AAAA;AAAA,cAAM0H,uBAAN;;;AAAJC,aAAC,GAAGvG,SAAJ;AACN;AAAA;AAAA,cAAOuG,CAAP;;;;AAEA,iBAAK9F,iBAAL,CAAuB,KAAK+F,kBAAL,GAA0B,KAAKA,kBAAL,CAAwB9F,SAAlD,GAA8D,EAArF,EAAyF,KAAK8F,kBAAL,GAA0B,KAAKA,kBAAL,CAAwB7F,SAAlD,GAA8D,EAAvJ,EAA2JC,6BAAmBC,KAA9K,EAAqLD,gCAAsB6F,YAA3M,EAAyNC,OAAzN;AACA;AAAA;AAAA,cAAO,IAAP;;;;;;;;;AAEP,GAfa,CAnclB,CAodI;;;AACQhH,0DAAR;AAAA;;AACI,QAAI,KAAKC,UAAL,EAAJ,EAAuB;AACnB,aAAOoB,OAAO,CAACC,OAAR,CAA6BQ,SAA7B,CAAP;AACH;;AACD,QAAI,KAAK1B,2BAAT,EAAsC;AAClC,aAAO,KAAKA,2BAAL,CAAiC6G,IAAjC,CAAsC,UAAC5G,UAAD,EAAwB;AACjE,YAAIA,UAAU,CAAC6G,KAAX,OAAuBrH,0BAAgBsH,YAA3C,EAAyD;AACrDrI,eAAI,CAACsI,gBAAL,GAAwB,IAAxB;AACAtI,eAAI,CAACsB,2BAAL,GAAmC,IAAnC;AACA,iBAAOtB,KAAI,CAACU,gBAAL,EAAP;AACH;;AACD,eAAOV,KAAI,CAACsB,2BAAZ;AACH,OAPM,EAOJ,UAACwB,KAAD,EAAc;AACb9C,aAAI,CAACsI,gBAAL,GAAwB,IAAxB;AACAtI,aAAI,CAACsB,2BAAL,GAAmC,IAAnC;AACA,eAAOtB,KAAI,CAACU,gBAAL,EAAP;AACH,OAXM,CAAP;AAYH;;AACD,QAAI,KAAKsB,oBAAT,EAA+B;AAC3B,aAAOO,OAAO,CAACC,OAAR,CAA6BQ,SAA7B,CAAP;AACH;;AAED,SAAK1B,2BAAL,GAAmC,KAAKiH,WAAL,GAAmBJ,IAAnB,CAAwB,UAAC5G,UAAD,EAAwB;AAC/E,aAAOA,UAAP;AACH,KAFkC,CAAnC;AAIA,WAAO,KAAKD,2BAAZ;AACH,GA3BO;;AA6BAJ,yDAAR,UAAwBsH,yBAAxB,EAAgF;AAC5E,QAAI1B,YAAJ;;AAEA,QAAI9D,SAAS,KAAKwF,yBAAlB,EAA6C;AACzC1B,kBAAY,GAAG,IAAI1E,sBAAJ,EAAf;;AACA,WAA0B,mEAA1B,EAA0BqG,uCAA1B,EAA0BA,IAA1B,EAAqD;AAAhD,YAAMC,WAAW,kCAAjB;AACD5B,oBAAY,CAAC6B,GAAb,CAAiBD,WAAW,CAACE,IAA7B,EAAmCF,WAAW,CAACA,WAA/C;AACH;AACJ;;AAED,WAAO5B,YAAP;AACH,GAXO;;AAYZ;AAAC,CA9fD,CAAgD+B,+BAAhD;;AAAaC","names":["__extends","authentication","connectionFactory","audioSource","recognizerConfig","conversationServiceConnector","_super","_this","privConversationServiceConnector","privConversationAuthentication","receiveMessageOverride","receiveConversationMessageOverride","recognizeOverride","noOp","postConnectImplOverride","conversationConnectImpl","configConnectionOverride","configConnection","disconnectOverride","privDisconnect","privConversationRequestSession","ConversationRequestSession_1","Exports_1","privConversationConnectionFactory","privConversationIsDisposed","ConversationServiceAdapter","isDisposed","call","reason","privConnectionConfigPromise","connection","_a","dispose","message","fetchConnection","send","ConversationConnectionMessage_1","Text","sink","terminateMessageLoop","cancelRecognition","sessionId","requestId","Exports_2","Error","NoError","Promise","resolve","connectionMessage","successCallback","errorCallBack","cancellationReason","errorCode","error","cancelEvent","undefined","canceled","privConnectionLoop","startMessageLoop","communicationCustodian","read","sendFinal","conversationMessageType","toLowerCase","commandPayload","Exports_4","fromJSON","textBody","command","participantsPayload","participantsResult","participants","map","p","participant","avatar","displayName","nickname","id","participantId","isHost","ishost","isMuted","ismuted","isUsingTts","usetts","preferredLanguage","locale","participantsListReceived","ConversationTranslatorEventArgs_1","roomid","token","translateTo","profanityFilter","roomProfanityFilter","roomLocked","muteAll","participantUpdateCommandReceived","ConversationTranslatorInterfaces_1","setTranslateToLanguages","value","setProfanityFiltering","setMute","muteAllCommandReceived","conversationExpiration","setUseTTS","lockRoomCommandReceived","changeNickname","joinParticipantPayload","joiningParticipant","participantJoinCommandReceived","leavingParticipant","participantLeaveCommandReceived","disconnectParticipant","speechPayload","speechResult","getTranslations","translations","language","recognition","isFinal","text","length","privLastPartialUtteranceId","translationReceived","final","partial","textPayload","textResult","originalText","instantMessage","e","promise","messageRetrievalPromise","r","privRequestSession","RuntimeError","error_1","then","state","Disconnected","privConnectionId","connectImpl","serviceResultTranslations","_i","translation","set","lang","Exports_3","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/src/common.speech/Transcription/ConversationServiceAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionMessage,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IConnection,\r\n    MessageType,\r\n} from \"../../common/Exports\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ConversationExpirationEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationResult,\r\n    Translations\r\n} from \"../../sdk/Exports\";\r\nimport {\r\n    IAuthentication,\r\n    IConnectionFactory,\r\n    RecognizerConfig,\r\n    ServiceRecognizerBase\r\n} from \"../Exports\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\r\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\r\nimport {\r\n    ConversationReceivedTranslationEventArgs,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs\r\n} from \"./ConversationTranslatorEventArgs\";\r\nimport {\r\n    ConversationTranslatorCommandTypes,\r\n    ConversationTranslatorMessageTypes,\r\n    IInternalParticipant\r\n} from \"./ConversationTranslatorInterfaces\";\r\nimport { ConversationTranslatorRecognizer } from \"./ConversationTranslatorRecognizer\";\r\nimport {\r\n    CommandResponsePayload,\r\n    IParticipantPayloadResponse,\r\n    IParticipantsListPayloadResponse,\r\n    ITranslationResponsePayload,\r\n    ParticipantPayloadResponse,\r\n    ParticipantsListPayloadResponse,\r\n    SpeechResponsePayload,\r\n    TextResponsePayload\r\n} from \"./ServiceMessages/Exports\";\r\n\r\n/***\r\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\r\n */\r\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\r\n    private privConversationServiceConnector: ConversationTranslatorRecognizer;\r\n    private privConversationConnectionFactory: IConnectionFactory;\r\n    private privConversationAuthFetchEventId: string;\r\n    private privConversationAuthentication: IAuthentication;\r\n    private privConversationRequestSession: ConversationRequestSession;\r\n    private privConnectionConfigPromise: Promise<IConnection>;\r\n    private privConnectionLoop: Promise<void>;\r\n    private terminateMessageLoop: boolean;\r\n    private privLastPartialUtteranceId: string = \"\";\r\n    private privConversationIsDisposed: boolean;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        conversationServiceConnector: ConversationTranslatorRecognizer) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\r\n\r\n        this.privConversationServiceConnector = conversationServiceConnector;\r\n        this.privConversationAuthentication = authentication;\r\n        this.receiveMessageOverride = this.receiveConversationMessageOverride;\r\n        this.recognizeOverride = this.noOp;\r\n        this.postConnectImplOverride = this.conversationConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\r\n        this.privConversationConnectionFactory = connectionFactory;\r\n        this.privConversationIsDisposed = false;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return super.isDisposed() || this.privConversationIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privConversationIsDisposed = true;\r\n        if (this.privConnectionConfigPromise) {\r\n            const connection: IConnection = await this.privConnectionConfigPromise;\r\n            await connection.dispose(reason);\r\n        }\r\n        await super.dispose(reason);\r\n    }\r\n\r\n    public async sendMessage(message: string): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new ConversationConnectionMessage(\r\n            MessageType.Text,\r\n            message));\r\n    }\r\n\r\n    public async sendMessageAsync(message: string): Promise<void> {\r\n        const sink: Deferred<void> = new Deferred<void>();\r\n\r\n        const connection: IConnection = await this.fetchConnection();\r\n\r\n        await connection.send(new ConversationConnectionMessage(MessageType.Text, message));\r\n    }\r\n\r\n    protected privDisconnect(): Promise<void> {\r\n        if (this.terminateMessageLoop) {\r\n            return;\r\n        }\r\n        this.cancelRecognition(this.privConversationRequestSession.sessionId,\r\n            this.privConversationRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        return Promise.resolve();\r\n    }\r\n\r\n    protected async processTypeSpecificMessages(\r\n        connectionMessage: ConnectionMessage,\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void): Promise<boolean> {\r\n        return true;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n            cancellationReason,\r\n            error,\r\n            errorCode,\r\n            undefined,\r\n            sessionId);\r\n\r\n        try {\r\n            if (!!this.privConversationServiceConnector.canceled) {\r\n                this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\r\n            }\r\n        } catch {\r\n            // continue on error\r\n        }\r\n    }\r\n\r\n    protected noOp = (): any => {\r\n        // operation not supported\r\n    }\r\n\r\n    /**\r\n     * Establishes a websocket connection to the end point.\r\n     * @param isUnAuthorized\r\n     */\r\n    protected async conversationConnectImpl(connection: Promise<IConnection>): Promise<IConnection> {\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return connection;\r\n    }\r\n\r\n    /**\r\n     * Process incoming websocket messages\r\n     */\r\n    private async receiveConversationMessageOverride(): Promise<void> {\r\n        if (this.isDisposed() || this.terminateMessageLoop) {\r\n            return Promise.resolve();\r\n        }\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<void> = new Deferred<void>();\r\n\r\n        try {\r\n            const connection: IConnection = await this.fetchConnection();\r\n            const message: ConversationConnectionMessage = await connection.read() as ConversationConnectionMessage;\r\n            if (this.isDisposed() || this.terminateMessageLoop) {\r\n                // We're done.\r\n                communicationCustodian.resolve();\r\n                return Promise.resolve();\r\n            }\r\n\r\n            if (!message) {\r\n                return this.receiveConversationMessageOverride();\r\n            }\r\n\r\n            const sessionId: string = this.privConversationRequestSession.sessionId;\r\n            let sendFinal: boolean = false;\r\n\r\n            try {\r\n                switch (message.conversationMessageType.toLowerCase()) {\r\n                    case \"info\":\r\n                    case \"participant_command\":\r\n                    case \"command\":\r\n                        const commandPayload: CommandResponsePayload = CommandResponsePayload.fromJSON(message.textBody);\r\n                        switch (commandPayload.command.toLowerCase()) {\r\n\r\n                            /**\r\n                             * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\r\n                             * The consuming client must wait for this message to arrive\r\n                             * before starting to send their own data.\r\n                             */\r\n                            case \"participantlist\":\r\n\r\n                                const participantsPayload: IParticipantsListPayloadResponse = ParticipantsListPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                const participantsResult: IInternalParticipant[] = participantsPayload.participants.map((p: IParticipantPayloadResponse) => {\r\n                                    const participant: IInternalParticipant = {\r\n                                        avatar: p.avatar,\r\n                                        displayName: p.nickname,\r\n                                        id: p.participantId,\r\n                                        isHost: p.ishost,\r\n                                        isMuted: p.ismuted,\r\n                                        isUsingTts: p.usetts,\r\n                                        preferredLanguage: p.locale\r\n                                    };\r\n                                    return participant;\r\n                                });\r\n\r\n                                if (!!this.privConversationServiceConnector.participantsListReceived) {\r\n                                    this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token,\r\n                                            participantsPayload.translateTo, participantsPayload.profanityFilter,\r\n                                            participantsPayload.roomProfanityFilter, participantsPayload.roomLocked,\r\n                                            participantsPayload.muteAll, participantsResult, sessionId));\r\n                                }\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\r\n                             * This is sent at the start of the Conversation\r\n                             */\r\n                            case \"settranslatetolanguages\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setTranslateToLanguages,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\r\n                             * If sent by the participant the setting will effect only their own profanity level.\r\n                             * If sent by the host, the setting will effect all participants including the host.\r\n                             * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\r\n                             */\r\n                            case \"setprofanityfiltering\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setProfanityFiltering,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetMute' is sent if the participant has been muted by the host.\r\n                             * Check the 'participantId' to determine if the current user has been muted.\r\n                             */\r\n                            case \"setmute\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setMute,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetMuteAll' is sent if the Conversation has been muted by the host.\r\n                             */\r\n                            case \"setmuteall\":\r\n\r\n                                if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\r\n                                    this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector,\r\n                                        new MuteAllEventArgs(commandPayload.value as boolean, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\r\n                             */\r\n                            case \"roomexpirationwarning\":\r\n\r\n                                if (!!this.privConversationServiceConnector.conversationExpiration) {\r\n                                    this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector,\r\n                                        new ConversationExpirationEventArgs(commandPayload.value as number, this.privConversationRequestSession.sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\r\n                             */\r\n                            case \"setusetts\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setUseTTS,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetLockState' is set if the host has locked or unlocked the Conversation.\r\n                             */\r\n                            case \"setlockstate\":\r\n\r\n                                if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\r\n                                    this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector,\r\n                                        new LockRoomEventArgs(commandPayload.value as boolean, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'ChangeNickname' is received if a user changes their display name.\r\n                             * Any cached particpiants list should be updated to reflect the display name.\r\n                             */\r\n                            case \"changenickname\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.changeNickname,\r\n                                            commandPayload.nickname, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'JoinSession' is sent when a user joins the Conversation.\r\n                             */\r\n                            case \"joinsession\":\r\n\r\n                                const joinParticipantPayload: ParticipantPayloadResponse = ParticipantPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                const joiningParticipant: IInternalParticipant = {\r\n                                    avatar: joinParticipantPayload.avatar,\r\n                                    displayName: joinParticipantPayload.nickname,\r\n                                    id: joinParticipantPayload.participantId,\r\n                                    isHost: joinParticipantPayload.ishost,\r\n                                    isMuted: joinParticipantPayload.ismuted,\r\n                                    isUsingTts: joinParticipantPayload.usetts,\r\n                                    preferredLanguage: joinParticipantPayload.locale,\r\n                                };\r\n\r\n                                if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantEventArgs(\r\n                                            joiningParticipant,\r\n                                            sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'LeaveSession' is sent when a user leaves the Conversation'.\r\n                             */\r\n                            case \"leavesession\":\r\n\r\n                                const leavingParticipant: IInternalParticipant = {\r\n                                    id: commandPayload.participantId\r\n                                };\r\n\r\n                                if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantEventArgs(leavingParticipant, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\r\n                             * Check the 'ParticipantId' to check whether the message is for the current user.\r\n                             */\r\n                            case \"disconnectsession\":\r\n\r\n                                const disconnectParticipant: IInternalParticipant = {\r\n                                    id: commandPayload.participantId\r\n                                };\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * Message not recognized.\r\n                             */\r\n                            default:\r\n                                break;\r\n                        }\r\n                        break;\r\n\r\n                    /**\r\n                     * 'partial' (or 'hypothesis') represents a unfinalized speech message.\r\n                     */\r\n                    case \"partial\":\r\n\r\n                    /**\r\n                     * 'final' (or 'phrase') represents a finalized speech message.\r\n                     */\r\n                    case \"final\":\r\n\r\n                        const speechPayload: SpeechResponsePayload = SpeechResponsePayload.fromJSON(message.textBody);\r\n\r\n                        const speechResult: ConversationTranslationResult = new ConversationTranslationResult(speechPayload.participantId,\r\n                            this.getTranslations(speechPayload.translations),\r\n                            speechPayload.language,\r\n                            undefined,\r\n                            undefined,\r\n                            speechPayload.recognition,\r\n                            undefined,\r\n                            undefined,\r\n                            message.textBody,\r\n                            undefined);\r\n\r\n                        if (speechPayload.isFinal) {\r\n                            // check the length, sometimes empty finals are returned\r\n                            if (speechResult.text !== undefined && speechResult.text.length > 0) {\r\n                                sendFinal = true;\r\n                            } else if (speechPayload.id === this.privLastPartialUtteranceId) {\r\n                                // send final as normal. We had a non-empty partial for this same utterance\r\n                                // so sending the empty final is important\r\n                                sendFinal = true;\r\n                            } else {\r\n                                // suppress unneeded final\r\n                            }\r\n\r\n                            if (sendFinal) {\r\n                                if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                        new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\r\n                                }\r\n                            }\r\n                        } else if (speechResult.text !== undefined) {\r\n                            this.privLastPartialUtteranceId = speechPayload.id;\r\n                            if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                    new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\r\n                            }\r\n                        }\r\n\r\n                        break;\r\n\r\n                    /**\r\n                     * \"translated_message\" is a text message or instant message (IM).\r\n                     */\r\n                    case \"translated_message\":\r\n\r\n                        const textPayload: TextResponsePayload = TextResponsePayload.fromJSON(message.textBody);\r\n\r\n                        const textResult: ConversationTranslationResult = new ConversationTranslationResult(textPayload.participantId,\r\n                            this.getTranslations(textPayload.translations),\r\n                            textPayload.language,\r\n                            undefined,\r\n                            undefined,\r\n                            textPayload.originalText,\r\n                            undefined,\r\n                            undefined,\r\n                            undefined,\r\n                            message.textBody,\r\n                            undefined);\r\n\r\n                        if (!!this.privConversationServiceConnector.translationReceived) {\r\n                            this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        // ignore any unsupported message types\r\n                        break;\r\n                }\r\n            } catch (e) {\r\n                // continue\r\n            }\r\n            return this.receiveConversationMessageOverride();\r\n        } catch (e) {\r\n            this.terminateMessageLoop = true;\r\n        }\r\n\r\n        return communicationCustodian.promise;\r\n    }\r\n\r\n    private async startMessageLoop(): Promise<void> {\r\n        if (this.isDisposed()) {\r\n            return Promise.resolve();\r\n        }\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveConversationMessageOverride();\r\n\r\n        try {\r\n            const r = await messageRetrievalPromise;\r\n            return r;\r\n        } catch (error) {\r\n            this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.isDisposed()) {\r\n            return Promise.resolve<IConnection>(undefined);\r\n        }\r\n        if (this.privConnectionConfigPromise) {\r\n            return this.privConnectionConfigPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigPromise = null;\r\n                    return this.configConnection();\r\n                }\r\n                return this.privConnectionConfigPromise;\r\n            }, (error: string): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigPromise = null;\r\n                return this.configConnection();\r\n            });\r\n        }\r\n        if (this.terminateMessageLoop) {\r\n            return Promise.resolve<IConnection>(undefined);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.connectImpl().then((connection: IConnection): any => {\r\n            return connection;\r\n        });\r\n\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private getTranslations(serviceResultTranslations: ITranslationResponsePayload[]): Translations {\r\n        let translations: Translations;\r\n\r\n        if (undefined !== serviceResultTranslations) {\r\n            translations = new Translations();\r\n            for (const translation of serviceResultTranslations) {\r\n                translations.set(translation.lang, translation.translation);\r\n            }\r\n        }\r\n\r\n        return translations;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}