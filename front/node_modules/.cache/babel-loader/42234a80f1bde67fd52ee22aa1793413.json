{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SpeechConnectionMessage = void 0;\n\nvar Exports_1 = require(\"../common/Exports\");\n\nvar HeaderNames_1 = require(\"./HeaderNames\");\n\nvar SpeechConnectionMessage =\n/** @class */\nfunction (_super) {\n  __extends(SpeechConnectionMessage, _super);\n\n  function SpeechConnectionMessage(messageType, path, requestId, contentType, body, streamId, additionalHeaders, id) {\n    var _this = this;\n\n    if (!path) {\n      throw new Exports_1.ArgumentNullError(\"path\");\n    }\n\n    if (!requestId) {\n      throw new Exports_1.ArgumentNullError(\"requestId\");\n    }\n\n    var headers = {};\n    headers[HeaderNames_1.HeaderNames.Path] = path;\n    headers[HeaderNames_1.HeaderNames.RequestId] = requestId;\n    headers[HeaderNames_1.HeaderNames.RequestTimestamp] = new Date().toISOString();\n\n    if (contentType) {\n      headers[HeaderNames_1.HeaderNames.ContentType] = contentType;\n    }\n\n    if (streamId) {\n      headers[HeaderNames_1.HeaderNames.RequestStreamId] = streamId;\n    }\n\n    if (additionalHeaders) {\n      for (var headerName in additionalHeaders) {\n        if (headerName) {\n          headers[headerName] = additionalHeaders[headerName];\n        }\n      }\n    }\n\n    if (id) {\n      _this = _super.call(this, messageType, body, headers, id) || this;\n    } else {\n      _this = _super.call(this, messageType, body, headers) || this;\n    }\n\n    _this.privPath = path;\n    _this.privRequestId = requestId;\n    _this.privContentType = contentType;\n    _this.privStreamId = streamId;\n    _this.privAdditionalHeaders = additionalHeaders;\n    return _this;\n  }\n\n  Object.defineProperty(SpeechConnectionMessage.prototype, \"path\", {\n    get: function () {\n      return this.privPath;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpeechConnectionMessage.prototype, \"requestId\", {\n    get: function () {\n      return this.privRequestId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpeechConnectionMessage.prototype, \"contentType\", {\n    get: function () {\n      return this.privContentType;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpeechConnectionMessage.prototype, \"streamId\", {\n    get: function () {\n      return this.privStreamId;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(SpeechConnectionMessage.prototype, \"additionalHeaders\", {\n    get: function () {\n      return this.privAdditionalHeaders;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  SpeechConnectionMessage.fromConnectionMessage = function (message) {\n    var path = null;\n    var requestId = null;\n    var contentType = null;\n    var requestTimestamp = null;\n    var streamId = null;\n    var additionalHeaders = {};\n\n    if (message.headers) {\n      for (var headerName in message.headers) {\n        if (headerName) {\n          if (headerName.toLowerCase() === HeaderNames_1.HeaderNames.Path.toLowerCase()) {\n            path = message.headers[headerName];\n          } else if (headerName.toLowerCase() === HeaderNames_1.HeaderNames.RequestId.toLowerCase()) {\n            requestId = message.headers[headerName];\n          } else if (headerName.toLowerCase() === HeaderNames_1.HeaderNames.RequestTimestamp.toLowerCase()) {\n            requestTimestamp = message.headers[headerName];\n          } else if (headerName.toLowerCase() === HeaderNames_1.HeaderNames.ContentType.toLowerCase()) {\n            contentType = message.headers[headerName];\n          } else if (headerName.toLowerCase() === HeaderNames_1.HeaderNames.RequestStreamId.toLowerCase()) {\n            streamId = message.headers[headerName];\n          } else {\n            additionalHeaders[headerName] = message.headers[headerName];\n          }\n        }\n      }\n    }\n\n    return new SpeechConnectionMessage(message.messageType, path, requestId, contentType, message.body, streamId, additionalHeaders, message.id);\n  };\n\n  return SpeechConnectionMessage;\n}(Exports_1.ConnectionMessage);\n\nexports.SpeechConnectionMessage = SpeechConnectionMessage;","map":{"version":3,"mappings":"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","names":["__extends","messageType","path","requestId","contentType","body","streamId","additionalHeaders","id","Exports_1","headers","HeaderNames_1","Path","RequestId","RequestTimestamp","Date","toISOString","ContentType","RequestStreamId","headerName","_this","privPath","privRequestId","privContentType","privStreamId","privAdditionalHeaders","Object","SpeechConnectionMessage","message","requestTimestamp","toLowerCase","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/src/common.speech/SpeechConnectionMessage.Internal.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { ArgumentNullError, ConnectionMessage, IStringDictionary, MessageType } from \"../common/Exports\";\r\nimport { HeaderNames } from \"./HeaderNames\";\r\n\r\nexport class SpeechConnectionMessage extends ConnectionMessage {\r\n\r\n    private privPath: string;\r\n    private privRequestId: string;\r\n    private privContentType: string;\r\n    private privStreamId: string;\r\n    private privAdditionalHeaders: IStringDictionary<string>;\r\n\r\n    public constructor(\r\n        messageType: MessageType,\r\n        path: string,\r\n        requestId: string,\r\n        contentType: string,\r\n        body: any,\r\n        streamId?: string,\r\n        additionalHeaders?: IStringDictionary<string>,\r\n        id?: string) {\r\n\r\n        if (!path) {\r\n            throw new ArgumentNullError(\"path\");\r\n        }\r\n\r\n        if (!requestId) {\r\n            throw new ArgumentNullError(\"requestId\");\r\n        }\r\n\r\n        const headers: IStringDictionary<string> = {};\r\n        headers[HeaderNames.Path] = path;\r\n        headers[HeaderNames.RequestId] = requestId;\r\n        headers[HeaderNames.RequestTimestamp] = new Date().toISOString();\r\n        if (contentType) {\r\n            headers[HeaderNames.ContentType] = contentType;\r\n        }\r\n\r\n        if (streamId) {\r\n            headers[HeaderNames.RequestStreamId] = streamId;\r\n        }\r\n\r\n        if (additionalHeaders) {\r\n            for (const headerName in additionalHeaders) {\r\n                if (headerName) {\r\n                    headers[headerName] = additionalHeaders[headerName];\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        if (id) {\r\n            super(messageType, body, headers, id);\r\n        } else {\r\n            super(messageType, body, headers);\r\n        }\r\n\r\n        this.privPath = path;\r\n        this.privRequestId = requestId;\r\n        this.privContentType = contentType;\r\n        this.privStreamId = streamId;\r\n        this.privAdditionalHeaders = additionalHeaders;\r\n    }\r\n\r\n    public get path(): string {\r\n        return this.privPath;\r\n    }\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get contentType(): string {\r\n        return this.privContentType;\r\n    }\r\n\r\n    public get streamId(): string {\r\n        return this.privStreamId;\r\n    }\r\n\r\n    public get additionalHeaders(): IStringDictionary<string> {\r\n        return this.privAdditionalHeaders;\r\n    }\r\n\r\n    public static fromConnectionMessage = (message: ConnectionMessage): SpeechConnectionMessage => {\r\n        let path = null;\r\n        let requestId = null;\r\n        let contentType = null;\r\n        let requestTimestamp = null;\r\n        let streamId = null;\r\n        const additionalHeaders: IStringDictionary<string> = {};\r\n\r\n        if (message.headers) {\r\n            for (const headerName in message.headers) {\r\n                if (headerName) {\r\n                    if (headerName.toLowerCase() === HeaderNames.Path.toLowerCase()) {\r\n                        path = message.headers[headerName];\r\n                    } else if (headerName.toLowerCase() === HeaderNames.RequestId.toLowerCase()) {\r\n                        requestId = message.headers[headerName];\r\n                    } else if (headerName.toLowerCase() === HeaderNames.RequestTimestamp.toLowerCase()) {\r\n                        requestTimestamp = message.headers[headerName];\r\n                    } else if (headerName.toLowerCase() === HeaderNames.ContentType.toLowerCase()) {\r\n                        contentType = message.headers[headerName];\r\n                    } else if (headerName.toLowerCase() === HeaderNames.RequestStreamId.toLowerCase()) {\r\n                        streamId = message.headers[headerName];\r\n                    } else {\r\n                        additionalHeaders[headerName] = message.headers[headerName];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return new SpeechConnectionMessage(\r\n            message.messageType,\r\n            path,\r\n            requestId,\r\n            contentType,\r\n            message.body,\r\n            streamId,\r\n            additionalHeaders,\r\n            message.id);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}