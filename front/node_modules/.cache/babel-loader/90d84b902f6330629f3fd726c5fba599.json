{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatText = void 0; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nvar AbstractTextFormatter =\n/** @class */\nfunction () {\n  function AbstractTextFormatter(regularExpression) {\n    this._regularExpression = regularExpression;\n  }\n\n  AbstractTextFormatter.prototype.format = function (lang, input) {\n    var matches;\n\n    if (input) {\n      var result = input;\n\n      while ((matches = this._regularExpression.exec(input)) != null) {\n        result = result.replace(matches[0], this.internalFormat(lang, matches));\n      }\n\n      ;\n      return result;\n    } else {\n      return input;\n    }\n  };\n\n  return AbstractTextFormatter;\n}();\n\nvar DateFormatter =\n/** @class */\nfunction (_super) {\n  __extends(DateFormatter, _super);\n\n  function DateFormatter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DateFormatter.prototype.internalFormat = function (lang, matches) {\n    var date = new Date(Date.parse(matches[1]));\n    var format = matches[2] != undefined ? matches[2].toLowerCase() : \"compact\";\n\n    if (format != \"compact\") {\n      return date.toLocaleDateString(lang, {\n        day: \"numeric\",\n        weekday: format,\n        month: format,\n        year: \"numeric\"\n      });\n    } else {\n      return date.toLocaleDateString();\n    }\n  };\n\n  return DateFormatter;\n}(AbstractTextFormatter);\n\nvar TimeFormatter =\n/** @class */\nfunction (_super) {\n  __extends(TimeFormatter, _super);\n\n  function TimeFormatter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeFormatter.prototype.internalFormat = function (lang, matches) {\n    var date = new Date(Date.parse(matches[1]));\n    return date.toLocaleTimeString(lang, {\n      hour: 'numeric',\n      minute: '2-digit'\n    });\n  };\n\n  return TimeFormatter;\n}(AbstractTextFormatter);\n\nfunction formatText(lang, text) {\n  var formatters = [new DateFormatter(/\\{{2}DATE\\((\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:Z|(?:(?:-|\\+)\\d{2}:\\d{2})))(?:, ?(COMPACT|LONG|SHORT))?\\)\\}{2}/g), new TimeFormatter(/\\{{2}TIME\\((\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:Z|(?:(?:-|\\+)\\d{2}:\\d{2})))\\)\\}{2}/g)];\n  var result = text;\n\n  for (var _i = 0, formatters_1 = formatters; _i < formatters_1.length; _i++) {\n    var formatter = formatters_1[_i];\n    result = formatter.format(lang, result);\n  }\n\n  return result;\n}\n\nexports.formatText = formatText;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6BAAA;AACA;;AACA;AAAA;AAAA;AAKI,iCAAYA,iBAAZ,EAAqC;AACjC,SAAKC,kBAAL,GAA0BD,iBAA1B;AACH;;AAEDE,qDAAOC,IAAP,EAAiCC,KAAjC,EAA0D;AACtD,QAAIC,OAAJ;;AAEA,QAAID,KAAJ,EAAW;AACP,UAAIE,MAAM,GAAGF,KAAb;;AAEA,aAAO,CAACC,OAAO,GAAG,KAAKJ,kBAAL,CAAwBM,IAAxB,CAA6BH,KAA7B,CAAX,KAAmD,IAA1D,EAAgE;AAC5DE,cAAM,GAAGA,MAAM,CAACE,OAAP,CAAeH,OAAO,CAAC,CAAD,CAAtB,EAA2B,KAAKI,cAAL,CAAoBN,IAApB,EAA0BE,OAA1B,CAA3B,CAAT;AACH;;AAAA;AAED,aAAOC,MAAP;AACH,KARD,MASK;AACD,aAAOF,KAAP;AACH;AACJ,GAfD;;AAgBJ;AAAC,CAzBD;;AA2BA;AAAA;AAAA;AAA4BM;;AAA5B;;AAYC;;AAXaC,2CAAV,UAAyBR,IAAzB,EAAmDE,OAAnD,EAA2E;AACvE,QAAIO,IAAI,GAAG,IAAIC,IAAJ,CAASA,IAAI,CAACC,KAAL,CAAWT,OAAO,CAAC,CAAD,CAAlB,CAAT,CAAX;AACA,QAAIU,MAAM,GAAGV,OAAO,CAAC,CAAD,CAAP,IAAcW,SAAd,GAA0BX,OAAO,CAAC,CAAD,CAAP,CAAWY,WAAX,EAA1B,GAAqD,SAAlE;;AAEA,QAAIF,MAAM,IAAI,SAAd,EAAyB;AACrB,aAAOH,IAAI,CAACM,kBAAL,CAAwBf,IAAxB,EAA8B;AAAEgB,WAAG,EAAE,SAAP;AAAkBC,eAAO,EAAEL,MAA3B;AAAmCM,aAAK,EAAEN,MAA1C;AAAkDO,YAAI,EAAE;AAAxD,OAA9B,CAAP;AACH,KAFD,MAGK;AACD,aAAOV,IAAI,CAACM,kBAAL,EAAP;AACH;AACJ,GAVS;;AAWd;AAZA,EAA4BhB,qBAA5B;;AAcA;AAAA;AAAA;AAA4BQ;;AAA5B;;AAMC;;AALaa,2CAAV,UAAyBpB,IAAzB,EAAmDE,OAAnD,EAA2E;AACvE,QAAIO,IAAI,GAAG,IAAIC,IAAJ,CAASA,IAAI,CAACC,KAAL,CAAWT,OAAO,CAAC,CAAD,CAAlB,CAAT,CAAX;AAEA,WAAOO,IAAI,CAACY,kBAAL,CAAwBrB,IAAxB,EAA8B;AAAEsB,UAAI,EAAE,SAAR;AAAmBC,YAAM,EAAE;AAA3B,KAA9B,CAAP;AACH,GAJS;;AAKd;AANA,EAA4BxB,qBAA5B;;AAQA,SAAgByB,UAAhB,CAA2BxB,IAA3B,EAAqDyB,IAArD,EAA6E;AACzE,MAAMC,UAAU,GAA4B,CACxC,IAAIlB,aAAJ,CAAkB,mHAAlB,CADwC,EAExC,IAAIY,aAAJ,CAAkB,uFAAlB,CAFwC,CAA5C;AAKA,MAAIjB,MAAM,GAAGsB,IAAb;;AAEA,OAAsB,qCAAtB,EAAsBE,wBAAtB,EAAsBA,IAAtB,EAAkC;AAA7B,QAAIC,SAAS,mBAAb;AACDzB,UAAM,GAAGyB,SAAS,CAAChB,MAAV,CAAiBZ,IAAjB,EAAuBG,MAAvB,CAAT;AACH;;AAED,SAAOA,MAAP;AACH;;AAbD0B","names":["regularExpression","_regularExpression","AbstractTextFormatter","lang","input","matches","result","exec","replace","internalFormat","__extends","DateFormatter","date","Date","parse","format","undefined","toLowerCase","toLocaleDateString","day","weekday","month","year","TimeFormatter","toLocaleTimeString","hour","minute","formatText","text","formatters","_i","formatter","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/adaptivecards/src/text-formatters.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nabstract class AbstractTextFormatter {\n    private _regularExpression: RegExp;\n\n    protected abstract internalFormat(lang: string | undefined, matches: RegExpExecArray): string;\n\n    constructor(regularExpression: RegExp) {\n        this._regularExpression = regularExpression;\n    }\n\n    format(lang: string | undefined, input: string | undefined): string | undefined {\n        let matches;\n\n        if (input) {\n            let result = input;\n\n            while ((matches = this._regularExpression.exec(input)) != null) {\n                result = result.replace(matches[0], this.internalFormat(lang, matches));\n            };\n\n            return result;\n        }\n        else {\n            return input;\n        }\n    }\n}\n\nclass DateFormatter extends AbstractTextFormatter {\n    protected internalFormat(lang: string | undefined, matches: RegExpExecArray): string {\n        let date = new Date(Date.parse(matches[1]));\n        let format = matches[2] != undefined ? matches[2].toLowerCase() : \"compact\";\n\n        if (format != \"compact\") {\n            return date.toLocaleDateString(lang, { day: \"numeric\", weekday: format, month: format, year: \"numeric\" } as Intl.DateTimeFormatOptions);\n        }\n        else {\n            return date.toLocaleDateString();\n        }\n    }\n}\n\nclass TimeFormatter extends AbstractTextFormatter {\n    protected internalFormat(lang: string | undefined, matches: RegExpExecArray): string {\n        let date = new Date(Date.parse(matches[1]));\n\n        return date.toLocaleTimeString(lang, { hour: 'numeric', minute: '2-digit' });\n    }\n}\n\nexport function formatText(lang: string | undefined, text: string | undefined): string | undefined {\n    const formatters: AbstractTextFormatter[] = [\n        new DateFormatter(/\\{{2}DATE\\((\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:Z|(?:(?:-|\\+)\\d{2}:\\d{2})))(?:, ?(COMPACT|LONG|SHORT))?\\)\\}{2}/g),\n        new TimeFormatter(/\\{{2}TIME\\((\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:Z|(?:(?:-|\\+)\\d{2}:\\d{2})))\\)\\}{2}/g)\n    ];\n\n    let result = text;\n\n    for (let formatter of formatters) {\n        result = formatter.format(lang, result);\n    }\n\n    return result;\n}\n"]},"metadata":{},"sourceType":"script"}