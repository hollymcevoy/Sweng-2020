{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DialogServiceAdapter = void 0;\n\nvar Exports_1 = require(\"../common.browser/Exports\");\n\nvar DialogEvents_1 = require(\"../common/DialogEvents\");\n\nvar Exports_2 = require(\"../common/Exports\");\n\nvar AudioOutputFormat_1 = require(\"../sdk/Audio/AudioOutputFormat\");\n\nvar Exports_3 = require(\"../sdk/Exports\");\n\nvar DialogServiceTurnStateManager_1 = require(\"./DialogServiceTurnStateManager\");\n\nvar Exports_4 = require(\"./Exports\");\n\nvar ActivityResponsePayload_1 = require(\"./ServiceMessages/ActivityResponsePayload\");\n\nvar SpeechConnectionMessage_Internal_1 = require(\"./SpeechConnectionMessage.Internal\");\n\nvar DialogServiceAdapter =\n/** @class */\nfunction (_super) {\n  __extends(DialogServiceAdapter, _super);\n\n  function DialogServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) {\n    var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) || this;\n\n    _this.sendAgentConfig = function (connection) {\n      if (_this.agentConfig && !_this.agentConfigSent) {\n        if (_this.privRecognizerConfig.parameters.getProperty(Exports_3.PropertyId.Conversation_DialogType) === Exports_3.DialogServiceConfig.DialogTypes.CustomCommands) {\n          var config = _this.agentConfig.get();\n\n          config.botInfo.commandsCulture = _this.privRecognizerConfig.parameters.getProperty(Exports_3.PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\n\n          _this.agentConfig.set(config);\n        }\n\n        _this.onEvent(new DialogEvents_1.SendingAgentContextMessageEvent(_this.agentConfig));\n\n        var agentConfigJson = _this.agentConfig.toJsonString(); // guard against sending this multiple times on one connection\n\n\n        _this.agentConfigSent = true;\n        return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, \"agent.config\", _this.privRequestSession.requestId, \"application/json\", agentConfigJson));\n      }\n\n      return;\n    };\n\n    _this.sendAgentContext = function (connection) {\n      var guid = Exports_2.createGuid();\n\n      var speechActivityTemplate = _this.privDialogServiceConnector.properties.getProperty(Exports_3.PropertyId.Conversation_Speech_Activity_Template);\n\n      var agentContext = {\n        channelData: \"\",\n        context: {\n          interactionId: guid\n        },\n        messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\n        version: 0.5\n      };\n      var agentContextJson = JSON.stringify(agentContext);\n      return connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, \"speech.agent.context\", _this.privRequestSession.requestId, \"application/json\", agentContextJson));\n    };\n\n    _this.handleResponseMessage = function (responseMessage) {\n      // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\n      // event according to the message type that's specified.\n      var responsePayload = JSON.parse(responseMessage.textBody);\n\n      switch (responsePayload.messageType.toLowerCase()) {\n        case \"message\":\n          var responseRequestId = responseMessage.requestId.toUpperCase();\n          var activityPayload = ActivityResponsePayload_1.ActivityPayloadResponse.fromJSON(responseMessage.textBody);\n\n          var turn = _this.privTurnStateManager.GetTurn(responseRequestId); // update the conversation Id\n\n\n          if (activityPayload.conversationId) {\n            var updateAgentConfig = _this.agentConfig.get();\n\n            updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\n\n            _this.agentConfig.set(updateAgentConfig);\n          }\n\n          var pullAudioOutputStream = turn.processActivityPayload(activityPayload, AudioOutputFormat_1.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(_this.privDialogServiceConnector.properties.getProperty(Exports_3.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\n          var activity = new Exports_3.ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\n\n          if (!!_this.privDialogServiceConnector.activityReceived) {\n            try {\n              _this.privDialogServiceConnector.activityReceived(_this.privDialogServiceConnector, activity);\n              /* tslint:disable:no-empty */\n\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n\n          break;\n\n        case \"messagestatus\":\n          if (!!_this.privDialogServiceConnector.turnStatusReceived) {\n            try {\n              _this.privDialogServiceConnector.turnStatusReceived(_this.privDialogServiceConnector, new Exports_3.TurnStatusReceivedEventArgs(responseMessage.textBody));\n              /* tslint:disable:no-empty */\n\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n\n          break;\n\n        default:\n          Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(\"Unexpected response of type \" + responsePayload.messageType + \". Ignoring.\"));\n          break;\n      }\n    };\n\n    _this.privEvents = new Exports_2.EventSource();\n    _this.privDialogServiceConnector = dialogServiceConnector;\n    _this.receiveMessageOverride = _this.receiveDialogMessageOverride;\n    _this.privTurnStateManager = new DialogServiceTurnStateManager_1.DialogServiceTurnStateManager();\n    _this.recognizeOverride = _this.listenOnce;\n    _this.postConnectImplOverride = _this.dialogConnectImpl;\n    _this.configConnectionOverride = _this.configConnection;\n    _this.disconnectOverride = _this.privDisconnect;\n    _this.privDialogAudioSource = audioSource;\n    _this.agentConfigSent = false;\n    _this.privLastResult = null;\n\n    _this.connectionEvents.attach(function (connectionEvent) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          if (connectionEvent.name === \"ConnectionClosedEvent\") {\n            this.terminateMessageLoop = true;\n          }\n\n          return [2\n          /*return*/\n          ];\n        });\n      });\n    });\n\n    return _this;\n  }\n\n  DialogServiceAdapter.prototype.sendMessage = function (message) {\n    return __awaiter(this, void 0, void 0, function () {\n      var interactionGuid, requestId, agentMessage, agentMessageJson, connection;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            interactionGuid = Exports_2.createGuid();\n            requestId = Exports_2.createNoDashGuid();\n            agentMessage = {\n              context: {\n                interactionId: interactionGuid\n              },\n              messagePayload: JSON.parse(message),\n              version: 0.5\n            };\n            agentMessageJson = JSON.stringify(agentMessage);\n            return [4\n            /*yield*/\n            , this.fetchConnection()];\n\n          case 1:\n            connection = _a.sent();\n            return [4\n            /*yield*/\n            , connection.send(new SpeechConnectionMessage_Internal_1.SpeechConnectionMessage(Exports_2.MessageType.Text, \"agent\", requestId, \"application/json\", agentMessageJson))];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  DialogServiceAdapter.prototype.privDisconnect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.NoError, \"Disconnecting\")];\n\n          case 1:\n            _a.sent();\n\n            this.terminateMessageLoop = true;\n            this.agentConfigSent = false;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  DialogServiceAdapter.prototype.processTypeSpecificMessages = function (connectionMessage) {\n    return __awaiter(this, void 0, void 0, function () {\n      var resultProps, result, processed, speechPhrase, args, hypothesis, offset, ev, keyword, event_1, audioRequestId, turn;\n      return __generator(this, function (_a) {\n        resultProps = new Exports_3.PropertyCollection();\n\n        if (connectionMessage.messageType === Exports_2.MessageType.Text) {\n          resultProps.setProperty(Exports_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n        }\n\n        switch (connectionMessage.path.toLowerCase()) {\n          case \"speech.phrase\":\n            speechPhrase = Exports_4.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n            this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\n\n            if (speechPhrase.RecognitionStatus !== Exports_4.RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== Exports_4.RecognitionStatus.Error) {\n              args = this.fireEventForResult(speechPhrase, resultProps);\n              this.privLastResult = args.result;\n\n              if (!!this.privDialogServiceConnector.recognized) {\n                try {\n                  this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\n                  /* tslint:disable:no-empty */\n                } catch (error) {// Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n            }\n\n            processed = true;\n            break;\n\n          case \"speech.hypothesis\":\n            hypothesis = Exports_4.SpeechHypothesis.fromJSON(connectionMessage.textBody);\n            offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n            result = new Exports_3.SpeechRecognitionResult(this.privRequestSession.requestId, Exports_3.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, undefined, connectionMessage.textBody, resultProps);\n            this.privRequestSession.onHypothesis(offset);\n            ev = new Exports_3.SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n\n            if (!!this.privDialogServiceConnector.recognizing) {\n              try {\n                this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\n                /* tslint:disable:no-empty */\n              } catch (error) {// Not going to let errors in the event handler\n                // trip things up.\n              }\n            }\n\n            processed = true;\n            break;\n\n          case \"speech.keyword\":\n            keyword = Exports_4.SpeechKeyword.fromJSON(connectionMessage.textBody);\n            result = new Exports_3.SpeechRecognitionResult(this.privRequestSession.requestId, keyword.Status === \"Accepted\" ? Exports_3.ResultReason.RecognizedKeyword : Exports_3.ResultReason.NoMatch, keyword.Text, keyword.Duration, keyword.Offset, undefined, undefined, undefined, undefined, connectionMessage.textBody, resultProps);\n\n            if (keyword.Status !== \"Accepted\") {\n              this.privLastResult = result;\n            }\n\n            event_1 = new Exports_3.SpeechRecognitionEventArgs(result, result.duration, result.resultId);\n\n            if (!!this.privDialogServiceConnector.recognized) {\n              try {\n                this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event_1);\n                /* tslint:disable:no-empty */\n              } catch (error) {// Not going to let errors in the event handler\n                // trip things up.\n              }\n            }\n\n            processed = true;\n            break;\n\n          case \"audio\":\n            {\n              audioRequestId = connectionMessage.requestId.toUpperCase();\n              turn = this.privTurnStateManager.GetTurn(audioRequestId);\n\n              try {\n                // Empty binary message signals end of stream.\n                if (!connectionMessage.binaryBody) {\n                  turn.endAudioStream();\n                } else {\n                  turn.audioStream.write(connectionMessage.binaryBody);\n                }\n              } catch (error) {// Not going to let errors in the event handler\n                // trip things up.\n              }\n            }\n            processed = true;\n            break;\n\n          case \"response\":\n            {\n              this.handleResponseMessage(connectionMessage);\n            }\n            processed = true;\n            break;\n\n          default:\n            break;\n        }\n\n        return [2\n        /*return*/\n        , processed];\n      });\n    });\n  }; // Cancels recognition.\n\n\n  DialogServiceAdapter.prototype.cancelRecognition = function (sessionId, requestId, cancellationReason, errorCode, error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var properties, cancelEvent, result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.terminateMessageLoop = true;\n            if (!!!this.privRequestSession.isRecognizing) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.privRequestSession.onStopRecognizing()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            if (!!this.privDialogServiceConnector.canceled) {\n              properties = new Exports_3.PropertyCollection();\n              properties.setProperty(Exports_4.CancellationErrorCodePropertyName, Exports_3.CancellationErrorCode[errorCode]);\n              cancelEvent = new Exports_3.SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n              try {\n                this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\n                /* tslint:disable:no-empty */\n              } catch (_b) {}\n\n              if (!!this.privSuccessCallback) {\n                result = new Exports_3.SpeechRecognitionResult(undefined, // ResultId\n                Exports_3.ResultReason.Canceled, undefined, // Text\n                undefined, // Duration\n                undefined, // Offset\n                undefined, // Language\n                undefined, // Language Detection Confidence\n                undefined, // Speaker Id\n                error, undefined, // Json\n                properties);\n\n                try {\n                  this.privSuccessCallback(result);\n                  this.privSuccessCallback = undefined;\n                  /* tslint:disable:no-empty */\n                } catch (_c) {}\n              }\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  DialogServiceAdapter.prototype.listenOnce = function (recoMode, successCallback, errorCallback) {\n    return __awaiter(this, void 0, void 0, function () {\n      var conPromise, preAudioPromise, node, format, deviceInfo, audioNode, error_1, sessionStartEventArgs, audioSendPromise;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.privRecognizerConfig.recognitionMode = recoMode;\n            this.privSuccessCallback = successCallback;\n            this.privErrorCallback = errorCallback;\n            this.privRequestSession.startNewRecognition();\n            this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\n            this.privRecognizerConfig.parameters.setProperty(Exports_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\n            conPromise = this.connectImpl();\n            preAudioPromise = this.sendPreAudioMessages();\n            return [4\n            /*yield*/\n            , this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId)];\n\n          case 1:\n            node = _a.sent();\n            return [4\n            /*yield*/\n            , this.privDialogAudioSource.format];\n\n          case 2:\n            format = _a.sent();\n            return [4\n            /*yield*/\n            , this.privDialogAudioSource.deviceInfo];\n\n          case 3:\n            deviceInfo = _a.sent();\n            audioNode = new Exports_1.ReplayableAudioNode(node, format.avgBytesPerSec);\n            return [4\n            /*yield*/\n            , this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false)];\n\n          case 4:\n            _a.sent();\n\n            this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {\n              source: deviceInfo\n            };\n            _a.label = 5;\n\n          case 5:\n            _a.trys.push([5, 8,, 10]);\n\n            return [4\n            /*yield*/\n            , conPromise];\n\n          case 6:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , preAudioPromise];\n\n          case 7:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 10];\n\n          case 8:\n            error_1 = _a.sent();\n            return [4\n            /*yield*/\n            , this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.ConnectionFailure, error_1)];\n\n          case 9:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , Promise.resolve()];\n\n          case 10:\n            sessionStartEventArgs = new Exports_3.SessionEventArgs(this.privRequestSession.sessionId);\n\n            if (!!this.privRecognizer.sessionStarted) {\n              this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n            }\n\n            audioSendPromise = this.sendAudio(audioNode); // /* tslint:disable:no-empty */\n\n            audioSendPromise.then(function () {}, function (error) {\n              return __awaiter(_this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.RuntimeError, error)];\n\n                    case 1:\n                      _a.sent();\n\n                      return [2\n                      /*return*/\n                      ];\n                  }\n                });\n              });\n            });\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // Establishes a websocket connection to the end point.\n\n\n  DialogServiceAdapter.prototype.dialogConnectImpl = function (connection) {\n    this.privConnectionLoop = this.startMessageLoop();\n    return connection;\n  };\n\n  DialogServiceAdapter.prototype.receiveDialogMessageOverride = function () {\n    var _this = this; // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n\n\n    var communicationCustodian = new Exports_2.Deferred();\n\n    var loop = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var isDisposed, terminateMessageLoop, connection, message, connectionMessage, _a, turnRequestId, audioSessionReqId, speechStartDetected, speechStartEventArgs, json, speechStopDetected, speechStopEventArgs, turnEndRequestId, audioSessionReqId, sessionStopEventArgs, ret, error_2;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              _b.trys.push([0, 12,, 13]);\n\n              isDisposed = this.isDisposed();\n              terminateMessageLoop = !this.isDisposed() && this.terminateMessageLoop;\n\n              if (isDisposed || terminateMessageLoop) {\n                // We're done.\n                communicationCustodian.resolve(undefined);\n                return [2\n                /*return*/\n                ];\n              }\n\n              return [4\n              /*yield*/\n              , this.fetchConnection()];\n\n            case 1:\n              connection = _b.sent();\n              return [4\n              /*yield*/\n              , connection.read()];\n\n            case 2:\n              message = _b.sent();\n\n              if (!message) {\n                return [2\n                /*return*/\n                , loop()];\n              }\n\n              connectionMessage = SpeechConnectionMessage_Internal_1.SpeechConnectionMessage.fromConnectionMessage(message);\n              _a = connectionMessage.path.toLowerCase();\n\n              switch (_a) {\n                case \"turn.start\":\n                  return [3\n                  /*break*/\n                  , 3];\n\n                case \"speech.startdetected\":\n                  return [3\n                  /*break*/\n                  , 4];\n\n                case \"speech.enddetected\":\n                  return [3\n                  /*break*/\n                  , 5];\n\n                case \"turn.end\":\n                  return [3\n                  /*break*/\n                  , 6];\n              }\n\n              return [3\n              /*break*/\n              , 10];\n\n            case 3:\n              {\n                turnRequestId = connectionMessage.requestId.toUpperCase();\n                audioSessionReqId = this.privRequestSession.requestId.toUpperCase(); // turn started by the service\n\n                if (turnRequestId !== audioSessionReqId) {\n                  this.privTurnStateManager.StartTurn(turnRequestId);\n                } else {\n                  this.privRequestSession.onServiceTurnStartResponse();\n                }\n              }\n              return [3\n              /*break*/\n              , 11];\n\n            case 4:\n              speechStartDetected = Exports_4.SpeechDetected.fromJSON(connectionMessage.textBody);\n              speechStartEventArgs = new Exports_3.RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\n\n              if (!!this.privRecognizer.speechStartDetected) {\n                this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\n              }\n\n              return [3\n              /*break*/\n              , 11];\n\n            case 5:\n              json = void 0;\n\n              if (connectionMessage.textBody.length > 0) {\n                json = connectionMessage.textBody;\n              } else {\n                // If the request was empty, the JSON returned is empty.\n                json = \"{ Offset: 0 }\";\n              }\n\n              speechStopDetected = Exports_4.SpeechDetected.fromJSON(json);\n              this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\n              speechStopEventArgs = new Exports_3.RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n\n              if (!!this.privRecognizer.speechEndDetected) {\n                this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\n              }\n\n              return [3\n              /*break*/\n              , 11];\n\n            case 6:\n              turnEndRequestId = connectionMessage.requestId.toUpperCase();\n              audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\n              if (!(turnEndRequestId !== audioSessionReqId)) return [3\n              /*break*/\n              , 7];\n              this.privTurnStateManager.CompleteTurn(turnEndRequestId);\n              return [3\n              /*break*/\n              , 9];\n\n            case 7:\n              sessionStopEventArgs = new Exports_3.SessionEventArgs(this.privRequestSession.sessionId);\n              return [4\n              /*yield*/\n              , this.privRequestSession.onServiceTurnEndResponse(false)];\n\n            case 8:\n              _b.sent();\n\n              if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\n                if (!!this.privRecognizer.sessionStopped) {\n                  this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\n                }\n              } // report result to promise.\n\n\n              if (!!this.privSuccessCallback && this.privLastResult) {\n                try {\n                  this.privSuccessCallback(this.privLastResult);\n                  this.privLastResult = null;\n                } catch (e) {\n                  if (!!this.privErrorCallback) {\n                    this.privErrorCallback(e);\n                  }\n                } // Only invoke the call back once.\n                // and if it's successful don't invoke the\n                // error after that.\n\n\n                this.privSuccessCallback = undefined;\n                this.privErrorCallback = undefined;\n              }\n\n              _b.label = 9;\n\n            case 9:\n              return [3\n              /*break*/\n              , 11];\n\n            case 10:\n              if (!this.processTypeSpecificMessages(connectionMessage)) {\n                if (!!this.serviceEvents) {\n                  this.serviceEvents.onEvent(new Exports_2.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                }\n              }\n\n              _b.label = 11;\n\n            case 11:\n              ret = loop();\n              return [2\n              /*return*/\n              , ret];\n\n            case 12:\n              error_2 = _b.sent();\n              this.terminateMessageLoop = true;\n              communicationCustodian.resolve();\n              return [3\n              /*break*/\n              , 13];\n\n            case 13:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    loop().catch(function (reason) {\n      Exports_2.Events.instance.onEvent(new Exports_2.BackgroundEvent(reason));\n    });\n    return communicationCustodian.promise;\n  };\n\n  DialogServiceAdapter.prototype.startMessageLoop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var error_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.terminateMessageLoop = false;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 5]);\n\n            return [4\n            /*yield*/\n            , this.receiveDialogMessageOverride()];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            error_3 = _a.sent();\n            return [4\n            /*yield*/\n            , this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_3.CancellationReason.Error, Exports_3.CancellationErrorCode.RuntimeError, error_3)];\n\n          case 4:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [2\n            /*return*/\n            , Promise.resolve()];\n        }\n      });\n    });\n  }; // Takes an established websocket connection to the endpoint and sends speech configuration information.\n\n\n  DialogServiceAdapter.prototype.configConnection = function (connection) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.terminateMessageLoop) {\n              this.terminateMessageLoop = false;\n              return [2\n              /*return*/\n              , Promise.reject(\"Connection to service terminated.\")];\n            }\n\n            return [4\n            /*yield*/\n            , this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize())];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.sendAgentConfig(connection)];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , connection];\n        }\n      });\n    });\n  };\n\n  DialogServiceAdapter.prototype.sendPreAudioMessages = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var connection;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.fetchConnection()];\n\n          case 1:\n            connection = _a.sent();\n            this.addKeywordContextData();\n            return [4\n            /*yield*/\n            , this.sendSpeechContext(connection)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.sendAgentContext(connection)];\n\n          case 3:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.sendWaveHeader(connection)];\n\n          case 4:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  DialogServiceAdapter.prototype.fireEventForResult = function (serviceResult, properties) {\n    var resultReason = Exports_4.EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\n    var offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\n    var result = new Exports_3.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, serviceResult.DisplayText, serviceResult.Duration, offset, serviceResult.Language, serviceResult.LanguageDetectionConfidence, undefined, undefined, JSON.stringify(serviceResult), properties);\n    var ev = new Exports_3.SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\n    return ev;\n  };\n\n  DialogServiceAdapter.prototype.onEvent = function (event) {\n    this.privEvents.onEvent(event);\n    Exports_2.Events.instance.onEvent(event);\n  };\n\n  DialogServiceAdapter.prototype.addKeywordContextData = function () {\n    var keywordPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\n\n    if (keywordPropertyValue === undefined) {\n      return;\n    }\n\n    var keywordOffsetPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\n    var keywordDurationPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect-Durations\");\n    var keywords = keywordPropertyValue.split(\";\");\n    var keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\n    var keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\n    var keywordDefinitionArray = [];\n\n    for (var i = 0; i < keywords.length; i++) {\n      var definition = {};\n      definition.text = keywords[i];\n\n      if (i < keywordOffsets.length) {\n        definition.offset = Number(keywordOffsets[i]);\n      }\n\n      if (i < keywordDurations.length) {\n        definition.duration = Number(keywordDurations[i]);\n      }\n\n      keywordDefinitionArray.push(definition);\n    }\n\n    this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\n    this.speechContext.setSection(\"keywordDetection\", [{\n      clientDetectedKeywords: keywordDefinitionArray,\n      onReject: {\n        action: \"EndOfTurn\"\n      },\n      type: \"startTrigger\"\n    }]);\n  };\n\n  return DialogServiceAdapter;\n}(Exports_4.ServiceRecognizerBase);\n\nexports.DialogServiceAdapter = DialogServiceAdapter;","map":{"version":3,"mappings":"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","names":["__extends","authentication","connectionFactory","audioSource","recognizerConfig","dialogServiceConnector","_super","_this","connection","agentConfig","agentConfigSent","privRecognizerConfig","parameters","getProperty","Exports_3","Conversation_DialogType","DialogTypes","CustomCommands","config","get","botInfo","commandsCulture","SpeechServiceConnection_RecoLanguage","set","onEvent","DialogEvents_1","agentConfigJson","toJsonString","send","SpeechConnectionMessage_Internal_1","Exports_2","Text","privRequestSession","requestId","guid","speechActivityTemplate","privDialogServiceConnector","properties","Conversation_Speech_Activity_Template","agentContext","channelData","context","interactionId","messagePayload","undefined","version","agentContextJson","JSON","stringify","responseMessage","responsePayload","parse","textBody","messageType","toLowerCase","responseRequestId","toUpperCase","activityPayload","ActivityResponsePayload_1","fromJSON","turn","privTurnStateManager","GetTurn","conversationId","updateAgentConfig","pullAudioOutputStream","processActivityPayload","AudioOutputFormat_1","fromSpeechSynthesisOutputFormatString","SpeechServiceConnection_SynthOutputFormat","activity","activityReceived","error","turnStatusReceived","instance","privEvents","receiveMessageOverride","receiveDialogMessageOverride","DialogServiceTurnStateManager_1","recognizeOverride","listenOnce","postConnectImplOverride","dialogConnectImpl","configConnectionOverride","configConnection","disconnectOverride","privDisconnect","privDialogAudioSource","privLastResult","connectionEvents","attach","connectionEvent","name","terminateMessageLoop","DialogServiceAdapter","message","interactionGuid","agentMessage","agentMessageJson","fetchConnection","_a","cancelRecognition","sessionId","Error","NoError","connectionMessage","resultProps","setProperty","SpeechServiceResponse_JsonResult","path","speechPhrase","Exports_4","onPhraseRecognized","currentTurnAudioOffset","Offset","Duration","RecognitionStatus","TooManyRequests","args","fireEventForResult","result","recognized","processed","hypothesis","offset","RecognizingSpeech","Language","LanguageDetectionConfidence","onHypothesis","ev","recognizing","keyword","Status","RecognizedKeyword","NoMatch","event_1","duration","resultId","audioRequestId","binaryBody","endAudioStream","audioStream","write","handleResponseMessage","cancellationReason","errorCode","isRecognizing","onStopRecognizing","canceled","cancelEvent","privSuccessCallback","Canceled","recoMode","successCallback","errorCallback","recognitionMode","privErrorCallback","startNewRecognition","listenForServiceTelemetry","events","Speech_SessionId","conPromise","connectImpl","preAudioPromise","sendPreAudioMessages","audioNodeId","node","format","deviceInfo","audioNode","Exports_1","avgBytesPerSec","onAudioSourceAttachCompleted","SpeechServiceConfig","Context","audio","source","ConnectionFailure","error_1","Promise","resolve","sessionStartEventArgs","privRecognizer","sessionStarted","audioSendPromise","sendAudio","then","RuntimeError","privConnectionLoop","startMessageLoop","communicationCustodian","loop","isDisposed","_b","read","fromConnectionMessage","turnRequestId","audioSessionReqId","StartTurn","onServiceTurnStartResponse","speechStartDetected","speechStartEventArgs","json","length","speechStopDetected","onServiceRecognized","speechStopEventArgs","speechEndDetected","turnEndRequestId","CompleteTurn","sessionStopEventArgs","onServiceTurnEndResponse","isContinuousRecognition","isSpeechEnded","sessionStopped","e","processTypeSpecificMessages","serviceEvents","ret","catch","reason","promise","error_3","reject","sendSpeechServiceConfig","serialize","sendAgentConfig","addKeywordContextData","sendSpeechContext","sendAgentContext","sendWaveHeader","serviceResult","resultReason","implTranslateRecognitionResult","DisplayText","event","keywordPropertyValue","keywordOffsetPropertyValue","keywordDurationPropertyValue","keywords","split","keywordOffsets","keywordDurations","keywordDefinitionArray","i","definition","text","Number","push","speechContext","setSection","clientDetectedKeywords","onReject","action","type","exports"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/src/common.speech/DialogServiceAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ReplayableAudioNode\r\n} from \"../common.browser/Exports\";\r\nimport { SendingAgentContextMessageEvent } from \"../common/DialogEvents\";\r\nimport {\r\n    BackgroundEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    createGuid,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    DialogEvent,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IConnection,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport { AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\nimport {\r\n    ActivityReceivedEventArgs,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    DialogServiceConfig,\r\n    DialogServiceConnector,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    RecognitionEventArgs,\r\n    ResultReason,\r\n    SessionEventArgs,\r\n    SpeechRecognitionCanceledEventArgs,\r\n    SpeechRecognitionEventArgs,\r\n    SpeechRecognitionResult,\r\n    TurnStatusReceivedEventArgs,\r\n} from \"../sdk/Exports\";\r\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager\";\r\nimport {\r\n    CancellationErrorCodePropertyName,\r\n    EnumTranslation,\r\n    ISpeechConfigAudioDevice,\r\n    RecognitionStatus,\r\n    ServiceRecognizerBase,\r\n    SimpleSpeechPhrase,\r\n    SpeechDetected,\r\n    SpeechHypothesis,\r\n    SpeechKeyword,\r\n} from \"./Exports\";\r\nimport { IAuthentication } from \"./IAuthentication\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory\";\r\nimport { RecognitionMode, RecognizerConfig } from \"./RecognizerConfig\";\r\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\r\n    private privDialogServiceConnector: DialogServiceConnector;\r\n\r\n    private privDialogAudioSource: IAudioSource;\r\n\r\n    private privConnectionLoop: Promise<void>;\r\n    private terminateMessageLoop: boolean;\r\n    private agentConfigSent: boolean;\r\n    private privLastResult: SpeechRecognitionResult;\r\n    private privEvents: EventSource<DialogEvent>;\r\n\r\n    // Turns are of two kinds:\r\n    // 1: SR turns, end when the SR result is returned and then turn end.\r\n    // 2: Service turns where an activity is sent by the service along with the audio.\r\n    private privTurnStateManager: DialogServiceTurnStateManager;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        dialogServiceConnector: DialogServiceConnector) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\r\n\r\n        this.privEvents = new EventSource<DialogEvent>();\r\n        this.privDialogServiceConnector = dialogServiceConnector;\r\n        this.receiveMessageOverride = this.receiveDialogMessageOverride;\r\n        this.privTurnStateManager = new DialogServiceTurnStateManager();\r\n        this.recognizeOverride = this.listenOnce;\r\n        this.postConnectImplOverride = this.dialogConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privDialogAudioSource = audioSource;\r\n\r\n        this.agentConfigSent = false;\r\n        this.privLastResult = null;\r\n        this.connectionEvents.attach(async (connectionEvent: ConnectionEvent): Promise<void> => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                this.terminateMessageLoop = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async sendMessage(message: string): Promise<void> {\r\n        const interactionGuid: string = createGuid();\r\n        const requestId: string = createNoDashGuid();\r\n\r\n        const agentMessage: any = {\r\n            context: {\r\n                interactionId: interactionGuid\r\n            },\r\n            messagePayload: JSON.parse(message),\r\n            version: 0.5\r\n        };\r\n\r\n        const agentMessageJson = JSON.stringify(agentMessage);\r\n        const connection: IConnection = await this.fetchConnection();\r\n        await connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"agent\",\r\n            requestId,\r\n            \"application/json\",\r\n            agentMessageJson));\r\n\r\n    }\r\n\r\n    protected async privDisconnect(): Promise<void> {\r\n        await this.cancelRecognition(this.privRequestSession.sessionId,\r\n            this.privRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        this.agentConfigSent = false;\r\n        return;\r\n    }\r\n\r\n    protected async processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\r\n\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        if (connectionMessage.messageType === MessageType.Text) {\r\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\r\n        }\r\n\r\n        let result: SpeechRecognitionResult;\r\n        let processed: boolean;\r\n\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"speech.phrase\":\r\n                const speechPhrase: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\r\n\r\n                this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\r\n\r\n                if (speechPhrase.RecognitionStatus !== RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== RecognitionStatus.Error) {\r\n                    const args: SpeechRecognitionEventArgs = this.fireEventForResult(speechPhrase, resultProps);\r\n                    this.privLastResult = args.result;\r\n\r\n                    if (!!this.privDialogServiceConnector.recognized) {\r\n                        try {\r\n                            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\r\n                            /* tslint:disable:no-empty */\r\n                        } catch (error) {\r\n                            // Not going to let errors in the event handler\r\n                            // trip things up.\r\n                        }\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.hypothesis\":\r\n                const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\r\n                const offset: number = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privRequestSession.requestId,\r\n                    ResultReason.RecognizingSpeech,\r\n                    hypothesis.Text,\r\n                    hypothesis.Duration,\r\n                    offset,\r\n                    hypothesis.Language,\r\n                    hypothesis.LanguageDetectionConfidence,\r\n                    undefined,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                this.privRequestSession.onHypothesis(offset);\r\n\r\n                const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognizing) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.keyword\":\r\n                const keyword: SpeechKeyword = SpeechKeyword.fromJSON(connectionMessage.textBody);\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privRequestSession.requestId,\r\n                    keyword.Status === \"Accepted\" ? ResultReason.RecognizedKeyword : ResultReason.NoMatch,\r\n                    keyword.Text,\r\n                    keyword.Duration,\r\n                    keyword.Offset,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                if (keyword.Status !== \"Accepted\") {\r\n                    this.privLastResult = result;\r\n                }\r\n\r\n                const event = new SpeechRecognitionEventArgs(result, result.duration, result.resultId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognized) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"audio\":\r\n                {\r\n                    const audioRequestId = connectionMessage.requestId.toUpperCase();\r\n                    const turn = this.privTurnStateManager.GetTurn(audioRequestId);\r\n                    try {\r\n                        // Empty binary message signals end of stream.\r\n                        if (!connectionMessage.binaryBody) {\r\n                            turn.endAudioStream();\r\n                        } else {\r\n                            turn.audioStream.write(connectionMessage.binaryBody);\r\n                        }\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            case \"response\":\r\n                {\r\n                    this.handleResponseMessage(connectionMessage);\r\n\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        return processed;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected async cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): Promise<void> {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        if (!!this.privRequestSession.isRecognizing) {\r\n            await this.privRequestSession.onStopRecognizing();\r\n        }\r\n\r\n        if (!!this.privDialogServiceConnector.canceled) {\r\n            const properties: PropertyCollection = new PropertyCollection();\r\n            properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n\r\n            const cancelEvent: SpeechRecognitionCanceledEventArgs = new SpeechRecognitionCanceledEventArgs(\r\n                cancellationReason,\r\n                error,\r\n                errorCode,\r\n                undefined,\r\n                sessionId);\r\n\r\n            try {\r\n                this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n\r\n            if (!!this.privSuccessCallback) {\r\n                const result: SpeechRecognitionResult = new SpeechRecognitionResult(\r\n                    undefined, // ResultId\r\n                    ResultReason.Canceled,\r\n                    undefined, // Text\r\n                    undefined, // Duration\r\n                    undefined, // Offset\r\n                    undefined, // Language\r\n                    undefined, // Language Detection Confidence\r\n                    undefined, // Speaker Id\r\n                    error,\r\n                    undefined, // Json\r\n                    properties);\r\n                try {\r\n                    this.privSuccessCallback(result);\r\n                    this.privSuccessCallback = undefined;\r\n                    /* tslint:disable:no-empty */\r\n                } catch { }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected async listenOnce(\r\n        recoMode: RecognitionMode,\r\n        successCallback: (e: SpeechRecognitionResult) => void,\r\n        errorCallback: (e: string) => void\r\n    ): Promise<void> {\r\n        this.privRecognizerConfig.recognitionMode = recoMode;\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallback;\r\n\r\n        this.privRequestSession.startNewRecognition();\r\n        this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\r\n\r\n        this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\r\n\r\n        // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\r\n        const conPromise: Promise<IConnection> = this.connectImpl();\r\n\r\n        const preAudioPromise: Promise<void> = this.sendPreAudioMessages();\r\n\r\n        const node: IAudioStreamNode = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);\r\n        const format: AudioStreamFormatImpl = await this.privDialogAudioSource.format;\r\n        const deviceInfo: ISpeechConfigAudioDevice = await this.privDialogAudioSource.deviceInfo;\r\n\r\n        const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\r\n        await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\r\n\r\n        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\r\n\r\n        try {\r\n            await conPromise;\r\n            await preAudioPromise;\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n\r\n        if (!!this.privRecognizer.sessionStarted) {\r\n            this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\r\n        }\r\n\r\n        const audioSendPromise = this.sendAudio(audioNode);\r\n\r\n        // /* tslint:disable:no-empty */\r\n        audioSendPromise.then(() => { /*add? return true;*/ }, async (error: string) => {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        });\r\n    }\r\n\r\n    // Establishes a websocket connection to the end point.\r\n    private dialogConnectImpl(connection: Promise<IConnection>): Promise<IConnection> {\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return connection;\r\n    }\r\n\r\n    private receiveDialogMessageOverride(): Promise<void> {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<void> = new Deferred<void>();\r\n\r\n        const loop = async (): Promise<void> => {\r\n            try {\r\n                const isDisposed: boolean = this.isDisposed();\r\n                const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                if (isDisposed || terminateMessageLoop) {\r\n                    // We're done.\r\n                    communicationCustodian.resolve(undefined);\r\n                    return;\r\n                }\r\n\r\n                const connection: IConnection = await this.fetchConnection();\r\n                const message: ConnectionMessage = await connection.read();\r\n\r\n                if (!message) {\r\n                    return loop();\r\n                }\r\n\r\n                const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        {\r\n                            const turnRequestId = connectionMessage.requestId.toUpperCase();\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.StartTurn(turnRequestId);\r\n                            } else {\r\n                                this.privRequestSession.onServiceTurnStartResponse();\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case \"speech.startdetected\":\r\n                        const speechStartDetected: SpeechDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\r\n\r\n                        const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechStartDetected) {\r\n                            this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case \"speech.enddetected\":\r\n\r\n                        let json: string;\r\n\r\n                        if (connectionMessage.textBody.length > 0) {\r\n                            json = connectionMessage.textBody;\r\n                        } else {\r\n                            // If the request was empty, the JSON returned is empty.\r\n                            json = \"{ Offset: 0 }\";\r\n                        }\r\n\r\n                        const speechStopDetected: SpeechDetected = SpeechDetected.fromJSON(json);\r\n\r\n                        this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\r\n\r\n                        const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechEndDetected) {\r\n                            this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\r\n                        }\r\n                        break;\r\n\r\n                    case \"turn.end\":\r\n                        {\r\n                            const turnEndRequestId = connectionMessage.requestId.toUpperCase();\r\n\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnEndRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.CompleteTurn(turnEndRequestId);\r\n                            } else {\r\n                                // Audio session turn\r\n\r\n                                const sessionStopEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n                                await this.privRequestSession.onServiceTurnEndResponse(false);\r\n\r\n                                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\r\n                                    if (!!this.privRecognizer.sessionStopped) {\r\n                                        this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\r\n                                    }\r\n                                }\r\n\r\n                                // report result to promise.\r\n                                if (!!this.privSuccessCallback && this.privLastResult) {\r\n                                    try {\r\n                                        this.privSuccessCallback(this.privLastResult);\r\n                                        this.privLastResult = null;\r\n                                    } catch (e) {\r\n                                        if (!!this.privErrorCallback) {\r\n                                            this.privErrorCallback(e);\r\n                                        }\r\n                                    }\r\n                                    // Only invoke the call back once.\r\n                                    // and if it's successful don't invoke the\r\n                                    // error after that.\r\n                                    this.privSuccessCallback = undefined;\r\n                                    this.privErrorCallback = undefined;\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\r\n                            if (!!this.serviceEvents) {\r\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                            }\r\n                        }\r\n                }\r\n                const ret: Promise<void> = loop();\r\n\r\n                return ret;\r\n            } catch (error) {\r\n                this.terminateMessageLoop = true;\r\n                communicationCustodian.resolve();\r\n            }\r\n        };\r\n\r\n        loop().catch((reason: string): void => {\r\n            Events.instance.onEvent(new BackgroundEvent(reason));\r\n        });\r\n\r\n        return communicationCustodian.promise;\r\n    }\r\n\r\n    private async startMessageLoop(): Promise<void> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        try {\r\n            await this.receiveDialogMessageOverride();\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configConnection(connection: IConnection): Promise<IConnection> {\r\n        if (this.terminateMessageLoop) {\r\n            this.terminateMessageLoop = false;\r\n            return Promise.reject(`Connection to service terminated.`);\r\n        }\r\n\r\n        await this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\r\n        await this.sendAgentConfig(connection);\r\n        return connection;\r\n    }\r\n\r\n    private async sendPreAudioMessages(): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        this.addKeywordContextData();\r\n        await this.sendSpeechContext(connection);\r\n        await this.sendAgentContext(connection);\r\n        await this.sendWaveHeader(connection);\r\n    }\r\n\r\n    private sendAgentConfig = (connection: IConnection): Promise<void> => {\r\n        if (this.agentConfig && !this.agentConfigSent) {\r\n\r\n            if (this.privRecognizerConfig\r\n                .parameters\r\n                .getProperty(PropertyId.Conversation_DialogType) === DialogServiceConfig.DialogTypes.CustomCommands) {\r\n                const config = this.agentConfig.get();\r\n                config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\r\n                this.agentConfig.set(config);\r\n            }\r\n            this.onEvent(new SendingAgentContextMessageEvent(this.agentConfig));\r\n\r\n            const agentConfigJson = this.agentConfig.toJsonString();\r\n\r\n            // guard against sending this multiple times on one connection\r\n            this.agentConfigSent = true;\r\n\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"agent.config\",\r\n                this.privRequestSession.requestId,\r\n                \"application/json\",\r\n                agentConfigJson));\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    private sendAgentContext = (connection: IConnection): Promise<void> => {\r\n        const guid: string = createGuid();\r\n\r\n        const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\r\n\r\n        const agentContext: any = {\r\n            channelData: \"\",\r\n            context: {\r\n                interactionId: guid\r\n            },\r\n            messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\r\n            version: 0.5\r\n        };\r\n\r\n        const agentContextJson = JSON.stringify(agentContext);\r\n\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"speech.agent.context\",\r\n            this.privRequestSession.requestId,\r\n            \"application/json\",\r\n            agentContextJson));\r\n    }\r\n\r\n    private fireEventForResult(serviceResult: SimpleSpeechPhrase, properties: PropertyCollection): SpeechRecognitionEventArgs {\r\n        const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\r\n\r\n        const offset: number = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n        const result = new SpeechRecognitionResult(\r\n            this.privRequestSession.requestId,\r\n            resultReason,\r\n            serviceResult.DisplayText,\r\n            serviceResult.Duration,\r\n            offset,\r\n            serviceResult.Language,\r\n            serviceResult.LanguageDetectionConfidence,\r\n            undefined,\r\n            undefined,\r\n            JSON.stringify(serviceResult),\r\n            properties);\r\n\r\n        const ev = new SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\r\n        return ev;\r\n    }\r\n\r\n    private handleResponseMessage = (responseMessage: SpeechConnectionMessage): void => {\r\n        // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\r\n        // event according to the message type that's specified.\r\n        const responsePayload = JSON.parse(responseMessage.textBody);\r\n        switch (responsePayload.messageType.toLowerCase()) {\r\n            case \"message\":\r\n                const responseRequestId = responseMessage.requestId.toUpperCase();\r\n                const activityPayload: ActivityPayloadResponse = ActivityPayloadResponse.fromJSON(responseMessage.textBody);\r\n                const turn = this.privTurnStateManager.GetTurn(responseRequestId);\r\n\r\n                // update the conversation Id\r\n                if (activityPayload.conversationId) {\r\n                    const updateAgentConfig = this.agentConfig.get();\r\n                    updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\r\n                    this.agentConfig.set(updateAgentConfig);\r\n                }\r\n\r\n                const pullAudioOutputStream: PullAudioOutputStreamImpl = turn.processActivityPayload(\r\n                    activityPayload,\r\n                    AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\r\n                const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\r\n                if (!!this.privDialogServiceConnector.activityReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"messagestatus\":\r\n                if (!!this.privDialogServiceConnector.turnStatusReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.turnStatusReceived(\r\n                            this.privDialogServiceConnector,\r\n                            new TurnStatusReceivedEventArgs(responseMessage.textBody));\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            default:\r\n                Events.instance.onEvent(\r\n                    new BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));\r\n                break;\r\n        }\r\n    }\r\n\r\n    private onEvent(event: DialogEvent): void {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private addKeywordContextData(): void {\r\n        const keywordPropertyValue: string = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\r\n        if (keywordPropertyValue === undefined) {\r\n            return;\r\n        }\r\n\r\n        const keywordOffsetPropertyValue: string = this.privRecognizerConfig.parameters\r\n            .getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\r\n        const keywordDurationPropertyValue: string = this.privRecognizerConfig.parameters\r\n            .getProperty(\"SPEECH-KeywordsToDetect-Durations\");\r\n\r\n        const keywords = keywordPropertyValue.split(\";\");\r\n        const keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\r\n        const keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\r\n\r\n        const keywordDefinitionArray = [];\r\n        for (let i = 0; i < keywords.length; i++) {\r\n            const definition: { [section: string]: any } = {};\r\n            definition.text = keywords[i];\r\n            if (i < keywordOffsets.length) {\r\n                definition.offset = Number(keywordOffsets[i]);\r\n            }\r\n            if (i < keywordDurations.length) {\r\n                definition.duration = Number(keywordDurations[i]);\r\n            }\r\n            keywordDefinitionArray.push(definition);\r\n        }\r\n\r\n        this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\r\n        this.speechContext.setSection(\"keywordDetection\", [{\r\n            clientDetectedKeywords: keywordDefinitionArray,\r\n            onReject: { action: \"EndOfTurn\" },\r\n            type: \"startTrigger\"\r\n        }]);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}