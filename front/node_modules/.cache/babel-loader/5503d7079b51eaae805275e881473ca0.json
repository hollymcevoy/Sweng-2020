{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.getEarliestUpdateNotBefore = getEarliestUpdateNotBefore;\n\nvar _react = require(\"react\");\n\nvar _simpleUpdateIn = _interopRequireDefault(require(\"simple-update-in\"));\n\nvar _findMin = _interopRequireDefault(require(\"../utils/findMin\"));\n\nvar _useForceRender = _interopRequireDefault(require(\"./internal/useForceRender\"));\n\nvar _useNotifications3 = _interopRequireDefault(require(\"./useNotifications\"));\n\nvar _useStyleOptions3 = _interopRequireDefault(require(\"./useStyleOptions\"));\n\nvar _useTimer = _interopRequireDefault(require(\"./internal/useTimer\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction getEarliestUpdateNotBefore(notificationMap) {\n  return (0, _findMin.default)(Object.values(notificationMap).filter(function (_ref) {\n    var outOfDate = _ref.outOfDate;\n    return outOfDate;\n  }).map(function (_ref2) {\n    var updateNotBefore = _ref2.updateNotBefore;\n    return updateNotBefore;\n  }));\n}\n\nfunction useDebouncedNotifications() {\n  var now = Date.now();\n\n  var _useStyleOptions = (0, _useStyleOptions3.default)(),\n      _useStyleOptions2 = _slicedToArray(_useStyleOptions, 1),\n      notificationDebounceTimeout = _useStyleOptions2[0].notificationDebounceTimeout;\n\n  var _useNotifications = (0, _useNotifications3.default)(),\n      _useNotifications2 = _slicedToArray(_useNotifications, 1),\n      notifications = _useNotifications2[0];\n\n  var debouncedNotificationsRef = (0, _react.useRef)({});\n  var forceRender = (0, _useForceRender.default)(); // Delete notifications or mark them to be deleted if debouncing.\n\n  var _iterator = _createForOfIteratorHelper(Object.keys(debouncedNotificationsRef.current).filter(function (id) {\n    return !(id in notifications);\n  })),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _id = _step.value;\n      debouncedNotificationsRef.current = (0, _simpleUpdateIn.default)(debouncedNotificationsRef.current, [_id], function (debouncedNotification) {\n        if (now < debouncedNotification.updateNotBefore) {\n          // The update need to be postponed.\n          return _objectSpread(_objectSpread({}, debouncedNotification), {}, {\n            outOfDate: true\n          });\n        } // Otherwise, return undefined will remove it.\n\n      });\n    } // For any changes, update notifications or mark them to be updated if debouncing.\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _loop = function _loop() {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n        _Object$entries$_i$ = _Object$entries$_i[1],\n        alt = _Object$entries$_i$.alt,\n        data = _Object$entries$_i$.data,\n        id = _Object$entries$_i$.id,\n        level = _Object$entries$_i$.level,\n        message = _Object$entries$_i$.message,\n        timestamp = _Object$entries$_i$.timestamp;\n\n    debouncedNotificationsRef.current = (0, _simpleUpdateIn.default)(debouncedNotificationsRef.current, [id], function (debouncedNotification) {\n      if (debouncedNotification && alt === debouncedNotification.alt && Object.is(data, debouncedNotification.data) && level === debouncedNotification.level && message === debouncedNotification.message && timestamp === debouncedNotification.timestamp) {\n        // If nothing changed, return as-is.\n        return debouncedNotification;\n      }\n\n      if (debouncedNotification && now < debouncedNotification.updateNotBefore) {\n        // The update need to be postponed.\n        return _objectSpread(_objectSpread({}, debouncedNotification), {}, {\n          outOfDate: true\n        });\n      } // Update the notification.\n\n\n      return _objectSpread(_objectSpread({}, debouncedNotification), {}, {\n        alt: alt,\n        data: data,\n        id: id,\n        level: level,\n        message: message,\n        outOfDate: false,\n        timestamp: timestamp,\n        updateNotBefore: now + notificationDebounceTimeout\n      });\n    });\n  };\n\n  for (var _i2 = 0, _Object$entries = Object.entries(notifications); _i2 < _Object$entries.length; _i2++) {\n    _loop();\n  }\n\n  (0, _useTimer.default)(getEarliestUpdateNotBefore(debouncedNotificationsRef.current), forceRender);\n  return [debouncedNotificationsRef.current];\n}\n\nvar _default = useDebouncedNotifications;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["getEarliestUpdateNotBefore","notificationMap","Object","values","filter","outOfDate","map","updateNotBefore","useDebouncedNotifications","now","Date","notificationDebounceTimeout","notifications","debouncedNotificationsRef","forceRender","keys","current","id","debouncedNotification","_iterator","alt","data","level","message","timestamp","is","entries","_loop"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-api/lib/src/hooks/useDebouncedNotifications.ts"],"sourcesContent":["import { useRef } from 'react';\nimport updateIn from 'simple-update-in';\n\nimport findMin from '../utils/findMin';\nimport Notification from '../types/Notification';\nimport useForceRender from './internal/useForceRender';\nimport useNotifications from './useNotifications';\nimport useStyleOptions from './useStyleOptions';\nimport useTimer from './internal/useTimer';\n\ntype DebouncedNotification = Notification & {\n  outOfDate: boolean;\n  updateNotBefore: number;\n};\n\ntype DebouncedNotifications = { [id: string]: DebouncedNotification };\n\nfunction getEarliestUpdateNotBefore(notificationMap: DebouncedNotifications) {\n  return findMin(\n    Object.values(notificationMap)\n      .filter(({ outOfDate }) => outOfDate)\n      .map(({ updateNotBefore }) => updateNotBefore)\n  );\n}\n\nfunction useDebouncedNotifications(): [DebouncedNotifications] {\n  const now = Date.now();\n\n  const [{ notificationDebounceTimeout }] = useStyleOptions();\n  const [notifications] = useNotifications();\n  const debouncedNotificationsRef = useRef({});\n  const forceRender = useForceRender();\n\n  // Delete notifications or mark them to be deleted if debouncing.\n  for (const id of Object.keys(debouncedNotificationsRef.current).filter(id => !(id in notifications))) {\n    debouncedNotificationsRef.current = updateIn(debouncedNotificationsRef.current, [id], debouncedNotification => {\n      if (now < debouncedNotification.updateNotBefore) {\n        // The update need to be postponed.\n        return { ...debouncedNotification, outOfDate: true };\n      }\n\n      // Otherwise, return undefined will remove it.\n    });\n  }\n\n  // For any changes, update notifications or mark them to be updated if debouncing.\n  for (const [, { alt, data, id, level, message, timestamp }] of Object.entries(notifications)) {\n    debouncedNotificationsRef.current = updateIn(debouncedNotificationsRef.current, [id], debouncedNotification => {\n      if (\n        debouncedNotification &&\n        alt === debouncedNotification.alt &&\n        Object.is(data, debouncedNotification.data) &&\n        level === debouncedNotification.level &&\n        message === debouncedNotification.message &&\n        timestamp === debouncedNotification.timestamp\n      ) {\n        // If nothing changed, return as-is.\n        return debouncedNotification;\n      }\n\n      if (debouncedNotification && now < debouncedNotification.updateNotBefore) {\n        // The update need to be postponed.\n        return {\n          ...debouncedNotification,\n          outOfDate: true\n        };\n      }\n\n      // Update the notification.\n      return {\n        ...debouncedNotification,\n        alt,\n        data,\n        id,\n        level,\n        message,\n        outOfDate: false,\n        timestamp,\n        updateNotBefore: now + notificationDebounceTimeout\n      };\n    });\n  }\n\n  useTimer(getEarliestUpdateNotBefore(debouncedNotificationsRef.current), forceRender);\n\n  return [debouncedNotificationsRef.current];\n}\n\nexport default useDebouncedNotifications;\n\nexport { getEarliestUpdateNotBefore };\n"]},"metadata":{},"sourceType":"script"}