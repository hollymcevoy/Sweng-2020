{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = activityAltText;\n\nvar _textFormatToContentType = _interopRequireDefault(require(\"./textFormatToContentType\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction walk(document, walker) {\n  var nodes = [].slice.call(document.childNodes);\n  var results = [];\n\n  while (nodes.length) {\n    var _node = nodes.shift();\n\n    var childNodes = _node.childNodes;\n    results.push.apply(results, _toConsumableArray(walker(_node) || []));\n    nodes.unshift.apply(nodes, _toConsumableArray([].slice.call(childNodes)));\n  }\n\n  return results;\n} // From https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\n\n\nvar HTML_INLINE_TAGS = ['A', 'ABBR', 'ACRONYM', 'AUDIO', 'B', 'BDI', 'BDO', 'BIG', 'BR', 'BUTTON', 'CANVAS', 'CITE', 'CODE', 'DATA', 'DATALIST', 'DEL', 'DFN', 'EM', 'EMBED', 'I', 'IFRAME', 'IMG', 'INPUT', 'INS', 'KBD', 'LABEL', 'MAP', 'MARK', 'METER', 'NOSCRIPT', 'OBJECT', 'OUTPUT', 'PICTURE', 'PROGRESS', 'Q', 'RUBY', 'S', 'SAMP', 'SCRIPT', 'SELECT', 'SLOT', 'SMALL', 'SPAN', 'STRONG', 'SUB', 'SUP', 'SVG', 'TEMPLATE', 'TEXTAREA', 'TIME', 'U', 'TT', 'VAR', 'VIDEO', 'WBR'];\n/**\n * Computes all text from a given HTML document as flattened array. This is best-effort.\n *\n * @param {Document} document - HTML document to computes texts from.\n */\n\nfunction htmlTextAlternatives(document) {\n  // TODO: [P2] #3923 Revisit this logic with W3C standard, we could do a better text alternatives computation.\n  //       For example, <abbr title=\"...\"> is not computed.\n  //       https://www.w3.org/TR/accname-1.1/#mapping_additional_nd_name\n  return walk(document, function (node) {\n    var nodeType = node.nodeType,\n        tagName = node.tagName,\n        textContent = node.textContent;\n\n    if (nodeType === Node.TEXT_NODE) {\n      return [textContent];\n    } else if (tagName === 'IMG') {\n      return [node.getAttribute('alt')];\n    } else if (!HTML_INLINE_TAGS.includes(tagName)) {\n      return ['\\n'];\n    }\n  });\n}\n/**\n * Returns the text alternatives for a message activity.\n *\n * @param {object} activity - Activity to compute the text alternatives.\n * @param {function} renderMarkdownAsHTML - Callback function to render Markdown as HTML string.\n */\n\n\nfunction activityAltText(activity, renderMarkdownAsHTML) {\n  var _activity$channelData, _activity$channelData2, _activity$channelData3;\n\n  if (activity.type !== 'message') {\n    return false;\n  }\n\n  var fallbackText = activity === null || activity === void 0 ? void 0 : (_activity$channelData = activity.channelData) === null || _activity$channelData === void 0 ? void 0 : _activity$channelData['webchat:fallback-text'];\n\n  if (typeof fallbackText === 'string') {\n    // If `fallbackText` is an empty string, we will treat the activity as presentational and skip narrating it (return false).\n    return fallbackText || false;\n  }\n\n  var text = (activity === null || activity === void 0 ? void 0 : (_activity$channelData2 = activity.channelData) === null || _activity$channelData2 === void 0 ? void 0 : (_activity$channelData3 = _activity$channelData2.messageBack) === null || _activity$channelData3 === void 0 ? void 0 : _activity$channelData3.displayText) || activity.text;\n\n  if (!text) {\n    // We will continue to narrate the activity, as empty.\n    return '';\n  }\n\n  if (renderMarkdownAsHTML && (0, _textFormatToContentType.default)(activity.textFormat) === 'text/markdown') {\n    return htmlTextAlternatives(new DOMParser().parseFromString(renderMarkdownAsHTML(text), 'text/html')).join('').replace(/\\n{2,}/g, '\\n').trim();\n  }\n\n  return text;\n}","map":{"version":3,"mappings":"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","names":["walk","document","walker","nodes","slice","call","childNodes","results","length","node","shift","push","_toConsumableArray","unshift","HTML_INLINE_TAGS","htmlTextAlternatives","nodeType","tagName","textContent","Node","TEXT_NODE","getAttribute","includes","activityAltText","activity","renderMarkdownAsHTML","type","fallbackText","channelData","_activity$channelData","text","messageBack","displayText","textFormat","DOMParser","parseFromString","join","replace","trim"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-component/lib/src/Utils/activityAltText.ts"],"sourcesContent":["import textFormatToContentType from './textFormatToContentType';\n\nfunction walk<T extends Node>(document: Document, walker: (node: T) => string[]): string[] {\n  const nodes: T[] = [].slice.call(document.childNodes);\n  const results: string[] = [];\n\n  while (nodes.length) {\n    const node = nodes.shift();\n    const { childNodes } = node;\n\n    results.push(...(walker(node) || []));\n    nodes.unshift(...[].slice.call(childNodes));\n  }\n\n  return results;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\nconst HTML_INLINE_TAGS = [\n  'A',\n  'ABBR',\n  'ACRONYM',\n  'AUDIO',\n  'B',\n  'BDI',\n  'BDO',\n  'BIG',\n  'BR',\n  'BUTTON',\n  'CANVAS',\n  'CITE',\n  'CODE',\n  'DATA',\n  'DATALIST',\n  'DEL',\n  'DFN',\n  'EM',\n  'EMBED',\n  'I',\n  'IFRAME',\n  'IMG',\n  'INPUT',\n  'INS',\n  'KBD',\n  'LABEL',\n  'MAP',\n  'MARK',\n  'METER',\n  'NOSCRIPT',\n  'OBJECT',\n  'OUTPUT',\n  'PICTURE',\n  'PROGRESS',\n  'Q',\n  'RUBY',\n  'S',\n  'SAMP',\n  'SCRIPT',\n  'SELECT',\n  'SLOT',\n  'SMALL',\n  'SPAN',\n  'STRONG',\n  'SUB',\n  'SUP',\n  'SVG',\n  'TEMPLATE',\n  'TEXTAREA',\n  'TIME',\n  'U',\n  'TT',\n  'VAR',\n  'VIDEO',\n  'WBR'\n];\n\n/**\n * Computes all text from a given HTML document as flattened array. This is best-effort.\n *\n * @param {Document} document - HTML document to computes texts from.\n */\nfunction htmlTextAlternatives(document: Document): string[] {\n  // TODO: [P2] #3923 Revisit this logic with W3C standard, we could do a better text alternatives computation.\n  //       For example, <abbr title=\"...\"> is not computed.\n  //       https://www.w3.org/TR/accname-1.1/#mapping_additional_nd_name\n  return walk<HTMLElement>(document, node => {\n    const { nodeType, tagName, textContent } = node;\n\n    if (nodeType === Node.TEXT_NODE) {\n      return [textContent];\n    } else if (tagName === 'IMG') {\n      return [node.getAttribute('alt')];\n    } else if (!HTML_INLINE_TAGS.includes(tagName)) {\n      return ['\\n'];\n    }\n  });\n}\n\n/**\n * Returns the text alternatives for a message activity.\n *\n * @param {object} activity - Activity to compute the text alternatives.\n * @param {function} renderMarkdownAsHTML - Callback function to render Markdown as HTML string.\n */\nexport default function activityAltText(\n  activity: any,\n  renderMarkdownAsHTML?: (markdown: string) => string\n): false | string {\n  if (activity.type !== 'message') {\n    return false;\n  }\n\n  const fallbackText = activity?.channelData?.['webchat:fallback-text'];\n\n  if (typeof fallbackText === 'string') {\n    // If `fallbackText` is an empty string, we will treat the activity as presentational and skip narrating it (return false).\n    return fallbackText || false;\n  }\n\n  const text = activity?.channelData?.messageBack?.displayText || activity.text;\n\n  if (!text) {\n    // We will continue to narrate the activity, as empty.\n    return '';\n  }\n\n  if (renderMarkdownAsHTML && textFormatToContentType(activity.textFormat) === 'text/markdown') {\n    return htmlTextAlternatives(new DOMParser().parseFromString(renderMarkdownAsHTML(text), 'text/html'))\n      .join('')\n      .replace(/\\n{2,}/gu, '\\n')\n      .trim();\n  }\n\n  return text;\n}\n"]},"metadata":{},"sourceType":"script"}