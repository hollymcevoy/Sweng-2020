{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime2 = require(\"@babel/runtime/regenerator\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = speakActivityAndStartDictateOnIncomingActivityFromOthersSaga;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _effects = require(\"redux-saga/effects\");\n\nvar _incomingActivity = require(\"../actions/incomingActivity\");\n\nvar _DictateState = require(\"../constants/DictateState\");\n\nvar _markActivity = _interopRequireDefault(require(\"../actions/markActivity\"));\n\nvar _setDictateState = _interopRequireDefault(require(\"../actions/setDictateState\"));\n\nvar _shouldSpeakIncomingActivity = _interopRequireDefault(require(\"../selectors/shouldSpeakIncomingActivity\"));\n\nvar _speakableActivity = _interopRequireDefault(require(\"../definitions/speakableActivity\"));\n\nvar _stopDictate = _interopRequireDefault(require(\"../actions/stopDictate\"));\n\nvar _whileConnected = _interopRequireDefault(require(\"./effects/whileConnected\"));\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime2.mark(speakActivityAndStartDictateOnIncomingActivityFromOthers),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime2.mark(speakActivityAndStartDictateOnIncomingActivityFromOthersSaga);\n\nfunction speakActivityAndStartDictateOnIncomingActivityFromOthers(_ref) {\n  var userID;\n  return _regenerator[\"default\"].wrap(function speakActivityAndStartDictateOnIncomingActivityFromOthers$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          userID = _ref.userID;\n          _context2.next = 3;\n          return (0, _effects.takeEvery)(function (_ref2) {\n            var payload = _ref2.payload,\n                type = _ref2.type;\n            return (// In Direct Line, the \"role\" is not filled (yet), but we do know the user ID.\n              // In Direct Line Speech, we do not know the user ID, but \"role\" is filled with \"bot\" or \"user\".\n              // Here, we do two checks: the speakable activity must not have user ID, and must not have role === 'user'\n              type === _incomingActivity.INCOMING_ACTIVITY && payload.activity.from.id !== userID && payload.activity.from.role !== 'user'\n            );\n          }, /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(_ref3) {\n            var activity, shouldSpeakIncomingActivity, shouldSpeak;\n            return _regenerator[\"default\"].wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    activity = _ref3.payload.activity;\n                    _context.next = 3;\n                    return (0, _effects.select)(_shouldSpeakIncomingActivity[\"default\"]);\n\n                  case 3:\n                    shouldSpeakIncomingActivity = _context.sent;\n                    shouldSpeak = (0, _speakableActivity[\"default\"])(activity) && shouldSpeakIncomingActivity;\n\n                    if (!(shouldSpeak && (activity.speak || activity.text || ~(activity.attachments || []).findIndex(function (_ref4) {\n                      var _ref4$content = _ref4.content;\n                      _ref4$content = _ref4$content === void 0 ? {} : _ref4$content;\n                      var speak = _ref4$content.speak;\n                      return speak;\n                    })))) {\n                      _context.next = 8;\n                      break;\n                    }\n\n                    _context.next = 8;\n                    return (0, _effects.put)((0, _markActivity[\"default\"])(activity, 'speak', true));\n\n                  case 8:\n                    if (!(shouldSpeak && activity.inputHint === 'expectingInput')) {\n                      _context.next = 13;\n                      break;\n                    }\n\n                    _context.next = 11;\n                    return (0, _effects.put)((0, _setDictateState[\"default\"])(_DictateState.WILL_START));\n\n                  case 11:\n                    _context.next = 16;\n                    break;\n\n                  case 13:\n                    if (!(activity.inputHint === 'ignoringInput')) {\n                      _context.next = 16;\n                      break;\n                    }\n\n                    _context.next = 16;\n                    return (0, _effects.put)((0, _stopDictate[\"default\"])());\n\n                  case 16:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }));\n\n        case 3:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction speakActivityAndStartDictateOnIncomingActivityFromOthersSaga() {\n  return _regenerator[\"default\"].wrap(function speakActivityAndStartDictateOnIncomingActivityFromOthersSaga$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return (0, _whileConnected[\"default\"])(speakActivityAndStartDictateOnIncomingActivityFromOthers);\n\n        case 2:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked2);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;qDAEUA;sDA6BeC;;AA7BzB,SAAUD,wDAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqEE,gBAArE,QAAqEA;AAArEC;AACE,iBAAM,wBACJ;AAAA,gBAAGC,OAAH,SAAGA,OAAH;AAAA,gBAAYC,IAAZ,SAAYA,IAAZ;AAAA,mBACE;AACA;AACA;AACAA,kBAAI,KAAKC,mCAATD,IAA8BD,OAAO,CAACG,QAARH,CAAiBI,IAAjBJ,CAAsBK,EAAtBL,KAA6BF,MAA3DG,IAAqED,OAAO,CAACG,QAARH,CAAiBI,IAAjBJ,CAAsBM,IAAtBN,KAA+B;AAJtG;AADI,uDAMJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwBG,4BAAxB,SAAaH,OAAb,CAAwBG;AAAxBI;AACsC,2BAAM,qBAAOC,uCAAP,CAAN;;AADtC;AACQC,+CADR,gBACQA;AACAC,+BAFR,GAEsB,mCAAkBP,QAAlB,KAA+BM,2BAA7CC;;AAFR,0BAKIA,WAAW,KACVP,QAAQ,CAACQ,KAATR,IACCA,QAAQ,CAACS,IADVT,IAEC,CAAC,CAACA,QAAQ,CAACU,WAATV,IAAwB,EAAzB,EAA6BW,SAA7B,CAAuC;AAAA,gDAAGC,OAAH;AAAAC,iEAAwB,EAAxB;AAAA,0BAAcL,KAAd,iBAAcA,KAAd;AAAA,6BAAiCA,KAAjC;AAAvC,sBAHQ,CALf;AAAAJ;AAAA;AAAA;;AAAAA;AAUI,2BAAM,kBAAI,8BAAaJ,QAAb,EAAuB,OAAvB,EAAgC,IAAhC,CAAJ,CAAN;;AAVJ;AAAA,0BAaMO,WAAW,IAAIP,QAAQ,CAACc,SAATd,KAAuB,gBAb5C;AAAAI;AAAA;AAAA;;AAAAA;AAcI,2BAAM,kBAAI,iCAAgBW,wBAAhB,CAAJ,CAAN;;AAdJ;AAAAX;AAAA;;AAAA;AAAA,0BAeaJ,QAAQ,CAACc,SAATd,KAAuB,eAfpC;AAAAI;AAAA;AAAA;;AAAAA;AAgBI,2BAAM,kBAAI,8BAAJ,CAAN;;AAhBJ;AAAA;AAAA;AAAA;AAAA;AAAA;AANI,aAAN;;AADF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA6Be,SAAUV,4DAAV;AAAA;AAAA;AAAA;AAAA;AAAAsB;AACb,iBAAM,gCAAevB,wDAAf,CAAN;;AADa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","names":["speakActivityAndStartDictateOnIncomingActivityFromOthers","speakActivityAndStartDictateOnIncomingActivityFromOthersSaga","userID","_context2","payload","type","INCOMING_ACTIVITY","activity","from","id","role","_context","shouldSpeakIncomingActivitySelector","shouldSpeakIncomingActivity","shouldSpeak","speak","text","attachments","findIndex","content","_ref4$content","inputHint","WILL_START","_context3"],"sources":["/Users/dylanmurray/Sweng-2022/front/node_modules/botframework-webchat-core/lib/src/sagas/speakActivityAndStartDictateOnIncomingActivityFromOthersSaga.js"],"sourcesContent":["import { put, select, takeEvery } from 'redux-saga/effects';\n\nimport { INCOMING_ACTIVITY } from '../actions/incomingActivity';\nimport { WILL_START } from '../constants/DictateState';\nimport markActivity from '../actions/markActivity';\nimport setDictateState from '../actions/setDictateState';\nimport shouldSpeakIncomingActivitySelector from '../selectors/shouldSpeakIncomingActivity';\nimport speakableActivity from '../definitions/speakableActivity';\nimport stopDictate from '../actions/stopDictate';\nimport whileConnected from './effects/whileConnected';\n\nfunction* speakActivityAndStartDictateOnIncomingActivityFromOthers({ userID }) {\n  yield takeEvery(\n    ({ payload, type }) =>\n      // In Direct Line, the \"role\" is not filled (yet), but we do know the user ID.\n      // In Direct Line Speech, we do not know the user ID, but \"role\" is filled with \"bot\" or \"user\".\n      // Here, we do two checks: the speakable activity must not have user ID, and must not have role === 'user'\n      type === INCOMING_ACTIVITY && payload.activity.from.id !== userID && payload.activity.from.role !== 'user',\n    function* ({ payload: { activity } }) {\n      const shouldSpeakIncomingActivity = yield select(shouldSpeakIncomingActivitySelector);\n      const shouldSpeak = speakableActivity(activity) && shouldSpeakIncomingActivity;\n\n      if (\n        shouldSpeak &&\n        (activity.speak ||\n          activity.text ||\n          ~(activity.attachments || []).findIndex(({ content: { speak } = {} }) => speak))\n      ) {\n        yield put(markActivity(activity, 'speak', true));\n      }\n\n      if (shouldSpeak && activity.inputHint === 'expectingInput') {\n        yield put(setDictateState(WILL_START));\n      } else if (activity.inputHint === 'ignoringInput') {\n        yield put(stopDictate());\n      }\n    }\n  );\n}\n\nexport default function* speakActivityAndStartDictateOnIncomingActivityFromOthersSaga() {\n  yield whileConnected(speakActivityAndStartDictateOnIncomingActivityFromOthers);\n}\n"]},"metadata":{},"sourceType":"script"}